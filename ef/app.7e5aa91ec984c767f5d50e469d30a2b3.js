
/**
 * Raven Setup
 * 
 * Set the key, install it, and wrap app code in callback method to ensure all
 * possible errors are captured.
 * 
 * @see     https://docs.sentry.io/clients/javascript/config/
 */
Raven.config("https:\/\/f955547dba75405b84aa9e372a69c7ae@sentry.io\/237054", {
    sampleRate: 1.0,

    /**
     * Addresses the issue with line numbers and signatures being off when an
     * error or console log occurs with Sentry activated.
     * 
     * At the moment, I only need this when I'm working locally.
     * 
     * @see     https://forum.sentry.io/t/sentry-raven-js-obfuscates-my-console-line-numbers/2262
     */
    // autoBreadcrumbs: {
    //     'console': false
    // },

    /**
     * ignoreErrors
     * 
     * @access  private
     * @var     Array
     */
    ignoreErrors: [
        /^Cookies are required for Stencil$/,
        /^Modern browser is required for Stencil$/
    ],

    /**
     * shouldSendCallback
     * 
     * Performs a series of checks to determine whether errors should be sent to
     * Sentry. They are as follows:
     * 1) If the Stencil object isn't available, it's likely that the user agent
     * has an issue loading something else, in which case that's not on us
     * 2) If it is available, but the options are an empty object, it likely
     * means that the app hasn't yet been initiated (and is being run via an
     * extension).
     * 3) If the Services object isn't available, app isn't fully ready yet
     * 4) If the Sentry service is turned off, then bail
     * 
     * @access  private
     * @param   Object data
     * @return  Boolean
     */
    shouldSendCallback: function(data) {
        var stencilInitiated = function() {
            if (window.Stencil === undefined) {
                return false;
            }
            return JSON.stringify(Stencil.getOptions()) !== JSON.stringify({});
        };
        if (stencilInitiated() === false) {
            return false;
        }
        if (window.Config === undefined) {
            return false;
        }
        if (Config.serviceAvailable('sentry') === false) {
            return false;
        }
        // data.options = Stencil.getOptions();
        return true;
    }
}).install();
Raven.context(function () {

/**
 * Account
 * 
 * Acts as a proxy for the session AccountAccessor, and makes it easier to bind
 * events to an all-purpose helper.
 * 
 * @note    This proxy is useful especially with login, since the
 *          AccountAccessor for a guest account ceases to exist after a login.
 *          Therefore binding to this singleton gets around issues with that.
 * @fires   upgrade
 * @abstract
 */
window.Account = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'account')
     */
    var __classType = 'account';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Account')
     */
    var __string = 'Account';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * coupon
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        coupon: function() {
            return Stencil.account().coupon();
        },

        /**
         * delinquent
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        delinquent: function() {
            return Stencil.account().delinquent();
        },

        /**
         * draftIsLocked
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        draftIsLocked: function() {
            return Stencil.account().draftIsLocked();
        },

        /**
         * favorites
         * 
         * @access  public
         * @return  Object
         */
        favorites: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                var favorites = Stencil.account().get('favorites'),
                    key = accessor.get('key');
                if (accessor.is.asset.apply(accessor) === true) {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                favorites.push(key);
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var favorites = Stencil.account().get('favorites'),
                    key = accessor.get('key'),
                    index;
                if (accessor.is.asset.apply(accessor) === true) {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = favorites.indexOf(key);
                if (index !== -1) {
                    favorites.splice(index, 1);
                }
            }
        },

        /**
         * free
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        free: function() {
            return Stencil.account().free();
        },

        /**
         * guest
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        guest: function() {
            return Stencil.account().guest();
        },

        /**
         * highlightAllDrawingsOnSnap
         * 
         * @access  public
         * @return  Boolean
         */
        highlightAllDrawingsOnSnap: function() {
            return Config.default('highlightAllDrawingsOnSnap') === true;
        },

        /**
         * highlightCenterGuidesOnSnap
         * 
         * @access  public
         * @return  Boolean
         */
        highlightCenterGuidesOnSnap: function() {
            return Config.default('highlightCenterGuidesOnSnap') === true;
        },

        /**
         * lifetime
         * 
         * @access  public
         * @return  Boolean
         */
        lifetime: function() {
            if (Account.upgraded() === false) {
                return false;
            }
            var upgrade = Account.upgrade();
            if (upgrade.get('interval') === 'lifetime') {
                return true;
            }
            return false;
        },

        /**
         * max
         * 
         * @access  public
         * @return  Object
         */
        max: {

            /**
             * bonus
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            bonus: function() {
                var account = Stencil.account();
                return account.max.bonus.apply(account);
            },

            /**
             * favorites
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            favorites: function() {
                var account = Stencil.account();
                return account.max.favorites.apply(account);
            },

            /**
             * images
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            images: function() {
                var account = Stencil.account();
                return account.max.images.apply(account);
            },

            /**
             * sms
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            sms: function() {
                var account = Stencil.account();
                return account.max.sms.apply(account);
            }
        },

        /**
         * onboard
         * 
         * Loads the appropriate modal if the loaded account has not yet seen
         * a specific just in time onboarding screen.
         * 
         * @access  public
         * @param   String key
         * @return  Boolean
         */
        onboard: function(key) {
            var account = Stencil.account(),
                value = account.getOnboardingValue(key);
            if (value === true) {
                return false;
            }
            Stencil.set('ignoreMouseDownLayerBlur', true);
            account.setOnboardingValue(key, true);
            var modal = ModalUtils.showOnboarding(key);
            modal.once({
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
            return true;
        },

        /**
         * plan
         * 
         * @note    proxy
         * @access  public
         * @param   String plan
         * @return  Boolean
         */
        plan: function(plan) {
            return Stencil.account().plan(plan);
        },

        /**
         * promo
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        promo: function() {
            return Stencil.account().promo();
        },

        /**
         * rates
         * 
         * @access  public
         * @var     Object
         */
        rates: {

            /**
             * raw
             * 
             * Provides object breaking down annual and monthly rates for the
             * available plans.
             * 
             * @access  public
             * @return  Object
             */
            raw: function() {
                var upgrade = Account.upgrade(),
                    plans = Config.get('plans');
                if (upgrade !== undefined) {
                    var plan = upgrade.get('plan');
                    if (plan === 'pro') {
                        return {
                            annually: {
                                pro: upgrade.get('annuallyProRate'),
                                unlimited: plans.unlimited.rates.annually
                            },
                            monthly: {
                                pro: upgrade.get('monthlyProRate'),
                                unlimited: plans.unlimited.rates.monthly
                            }
                        };
                    }
                    if (plan === 'unlimited') {
                        return {
                            annually: {
                                pro: plans.pro.rates.annually,
                                unlimited: upgrade.get('annuallyUnlimitedRate')
                            },
                            monthly: {
                                pro: plans.pro.rates.monthly,
                                unlimited: upgrade.get('monthlyUnlimitedRate')
                            }
                        };
                    }
                    var msg = 'Invalid plan during raw lookup';
                    throw new Error(msg);
                }
                return {
                    annually: {
                        pro: plans.pro.rates.annually,
                        unlimited: plans.unlimited.rates.annually
                    },
                    monthly: {
                        pro: plans.pro.rates.monthly,
                        unlimited: plans.unlimited.rates.monthly
                    }
                };
            },

            /**
             * monthly
             * 
             * @access  public
             * @param   String plan
             * @return  Number
             */
            monthly: function(plan) {
                var raw = Account.rates.raw(),
                    monthly = raw.monthly[plan];
                return monthly;
            },

            /**
             * relative
             * 
             * Returns the annual rate broken down to relative-monthly pricing.
             * 
             * @access  public
             * @param   String plan
             * @return  Number
             */
            relative: function(plan) {
                var raw = Account.rates.raw(),
                    annually = raw.annually[plan];
                return Math.round(annually / 12);
            }
        },

        /**
         * requireCaptcha
         * 
         * @access  public
         * @return  Boolean
         */
        requireCaptcha: function() {
return false;
            var exemptCountryCodes = [
                    'ar',
                    'ca',
                    'de',
                    'gb',
                    'il',
                    'it',
                    'pl',
                    'us'
                ],
                countryCode = Stencil.account().geo().country.code;
            countryCode = countryCode.toLowerCase();
            if (ArrayUtils.contains(countryCode, exemptCountryCodes) === false) {
                return true;
            }
return true;
            return false;
        },

        /**
         * showWelcomeTour
         * 
         * Goal is to determine whether the welcome tour should automatically be
         * shown. This is determined by first ensuring the account is a
         * guest-account, then checking to see if the user is in the curtain
         * authentication flow, then checking if the signup modal is showing and
         * then finally ensuring the guest account has not yet seen the welcome
         * tour.
         * 
         * Check for the curtain to prevent the WelcomeTour modal from taking
         * over when a guest attempts to signup or login from the public site.
         * 
         * Check for /app/signup is incase a user was sent directly to a url
         * like /app/checkout/pro/annually/coupon/FREETRIAL
         * In that case, we just want to take them through the flow without the
         * WelcomeModal interrupting.
         * 
         * @access  public
         * @return  Boolean
         */
        showWelcomeTour: function() {
            if (Account.guest() === false) {
                return false;
            }
            if (location.href.match(/curtain/) !== null) {
                return false;
            }
            if (location.href.match(/\/app\/signup/) !== null) {
                return false;
            }
            return Stencil.account().setting('hasSeenWelcomeTour').toInt() === 0;
        },

        /**
         * upgrade
         * 
         * @note    proxy
         * @access  public
         * @return  UpgradeAccessor|undefined
         */
        upgrade: function() {
            return Stencil.account().reference('upgrade');
        },

        /**
         * upgraded
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        upgraded: function() {
            return Stencil.account().upgraded();
        }
    });
})();

/**
 * Alerts
 * 
 * @todo     Move this to the server side
 * @abstract
 */
window.Alerts = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'alerts')
     */
    var __classType = 'alerts';

    /**
     * __settings
     * 
     * @access  private
     * @return  Object
     */
    var __settings = {

        /**
         * Services
         * 
         */

            /**
             * Generic
             * 
             */
            'services.generic.blocked': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Your AdBlocker doesn\'t like us',
                message: 'It seems like you have an Ad Blocker, or are behind a ' +
                    'firewall which is blocking some code we need.' +
                    '<br /><br />Please disable your Ad Blocker for our ' +
                    'site (getstencil.com) in order to experience Stencil ' +
                    'fully.',
                slim: false
            },
            'services.generic.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Service unavailable',
                message: 'Due to technical difficulties, this service is ' +
                    'currently unavailable. It should be available again soon.',
                slim: true
            },

            /**
             * AccountDock
             * 
             */
            'services.accountDock.blocked': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Your AdBlocker doesn\'t like us',
                message: 'It seems like you have an Ad Blocker, or are behind a ' +
                    'firewall which is blocking some code we need to show you ' +
                    'your Billing History.<br /><br />Please disable your Ad ' +
                    'Blocker for our site (getstencil.com) in order to ' +
                    'experience Stencil fully.',
                slim: false
            },
            'services.accountDock.extension.disabled': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Some embarrassing news..',
                message: 'Unfortunately your Billing History cannot be accessed ' +
                    'through the Stencil extension.<br /><br />Please access it at: ' +
                    '<a href="/app/settings/payment" target="_blank" class="text">https://getstencil.com/app/settings/payment</a>',
                slim: false
            },
            'services.accountDock.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Billing History currently unavailable',
                message: 'Due to technical difficulties, your Billing History ' +
                    'is currently unavailable. ' +
                    'It should be available again soon.',
                slim: false
            },

            /**
             * Bitly
             * 
             */
            'services.bitly.error': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Problem generating share URL',
                message: 'There was a problem creating the share URL for ' +
                    'this image. ' +
                    'Please try again shortly.',
                slim: true
            },
            'services.bitly.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Share URLs are unavailable',
                message: 'Due to technical difficulties, share URLs are ' +
                    'currently unavailable. They should be available again ' +
                    'soon.',
                slim: false
            },

            /**
             * Buffer
             * 
             */
            'services.buffer.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Buffer currently unavailable',
                message: 'Due to technical difficulties, our Buffer ' +
                    'features are currently unavailable. ' +
                    'They should be available again soon.',
                slim: false
            },

            /**
             * Cloudinary
             * 
             * @see     https://cloudinary.com/console/settings/account
             */
            'services.cloudinary.maxResolution': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Image is too large',
                message: 'This image is too large (over 140 Megapixels). ' +
                    'Please try another one.',
                slim: true
            },

            /**
             * Cropper
             * 
             */
            'services.cropper.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Cropping currently unavailable',
                message: 'Due to technical difficulties, our cropping ' +
                    'features are currently unavailable. ' +
                    'They should be available again soon.',
                slim: false
            },

            /**
             * Facebook
             * 
             */
            'services.facebook.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Facebook currently unavailable',
                message: 'Due to technical difficulties, our Facebook ' +
                    'features are currently unavailable. ' +
                    'They should be available again soon.',
                slim: false
            },

            /**
             * Fonts
             * 
             */
            'services.fontUploads.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Font uploading currently unavailable',
                message: 'Due to technical difficulties, our Font Uploading ' +
                    'features are currently unavailable. ' +
                    'They should be available again soon.',
                slim: false
            },

            /**
             * Pinterest
             * 
             */
            'services.pinterest.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Pinterest currently unavailable',
                message: 'Due to technical difficulties, our Pinterest ' +
                    'features are currently unavailable. ' +
                    'They should be available again soon.',
                slim: true
            },

            /**
             * Twitter
             * 
             */
            'services.twitter.unavailable': {
                icons: {
                    primary: 'warning icon-only sift sift-warning'
                },
                headline: 'Twitter currently unavailable',
                message: 'Due to technical difficulties, our Twitter ' +
                    'features are currently unavailable. ' +
                    'They should be available again soon.',
                slim: false
            },

        /**
         * Other
         * 
         */
        'account.downgrade': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Contact us to downgrade.',
            // message: 'Looks like you\'re trying to downgrade your plan, ' +
            //     'which will essentially cancel your current plan.<br />' +
            //     'Please <a href="/contact" target="_blank" class="text">contact us</a> for more details.',
            message: 'We\'re currently in the process of improving our plan ' +
                'management options. Please ' +
                '<a href="/contact" target="_blank" class="text">contact us</a> ' +
                'directly to cancel at this time. Apologies for any ' +
                'inconvenience.',
            buttons: [
                {
                    copy: 'Okay, got it'
                }
            ],
            slim: false
        },
        'account.sessionAccount.false': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'It looks like you\'ve been logged out. Please reload ' +
                'Stencil to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'account.refilled': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Account refilled',
            message: 'Looks like while you\'ve been using Stencil, we ' +
                'refilled your account\'s monthly limits.<br /><br />So if ' +
                'some numbers jumped around, just so you know, that\'s what ' +
                'happened.',
            slim: true
        },
        'account.unlimited.limit.sms': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'You have reached your SMS limit',
            message: 'Please <a href="/contact" target="_blank" class="text">contact us</a> for details on ' +
                'raising your account limit.',
            slim: true
        },
        'account.upgrade': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Contact us to upgrade.',
            message: 'Looks like you\'re trying to upgrade your plan. ' +
                'Please <a href="/contact" target="_blank" class="text">contact us</a> for more details.',
            buttons: [
                {
                    copy: 'Okay, got it'
                }
            ],
            slim: true
        },
        'adBlocker.found': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'AdBlockers may affect your experience',
            message: 'We detected that you\'re using an AdBlocker. Just a ' +
                'heads-up this may affect your experience on Stencil.' +
                '<br /><br />We recommend you turn it off for getstencil.com ' +
                'to make sure things run smoothly.<br /><br />' +
                'If you\'re not able to, you may experience some issues.',
            slim: false
        },
        'scripts.headway.failed': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Your AdBlocker doesn\'t like us',
            message: 'It seems like you have an Ad Blocker, or are behind a ' +
                'firewall which is blocking some code we need to show you ' +
                'our Update Log.<br /><br />Please disable your Ad Blocker ' +
                'for our site (getstencil.com) in order to experience ' +
                'Stencil fully.',
            slim: false
        },
        'admin.user.update': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'User record updated',
            message: 'All set! Please click the Reload button below to have ' +
                'changes reflected.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return Stencil.get('temporaryReloadUrl');
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'app.maintenance': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Upgrading Stencil',
            message: 'Unfortunately you caught us while we\'re upgrading ' +
                'Stencil. None of your changes have been lost, and we\'ll be ' +
                'available again in about <strong>maintenanceModeDurationString</strong>.' +
                '<br /><br />Thanks for your understanding.',
            closable: false,
            buttons: [],
            slim: true
        },
        'canvas.text.rclick': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Looking to paste text?',
            message: 'If you\'re on Windows, use [CTRL+V] on ' +
                'your keyboard to paste text.<br />' +
                'If you\'re on a Mac, use [Command+V] on your ' +
                'keyboard to paste text.',
            slim: false
        },
        'connection': {
            icons: {
                primary: 'black icon-only sift sift-cloud-stop'
            },
            headline: 'Internet connection issue',
            message: 'It looks like your connection to the internet may have ' +
                'dropped. Please make sure you\'re properly connected and ' +
                'reload Stencil.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'cookies.cleared': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'We had trouble accessing your cookies, which is needed ' +
                'for Stencil to work properly.<br /><br />' +
                'This can happen if you reset them or your computer runs out ' +
                'of memory. Reloading should fix this.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'dependency.failed': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not load some code',
            message: 'Unfortunately, we could not load some required code.' +
                '<br />This could mean your internet connection is down, you ' +
                'have an Ad Blocker installed that is preventing the code ' +
                'from being loaded, or possibly something is wrong on our ' +
                'side. <br /><br />Please disable any Ad Blockers you may ' +
                'have turned on, and try again.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'devicePixelRatio.change': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Heads up!',
            message: 'We just detected a change to your display settings and ' +
                'need you to reload Stencil.<br /><br />Don\'t worry: we\'ve ' +
                'saved your image and nothing will be lost.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'extension.reload.force': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'We\'ve updated Stencil in the last few minutes. Please ' +
                'reload to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'extension.conflicting.ezLinkPreview': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'ezLinkPreview Extension Issue',
            message: 'It looks like you have the ezLinkPreview extension ' +
                'installed. Unfortunately it can cause issues with Stencil. ' +
                'We recommend you turn it off.<br /><br />If you\'re not ' +
                'able to, it may cause issues. Contact support if you notice ' +
                'anything strange.',
            slim: false
        },
        'extension.conflicting.ghostery': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Ghostery Extension Issue',
            message: 'It looks like you have the Ghostery extension ' +
                'installed. Unfortunately it can cause issues with Stencil. ' +
                'We recommend you turn it off.<br /><br />If you\'re not ' +
                'able to, it may cause issues. Contact support if you notice ' +
                'anything strange.',
            slim: true
        },
        // 'extension.install.chrome': {
        //     icons: {
        //         primary: 'info icon-only sift sift-exclamation-point'
        //     },
        //     headline: 'Google Chrome Required',
        //     message: 'Please use Google Chrome to use the Stencil Chrome ' +
        //         'Extension.<br /><br />You can download it ' +
        //         '<a href="https://www.google.com/chrome/" target="_blank" class="text">here</a>.',
        //     slim: true
        // },
        // 'extension.install.window': {
        //     icons: {
        //         primary: 'info icon-only sift sift-exclamation-point'
        //     },
        //     headline: 'Browser security requirement',
        //     message: 'To install the Stencil Extension for Chrome, please ' +
        //         'visit ' +
        //         '<a href="/app/extras" target="_blank" class="text">https://getstencil.com/app/extras</a>',
        //     slim: true
        // },
        'facebook.auth.minimum': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not connect to your Facebook account',
            message: 'In order to connect your Facebook account, Stencil ' +
                'requires you to accept all the permissions when prompted. ' +
                '<br /><br />Please know that we will ' +
                '<strong class="underline">never</strong> post to your ' +
                'profile or page without you clicking a button to do so.',
            slim: false
        },
        'services.facebook.pages.noneFound': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Could not find any Pages',
            message: 'Your Facebook account has no Pages ' +
                'linked to it. You can only share images directly to Facebook Pages.' +
                '<br /><br />To connect to a different Facebook account, ' +
                'please logout from Facebook and try again.',
            buttons: [
                {
                    copy: 'Logout from Facebook',
                    path: function() {
                        return 'https://facebook.com';
                    },
                    target: '_blank'
                }
            ],
            slim: false
        },
        'services.facebook.pages.noUniqueFound': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Could not find any new Pages',
            message: 'All the Pages linked to your Facebook account have ' +
                'already been added to Stencil.<br /><br />To connect to a ' +
                'different Facebook account, please logout from Facebook and ' +
                'try again.',
            buttons: [
                {
                    copy: 'Logout from Facebook',
                    path: function() {
                        return 'https://facebook.com';
                    },
                    target: '_blank'
                }
            ],
            slim: false
        },
        // 'facebook.logout': {
        //     icons: {
        //         primary: 'info icon-only sift sift-exclamation-point'
        //     },
        //     headline: 'Could not find any new pages',
        //     message: 'All the pages linked to the Facebook account you\'re ' +
        //         'logged in with have already been added to Stencil. ' +
        //         '<br /><br />To connect to a different Facebook account, ' +
        //         'please log out on Facebook and try again.',
        //     buttons: [
        //         {
        //             copy: 'Logout from Facebook',
        //             path: function() {
        //                 return 'https://facebook.com';
        //             },
        //             target: '_blank'
        //         }
        //     ],
        //     slim: false
        // },
        'frame.ratio.unchanged': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Heads up!',
            message: 'While you may not notice a different in your image ' +
                'above, we\'ve recorded the change in dimensions, and when ' +
                'you save or download this image, it will be your new size.',
            slim: true
        },
        'import.failed': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not import that image',
            message: 'Unfortunately, we could not import the image you ' +
                'right-clicked. Please try uploading it right into Stencil.',
            slim: true
        },
        'import.failed.max.filesize': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Right-clicked image is too large',
            message: 'Unfortunately, the image you attempted to use is ' +
                'larger than the maximum allowed. Please try another.',
            slim: true
        },
        'import.normalize.disabled': {// Not currently being used
            headline: 'Cannot load this image right now',
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            message: 'We\'re fixing some bugs, and cannot load this image ' +
                'right now. Please try again shortly.',
            slim: true
        },

        /**
         * Directory uploading
         */
        'upload.image.max.count.directory': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Too many image uploads',
            message: 'Unfortunately you can only upload up to 50 images at ' +
                'once.<br /><br />One of the directories you tried uploading ' +
                'likely contains too many images.',
            slim: true
        },
        /**
         * The follow error can be encountered if bit.ly doesn't come back with
         * a proper response. Ran into this locally because the request was
         * timing out (presumably to do with my internet connection).
         */
        'image.shortUrl.error': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not create short url',
            message: 'There was a problem creating a short url for this ' +
                'image. Apologies for that. Please try again at another time.',
            slim: true
        },
        'image.upload.error': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not save your image',
            message: 'Something strange happened and we could not save your ' +
                'image. Please reload Stencil to continue where you left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'image.upload.exception': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Problem while saving',
            message: 'We are having trouble with your browser. Please try ' +
                'another browser until we can fix the issue in this version.',
            closable: false,
            buttons: [],
            slim: true
        },
        'image.uploaded': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Image has been saved',
            message: 'Thanks for your patience. Go ahead and try again.',
            slim: true
        },
        'image.uploaded.already': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'This image has already been saved',
            message: 'It seems like this image was already saved in another ' +
                'tab, browser, or on another computer. Please reload Stencil ' +
                'to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'image.uploaded.deleted': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Account being used in multiple locations',
            message: 'It appears this account is being used on more than one ' +
                'computer, tab or browser. At this time, Stencil accounts ' +
                'cannot be used simultaneously.<br /><br />' +
                'Please log out from your other device and then reload ' +
                'Stencil.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'image.uploading': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Image is still being saved',
            message: 'Please wait a moment and then try again.',
            slim: true
        },
        'password.reset': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Please check your email',
            message: 'We\'ve sent you instructions on how to change your ' +
                'password.',
            buttons: [],
            slim: true
        },
        'modal.paused': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Just a second..',
            message: 'Please wait until your submission has finished.',
            slim: true
        },
        'service.aws': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Saving options temporarily off',
            message: 'Sorry about the trouble.<br /><br />We\'re working on ' +
                'the problem, and will have things up and running as soon as ' +
                'possible. Your image has been saved, so when you come back ' +
                'you will be able to get going quickly.',
            slim: false
        },
        'service.aws.skew.fail': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Connection error',
            message: 'We could not connect to a server needed for Stencil to ' +
                'work properly.<br /><br />' +
                'This can sometimes happen if you are behind a [firewall] or ' +
                'have an [Ad Blocker] installed that blocks access to the ' +
                'Amazon AWS services.<br /><br />' +
                'If that isn\'t the issue, please check your computer\'s ' +
                '[Date &amp; Time Preferences] to make sure your system clock ' +
                '&amp; timezone are properly set.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload Stencil',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'search.bug': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Error with Stencil search results',
            message: 'Unfortunately, an error has occured with your search. ' +
                'Please reload Stencil to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'crop.image.tooSmall': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Image too small to crop',
            message: 'Unfortunately the image you\'ve selected is too small ' +
                'for our cropping tool.<br /><br />' +
                'Images need to be at least 150px wide and 50px high in ' +
                'order to crop.',
            slim: true
        },
        'clients.electron.crop.download.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Cropped image downloaded!',
            message: 'Your cropped image has been successfully downloaded. ' +
                'Please check your file system for the image.',
            slim: true
        },
        'clients.electron.images.download.single.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Image downloaded!',
            message: 'Your image has been successfully downloaded. Please ' +
                'check your file system for the image.',
            slim: true
        },
        'clients.electron.images.download.multiple.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Images downloaded!',
            message: 'Your images have been successfully downloaded. Please ' +
                'check your file system for the images.',
            slim: true
        },
        'clients.electron.uploads.download.single.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Upload downloaded!',
            message: 'Your upload has been successfully downloaded. Please ' +
                'check your file system for the upload.',
            slim: true
        },
        'clients.electron.uploads.download.multiple.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Uploads downloaded!',
            message: 'Your uploads have been successfully downloaded. Please ' +
                'check your file system for the uploads.',
            slim: true
        },
        'clients.electron.watermarks.download.single.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Watermark / Logo downloaded!',
            message: 'Your watermark / logo has been successfully ' +
                'downloaded. Please check your file system for the logo / ' +
                'watermark.',
            slim: true
        },
        'clients.electron.watermarks.download.multiple.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Watermarks / Logos downloaded!',
            message: 'Your watermarks / logos have been successfully ' +
                'downloaded. Please check your file system for the logos / ' +
                'watermarks.',
            slim: true
        },
        'download.bug': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Problem downloading your image',
            message: 'We\'re really sorry about this, but something went ' +
                'wrong while trying to download your image. We\'re aware of ' +
                'this issue and we\'re working hard to fix it.<br /><br />' +
                'Please reload Stencil and try to download again.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'search.expired': {// Not currently being used
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'For security purposes, please reload Stencil to ' +
                'continue where you left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'svg.load.fail': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Temporary icon issue',
            message: 'Sorry, but at the moment we\'re having trouble loading ' +
                'that icon. Please try another, while we work on a fix.',
            slim: true
        },
        'svg.load.fail.2': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Temporary icon issue',
            message: 'Sorry, but at the moment we\'re having trouble loading ' +
                'a specific icon. It may not appear in your image at for the ' +
                'moment.',
            slim: true
        },
        'timeout': {// Not currently being used
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Request timed out',
            message: 'Apologies, but it seems like we\'re getting overloaded ' +
                'with traffic. Please reload Stencil to continue where you ' +
                'left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'cloudflare.timeout': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'CloudFlare Timeout is coming',
            message: 'This request is likely to go beyond Cloudflare\'s ' +
                'allowable duration (60s - 100s). Stopping it now, so that ' +
                'you know what\'s up.<br /><br />An email will be sent to ' +
                'you upon completion.<br /><br />Please wait for that email ' +
                'before continueing to use Stencil.',
            closable: false,
            buttons: [],
            slim: false
        },

        /**
         * Font import max
         * 
         */
        'font.import.max': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Max fonts reached',
            message: 'For performance reasons, you cannot have more than ' +
                '50 fonts in your My Fonts section at time. Sorry for the ' +
                'inconvenience.',
            slim: true
        },

        /**
         * Security
         * 
         */
        'security.failedDataIntegrityCheck': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Oh ho!',
            message: 'Something went wrong. Please contact support. You ' +
                'really should not be seeing this message (#1).',
            closable: false,
            buttons: [
                {
                    copy: 'Contact Support',
                    path: function() {
                        return '/contact';
                    },
                    target: '_blank'
                }
            ],
            slim: true
        },
        'security.failedCSRFTokenCheck': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Oh ho!',
            message: 'Something went wrong. If you\'re trying to use Stencil ' +
                'in more than one tab at a time, that could be the proble.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },

        /**
         * Font uploads
         * 
         */
        'upload.font.fail': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not process font',
            message: 'There was an issue processing your font. Please make ' +
                'sure the font is either an `OTF`, `TTF`, `WOFF` or `WOFF2` ' +
                'font file.<br /><br />If you are trying to upload a `ZIP` ' +
                'file, please unzip it first, and then try again.<br /><br />' +
                'Otherwise, please try another font, or ' +
                '<a href="/contact" class="text" target="_blank">contact support</a>.',
            slim: false
        },
        'upload.font.max.count': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Too many font uploads',
            message: 'Unfortunately you can only upload up to 20 fonts at once.',
            slim: true
        },
        'upload.font.max.filesize': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'One of your font uploads is too large',
            message: 'Unfortunately we can only process font uploads that ' +
                'are less than 2 megabytes.',
            slim: true
        },
        'upload.font.type': {// Only used when a .zip file is detected
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Only `OTF`, `TTF`, `WOFF` and `WOFF2` fonts',
            message: 'Please make sure fonts are either `OTF`, `TTF`, `WOFF` ' +
                'or `WOFF2`.<br /><br />If you are trying to upload a `ZIP` ' +
                'file, please unzip it first, and then upload the unzipped ' +
                'font files.',
            slim: true
        },

        /**
         * Image uploads
         * 
         */
        'upload.image.max.count': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Too many image uploads',
            message: 'Unfortunately you can only upload up to 50 images at ' +
                'once.',
            slim: true
        },
        'upload.image.max.filesize': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'One of your image uploads is too large',
            message: 'Unfortunately we can only process image uploads that ' +
                'are less than 30 megabytes.',
            slim: true
        },
        'upload.image.type': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Only `PNG`, `JPEG`, `GIF` AND `WEBP` images',
            message: 'Currently, you can only upload `PNG`, `JPEG`, `GIF` or ' +
                '`WEBP` images.',
            slim: true
        },

        /**
         * Upload filesize issues
         * 
         */
        'upload.multiple.filesize.zero': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'One of your files cannot be uploaded',
            message: 'Unfortunately we won\'t be able to process your upload. ' +
                'One of your files is empty, and cannot be uploaded. Please ' +
                'try another.',
            slim: true
        },
        'upload.singular.filesize.zero': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Cannot upload that file',
            message: 'Unfortunately we won\'t be able to process that file. ' +
                'It may not be the right format. Please try another.',
            slim: true
        },

        /**
         * 
         * 
         */
        'user.settings.frozen': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Your account has been frozen',
            message: 'Please contact support to fix this issue.',
            closable: false,
            buttons: [
                {
                    copy: 'Contact Support',
                    path: function() {
                        return '/contact';
                    }
                }
            ],
            slim: true
        },
        'users.checkout.blocked': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Cannot upgrade your account',
            message: 'Please contact support for help in upgrading your ' +
                'account.',
            closable: true,
            buttons: [
                {
                    copy: 'Contact Stencil Support',
                    path: function() {
                        return 'https://getstencil.com/contact';
                    }
                }
            ],
            slim: true
        },

        /**
         * User related alerts
         * 
         */
        'users.obfuscate.success': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Your account has been deleted',
            message: 'Thanks for using Stencil. Please feel free to contact ' +
                'us if you have any questions in the future.',
            closable: false,
            buttons: [
                {
                    copy: 'Go to Stencil homepage',
                    path: function() {
                        return 'https://getstencil.com/?deleted';
                    }
                }
            ],
            slim: true
        },
        'users.obfuscate.failed.subscription': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Your account could not be deleted',
            message: 'You still have an active subscription with us. Please ' +
                'contact support to have us cancel your subscription before ' +
                'attempting to delete your account.',
            closable: true,
            buttons: [
                {
                    copy: 'Contact Stencil Support',
                    path: function() {
                        return 'https://getstencil.com/contact';
                    }
                }
            ],
            slim: true
        },
        'users.obfuscate.failed.other': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Your account could not be deleted',
            message: 'Please contact support for help deleting your account.',
            closable: true,
            buttons: [
                {
                    copy: 'Contact Stencil Support',
                    path: function() {
                        return 'https://getstencil.com/contact';
                    }
                }
            ],
            slim: true
        },

        /**
         * AdBlocker
         * 
         */
        'window.blocked': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Window Blocked',
            message: 'We could not complete the action because your browser ' +
                'is blocking popups. Please turn this off to continue.' +
                '<br /><br /><a href="https://bit.ly/1SINEbr" class="text" target="_blank">Learn more &rarr;</a>',
            slim: true
        }
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Alerts')
     */
    var __string = 'Alerts';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * show
         * 
         * @access  public
         * @param   String code
         * @return  AlertModalView
         */
        show: function(code) {
            var alertModal = ModalUtils.showAlert(code, __settings[code]);
            return alertModal;
        }
    });
})();
window.DependencyLoader.push('Class', function() {

    /**
     * Base
     * 
     * @fires   set
     *          set/<x>
     * @extends Class
     */
    window.Base = Class.extend({

        /**
         * _classType
         * 
         * Variable to track what type of class the instance is, which is then
         * used in logging to show a different color for the message.
         * 
         * I chose the variable name <_classType> because <_type> might be too
         * generall, and conflict with other instance-properties. 
         * 
         * @access  protected
         * @var     String (default: 'base')
         */
        _classType: 'base',

        /**
         * _data
         * 
         * Simple storage hash that can be used quite widely, since so many
         * classes extend Base.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _data: {},

        /**
         * _logEvents
         * 
         * Marks whether or not events that are triggered against this object
         * are logged to the console.
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Base')
         */
        _string: 'Base',

        /**
         * _timers
         * 
         * Object to keep track of timers, instance-wide.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _timers: {},

        /**
         * init
         * 
         * @note    The extend.js library is limited in that there is a bug
         *          around array/object references. Specifically, the
         *          constructor always needs to be reset array/object
         *          references. This is to prevent a foundational bug with the
         *          library whereby adding elements to an instance array or
         *          setting properties to an instance object/map causes values
         *          to persist between instances. It's a huge bug, but one that
         *          is relatively easy to work-around: make sure that the any
         *          arrays or objects that are available to a class are reset
         *          upon instance instantiation.
         * @access  public
         * @return  void
         */
        init: function() {
            this._data = {};
            this._timers = {};
        },

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        get: function(key) {
            return this._data[key];
        },

        /**
         * getClassType
         * 
         * @access  public
         * @return  String
         */
        getClassType: function() {
            return this._classType;
        },

        /**
         * log
         * 
         * Logging method, which with the exception of the override parameter,
         * abides by the logic within Stencil.log as to whether or not anything
         * is actually logged to the console. The toString method is used here
         * to pass along the name of the instance.
         * 
         * @access  public
         * @param   undefined|String msg (default: '(no message)')
         * @param   undefined|Boolean override (default: false)
         * @return  void
         */
        log: function(msg, override) {
            msg = DataUtils.getDefaultValue(msg, '(no message)');
            override = DataUtils.getDefaultValue(override, false);
            LogUtils.log.object(this, msg, override);
        },

        /**
         * off
         * 
         * Proxy for jQuery off method.
         * 
         * @access  public
         * @return  void
         */
        off: function() {
            $(this).off.apply($(this), $(arguments).toArray());
        },

        /**
         * on
         * 
         * Proxy for jQuery on method.
         * 
         * @access  public
         * @return  void
         */
        on: function() {
            $(this).on.apply($(this), $(arguments).toArray());
        },

        /**
         * once
         * 
         * Proxy for jQuery one method.
         * 
         * @access  public
         * @return  void
         */
        once: function() {
            $(this).one.apply($(this), $(arguments).toArray());
        },

        /**
         * set
         * 
         * @example Accessor.set('key', 'value')
         *          Accessor.set({key: 'value'})
         * @access  public
         * @param   Object|String key
         * @param   undefined|Number|String value
         * @return  void
         */
        set: function() {

            // Object or key/value arguments
            var args = jQuery.makeArray(arguments),
                data = args[0];
            if (typeof data === 'string') {
                data = {};
                data[args[0]] = args[1];
            }

            // Run set the set for all the properties in the object
            this._data = DataUtils.merge(this._data, data);

            // Events
            var index, value;
            for (index in data) {
                value = data[index];
                this.triggerHandler('set', [index, value]);
                this.triggerHandler('set/' + (index), [value]);
            }
        },

        /**
         * time
         * 
         * Helper method to track the execution duration of code, using the
         * passed in key to differentiate between different timers.
         * 
         * @access  public
         * @param   mixed key
         * @return  void
         */
        time: function(key) {
            var now = new Date().getTime();
            if (this._timers[key] === undefined) {
                this._timers[key] = now;
            } else {
                var msg = 'Timer [' + (key) + '] ' + (now - this._timers[key]);
                this.log(msg);
                delete this._timers[key];
            }
        },

        /**
         * toString
         * 
         * Native method implementation, which at the moment, is used
         * extensively by logging.
         * 
         * @access  public
         * @return  String
         */
        toString: function() {
            return this._string;
        },

        /**
         * triggerHandler
         * 
         * Proxies a call to jQuery's triggerHandler function. triggerHandler is
         * is used in place of trigger, since trigger can conflict with native
         * events. For example, a call to trigger('click') would initiate native
         * event dispatching, along with events that were bound to the click
         * listener on the object.
         * 
         * It's worth noting that even if the object is set up to have it's
         * events logged, it will depend on other factors. See Stencil.log for
         * more information.
         * 
         * @access  public
         * @return  void
         */
        triggerHandler: function() {
            var log = DataUtils.getDefaultValue(this._logEvents, false);
            if (log === true) {
                var eventType = arguments[0];
                this.log(eventType);
            }
            $(this).triggerHandler.apply($(this), $(arguments).toArray());
        },

        /**
         * unbind
         * 
         * Proxy for jQuery unbind method.
         * 
         * @access  public
         * @return  void
         */
        unbind: function() {
            $(this).unbind.apply($(this), $(arguments).toArray());
        }
    });
});

/**
 * ChangeHistory
 * 
 * @abstract
 */
window.ChangeHistory = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'changeHistory')
     */
    var __classType = 'changeHistory';

    /**
     * Private variables
     * 
     */

    /**
     * __groupableOperationTypes
     * 
     * This contains the array of types whereby a sequence of them would be
     * grouped together. This is important because some things should not be
     * tracked entirely independently of one another. (eg. nudging).
     * 
     * Note that these _are_ in fact tracked independently if they occur spaced
     * apart by a specific number of milliseconds (defined in config.inc.php).
     * 
     * @access  private
     * @var     Array
     */
    var __groupableOperationTypes = [

        // Typing
        'layer // type: text // text:changed',

        // Nudging
        'layer // type: text // nudged',
        'layer // type: image, vector: true // nudged',
        'layer // type: image, background: false // nudged',
        'layer // type: image, watermark: true // nudged',

        // Color changing
        'layer // type: rectangle, background: true // backgroundColor:changed',
        'layer // type: text // backdrop:colorChanged',
        'layer // type: text // strokeColor:changed',
        'layer // type: text // textColorChanged',
        'layer // type: image, vector: true // fillColor:changed'
    ];

    /**
     * __operationType
     * 
     * @access  private
     * @var     false|String
     */
    var __operationType = false;

    /**
     * __paused
     * 
     * Modified via the public ChangeHistory.pause and ChangeHistory.unpause
     * methods, in order to prevent history changes during certain
     * circumstances.
     * 
     * This includes:
     *  - If the canvas is still being drawn (eg. background image being as or
     *    vector being added)
     * 
     * @access  private
     * @var     Boolean (default: false)
     */
    // var __paused = false;

    /**
     * Private methods
     * 
     */

    /**
     * __getChangeHistoryOperationsMap
     * 
     * @access  private
     * @return  Object
     */
    var __getChangeHistoryOperationsMap = function() {
        return Config.get('changeHistoryOperations');
    };

    /**
     * __getMaxOperations
     * 
     * Returns the maximum number of operations that can be tracked in the
     * undo or redo change history arrays. Each can have this number of
     * changes.
     * 
     * @access  private
     * @return  Number
     */
    var __getMaxOperations = function() {
        return Config.default('changeHistory').maxOperations.toInt();
    };

    /**
     * __getMinDelayUntilNewOperationRegistered
     * 
     * @access  private
     * @return  Number
     */
    var __getMinDelayUntilNewOperationRegistered = function() {
        return Config.default('changeHistory').minDelayUntilNewOperationRegistered.toInt();
    };

    /**
     * __getOperationDescription
     * 
     * @access  private
     * @return  String
     */
    var __getOperationDescription = function() {
        var operationType = __getOperationType(),
            map = __getChangeHistoryOperationsMap(),
            operationDescription = map[operationType];
        if (operationDescription === undefined) {
            LogUtils.log.simple(operationType, true);
            LogUtils.log.simple('Unknown operation type', true);
            return 'Change';
        }
        return operationDescription;
    };

    /**
     * __getOperationType
     * 
     * @access  private
     * @return  String
     */
    var __getOperationType = function() {
        return __operationType;
    };

    /**
     * __replacableOperation
     * 
     * This checks the __groupableOperationTypes array to determine if the
     * operation passed in (which is presumably the one that could be added
     * next), is within that array, and if it is, if it's witin the minimum
     * range to be considered as a replacement operation.
     * 
     * The best example is that when someone is nudging something, we don't want
     * nudges that happen within 1500ms (or whatever) of eachother to count as
     * a new operation. We just want the most recent one to be the last
     * operation.
     * 
     * This is primarily to prevent operations that would be redundant from
     * entering in the history.
     * 
     * Also note that currently this replacing/grouping is limited to changes
     * that originate from keyup events (as opposed to mouseup events).
     * 
     * @access  private
     * @param   Object operation
     * @param   jQuery event
     * @return  Boolean
     */
    var __replacableOperation = function(operation, event) {
        if (event.type !== 'keyup') {
            return false;
        }
        var operationType = operation.type;
        if (ArrayUtils.contains(operationType, __groupableOperationTypes) === false) {
            return false;
        }
        var account = Stencil.account(),
            undoHistory = ChangeHistory.history.undo(),
            lastUndoChange = undoHistory.pop();
        if (lastUndoChange.type !== operationType) {
            return false;
        }
        var range = __getMinDelayUntilNewOperationRegistered(),
            withinRange = DTUtils.timestampWithin(
                lastUndoChange.timestamp.full * 1000,
                operation.timestamp.full * 1000,
                range
            );
        if (withinRange === false) {
            return false;
        }
        return true;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ChangeHistory')
     */
    var __string = 'ChangeHistory';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * active
         * 
         * Simply returns whether or not change history is enabled.
         * 
         * @access  public
         * @return  Boolean
         */
        active: function() {
            return Config.default('changeHistory').active === true;
        },

        /**
         * clearOperationType
         * 
         * In practice, this method is used to ensure that a specific operation
         * is the one that gets registered as a chance. The best example of this
         * is when a user is dragging a layer around, and then presses the
         * delete key.
         * 
         * In that case, we want the change operation that gets registered to be
         * that the layer was deleted, but traditionally, the move would get
         * registered, since it was the operation that the started first and has
         * yet to be completed (and registered). So when a delete is detected,
         * we override the operation type by first calling this method (which
         * clears the operation type), and then setting the operation type.
         * 
         * @access  public
         * @return  void
         */
        clearOperationType: function() {
            __operationType = false;
        },

        /**
         * history
         * 
         * Helper object to return the object of redo/undo change operations, or
         * individual change history arrays (eg. the undo changes or redo
         * changes).
         * 
         * @access  public
         * @var     Object
         */
        history: {

            /**
             * all
             * 
             * @access  public
             * @return  Object
             */
            all: function() {
                var account = Stencil.account(),
                    all = account.setting('changeHistory');
                if (JSONUtils.valid(all) === false) {
                    return {
                        redo: [],
                        undo: []
                    };
                }
                return JSON.parse(all);
            },

            /**
             * redo
             * 
             * @access  public
             * @return  Array
             */
            redo: function() {
                return ChangeHistory.history.all().redo;
            },

            /**
             * undo
             * 
             * @access  public
             * @return  Array
             */
            undo: function() {
                return ChangeHistory.history.all().undo;
            }
        },

        /**
         * initiate
         * 
         * Helper object to initiate a redo or undo operation.
         * 
         * @access  public
         * @var     Object
         */
        initiate: {

            /**
             * redo
             * 
             * @access  public
             * @param   Number stepsForward
             * @return  void
             */
            redo: function(stepsForward) {
                var account = Stencil.account(),
                    allHistory = ChangeHistory.history.all(),
                    redoHistory = allHistory.redo;
                if (redoHistory.length > 0) {

                    // Update the history arrays (by splicing at the right spot)
                    var undoHistory = allHistory.undo,
                        slicedRedoHistory = redoHistory.splice(0, stepsForward);
                    undoHistory = undoHistory.concat(slicedRedoHistory);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': redoHistory,
                            'undo': undoHistory
                        })
                    });

                    // Prepare for change
                    var futureOperation = undoHistory[undoHistory.length - 1],
                        draft = account.draft();

                    // Change
                    draft.once({

                        /**
                         * (anonymous)
                         * 
                         * The way the below <select> method works is it
                         * first deletes all the layers on the canvas. So
                         * once that's done, I set the configuration details
                         * for the image, so that when the actual select
                         * flow begins, the proper configuration details
                         * will have been set.
                         */
                        'delete/all/finish': function(event) {
                            var sourceImageId = futureOperation.configuration.sourceImageId.toInt(),
                                sourceImage = Stencil.getModel('Image').getImageById(sourceImageId);
                            this.set({
                                'frame': futureOperation.configuration.frame,
                                'width': futureOperation.configuration.width.toInt(),
                                'height': futureOperation.configuration.height.toInt(),
                                'sourceImageId': sourceImageId.toInt(),
                                'settings.json': futureOperation.configuration.settings.json,
                                'settings.watermarks': futureOperation.configuration.settings.watermarks
                            });
                            this._setSourceImage(sourceImage);
                        },
                        'set/previewCanvas/finish': function(event) {
                            var content = App.getStage().getContent();
                            content.refreshChangeHistoryElements();
                        }
                    });
                    var locked = draft.isLocked();
                    draft.select('redo', locked, {
                        operationType: undoHistory[(undoHistory.length - 1)].type
                    });
                    draft.getImageDocument().syncLockedState();

                    // Referesh
                    App.getStage().getContent().getChangeHistoryPopover().refresh();
                }
            },

            /**
             * undo
             * 
             * @access  public
             * @param   Number stepsBack
             * @return  void
             */
            undo: function(stepsBack) {
                var account = Stencil.account(),
                    allHistory = ChangeHistory.history.all(),
                    undoHistory = allHistory.undo;
                if (undoHistory.length > 1) {

                    // Update the history arrays (by splicing at the right spot)
                    var redoHistory = allHistory.redo,
                        removedUndoOperations = undoHistory.splice(0 - stepsBack, stepsBack);
                    // removedUndoOperations.reverse();
                    redoHistory = removedUndoOperations.concat(redoHistory);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': redoHistory,
                            'undo': undoHistory
                        })
                    });

                    // Prepare for change
                    var lastOperation = undoHistory[undoHistory.length - 1],
                        draft = account.draft();

                    // Change
                    draft.once({

                        /**
                         * (anonymous)
                         * 
                         * The way the below <select> method works is it
                         * first deletes all the layers on the canvas. So
                         * once that's done, I set the configuration details
                         * for the image, so that when the actual select
                         * flow begins, the proper configuration details
                         * will have been set.
                         */
                        'delete/all/finish': function(event) {
                            var sourceImageId = lastOperation.configuration.sourceImageId.toInt(),
                                sourceImage = Stencil.getModel('Image').getImageById(sourceImageId);
                            this.set({
                                'frame': lastOperation.configuration.frame,
                                'width': lastOperation.configuration.width.toInt(),
                                'height': lastOperation.configuration.height.toInt(),
                                'sourceImageId': sourceImageId.toInt(),
                                'settings.json': lastOperation.configuration.settings.json,
                                'settings.watermarks': lastOperation.configuration.settings.watermarks
                            });
                            this._setSourceImage(sourceImage);
                        },
                        'set/previewCanvas/finish': function(event) {
                            var content = App.getStage().getContent();
                            content.refreshChangeHistoryElements();
                        }
                    });
                    var locked = draft.isLocked();
                    draft.select('undo', false, {
                        operationType: redoHistory[0].type
                    });
                    draft.getImageDocument().syncLockedState();

                    // Referesh
                    App.getStage().getContent().getChangeHistoryPopover().refresh();
                }
            }
        },

        /**
         * keyboardShortcuts
         * 
         * Helper object used to determine if a keyboard combination shortcut
         * was used to initiate a redo or undo operation.
         * 
         * @note    Safari error'd out when checking event.key. For some
         *          reason, not available there.
         * @note    I check for the range input type, since it should be okay to
         *          trigger a redo/undo if the user is focused on a slider.
         * @access  public
         * @var     Object
         */
        keyboardShortcuts: {

            /**
             * redo
             * 
             * @access  public
             * @param   jQuery event
             * @return  Boolean
             */
            redo: function(event) {
                if (ModalUtils.getOpen().length > 0) {
                    return false;
                }
                var $target = $(event.target);
                if ($target.tag() === 'input') {
                    if ($target.attr('type') !== 'range') {
                        return false;
                    }
                }
                var which = event.which.toInt(),
                    validKeys = [89, 90];
                if (ArrayUtils.contains(which, validKeys) === false) {
                    return false;
                }
                // shift + command + z
                if (which === 90) {
                    if (event.metaKey === true && event.shiftKey === true) {
                        return true;
                    }
                    if (event.ctrlKey === true && event.shiftKey === true) {
                        return true;
                    }
                    return false;
                }
                // command + y
                if (event.metaKey === true && event.shiftKey === false) {
                    return true;
                }
                if (event.ctrlKey === true && event.shiftKey === false) {
                    return true;
                }
                return false;
            },

            /**
             * undo
             * 
             * @access  public
             * @param   jQuery event
             * @return  Boolean
             */
            undo: function(event) {
                if (ModalUtils.getOpen().length > 0) {
                    return false;
                }
                var $target = $(event.target);
                if ($target.tag() === 'input') {
                    if ($target.attr('type') !== 'range') {
                        return false;
                    }
                }
                var which = event.which.toInt();
                if (which !== 90) {
                    return false;
                }
                // command + z
                if (event.metaKey === true && event.shiftKey === false) {
                    return true;
                }
                if (event.ctrlKey === true && event.shiftKey === false) {
                    return true;
                }
                return false;
            }
        },

        /**
         * persistWatermarksForFeaturedTemplates
         * 
         * Proxy for change history setting, which in this case, is used to
         * determine if a watermark should persist on templates the user does
         * not own (in practice this is only applicable to featured templates).
         * 
         * @access  public
         * @return  Boolean
         */
        persistWatermarksForFeaturedTemplates: function() {
            return Config.default('changeHistory').persistWatermarksForFeaturedTemplates === true;
        },

        /**
         * replaceAccountChangeHistory
         * 
         * This method receives raw data from the auth flow, representing the
         * account that is being logged in, and replaces the change history with
         * what's already stored in the ChangeHistory singleton. This is
         * important because without it, the change history for a session would
         * get lost, since the default setting for change history is just the
         * empty redo and undo arrays.
         * 
         * @access  public
         * @param   Object accountData
         * @return  Object
         */
        replaceAccountChangeHistory: function(accountData) {
            var currentChangeHistory = ChangeHistory.history.all(),
                currentChangeHistoryJson = JSON.stringify(currentChangeHistory);
            accountData.settings.changeHistory = currentChangeHistoryJson;
            return accountData;
        },

        /**
         * replaceConsecutiveMirrors
         * 
         * Oh boy this one is fun. So...
         * When a watermark is deleted from an account, it's possible that there
         * are operations in either the redo or undo stack that solely relate to
         * that watermark. For example, when a watermark is moved, nudged,
         * rotated, resized, or a filter is applied to it.
         * 
         * When a watermark is deleted, however, those operations should no
         * longer be available in the change history, since that watermark can't
         * actually be reverted to. So I deal with this by iterating over all
         * the operations and removed any that are "consecutive mirrors" of
         * one another. This is possible because in a previous step (defined in
         * the syncWatermark method), the watermarks array in the configuration
         * object is actually removed. So there wouldn't be anything different
         * in the configuration objects as a whole.
         * 
         * I'm a bit worried that this could result in removing some valid
         * operations, but I _think_ it's okay..
         * 
         * @note    In most places in this class, I operate against the change
         *          history stacks in alphabetical order (namely, redo and then
         *          undo). I need to operate on them here in the undo -> redo
         *          order to prevent issues with splicing.
         * @access  public
         * @return  void
         */
        replaceConsecutiveMirrors: function() {
            var account = Stencil.account(),
                index,
                operations = {},
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo();
            index = undoHistory.length;
            while (index--) {
                if (index === 0) {
                    continue;
                }
                operations.current = undoHistory[index];
                operations.previous = undoHistory[index - 1];
                if (JSON.stringify(operations.current.configuration) === JSON.stringify(operations.previous.configuration)) {
                    undoHistory.splice(index, 1);
                }
            }
            index = redoHistory.length;
            while (index--) {
                if (index === 0) {
                    operations.previous = undoHistory[undoHistory.length - 1];
                } else {
                    operations.previous = redoHistory[index - 1];
                }
                operations.current = redoHistory[index];
                if (JSON.stringify(operations.current.configuration) === JSON.stringify(operations.previous.configuration)) {
                    redoHistory.splice(index, 1);
                }
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * replaceLastUndoOperation
         * 
         * This exists only, at the moment, to support VectorImage drawings.
         * This is because when a VectorImage is drawn via a user action
         * (opposed to from the app initially loading, and having a VectorImage
         * part of the initial image document / json), we check if the ratio of
         * the drawing is less than 1 (meaning it's taller than it is wide).
         * 
         * If it is, we resize the width so that it's proportional to a maximum
         * height of 25% of the canvas. The problem with doing this, is it
         * happens after the ChangeHistory.track call happens (which makes
         * sense, because a vector can take a little while to load).
         * 
         * So if we don't replace the last undo operation, it would result in
         * another undo operation appearing in the history (since the json of
         * the configuration object would in fact be different).
         * 
         * So: we provide this helper method to replace the last undo operation.
         * See the VectorImage.js drawing to see how this is used.
         * 
         * Update: Saturday, February 18th, 2017
         * This method is used in two other places:
         * 1) the syncBackgroundImageSet method
         * 2) The throttling of groupable operation types
         * 
         * @access  public
         * @param   Object operation
         * @return  void
         */
        replaceLastUndoOperation: function(operation) {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                index = undoHistory.length - 1;
            undoHistory[index] = operation;
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': ChangeHistory.history.redo(),
                    'undo': undoHistory
                })
            });
        },

        /**
         * replaceUserChangeHistory
         * 
         * This does the same as replaceAccountChangeHistory, but simply for the
         * active account, and loops over the accounts being passed down, and
         * when matching the account the user is logging into, replaces the
         * change history for it.
         * 
         * @access  public
         * @param   Object userData
         * @return  Object
         */
        replaceUserChangeHistory: function(userData) {
            var currentChangeHistory = ChangeHistory.history.all(),
                currentChangeHistoryJson = JSON.stringify(currentChangeHistory),
                index;
            userData.active.settings.changeHistory = currentChangeHistoryJson;
            for (index in userData.accounts) {
                if (userData.accounts[index].id.toInt() === userData.active.id.toInt()) {
                    userData.accounts[index].settings.changeHistory = currentChangeHistoryJson;
                }
            }
            return userData;
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        // pause: function() {
        //     __paused = true;
        // },

        /**
         * setOperationType
         * 
         * @access  public
         * @param   String type
         * @return  void
         */
        setOperationType: function(type) {
            if (__operationType === false) {
                __operationType = type;
            }
        },

        /**
         * syncBackgroundImageSet
         * 
         * When a background image is set, after it's been loaded, the
         * background is set to white. I believe the logic at the time of
         * implementation was that it should be white, because if the user
         * removes the background image, they would expect to see a white
         * background and not whatever the background rectangle's color was set
         * to last.
         * 
         * The issue with this is that when the user eventually clicks somewhere
         * else on the page, it will trigger a ChangeHistory.track call, which
         * will incorrectly believe the image JSON is different (since the
         * background color may have changed from a color before the background
         * image was set, to white).
         * 
         * So this method's purpose is to grab the last change operation, and
         * overwrite whatever color is there with white, to ensure a
         * false-positive doesn't occur.
         * 
         * @access  public
         * @return  void
         */
        syncBackgroundImageSet: function() {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                lastUndoOperation = undoHistory[undoHistory.length - 1],
                index,
                layer,
                white = ColorUtils.getWhite('rgba'),
                backgroundColor,
                json = lastUndoOperation.configuration.settings.json,
                jsonObject = JSON.parse(json);
            for (index in jsonObject.layers) {
                layer = jsonObject.layers[index];
                if (layer.type === 'rectangle' && layer.background === true) {
                    backgroundColor = ColorUtils.addSpaces(
                        layer.styles.backgroundColor
                    );
                    if (backgroundColor !== white) {
                        layer.styles.backgroundColor = white;
                        json = JSON.stringify(jsonObject);
                        lastUndoOperation.configuration.settings.json = json;
                        ChangeHistory.replaceLastUndoOperation(
                            lastUndoOperation
                        );
                        break;
                    }
                }
            }
        },

        /**
         * syncDeletedFont
         * 
         * This method is responsible for swapping out any fonts that have been
         * deleted, and replacing them with the defaultFontFamily for the
         * account (which is stored in the AccountAccessor's settings, since we
         * wanted it to be flexible enough for account's to be able to define
         * their own default font).
         * 
         * This is again importantt, since once a font is deleted, it can't be
         * gracefully restored to the app's flow. So we want to ensure
         * operations aren't referencing fonts that can't be properly used
         * through previous or future operations.
         * 
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        syncDeletedFont: function(font) {
            var key = font.get('key'),
                account = Stencil.account(),
                appDefaultFontFamily = account.getDefaultFontFamily(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json,
                regExp = new RegExp(key, 'g');
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace(regExp, appDefaultFontFamily);
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace(regExp, appDefaultFontFamily);
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncLockedOperations
         * 
         * When a user logs into an upgraded account, or upgrades their account,
         * it's possible that previously they had some change operations that
         * included a locked asset. This helper method is designed to go through
         * all previously and future-oriented change operations and remove any
         * locked-state's for layers.
         * 
         * @access  public
         * @return  void
         */
        syncLockedOperations: function() {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json;
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace('"locked":true', '"locked":false');
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace('"locked":true', '"locked":false');
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncResourceKeyInOperations
         * 
         * This method is responsible for looping over all operations in the
         * change history, and replacing any keys matching previousKey with
         * newKey. This is important because when a 3rd-party resource is
         * initially used, the resource is loaded directly, before a /save
         * call is made. Once that call comes back, it changes the
         * image-property for the JSON of the draft to that new key.
         * 
         * After this happens, if the user initiates a ChangeHistory.track call
         * (via the mouseup or keyup events), the app will think something is
         * different (even though that's not the case).
         * 
         * @access  public
         * @param   String previousKey
         * @param   String newKey
         * @return  void
         */
        syncResourceKeyInOperations: function(previousKey, newKey) {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json,
                regExp = new RegExp(previousKey, 'g');
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace(regExp, newKey);
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace(regExp, newKey);
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncSourceImageId
         * 
         * This method is responsible for swapping out the sourceImageId value
         * for operations. The reason this is required is because when a save
         * happens, previous operations (before the save action) have a
         * sourceImageId that corresponds to the draft at that time. But when a
         * save happens, the draft imageId changes, and so the previous
         * operations would be seen to be different, and would result in
         * improper Footer button UI states.
         * 
         * So, this method should only really be called when a save action
         * happens, since at the moment, that's the only time the account's
         * draft image can have it's imageId changed.
         * 
         * @access  public
         * @param   Number previousSourceImageId
         * @param   Number newSourceImageId
         * @return  void
         */
        syncSourceImageId: function(previousSourceImageId, newSourceImageId) {
            var account = Stencil.account(),
                index,
                operation,
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo();
            for (index in redoHistory) {
                operation = redoHistory[index];
                if (operation.configuration.sourceImageId.toInt() === previousSourceImageId.toInt()) {
                    operation.configuration.sourceImageId = newSourceImageId.toInt();
                }
            }
            for (index in undoHistory) {
                operation = undoHistory[index];
                if (operation.configuration.sourceImageId.toInt() === previousSourceImageId.toInt()) {
                    operation.configuration.sourceImageId = newSourceImageId.toInt();
                }
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncWatermark
         * 
         * This method is responsible for removing any watermark layers from
         * change operations that match the passed in uploadKey argument. This
         * needs to exist because it's possible for a user to delete a watermark
         * that exists in the change history stacks. If this isn't taken into
         * consideration, iterating through the change history can cause a bug.
         * 
         * This method does not yet splice out the watermark operations for the
         * deleted watermark. Ideally, it would.
         * 
         * @access  public
         * @param   String uploadKey
         * @return  void
         */
        syncWatermark: function(uploadKey) {
            var account = Stencil.account(),
                index,
                index2,
                operation,
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo(),
                watermark,
                watermarks;
            for (index in redoHistory) {
                operation = redoHistory[index];
                watermarks = JSON.parse(operation.configuration.settings.watermarks);
                for (index2 in watermarks.layers) {
                    watermark = watermarks.layers[index2];
                    if (watermark.image === uploadKey) {
                        watermarks.layers.splice(index2, 1);
                    }
                }
                redoHistory[index].configuration.settings.watermarks = JSON.stringify(watermarks);
            }
            for (index in undoHistory) {
                operation = undoHistory[index];
                watermarks = JSON.parse(operation.configuration.settings.watermarks);
                for (index2 in watermarks.layers) {
                    watermark = watermarks.layers[index2];
                    if (watermark.image === uploadKey) {
                        watermarks.layers.splice(index2, 1);
                    }
                }
                undoHistory[index].configuration.settings.watermarks = JSON.stringify(watermarks);
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });

            // 
            ChangeHistory.replaceConsecutiveMirrors();
        },

        /**
         * track
         * 
         * This is the heavy-lifter. It tracks a change operation in the undo
         * history, and when an undo operation happens, ensures the redo array
         * receives the previously undone operation.
         * 
         * @note    The redo and undo property checks are meant to determine
         *          if the source of a trackChangeHistory call is from undoing
         *          or redoing a previous change. We do not want to track those,
         *          since they're not actually changes the user is performing,
         *          but rather changes they're reverting, or reverting back to.
         * @access  public
         * @param   Boolean clearRedoHistory
         * @param   false|jQuery event The event (if any) that triggered the
         *          track call, currently being used for grouping related
         *          operations
         * @return  void
         */
        track: function(clearRedoHistory, event) {
// console.log('track called');
            var draft = Stencil.account().draft(),
                currentConfiguration = draft.getConfiguration(),
                account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo();

            // This should only happen when the app is initially loaded
            if (undoHistory.length === 0) {
                var currentUnixTimestamp = DTUtils.getTimestamp(),
                    operation = {
                        configuration: currentConfiguration,
                        description: __getOperationDescription(),
                        timestamp: {
                            full: currentUnixTimestamp,
                            simple: Math.floor(currentUnixTimestamp)
                        },
                        type: __getOperationType()
                    };
                undoHistory.push(operation);
                account.set({
                    'settings.changeHistory': JSON.stringify({
                        'redo': ChangeHistory.history.redo(),
                        'undo': undoHistory
                    })
                });
                __operationType = false;
            } else {
                var lastUndoChange = undoHistory[undoHistory.length - 1],
                    currentConfigurationString = JSON.stringify(currentConfiguration),
                    lastUndoChangeString = JSON.stringify(lastUndoChange.configuration);
                currentConfigurationString = ColorUtils.addSpaces(currentConfigurationString);
                lastUndoChangeString = ColorUtils.addSpaces(lastUndoChangeString);
                if (currentConfigurationString !== lastUndoChangeString) {

                    // Operation
                    var currentUnixTimestamp = DTUtils.getTimestamp(),
                        operation = {
                            configuration: currentConfiguration,
                            description: __getOperationDescription(),
                            timestamp: {
                                full: currentUnixTimestamp,
                                simple: Math.floor(currentUnixTimestamp)
                            },
                            type: __getOperationType()
                        };

                    // If the operation should replace the last one
                    if (__replacableOperation(operation, event) === true) {
                        ChangeHistory.replaceLastUndoOperation(operation);
                        undoHistory = ChangeHistory.history.undo();
                    } else {
                        undoHistory.push(operation);
                    }

                    // 
                    var maxOperations = __getMaxOperations();
                    __operationType = false;
                    undoHistory = undoHistory.slice(0 - maxOperations - 1);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': ChangeHistory.history.redo(),
                            'undo': undoHistory
                        })
                    });

                    /**
                     * Clear redo history
                     * 
                     * This logic ensures the redo history is entirely cleared. This
                     * happens when a user actively makes any change to the image,
                     * since any previous changes in the redo history stack are no
                     * longer relevant.
                     * 
                     * It's also being triggered when the app initially loads, since
                     * the redo stack should be empty at that time anyway.
                     */
                    if (clearRedoHistory === true) {
                        account.set({
                            'settings.changeHistory': JSON.stringify({
                                'redo': [],
                                'undo': ChangeHistory.history.undo()
                            })
                        });
                    }
                } else {
                    __operationType = false;
                }
            }

            // Refresh shit
            App.getStage().getContent().refreshChangeHistoryElements();
            App.getStage().getContent().getChangeHistoryPopover().refresh();
        }

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        // unpause: function() {
        //     __paused = false;
        // }
    });
})();

/**
 * ClientWrappers
 * 
 * @abstract
 */
window.ClientWrappers = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'clientWrappers')
     */
    var __classType = 'clientWrappers';

    /**
     * __clientWrappers
     * 
     * @access  private
     * @var     Array (default: [])
     */
    var __clientWrappers = [];

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ClientWrappers')
     */
    var __string = 'ClientWrappers';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * get
         * 
         * @access  public
         * @param   String serviceKey
         * @return  BaseClientWrapper
         */
        get: function(serviceKey) {
            if (__clientWrappers[serviceKey] !== undefined) {
                var clientWrapper = __clientWrappers[serviceKey];
                return clientWrapper;
            }
            var className = StringUtils.ucfirst(serviceKey) + 'ClientWrapper',
                clientWrapper = new window[className];
            __clientWrappers[serviceKey] = clientWrapper;
            return clientWrapper;
        }
    });
})();
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * AccountDockClientWrapper
     * 
     * @extends BaseClientWrapper
     */
    window.AccountDockClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'accountDock')
         */
        _serviceKey: 'accountDock',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AccountDockClientWrapper')
         */
        _string: 'AccountDockClientWrapper',

        /**
         * _configure
         * 
         * @access  protected
         * @return  Boolean
         */
        _configure: function() {
            if (StringUtils.validMethod('window.AccountDock.configure') === false) {
                return false;
            }
            var key = this._getKey();
            window.AccountDock.configure({
                key: key
            });
            return true;
        },

        /**
         * _getKey
         * 
         * @access  protected
         * @return  String
         */
        _getKey: function() {
            var config = Config.get('accountDock'),
                key = config.key;
            return key;
        },

        /**
         * openWindow
         * 
         * @access  public
         * @param   String key
         * @return  Boolean
         */
        openWindow: function(key) {
            if (Config.serviceAvailable('accountDock') === false) {
                Stencil.alert('services.accountDock.unavailable');
                return false;
            }
            if (UserAgentUtils.extension() === true) {
                Stencil.alert('services.accountDock.extension.disabled');
                return false;
            }
            if (Scripts.loaded('accountDock') === false) {
                Scripts.waitFor('accountDock');
                return false;
            }
            if (StringUtils.validMethod('window.AccountDock.configure') === false) {
                Stencil.alert('services.accountDock.blocked');
                return false;
            }
            var handler = window.AccountDock.configure({
                customer: key
            });
            handler.open({
                container: 'window'
            });
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._configure();
            return true;
        }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * BaseClientWrapper
     * 
     * @events  loaded
     *          failed
     * @extends Base
     */
    window.BaseClientWrapper = Base.extend({

        /**
         * _aggressiveLogging
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _aggressiveLogging: false,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'baseClientWrapper')
         */
        _classType: 'baseClientWrapper',

        /**
         * _failed
         * 
         * Boolean value tracking whether the external request for this client
         * wrapper failed.
         * 
         * @access  protected
         * @var     Boolean (defaut: false)
         */
        _failed: false,

        /**
         * _loaded
         * 
         * Boolean value tracking whether the external request for this client
         * wrapper was successful.
         * 
         * @access  protected
         * @var     Boolean (defaut: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Boolean value tracking whether the external request for this client
         * wrapper is currently being made.
         * 
         * @access  protected
         * @var     Boolean (defaut: false)
         */
        _loading: false,

        /**
         * _routeThroughProxy
         * 
         * @access  protected
         * @var     Boolean (defaut: true)
         */
        _routeThroughProxy: true,

        /**
         * _scriptTimeout
         * 
         * Maximum number of milliseconds to wait before triggering a failed
         * error for this client wrapper's external request.
         * 
         * @access  protected
         * @var     Number (defaut: 27.5 * 1000) in milliseconds (aka 27.5
         *          seconds)
         */
        _scriptTimeout: 27.5 * 1000,

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     null|String (defaut: null)
         */
        _serviceKey: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BaseClientWrapper')
         */
        _string: 'BaseClientWrapper',

        /**
         * _url
         * 
         * @access  protected
         * @var     null|String (defaut: null)
         */
        _url: null,

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            this._addFailEventListener();
            this._setUrl();
        },

        /**
         * _addFailEventListener
         * 
         * @access  protected
         * @return  Boolean
         */
        _addFailEventListener: function() {
            var _this = this,
                serviceKey = this._serviceKey;
            this.once({
                'failed': function(event) {
                    var msg = 'Could not load script: ' + (serviceKey);
                    LogUtils.log.object(_this, msg, true);
                }
            });
            return true;
        },

        /**
         * _log
         * 
         * @access  protected
         * @param   String msg
         * @return  Boolean
         */
        _log: function(msg) {
            var override = this._aggressiveLogging;
            LogUtils.log.simple(msg, override);
            return true;
        },

        /**
         * _requestScript
         * 
         * @note    It's important that the error callback for this call does
         *          not trigger a RequestUtils.alive / Stencil.error call. This
         *          is because I'm managing Scripts failing to load within
         *          Scripts.waitFor where I show a Stencil.alert instead,
         *          communicating to the user that the dependency failed to
         *          load.
         * @access  protected
         * @return  Boolean
         */
        _requestScript: function() {
            var signature = {"basename":"Base.js","line":161},
                url = this._url;
            this._loading = true;
            RequestUtils.ajax({
                excludeDefaultData: true,
                cache: true,
                signature: signature,
                timeout: this._scriptTimeout,
                url: url,
                type: 'GET',
                dataType: 'script',
                error: this._requestScriptErrorHandler.proxy(this),
                success: this._requestScriptSuccessHandler.proxy(this)
            });
            return true;
        },

        /**
         * _requestScriptErrorHandler
         * 
         * @access  protected
         * @return  Boolean
         */
        _requestScriptErrorHandler: function() {
            this._failed = true;
            this._loaded = false;
            this._loading = false;
            this.triggerHandler('failed');
            return true;
        },

        /**
         * _requestScriptSuccessHandler
         * 
         * @access  protected
         * @return  Boolean
         */
        _requestScriptSuccessHandler: function() {
            this._failed = false;
            this._loaded = true;
            this._loading = false;
            this.triggerHandler('loaded');
            return true;
        },

        /**
         * _serviceAvailable
         * 
         * @access  protected
         * @return  Boolean
         */
        _serviceAvailable: function() {
            var serviceKey = this._serviceKey,
                serviceAvailable = Config.serviceAvailable(serviceKey);
            return serviceAvailable;
        },

        /**
         * _setUrl
         * 
         * @access  protected
         * @return  Boolean
         */
        _setUrl: function() {
            var scripts = Config.get('scripts'),
                serviceKey = this._serviceKey;
            if (scripts[serviceKey] === undefined) {
                return false;
            }
            var script = scripts[serviceKey],
                url = script.url,
                hash = script.hash,
                timestamp = script.timestamp;
            this._url = url;
            if (this._shouldRouteThroughProxy() === true) {
                var queryString = timestamp;
                this._url = '/utils/scripts/proxy/' + (hash);
                this._url += '?' + (queryString);
            }
            return true;
        },

        /**
         * _shouldRouteThroughProxy
         * 
         * @access  protected
         * @return  Boolean
         */
        _shouldRouteThroughProxy: function() {
            var routeScriptsThroughProxy = Config.get('security').routeScriptsThroughProxy;
            if (routeScriptsThroughProxy === false) {
                return false;
            }
            var routeThroughProxy = this._routeThroughProxy;
            return routeThroughProxy;
        },

        /**
         * enabled
         * 
         * @access  public
         * @return  Boolean
         */
        enabled: function() {
            var serviceAvailable = this._serviceAvailable();
            if (serviceAvailable === false) {
                var serviceKey = this._serviceKey,
                    msg = 'Service *' + (serviceKey) + '* disabled';
                this._log(msg);
            }
            return serviceAvailable;
        },

        /**
         * failed
         * 
         * @access  public
         * @return  Boolean
         */
        failed: function() {
            var failed = this._failed;
            return failed;
        },

        /**
         * load
         * 
         * @access  public
         * @return  Boolean
         */
        load: function() {
            if (this.enabled() === false) {
                return false;
            }
            this.prepare();
            this.once(
                'loaded',
                this.setup.proxy(this)
            );
            this._requestScript();
            return true;
        },

        /**
         * loaded
         * 
         * @access  public
         * @return  Boolean
         */
        loaded: function() {
            var loaded = this._loaded;
            return loaded;
        },

        /**
         * loading
         * 
         * @access  public
         * @return  Boolean
         */
        loading: function() {
            var loading = this._loading;
            return loading;
        },

        /**
         * prepare
         * 
         * @access  public
         * @return  Boolean
         */
        prepare: function() {
            var msg = 'Preparing: ' + (this._serviceKey);
            this._log(msg);
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            var msg = 'Setting up: ' + (this._serviceKey);
            this._log(msg);
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * ChromeWebstoreClientWrapper
     * 
     * @extends BaseClientWrapper
     */
    window.ChromeWebstoreClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'chromeWebstore')
         */
        _serviceKey: 'chromeWebstore',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChromeWebstoreClientWrapper')
         */
        _string: 'ChromeWebstoreClientWrapper',

        /**
         * _promptInstall
         * 
         * @access  protected
         * @return  Boolean
         */
        _promptInstall: function() {
            if (StringUtils.validMethod('window.chrome.webstore.install') === false) {
                return false;
            }
            var $link = $('link[rel="chrome-webstore-item"][class="extension"]');
            window.chrome.webstore.install(
                $link.attr('href'),
                function() {
                    Stencil.navigate('/app/extras/chrome/success');
                },
                function(message, code) {
                    var msgs = ['Errored', message, code];
                    LogUtils.log.simple(msgs, true)
                    if (code === 'notPermitted') {
                    } else if (code === 'userCancelled') {
                    }
                }
            );
            return true;
        },

        /**
         * available
         * 
         * @access  public
         * @return  Boolean
         */
        available: function() {
            var available = StringUtils.validObject('window.chrome.webstore');
            return available;
        },

        /**
         * promptInstall
         * 
         * @access  public
         * @return  Boolean
         */
        promptInstall: function() {
            var $link = $('link[rel="chrome-webstore-item"][class="extension"]');
            if ($link.length === 0) {
                return false;
            }
            var prompted = this._promptInstall();
            return prompted;
        }
    });
});
window.DependencyLoader.push('ImageResizerServiceRequestClientWrapper', function() {

    /**
     * CloudinaryRequestClientWrapper
     * 
     * @note    Meant to mirror as close as possible the server side version of
     *          this.
     * @extends ImageResizerServiceRequestClientWrapper
     */
    window.CloudinaryRequestClientWrapper = ImageResizerServiceRequestClientWrapper.extend({

        /**
         * _proxy
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _proxy: null,

        /**
         * _quality
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _quality: null,

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'cloudinaryRequest')
         */
        _serviceKey: 'cloudinaryRequest',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CloudinaryRequestClientWrapper')
         */
        _string: 'CloudinaryRequestClientWrapper',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _cleanPath
         * 
         * Replaces Share As Image local and dev proxies with the production
         * one, since locally and on dev, the production database has been
         * imported, and thus the proxy should never be the local or dev
         * version.
         * 
         * @note    I haven't been able to test this
         * @access  protected
         * @param   String path
         * @return  String
         */
        _cleanPath: function(path) {
            path = path.replace(/sai\.images\.local/, 'sai.images');
            path = path.replace(/sai\.images\.dev/, 'sai.images');
            return path;
        },

        /**
         * _getCloudName
         * 
         * @access  protected
         * @return  String
         */
        _getCloudName: function() {
            var config = Config.get(),
                cloudName = config.cloudinary.name;
            return cloudName;
        },

        /**
         * _getHost
         * 
         * @access  protected
         * @return  String
         */
        _getHost: function() {
            var config = Config.get(),
                host = config.aws.cloudFront.distributions.cloudinary.host;
            return host;
        },

        /**
         * _getProxy
         * 
         * @access  protected
         * @return  String
         */
        _getProxy: function() {
            if (this._proxy === null) {
                var config = Config.get(),
                    proxy = config.cloudinary.proxies.stencil;
                return proxy;
            }
            var proxy = this._proxy;
            return proxy;
        },

        /**
         * crop
         * 
         * @see     https://cloudinary.com/documentation/image_transformations#crop
         * @access  public
         * @param   Number x
         * @param   Number y
         * @param   Number width
         * @param   Number height
         * @return  Boolean
         */
        crop: function(x, y, width, height) {
            var pieces = [
                    'x_' + (x),
                    'y_' + (y),
                    'w_' + (width),
                    'h_' + (height),
                    'c_crop'
                ],
                transformation = pieces.join(',');
            this._transformations.push(transformation);
            return true;
        },

        /**
         * else
         * 
         * @access  public
         * @return  Object
         */
        else: function() {
            var pieces = [
                    'if',
                    'else'
                ],
                transformation = pieces.join('_');
            this._transformations.push(transformation);
            return {
                then: (function(callback) {
                    var transformations = this._transformations.length;
                    callback();
                    var transformationsAdded = this._transformations.length - transformations,
                        deletedCount = 1 + (transformationsAdded),
                        pieces = this._transformations.splice(0 - deletedCount),
                        transformation = pieces.join(',');
                    this._transformations.push(transformation);
                }).proxy(this)
            };
        },

        /**
         * format
         * 
         * @access  public
         * @param   String format
         * @return  Boolean
         */
        format: function(format) {
            var transformation = 'f_' + (format);
            this._transformations.push(transformation);
            return true;
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var pieces = [],
                cloudName = this._getCloudName();
            pieces.push(cloudName);
            pieces.push('image/upload');
            var transformations = this._transformations,
                index;
            if (this._quality !== null) {
                var transformation = 'q_' + (this._quality);
                this._transformations.push(transformation);
            }
            for (index in transformations) {
                pieces.push(transformations[index]);
            }
            var proxy = this._getProxy();
            pieces.push(proxy);
            pieces.push(this._objectKey);
            var path = '/';
            path += pieces.join('/');
            path = this._cleanPath(path);
            return path;
        },

        /**
         * height
         * 
         * @access  public
         * @param   Number height
         * @return  Boolean
         */
        height: function(height) {
            var transformation = 'h_' + (height);
            this._transformations.push(transformation);
            return true;
        },

        /**
         * if
         * 
         * @access  public
         * @param   String property
         * @param   String comparison
         * @param   mixed value
         * @return  Object
         */
        if: function(property, comparison, value) {
            var pieces = [
                    'if',
                    property,
                    comparison,
                    value
                ],
                transformation = pieces.join('_');
            this._transformations.push(transformation);
            return {
                then: (function(callback) {
                    var transformations = this._transformations.length;
                    callback();
                    var transformationsAdded = this._transformations.length - transformations,
                        deletedCount = 1 + (transformationsAdded),
                        pieces = this._transformations.splice(0 - deletedCount),
                        transformation = pieces.join(',');
                    this._transformations.push(transformation);
                }).proxy(this)
            };
        },

        /**
         * mask
         * 
         * @access  public
         * @param   String objectKey
         * @param   null|String proxy (default: null)
         * @return  Boolean
         */
        mask: function(objectKey, proxy) {
            proxy = DataUtils.getDefaultValue(proxy, null);
            var maskObjectKey = objectKey;
            if (proxy !== null) {
                maskObjectKey = (proxy) + '/' + objectKey;
                maskObjectKey = maskObjectKey.replace('/', ':');
            }
            var pieces = [
                    'l_' + (maskObjectKey),
                    'fl_cutter.relative',
                    'w_1.0',
                    'h_1.0'
                ],
                transformation = pieces.join(',');
            this._transformations.push(transformation);
            return true;
        },

        /**
         * radius
         * 
         * @access  public
         * @param   null|String $radius
         * @return  Boolean
         */
        radius: function(radius) {
            if (radius === null) {
                return false;
            }
            var transformation = 'r_' + (radius);
            this._transformations.push(transformation);
            return true;
        },

        /**
         * scaleHeight
         * 
         * @access  public
         * @param   Number height
         * @return  Boolean
         */
        scaleHeight: function(height) {
            var pieces = [
                    'h_' + (height),
                    'c_scale'
                ],
                transformation = pieces.join(',');
            this._transformations.push(transformation);
            return true;
        },

        /**
         * scaleWidth
         * 
         * @access  public
         * @param   Number width
         * @return  Boolean
         */
        scaleWidth: function(width) {
            var pieces = [
                    'w_' + (width),
                    'c_scale'
                ],
                transformation = pieces.join(',');
            this._transformations.push(transformation);
            return true;
        },

        /**
         * setProxy
         * 
         * @access  public
         * @param   String proxyKey
         * @return  Boolean
         */
        setProxy: function(proxyKey) {
            var config = Config.get(),
                proxy = config.cloudinary.proxies[proxyKey];
            this._proxy = proxy;
            return true;
        },

        /**
         * setQuality
         * 
         * @access  public
         * @param   null|String quality
         * @return  Boolean
         */
        setQuality: function(quality) {
            this._quality = quality;
            return true;
        },

        /**
         * width
         * 
         * @access  public
         * @param   Number width
         * @return  Boolean
         */
        width: function(width) {
            var transformation = 'w_' + (width);
            this._transformations.push(transformation);
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * FacebookClientWrapper
     * 
     * @extends BaseClientWrapper
     */
    window.FacebookClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'facebook')
         */
        _serviceKey: 'facebook',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FacebookClientWrapper')
         */
        _string: 'FacebookClientWrapper',

        /**
         * _init
         * 
         * @access  protected
         * @return  Boolean
         */
        _init: function() {
            if (StringUtils.validMethod('window.FB.init') === false) {
                return false;
            }
            var id = this._getId(),
                version = this._getVersion();
            window.FB.init({
                appId: id,
                status: true,
                cookie: true,
                xfbml: true,
                version: version
            });
            return true;
        },

        /**
         * _getId
         * 
         * @access  protected
         * @return  String
         */
        _getId: function() {
            var config = Config.get('facebook'),
                id = config.id;
            return id;
        },

        /**
         * _getVersion
         * 
         * @access  protected
         * @return  String
         */
        _getVersion: function() {
            var config = Config.get('facebook'),
                version = config.version;
            version = 'v' + (version);
            return version;
        },

        /**
         * promptLogin
         * 
         * @access  public
         * @param   Array permissions
         * @param   Function callback
         * @return  Boolean
         */
        promptLogin: function(permissions, callback) {
            Scripts.load('facebook', function() {
                if (StringUtils.validMethod('window.FB.login') === false) {
                    return false;
                }
                window.FB.login(
                    callback,
                    {
                        auth_type: 'rerequest',
                        scope: permissions.join(','),
                        enable_profile_selector: true,
                        return_scopes: true
                    }
                );
                return true;
            });
            return true;
        },

        /**
         * requestPermissions
         * 
         * @access  public
         * @param   Function callback
         * @return  Boolean
         */
        requestPermissions: function(callback) {
            if (StringUtils.validMethod('window.FB.api') === false) {
                return false;
            }
            window.FB.api('/me/permissions', callback);
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._init();
            return true;
        },

        /**
         * showShareDialog
         * 
         * @access  public
         * @param   Object shareObject
         * @param   undefined|Function callback (default: function() {})
         * @return  Boolean
         */
        showShareDialog: function(shareObject, callback) {
            callback = DataUtils.getDefaultValue(callback, function() {});
            if (StringUtils.validMethod('window.FB.ui') === false) {
                return false;
            }
            window.FB.ui(shareObject, function(response) {
                callback(response);
            });
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * HeadwayClientWrapper
     * 
     * @see     https://headway.gitbooks.io/docs/content/widget.html
     * @extends BaseClientWrapper
     */
    window.HeadwayClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'headway')
         */
        _serviceKey: 'headway',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'HeadwayClientWrapper')
         */
        _string: 'HeadwayClientWrapper',

        /**
         * _getConfigObject
         * 
         * @access  protected
         * @return  Object
         */
        _getConfigObject: function() {
            var id = this._getId(),
                configObject = {
                    selector: 'header div.headway',
                    account: id
                };
            return configObject;
        },

        /**
         * _getId
         * 
         * @access  protected
         * @return  String
         */
        _getId: function() {
            var config = Config.get('headway'),
                id = config.auth.apps.paid.id;
            return id;
        },

        /**
         * _init
         * 
         * @access  protected
         * @return  Boolean
         */
        _init: function() {
            if (StringUtils.validMethod('window.Headway.init') === false) {
                return false;
            }
            var configObject = this._getConfigObject();
            window.Headway.init(configObject);
            return true;
        },

        /**
         * _setupTabIndexCheck
         * 
         * @note    tabindex logic below is to make it so that nothing in the
         *          iframe can be accessed via the tab-key.
         * @access  protected
         * @return  Boolean
         */
        _setupTabIndexCheck: function() {
            var interval = (function() {
                if ($('#HW_frame_cont iframe').length !== 0) {
                    $('#HW_frame_cont iframe').attr('tabindex', '-1');
                    IntervalPool.clear(interval);
                }
            }).interval(250);
            return true;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  Boolean
         */
        hide: function() {
            if (StringUtils.validMethod('window.Headway.hide') === false) {
                return false;
            }
            window.Headway.hide();
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._setupTabIndexCheck();
            this._init();
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * HelpScoutClientWrapper
     * 
     * @see     https://developer.helpscout.com/beacons/javascript-api/
     * @extends BaseClientWrapper
     */
    window.HelpScoutClientWrapper = BaseClientWrapper.extend({

        /**
         * _routeThroughProxy
         * 
         * Overwriting whatever the value of BaseClientWrapper is, since
         * HelpScout doesn't work properly when script is proxied.
         * 
         * @access  protected
         * @var     Boolean (defaut: false)
         */
        _routeThroughProxy: false,

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'helpScout')
         */
        _serviceKey: 'helpScout',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'HelpScoutClientWrapper')
         */
        _string: 'HelpScoutClientWrapper',

        /**
         * _getId
         * 
         * @access  protected
         * @return  String
         */
        _getId: function() {
            var config = Config.get('helpScout'),
                id = config.auth.beacon.id;
            return id;
        },

        /**
         * _prepare
         * 
         * @access  protected
         * @return  Boolean
         */
        _prepare: function() {
            var id = this._getId();
            !function(e,o,n){
                window.HSCW = o,
                window.HS = n,
                n.beacon = n.beacon || {};
                var t = n.beacon;
                t.userConfig = {},
                t.readyQueue = [],
                t.config = function(e) {
                    this.userConfig = e;
                },
                t.ready = function(e) {
                    this.readyQueue.push(e);
                },
                o.config = {
                    docs: {
                        enabled: !0,
                        baseUrl: '//stencil.helpscoutdocs.com/'
                    },
                    contact: {
                        enabled: !0,
                        formId: id
                    }
                };
            }(document, window.HSCW || {}, window.HS || {});
            return true;
        },

        /**
         * _setupBeacon
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupBeacon: function() {
            if (StringUtils.validMethod('window.HS.beacon.config') === false) {
                return false;
            }
            window.HS.beacon.config({
                poweredBy: false,
                showName: true,
                icon: 'buoy',
                position: 'left',
                translation: {
                    nameLabel: 'Your full name',
                    contactSuccessDescription: 'Thanks for getting in touch! ' +
                        'We\'ll try to get back to you within 24 business ' +
                        'hours (Monday-Friday 9am-6pm EST).'
                },
                color: '#35ACE0',
                topArticles: true,
                topics: [
                    { val: 'need-help', label: 'Need help with Stencil' },
                    { val: 'download-bug', label: 'My images aren\'t downloading'},
                    { val: 'bug', label: 'I think I found a bug!'},
                    { val: 'cancel', label: 'I\'d like to cancel my account'},
                    { val: 'saying-hi', label: 'Just saying hi!'},
                    { val: 'other', label: 'Other'}
                ],
                zIndex: 101,
                attachment: true,
                instructions: 'Fill out this form and we\'ll get right back ' +
                    'to you!'
            });
            return true;
        },

        /**
         * _setupFade
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupFade: function() {
            (function() {
                $('#hs-beacon').addClass('visible');
            }).delay(1000);
            return true;
        },

        /**
         * _setupIdentify
         * 
         * @access  protected
         * @param   undefined|Object additionalUserTraits (default: {})
         * @return  Boolean
         */
        _setupIdentify: function(additionalUserTraits) {
            if (StringUtils.validMethod('window.HS.beacon.identify') === false) {
                return false;
            }
            additionalUserTraits = DataUtils.getDefaultValue(additionalUserTraits, {});
            var user = Stencil.get('user');
            if (user !== false) {
                var userTraitsObject = this.getUserTraitsObject();
                userTraitsObject = DataUtils.merge(userTraitsObject, additionalUserTraits);
                window.HS.beacon.identify(userTraitsObject);
                return true;
            }
            User.once({
                'login': this._setupIdentify.proxy(this, [additionalUserTraits]),
                'signup': this._setupIdentify.proxy(this, [additionalUserTraits])
            });
            return false;
        },

        /**
         * _setupLogRocketIntegration
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupLogRocketIntegration: function() {
            var _this = this;
            Scripts.load('logRocket', function() {
                ClientWrappers.get('logRocket').getSessionUrl(function(sessionUrl) {
                    _this._setupIdentify({
                        sessionUrl: sessionUrl
                    });
                });
            });
            return true;
        },

        /**
         * closeBeacon
         * 
         * @access  public
         * @return  Boolean
         */
        closeBeacon: function() {
            if (StringUtils.validMethod('window.HS.beacon.close') === true) {
                window.HS.beacon.close();
                return true;
            }
            return false;
        },

        /**
         * getUserTraitsObject
         * 
         * @access  public
         * @return  Object
         */
        getUserTraitsObject: function() {
            var user = Stencil.get('user'),
                name = user.get('name'),
                accountEmail = user.get('email'),
                signupDateTimestamp = user.get('created').toInt(),
                signupDateLabel = moment(signupDateTimestamp * 1000).calendar(),
                plan = user.getPlan(),
                partner = user.getPartner(),
                interval = user.getInterval(),
                monthlySavedImages = user.active().get('monthlySavedImages'),
                totalSavedImages = user.active().get('totalSavedImages'),
                userTraitsObject = {
                    'Name': name,
                    'Account email': accountEmail,
                    'Signup date': signupDateLabel,
                    'Plan': plan,
                    'Submitted from': 'App' + (UserAgentUtils.extension() === true ? ' (extension)' : ''),
                    'Partner': partner,
                    'Interval': interval,
                    'Monthly saved images': monthlySavedImages,
                    'Total saved images': totalSavedImages
                };
            return userTraitsObject;
        },

        /**
         * prepare
         * 
         * @access  public
         * @return  Boolean
         */
        prepare: function() {
            this._super();
            this._prepare();
            this._setupLogRocketIntegration();
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            if (StringUtils.validMethod('window.HS.beacon.ready') === false) {
                return false;
            }
            this._super();
            var _this = this;
            this._setupBeacon();
            window.HS.beacon.ready(function() {
                _this._setupFade();
                _this._setupIdentify();
            });
            return true;
        },

        /**
         * showBeacon
         * 
         * @access  public
         * @param   String articleId
         * @return  Boolean
         */
        showBeacon: function(articleId) {
            if (StringUtils.validMethod('window.HS.beacon.show') === false) {
                return false;
            }
            window.HS.beacon.show(articleId);
            return true;
        },

        /**
         * showCollectionsIntroArticle
         * 
         * @access  public
         * @return  Boolean
         */
        showCollectionsIntroArticle: function() {
            var collectionsArticleId = '59e4c4e42c7d3a752de11f73',
                shown = this.showBeacon(collectionsArticleId);
            return shown;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * ImageResizerServiceRequestClientWrapper
     * 
     * @extends BaseClientWrapper
     */
    window.ImageResizerServiceRequestClientWrapper = BaseClientWrapper.extend({

        /**
         * _objectKey
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _objectKey: null,

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'imageResizerServiceRequest')
         */
        _serviceKey: 'imageResizerServiceRequest',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageResizerServiceRequestClientWrapper')
         */
        _string: 'ImageResizerServiceRequestClientWrapper',

        /**
         * _transformations
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _transformations: [],

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._transformations = [];
            this._super();
        },

        /**
         * getUrl
         * 
         * @access  public
         * @return  String
         */
        getUrl: function() {
            var host = this._getHost(),
                base = 'https://' + (host),
                path = this.getPath(),
                url = (base) + (path);
            return url;
        },

        /**
         * setObjectKey
         * 
         * @access  public
         * @param   String objectKey
         * @return  Boolean
         */
        setObjectKey: function(objectKey) {
            this._objectKey = objectKey;
            return true;
        }
//        ,
//
//        /**
//         * toString
//         * 
//         * @access  public
//         * @return  String
//         */
//        toString: function() {
//            var url = this.getUrl();
//            return url;
//        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * LogRocketClientWrapper
     * 
     * @extends BaseClientWrapper
     */
    window.LogRocketClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'logRocket')
         */
        _serviceKey: 'logRocket',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LogRocketClientWrapper')
         */
        _string: 'LogRocketClientWrapper',

        /**
         * _getAccountCountryCode
         * 
         * @access  protected
         * @return  false|String
         */
        _getAccountCountryCode: function() {
            var account = Stencil.account(),
                countryCode = account.get('geo').country.code;
            return countryCode;
        },

        /**
         * _getCountryCodeWhitelist
         * 
         * @access  protected
         * @return  Array
         */
        _getCountryCodeWhitelist: function() {
            var config = Config.get('logRocket'),
                countryCodeWhitelist = config.countryCodeWhitelist;
            return countryCodeWhitelist;
        },

        /**
         * _getImageCountMinimum
         * 
         * @access  protected
         * @return  Number
         */
        _getImageCountMinimum: function() {
            var config = Config.get('logRocket'),
                imageCountMinimum = config.imageCountMinimum.toInt();
            return imageCountMinimum;
        },

        /**
         * _getKey
         * 
         * @access  protected
         * @return  String
         */
        _getKey: function() {
            var config = Config.get('logRocket'),
                apiId = config.apiId,
                projectKey = config.projectKey,
                key = (apiId) + '/' + (projectKey);
            return key;
        },

        /**
         * _getRelease
         * 
         * @access  protected
         * @return  String
         */
        _getRelease: function() {
            var release = Stencil.get('version');
            return release;
        },

        /**
         * _getUserId
         * 
         * @access  protected
         * @return  Number
         */
        _getUserId: function() {
            var user = Stencil.get('user'),
                userId = user.get('id');
            return userId;
        },

        /**
         * _init
         * 
         * @access  protected
         * @return  Boolean
         */
        _init: function() {
            if (StringUtils.validMethod('window.LogRocket.init') === false) {
                return false;
            }
            var key = this._getKey(),
                release = this._getRelease();
            window.LogRocket.init(key, {
                release: release
            });
            return true;
        },

        /**
         * _setupIdentify
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupIdentify: function() {
            if (StringUtils.validMethod('window.LogRocket.identify') === false) {
                return false;
            }
            var user = Stencil.get('user');
            if (user !== false) {
                var userId = this._getUserId(),
                    userTraitsObject = this.getUserTraitsObject();
                window.LogRocket.identify(userId, userTraitsObject);
            } else {
                User.once({
                    'login': this._setupIdentify.proxy(this),
                    'signup': this._setupIdentify.proxy(this)
                });
            }
            return true;
        },

        /**
         * _setupSegmentIntegration
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupSegmentIntegration: function() {
            Scripts.load('segment', function() {
                ClientWrappers.get('logRocket').getSessionUrl(
                    function(sessionUrl) {
                        ClientWrappers.get('segment').trackEvent('LogRocket', {
                            sessionUrl: sessionUrl
                        });
                    }
                );
            });
            return true;
        },

        /**
         * _setupSentryIntegration
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupSentryIntegration: function() {
            this.getSessionUrl(function(sessionUrl) {
                Raven.setDataCallback(function(data) {
                    data.extra.sessionUrl = sessionUrl;
                    return data;
                });
            });
            return true;
        },

        /**
         * _useCountryCodeWhitelist
         * 
         * @access  protected
         * @return  Boolean
         */
        _useCountryCodeWhitelist: function() {
            var config = Config.get('logRocket'),
                useCountryCodeWhitelist = config.useCountryCodeWhitelist;
            return useCountryCodeWhitelist;
        },

        /**
         * _validAccountRole
         * 
         * @access  protected
         * @return  Boolean
         */
        _validAccountRole: function() {
            if (Account.guest() === true) {
                return false;
            }
            return true;
        },

        /**
         * _validCountryCode
         * 
         * @access  protected
         * @return  Boolean
         */
        _validCountryCode: function() {
            var useCountryCodeWhitelist = this._useCountryCodeWhitelist();
            if (useCountryCodeWhitelist === false) {
                return true;
            }
            var countryCode = this._getAccountCountryCode();
            if (countryCode === false) {
                return false;
            }
            if (countryCode === '') {
                return false;
            }
            var countryCodeWhitelist = this._getCountryCodeWhitelist();
            countryCode = countryCode.toLowerCase();
            if (ArrayUtils.contains(countryCode, countryCodeWhitelist) === false) {
                return false;
            }
            return true;
        },

        /**
         * _validUserProperties
         * 
         * @access  protected
         * @return  Boolean
         */
        _validUserProperties: function() {
            var account = Stencil.account(),
                totalSavedImages = account.get('totalSavedImages').toInt(),
                imageCountMinimum = this._getImageCountMinimum();
            if (totalSavedImages < imageCountMinimum) {
                return false;
            }
            return true;
        },

        /**
         * _validUserRole
         * 
         * @access  protected
         * @return  Boolean
         */
        _validUserRole: function() {
            if (User.editor() === true) {
                return false;
            }
            if (User.admin() === true) {
                return false;
            }
            return true;
        },

        /**
         * enabled
         * 
         * Loads LogRocket script and prepares it, only if it's for a specific
         * country (determined by checking the country code and comparing it
         * with the whitelist of country codes).
         * 
         * Also won't load Log Rocket for admins, editors or guests, since it'll
         * use up too many "credits".
         * 
         * @access  public
         * @return  Boolean
         */
        enabled: function() {
            if (this._super() === false) {
                return false;
            }
            var config = Config.get('logRocket');
            if (config.enabled === false) {
                return false;
            }
            if (this._validCountryCode() === false) {
                return false;
            }
            if (this._validAccountRole() === false) {
                return false;
            }
            if (this._validUserRole() === false) {
                return false;
            }
            if (this._validUserProperties() === false) {
                return false;
            }
            return true;
        },

        /**
         * getSessionUrl
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        getSessionUrl: function(callback) {
            if (this.enabled() === false) {
                callback(null);
            }
            Scripts.load('logRocket', function() {
                if (StringUtils.validMethod('window.LogRocket.getSessionURL') === false) {
                    callback(null);
                    return false;
                }
                window.LogRocket.getSessionURL(function(sessionUrl) {
                    callback(sessionUrl);
                });
                return true;
            });
        },

        /**
         * getUserTraitsObject
         * 
         * @access  public
         * @return  Object
         */
        getUserTraitsObject: function() {
            var user = Stencil.get('user'),
                name = user.get('name'),
                email = user.get('email'),
                userTraitsObject = {
                    'Name': name,
                    'Email': email
                };
            return userTraitsObject;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._init();
            this._setupIdentify();
            this._setupSegmentIntegration();
            this._setupSentryIntegration();
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * ReCaptchaClientWrapper
     * 
     * @extends BaseClientWrapper
     */
    window.ReCaptchaClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'reCaptcha')
         */
        _serviceKey: 'reCaptcha',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ReCaptchaClientWrapper')
         */
        _string: 'ReCaptchaClientWrapper'
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * SegmentClientWrapper
     * 
     * @todo!   Move declarations of which events should be sent to which
     *          providers to the server side. Better to have that all sync'd up,
                since calls are also made on the server side.
     * @see     https://segment.com/docs/sources/website/analytics.js/
     * @extends BaseClientWrapper
     */
    window.SegmentClientWrapper = BaseClientWrapper.extend({

        /**
         * _lastIdentifyTraitsHash
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastIdentifyTraitsHash: '',

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'segment')
         */
        _serviceKey: 'segment',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SegmentClientWrapper')
         */
        _string: 'SegmentClientWrapper',

        /**
         * _tracked
         * 
         * @access  protected
         * @var     Object
         */
        _tracked: {
            pages: []
        },

        /**
         * _getIntegrations
         * 
         * @access  protected
         * @return  Object
         */
        _getIntegrations: function() {
            var integrations = {
                'All': false,
                'AdRoll': false,
                'Facebook Pixel': true,
                'Google Analytics': true,
                'Mixpanel': false
            };
            return integrations;
        },

        /**
         * _getKey
         * 
         * @access  protected
         * @return  String
         */
        _getKey: function() {
            var config = Config.get('segment'),
                key = config.key;
            return key;
        },

        /**
         * _getUserAccountId
         * 
         * @access  protected
         * @return  Number
         */
        _getUserAccountId: function() {
            var user = Stencil.get('user'),
                activeAccount = user.active(),
                userAccount = activeAccount.get('userAccount'),
                id = userAccount.id;
            return id;
        },

        /**
         * _getUserTraitsObject
         * 
         * @access  protected
         * @return  Object
         */
        _getUserTraitsObject: function() {
            var user = Stencil.get('user'),
                userTraitsObject = user.getTraits();
            return userTraitsObject;
        },

        /**
         * _updateUrl
         * 
         * @access  protected
         * @return  Boolean
         */
        _updateUrl: function() {
            var url = this._url,
                key = this._getKey();
            url = url.replace('$key', key);
            this._url = url;
            return true;
        },

        /**
         * disable
         * 
         * @access  public
         * @return  Boolean
         */
        disable: function() {
            var config = Config.get('segment');
            config.enabled = false;
            return true;
        },

        /**
         * enabled
         * 
         * @access  public
         * @return  Boolean
         */
        enabled: function() {
            if (this._super() === false) {
                return false;
            }
            var config = Config.get('segment');
            if (config.enabled === false) {
                return false;
            }
            if (User.editor() === true) {
                return false;
            }
            if (User.admin() === true) {
                return false;
            }
            return true;
        },

        /**
         * prepare
         * 
         * @access  public
         * @return  Boolean
         */
        prepare: function() {
            this._super();
            this._updateUrl();
            return true;
        },

        /**
         * reset
         * 
         * @access  public
         * @return  void
         */
        reset: function() {
            if (this.enabled() === false) {
                return false;
            }
            if (StringUtils.validMethod('window.analytics.reset') === true) {
                window.analytics.reset();
            }
            if (StringUtils.validMethod('window.mixpanel.cookie.clear') === true) {
                window.mixpanel.cookie.clear();
            }
            return true;
        },

        /**
         * setAlias
         * 
         * @note    The userAccount data is accessed directly, instead of through
         *          the UserAccountAccessor reference (eg.
         *          .active().userAccount()) since the reference won't have been
         *          created yet. The reason for this, is that creating that
         *          reference happens when the login/signup event is triggered.
         * @access  public
         * @return  Boolean
         */
        setAlias: function() {
            if (this.enabled() === false) {
                return false;
            }
            if (StringUtils.validMethod('window.analytics.alias') === false) {
                return false;
            }
            var id = this._getUserAccountId();
            window.analytics.alias(id);
            return true;
        },

        /**
         * trackEvent
         * 
         * @access  public
         * @param   String action
         * @param   undefined|Object properties (default: {})
         * @return  Boolean
         */
        trackEvent: function(action, properties) {
            properties = DataUtils.getDefaultValue(properties, {});
            if (this.enabled() === false) {
                return false;
            }
            if (StringUtils.validMethod('window.analytics.track') === false) {
                return false;
            }
            properties.category = 'App';
            var integrations = this._getIntegrations();
            window.analytics.track(action, properties, integrations);
            return true;
        },

        /**
         * trackPage
         * 
         * @note    Less-than-or-equal-to check is performed to prevent initial
         *          call, since Segment automatically makes call upon load.
         * @access  public
         * @param   String path
         * @return  Boolean
         */
        trackPage: function(path) {
            if (this.enabled() === false) {
                return false;
            }
            if (StringUtils.validMethod('window.analytics.page') === false) {
                return false;
            }
            this._tracked.pages.push(path);
            if (this._tracked.pages.length <= 1) {
                return false;
            }
            var integrations = this._getIntegrations();
            window.analytics.page({
                path: path,
                integrations: integrations
            });
            return true;
        },

        /**
         * trackUser
         * 
         * @note    The JSON check below is because when change history was
         *          introduced, it resulted in way too many calls to this method
         *          happening when nothing really changed.
         *          This was because the AccountAccessor changeHistory property
         *          was changed each time the canvas was updated, which would
         *          result in this method being continuously called.
         * @note    The userAccount data is accessed directly, instead of
         *          through the UserAccountAccessor reference (eg.
         *          .active().userAccount()) since the reference won't have been
         *          created yet. The reason for this, is that creating that
         *          reference happens when the login/signup event is triggered.
         * @access  public
         * @return  Boolean
         */
        trackUser: function() {
            if (this.enabled() === false) {
                return false;
            }
            if (StringUtils.validMethod('window.analytics.identify') === false) {
                return false;
            }
            var traits = this._getUserTraitsObject(),
                identifyTraitsHash = JSON.stringify(traits);
            if (identifyTraitsHash === this._lastIdentifyTraitsHash) {
                return false;
            }
            this._lastIdentifyTraitsHash = identifyTraitsHash;
            var id = this._getUserAccountId();
            window.analytics.identify(
                id,
                traits,
                {
                    integrations: {
                        'All': false,
                        'Google Analytics': false,
                        'Mixpanel': false
                    }
                }
            );
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * StripeClientWrapper
     * 
     * @see     https://stripe.com/docs/testing
     *          https://stripe.com/docs/stripe.js
     * @extends BaseClientWrapper
     */
    window.StripeClientWrapper = BaseClientWrapper.extend({

        /**
         * _routeThroughProxy
         * 
         * Overwriting whatever the value of BaseClientWrapper is, since Stripe
         * does not (and explicitly console logs messaging) allow JS code to be
         * served directly (eg. not through their cdn).
         * 
         * @access  protected
         * @var     Boolean (defaut: false)
         */
        _routeThroughProxy: false,

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'stripe')
         */
        _serviceKey: 'stripe',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StripeClientWrapper')
         */
        _string: 'StripeClientWrapper',

        /**
         * _getPublishableKey
         * 
         * @access  protected
         * @return  String
         */
        _getPublishableKey: function() {
            var config = Config.get('stripe'),
                publishableKey = config.publishableKey;
            return publishableKey;
        },

        /**
         * _setPublishableKey
         * 
         * @access  protected
         * @return  Boolean
         */
        _setPublishableKey: function() {
            if (StringUtils.validMethod('window.Stripe.setPublishableKey') === false) {
                return false;
            }
            var publishableKey = this._getPublishableKey();
            window.Stripe.setPublishableKey(publishableKey);
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._setPublishableKey();
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * TapfiliateClientWrapper
     * 
     * @see     https://tapfiliate.com/docs/javascript/
     * @extends BaseClientWrapper
     */
    window.TapfiliateClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'tapfiliate')
         */
        _serviceKey: 'tapfiliate',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TapfiliateClientWrapper')
         */
        _string: 'TapfiliateClientWrapper',

        /**
         * _getAccountId
         * 
         * @access  protected
         * @return  String
         */
        _getAccountId: function() {
            var config = Config.get('tapfiliate'),
                accountId = config.auth.accountId;
            return accountId;
        },

        /**
         * _setAccount
         * 
         * @access  protected
         * @return  Boolean
         */
        _setAccount: function() {
            if (StringUtils.validMethod('window.tap') === false) {
                return false;
            }
            var accountId = this._getAccountId();
            window.tap('create', accountId);
            return true;
        },

        /**
         * _trackLoad
         * 
         * @access  protected
         * @return  Boolean
         */
        _trackLoad: function() {
            if (StringUtils.validMethod('window.tap') === false) {
                return false;
            }
            window.tap('detectClick');
            return true;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._setAccount();
            this._trackLoad();
            return true;
        },

        /**
         * trackConversion
         * 
         * @access  public
         * @param   String externalId
         * @param   Number amount
         * @param   Object options
         * @param   String commissionType
         * @param   Function callback
         * @return  Boolean
         */
        trackConversion: function(externalId, amount, options, commissionType, callback) {
            if (StringUtils.validMethod('window.tap') === false) {
                return false;
            }
            window.tap(
                'conversion',
                externalId,
                amount,
                options,
                commissionType,
                callback
            );
            return true;
        }
    });
});
window.DependencyLoader.push('ImageResizerServiceRequestClientWrapper', function() {

    /**
     * ThumborRequestClientWrapper
     * 
     * @note    Two things changed in Thumbor package:
     *          1) PIL/Image.py modifications for PNG transparency bug when
     *             resizing: https://i.imgur.com/kUKgAU6.png
     *          2) image_handler/lambda_function.py modifications for access
     *             control: https://i.imgur.com/ngT1IdC.png
     * @see     http://plouc.github.io/thumbor-toy/
     * @see     http://thumbor.readthedocs.io/en/latest/usage.html#image-endpoint
     * @see     https://github.com/thumbor/thumbor/wiki/Usage
     * @see     https://github.com/thumbor/thumbor/wiki/Quality
     * @see     https://github.com/python-pillow/Pillow/commit/2ad43c4eeb8cb0124c76cbdd0fe0b131df2c6c70
     * @see     https://github.com/wiredfool/Pillow/commit/e422f92e523f4d0d66611b2f9f54f6606a218d4b (duplicate)
     * @see     https://github.com/thumbor/thumbor/issues/943
     * @see     https://github.com/thumbor/thumbor/issues/943
     * @see     https://d32q3izcmhqbti.cloudfront.net/full-fit-in/972x486/filters:quality(100)/asst3084e0f3
     * @extends ImageResizerServiceRequestClientWrapper
     */
    window.ThumborRequestClientWrapper = ImageResizerServiceRequestClientWrapper.extend({

        /**
         * _host
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _host: null,

        /**
         * _quality
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _quality: null,

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'thumborRequest')
         */
        _serviceKey: 'thumborRequest',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ThumborRequestClientWrapper')
         */
        _string: 'ThumborRequestClientWrapper',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _getHost
         * 
         * @access  protected
         * @return  String
         */
        _getHost: function() {
            if (this._host === null) {
                var config = Config.get(),
                    host = config.aws.cloudFront.distributions.thumbor.stencil.host;
                return host;
            }
            var host = this._host;
            return host;
        },

        /**
         * _getProdShareAsImageThumborHost
         * 
         * Currently, this is only relevant when thumbor is being used for all
         * requests. This is because the only time a distributeKey is set to
         * this value is when it's a legacy image that hasn't yet been imported.
         * But in that case, the key value passed to ImageUtils.url.thumb is
         * changed. As a result, thumbor wouldn't be called (see
         * ImageUtils.url.thumb for the reason why; specifically, the check
         * against the accessor using the key passed in).
         * 
         * So, the only time this code could be triggered is when Thumbor is
         * being used for all requests, since at that point, the check for an
         * accessor is not performed.
         * 
         * @access  protected
         * @return  String
         */
        _getProdShareAsImageThumborHost: function() {
            var config = Config.get(),
                host = config.aws.legacy.cloudFront.distributions.thumbor.shareAsImage.prod.host;
            return host;
        },

        /**
         * filter
         * 
         * @access  public
         * @param   String name
         * @param   mixed value
         * @return  Boolean
         */
        filter: function(filter, value) {
            var transformation = 'filters:' + (filter) + '(' + (value) + ')';
            this._transformations.push(transformation);
            return true;
        },

        /**
         * fullFit
         * 
         * @access  public
         * @param   Number width
         * @param   Number height
         * @return  Boolean
         */
        fullFit: function(width, height) {
            var transformation = 'full-fit-in';
            this._transformations.push(transformation);
            transformation = (width) + 'x' + (height);
            this._transformations.push(transformation);
            return true;
        },

        /**
         * height
         * 
         * @access  public
         * @param   Number height
         * @return  Boolean
         */
        height: function(height) {
            var transformation = '0x' + (height);
            this._transformations.push(transformation);
            return true;
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var pieces = [],
                transformations = this._transformations,
                index;
            if (this._quality !== null) {
                this.filter('quality', this._quality);
            }
            for (index in transformations) {
                pieces.push(transformations[index]);
            }
            pieces.push(this._objectKey);
            var path = '/';
            path += pieces.join('/');
            return path;
        },

        /**
         * setHost
         * 
         * @access  public
         * @param   String distributionKey
         * @return  Boolean
         */
        setHost: function(distributionKey) {
            if (distributionKey === 'shareAsImage') {
                var host = this._getProdShareAsImageThumborCloudFrontDistribution();
                this._host = host;
                return true;
            }
            var config = Config.get(),
                host = config.aws.cloudFront.distributions.thumbor[distributionKey].host;
            this._host = host;
            return true;
        },

        /**
         * setQuality
         * 
         * @access  public
         * @param   String quality
         * @return  Boolean
         */
        setQuality: function(quality) {
            this._quality = quality;
            return true;
        },

        /**
         * width
         * 
         * @access  public
         * @param   Number width
         * @return  Boolean
         */
        width: function(width) {
            var transformation = (width) + 'x0';
            this._transformations.push(transformation);
            return true;
        }
    });
});
window.DependencyLoader.push('BaseClientWrapper', function() {

    /**
     * UppyClientWrapper
     * 
     * @see     https://uppy.io/docs/dashboard/#openModal
     * @see     https://uppy.io/docs/uppy/#uppy-close
     * @extends BaseClientWrapper
     */
    window.UppyClientWrapper = BaseClientWrapper.extend({

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     String (default: 'uppy')
         */
        _serviceKey: 'uppy',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UppyClientWrapper')
         */
        _string: 'UppyClientWrapper',

        /**
         * _urls
         * 
         * @access  protected
         * @var     Object
         */
        _urls: {
            css: 'https://transloadit.edgly.net/releases/uppy/v0.28.0/dist/uppy.min.css'
        },

        /**
         * _init
         * 
         * @access  protected
         * @return  Boolean
         */
        _init: function() {
            if (window.Uppy === undefined) {
                return false;
            }
            return true;
        },

        /**
         * _loadCSS
         * 
         * @see     https://stackoverflow.com/questions/2126238/can-i-load-external-stylesheets-on-request
         * @access  protected
         * @return  Boolean
         */
        _loadCSS: function() {
            if (window.Uppy === undefined) {
                return false;
            }
            var url = this._urls.css;
            $('head').append('<link rel="stylesheet" type="text/css" href="' + (url) + '">');
            return true;
        },

        /**
         * getReference
         * 
         * @access  public
         * @param   Function callback
         * @return  Boolean|Uppy
         */
        getReference: function(callback) {
            if (Config.serviceAvailable('uppy') === false) {
                Stencil.alert('services.generic.unavailable');
                return false;
            }
            if (StringUtils.validMethod('window.Uppy.Core') === false) {
                Stencil.alert('services.generic.blocked');
                return false;
            }
            var uppy = Uppy.Core({
                autoProceed: false,
                restrictions: {
                    maxFileSize: 200*1024*1024,
                    allowedFileTypes: ['*/*']
                }
            });
            uppy.use(Uppy.Dashboard, {
                inline: false,
                showProgressDetails: true,
                note: 'Up to 200 MB',
                height: 470,
                closeModalOnClickOutside: true,
                animateOpenClose: false,
                browserBackButtonClose: true
            });
            uppy.use(Uppy.Tus, {
                endpoint: 'https://master.tus.io/files/'
            });
            uppy.on('complete', function(result) {
                var files = result.successful;
                if (files.length > 0) {
                    var urls = [];
                    for (var index in files) {
                        urls.push(
                            files[index].uploadURL
                        );
                    }
                    callback.apply(callback, [urls]);
                    // uppy.close.delay(2500, uppy);
                    (function() {
                        uppy.getPlugin('Dashboard').closeModal();
                    }).delay(1500);
                }
            });
            return uppy;
        },

        /**
         * setup
         * 
         * @access  public
         * @return  Boolean
         */
        setup: function() {
            this._super();
            this._init();
            this._loadCSS();
            return true;
        }
    });
});

/**
 * Config
 * 
 * @abstract
 */
window.Config = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'config')
     */
    var __classType = 'config';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Config')
     */
    var __string = 'Config';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * getCSRFToken
         * 
         * @access  public
         * @return  null|String
         */
        getCSRFToken: function() {
            if (Stencil.get('config') === undefined) {
                return null;
            }
            var security = Config.get('security'),
                csrfToken = security.csrfToken;
            return csrfToken;
        },

        /**
         * default
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        default: function(key) {
            var defaults = Config.get('defaults');
            if (defaults[key] === undefined) {
                var msg = 'Invalid default config lookup: ' + (key);
                throw new Error(msg);
            }
            return defaults[key];
        },

        /**
         * get
         * 
         * @access  public
         * @param   undefined|String key (optional)
         * @return  mixed
         */
        get: function(key) {
            var config = Stencil.get('config');
            if (key === undefined) {
                return config;
            }
            return config[key];
        },

        /**
         * getFilterResampleDelay
         * 
         * @access  public
         * @return  Number
         */
        getFilterResampleDelay: function() {
            var filterResampleDelay = Config.default('filterResampleDelay').toInt();
            return filterResampleDelay;
        },

        /**
         * getMessage
         * 
         * @access  public
         * @param   String key
         * @return  String
         */
        getMessage: function(key) {
            var messages = Config.get('messages'),
                message = messages[key];
            return message;
        },

        /**
         * getResizeDelay
         * 
         * @access  public
         * @param   String key
         * @return  Number
         */
        getResizeDelay: function(key) {
            var resizeDelays = Config.default('resizeDelays'),
                resizeDelay = resizeDelays[key];
            return resizeDelay;
        },

        /**
         * getRole
         * 
         * @access  public
         * @return  String
         */
        getRole: function() {
            var role = Config.get('role');
            return role;
        },

        /**
         * getSaveDelay
         * 
         * @access  public
         * @param   String key
         * @return  Number
         */
        getSaveDelay: function(key) {
            var saveDelays = Config.default('saveDelays'),
                saveDelay = saveDelays[key];
            return saveDelay;
        },

        /**
         * getStaticHost
         * 
         * @access  public
         * @return  String
         */
        getStaticHost: function() {
            var host = Config.get('hosts').static;
            return host;
        },

        /**
         * ready
         * 
         * Helper method used to determine whether the app config is available
         * for use. At the time of documentation, this was only being used by
         * the LogUtils class to determine whether messages should be logged to
         * the console. Since that logic checks the app config, we had to check
         * whether the config was available to _be_ checked.
         * 
         * @access  public
         * @return  Boolean
         */
        ready: function() {
            var config = Stencil.get('config'),
                ready = config !== undefined;
            return ready;
        },

        /**
         * serviceAvailable
         * 
         * @access  public
         * @param   String serviceKey
         * @return  Boolean
         */
        serviceAvailable: function(serviceKey) {
            var override = Stencil.get('overrides').service(serviceKey);
            if (override !== undefined) {
                return override.get('value').toInt() === 1;
            }
            var services = Config.get('services'),
                serviceAvailable = services[serviceKey] === true;
            return serviceAvailable;
        },

        /**
         * set
         * 
         * @note    undefined check is required because if this method can be
         *          called before the config has actually been stored in the
         *          Stencil singleton
         * @access  public
         * @param   String key
         * @param   mixed value
         * @return  void
         */
        set: function(key, value) {
            var config = Stencil.get('config');
            if (config !== undefined) {
                config[key] = value;
            }
        }
    });
})();

/**
 * Frames
 * 
 * @abstract
 */
window.Frames = (function() {

    /**
     * __all
     * 
     * @access  private
     * @var     Array
     */
    var __all;

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'frames')
     */
    var __classType = 'frames';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Frames')
     */
    var __string = 'Frames';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * all
         * 
         * @access  public
         * @return  Array
         */
        all: function() {
            return __all;
        },

        /**
         * store
         * 
         * @access  public
         * @param   Array all
         * @return  void
         */
        store: function(all) {
            __all = all;
        }
    });
})();

/**
 * ImagePreloadWorker
 * 
 * @see     https://gist.github.com/mseeley/9321422
 * @abstract
 */
window.ImagePreloadWorker = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'imagePreloadWorker')
     */
    var __classType = 'imagePreloadWorker';

    /**
     * __getPreloadWorkerStr
     * 
     * @access  private
     * @return  void
     */
    var __getPreloadWorkerStr = function() {
        var fn = __preloadWorker.toString(),
            body = fn.slice(
                fn.indexOf('{') + 1,
                fn.lastIndexOf('}')
            );
        return 'self.onmessage = ' + (fn) + ';';
    };

    /**
     * __getWorker
     * 
     * @access  private
     * @param   Array urls
     * @return  Worker
     */
    var __getWorker = function(urls) {
        var url = __getWorkerUrl(),
            worker = new Worker(url);

        /**
         * worker.onmessage
         * 
         * @access  private
         * @param   MessageEvent event
         * @return  void
         */
        worker.onmessage = function(event) {
            var remaining = urls.length,
                onload = function() {
                    delete this.onload;
                    remaining--;
                    if (remaining === 0) {
                        console.log('done')
                    }
                };
            urls.forEach(function(url) {
                var el = document.createElement('img');
                el.onload = onload;
                el.src = url;
            });
            URL.revokeObjectURL(url);
        };
        return worker;
    };

    /**
     * __getWorkerUrl
     * 
     * @access  private
     * @return  String
     */
    var __getWorkerUrl = function() {
        var preloadWorkerStr = __getPreloadWorkerStr(),
            URL = window.URL || window.webkitURL,
            url = URL.createObjectURL(
                new Blob(
                    [preloadWorkerStr],
                    {
                        type: 'text/javascript'
                    }
                )
            );
        return url;
    };

    /**
     * __preloadWorker
     * 
     * @access  private
     * @param   MessageEvent event
     * @return  void
     */
    var __preloadWorker = function(event) {
        var urls = event.data,
            remaining = urls.length,
            onload = function(event) {
                remaining--;
                if (remaining === 0) {
                    self.postMessage(true);
                    self.close();
                }
            };
        urls.forEach(function(url) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'blob';
            xhr.onload = xhr.onerror = onload;
            xhr.open('GET', url, true);
            xhr.send();
        });
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ImagePreloadWorker')
     */
    var __string = 'ImagePreloadWorker';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * preload
         * 
         * @access  public
         * @param   Array urls
         * @return  void
         */
        preload: function(urls) {
            var worker = __getWorker(urls);
            worker.postMessage(urls);
        }
    });
})();
window.DependencyLoader.push('Base', function() {

    /**
     * ImageRequest
     * 
     * @events  error
     *          load
     * @extends Base
     */
    window.ImageRequest = Base.extend({

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'imageRequest')
         */
        _classType: 'imageRequest',

        /**
         * _crossOrigin
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _crossOrigin: false,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|Image (default: null)
         */
        _image: null,

        /**
         * _src
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _src: null,

        /**
         * init
         * 
         * @access  public
         * @param   undefined|String src (default: null)
         * @param   undefined|Boolean crossOrigin (default: false)
         * @return  void
         */
        init: function(src, crossOrigin) {
            src = DataUtils.getDefaultValue(src, null);
            crossOrigin = DataUtils.getDefaultValue(crossOrigin, false);
            this._src = src;
            this._crossOrigin = crossOrigin;
            this._super();
            this._addErrorListener();
            this._addLoadListener();
            this._image = new Image();
        },

        /**
         * _addErrorListener
         * 
         * @access  protected
         * @return  void
         */
        _addErrorListener: function() {
            this.once({
                'error': function(event, reference) {
                    var url = this._image.src,
                        msgs = [
                            'Could not load image',
                            url
                        ],
                        msg = msgs.join(' / ');
                    LogUtils.log.simple(msg, true);
                }
            });
        },

        /**
         * _addLoadListener
         * 
         * @access  protected
         * @return  void
         */
        _addLoadListener: function() {
            this.once({
                'load': function(event) {
                }
            });
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  null|Image
         */
        getImage: function() {
            var image = this._image;
            return image;
        },

        /**
         * request
         * 
         * @access  public
         * @return  void
         */
        request: function() {
            if (this._crossOrigin === true) {
                this._image.crossOrigin = 'anonymous';
            }
            this._image.onerror = (function() {
                var image = this._image;
                this.triggerHandler('error', [image]);
            }).proxy(this);
            this._image.onload = (function() {
                var image = this._image;
                this.triggerHandler('load', [image]);
            }).proxy(this);
            this._image.src = this._src;
        },

        /**
         * setCrossOrigin
         * 
         * @access  public
         * @return  void
         */
        setCrossOrigin: function() {
            this._crossOrigin = true;
        },

        /**
         * setSource
         * 
         * @access  public
         * @param   String src
         * @return  void
         */
        setSource: function(src) {
            this._src = src;
        }
    });
});

/**
 * Normalizer
 * 
 * @abstract
 */
window.Normalizer = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'normalizer')
     */
    var __classType = 'normalizer';

    /**
     * __documents
     * 
     * @var     Object
     * @access  private
     */
    var __documents = {
        legacy: {},
        normalized: {
            layers: []
        }
    };

    /**
     * __order
     * 
     * @var     Number (default: 0)
     * @access  private
     */
    var __order = 0;

    /**
     * __backgroundImageLayer
     * 
     * @access  private
     * @return  void
     */
    var __backgroundImageLayer = function() {
        var layer = {
            background: true,
            filters: [],
            image: false,
            styles: {
                left: 50,
                top: 50
            },
            type: 'image'
        };
        jQuery.each(__documents.legacy.layers, function() {
            if (this.type === 'image') {
                layer.image = this.sourceSrc;
                layer.filters = __getAppliedFilters(this);
            }
        });
        __documents.normalized.layers.push(layer);
    };

    /**
     * __backgroundRectangleLayer
     * 
     * @access  private
     * @return  void
     */
    var __backgroundRectangleLayer = function() {
        var layer = {
            background: true,
            styles: {
                backgroundColor: ColorUtils.convert('#ffffff', 'rgba'),
                height: 100,
                left: 50,
                top: 50,
                width: 100
            },
            type: 'rectangle'
        };
        jQuery.each(__documents.legacy.layers, function() {
            if (this.type === 'rectangle') {
                layer.styles.backgroundColor = ColorUtils.convert(
                    this.styles.fillStyle,
                    'rgba'
                );
            }
        });
        __documents.normalized.layers.push(layer);
    };

    /**
     * __getAppliedFilters
     * 
     * @access  private
     * @param   Object sourceLayer
     * @return  Array
     */
    var __getAppliedFilters = function(sourceLayer) {
        var encoded = JSON.stringify(sourceLayer),
            matching = [],
            possible = {
                'blur': 'blur',
                'darken': 'darken',
                'greyscale': 'bw',
                'sepia': 'sepia',
                'grungy': 'grungy',
                'glowingSun': 'glowingSun',
                'inverse': 'inverse',
                'lomo': 'lomo',
                'vintage': 'vintage',
                'posterize': 'posterize',
                'clarity': 'clarity',
                'sinCity': 'sinCity',
                'orangePeel': 'orangePeel',
                'hazyDays': 'hazyDays',
                'hemingway': 'hemingway',
                'concentrate': 'concentrate',
                'sunrise': 'sunrise',
                'love': 'love'
            },
            check;
        for (var index in possible) {
            check = new RegExp('type\"\:[ ]?\"' + (index), 'i');
            if (encoded.match(check) !== null) {
                matching.push(possible[index]);
            }
        }
        return matching;
    };

    /**
     * __getCanvasHeight
     * 
     * @access  private
     * @return  Number
     */
    var __getCanvasHeight = function() {
        var json = JSON.stringify(__documents.legacy),
            matches = json.match(/\"height\"\:[ ]?([0-9]+)/i);
        if (matches === null) {
            return 385;
        }
        return matches.pop().toInt();
    };

    /**
     * __getCanvasWidth
     * 
     * @access  private
     * @return  Number
     */
    var __getCanvasWidth = function() {
        var json = JSON.stringify(__documents.legacy),
            matches = json.match(/\"width\"\:[ ]?([0-9]+)/i);
        if (matches === null) {
            return 495;
        }
        return matches.pop().toInt();
    };

    /**
     * __getDefaultBackdropPaddingFactor
     * 
     * @access  private
     * @return  Number
     */
    var __getDefaultBackdropPaddingFactor = function() {
        return Config.default('backdropPaddingFactor');
    };

    /**
     * __getDefaultStrokeWidthDividingFactor
     * 
     * @access  private
     * @return  Number
     */
    var __getDefaultStrokeWidthDividingFactor = function() {
        return Config.default('strokeWidthDividingFactor');
    };

    /**
     * __getTranslatedPosition
     * 
     * @access  private
     * @param   Object sourceLayer
     * @return  Object
     */
    var __getTranslatedPosition = function(sourceLayer) {
        var position = {
            repositionLeft: true,
            repositionTop: true,
            left: sourceLayer.styles.x,
            top: sourceLayer.styles.y
        };
        if (position.left === 'center') {
            position.repositionLeft = false;
            position.left = 50;
        }
        if (position.top === 'center') {
            position.repositionTop = false;
            position.top = 50;
        }
        position.left = position.left.round(4);
        position.top = position.top.round(4);
        if (isNaN(position.left) === true) {
            position.repositionLeft = false;
            position.left = 50;
        }
        if (isNaN(position.top) === true) {
            position.repositionTop = false;
            position.top = 50;
        }
        return position;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Normalizer')
     */
    var __string = 'Normalizer';

    /**
     * __textLayer
     * 
     * @access  private
     * @param   Object sourceLayer
     * @return  void
     */
    var __textLayer = function(sourceLayer) {
        var layer = {
            styles: {
                angle: 0,
                backdropColor: false,
                backdropPaddingFactor: __getDefaultBackdropPaddingFactor(),
                backdropStretch: 'slim',
                bold: false,
                italic: false,
                // lineHeight: 1.2,
                lineHeight: 1.1,
                // lineHeight: 1,
                order: __order,
                strokeColor: false,
                strokeWidthDividingFactor: __getDefaultStrokeWidthDividingFactor(),
                underline: false
            },
            text: sourceLayer.styles.text,
            type: 'text'
        };

        // Positioning
        var position = __getTranslatedPosition(sourceLayer);
        layer.styles.repositionLeft = position.repositionLeft;
        layer.styles.repositionTop = position.repositionTop;
        layer.styles.left = position.left;
        layer.styles.top = position.top;

        // Font size (reverse of relative font sizing in TextDrawing class)
        var fontSize = sourceLayer.styles.fontSize.toFloat();
        layer.styles.fontSize = (fontSize / __getCanvasWidth() * 1000 * 0.95).round(4);

        // 95% width
        layer.styles.width = 95;

        // The rest..
        layer.styles.align = sourceLayer.styles.align;
        layer.styles.fontFamily = sourceLayer.styles.fontFamily;
        layer.styles.textColor = ColorUtils.convert(
            sourceLayer.styles.fillStyle,
            'rgba'
        );
        if (sourceLayer.plane !== undefined) {
            layer.styles.backdropColor = ColorUtils.convert(
                sourceLayer.plane,
                'rgba'
            );
            layer.styles.backdropStretch = 'full';
        }
        if (
            sourceLayer.styles.strokeStyle !== undefined
            && (
                sourceLayer.styles.strokeWidth !== undefined
                && sourceLayer.styles.strokeWidth.toInt() !== 0
            )
        ) {
            layer.styles.strokeColor = ColorUtils.convert(
                sourceLayer.styles.strokeStyle,
                'rgba'
            );
        }
        else {
            // layer.styles.shadow = 'rgba(0,0,0,0.25)';
        }
        if (sourceLayer.styles.fontStyle === 'italic') {
            layer.styles.italic = true;
        }
        if (sourceLayer.styles.fontStyle === 'bold') {
            layer.styles.bold = true;
        }
        __documents.normalized.layers.push(layer);
    };

    /**
     * __textLayers
     * 
     * @access  private
     * @return  void
     */
    var __textLayers = function() {
        jQuery.each(__documents.legacy.layers, function() {
            if (this.type === 'text') {
                __textLayer(this);
                ++__order;
            }
        });
    };

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * image
         * 
         * @access  public
         * @param   String json
         * @return  void
         */
        image: function(json) {
            __documents.legacy = JSON.parse(json);
            __documents.normalized.layers = [];
            __order = 0;
            __backgroundRectangleLayer();
            __backgroundImageLayer();
            __textLayers();
            return JSON.stringify(__documents.normalized);
        }
    });
})();

/**
 * Scripts
 * 
 * @abstract
 */
window.Scripts = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'scripts')
     */
    var __classType = 'scripts';

    /**
     * __getClientWrapper
     * 
     * @access  private
     * @param   String serviceKey
     * @var     BaseClientWrapper
     */
    var __getClientWrapper = function(serviceKey) {
        var clientWrapper = ClientWrappers.get(serviceKey);
        return clientWrapper;
    };

    /**
     * __maxScriptWaitMilliseconds
     * 
     * The maximum number of milliseconds the app will wait for a 3rd-party
     * script to load, before showing an alert.
     * 
     * @access  private
     * @var     Number (default: 30 * 1000)
     */
    var __maxScriptWaitMilliseconds = 30 * 1000;

    /**
     * __skewCheckDelay
     * 
     * @access  private
     * @var     Number (default: 5 * 60 * 1000)
     */
    var __skewCheckDelay = 5 * 60 * 1000;

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Scripts')
     */
    var __string = 'Scripts';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * load
         * 
         * @access  public
         * @param   String serviceKey
         * @param   undefined|Function callback (default: function() {})
         * @return  Boolean
         */
        load: function(serviceKey, callback) {
            callback = DataUtils.getDefaultValue(callback, function() {});
            if (Config.serviceAvailable(serviceKey) === false) {
                return false;
            }
            var clientWrapper = __getClientWrapper(serviceKey);
            if (clientWrapper.failed() === true) {
                return false;
            }
            if (clientWrapper.loaded() === true) {
                callback();
                return true;
            }
            if (clientWrapper.loading() === true) {
                clientWrapper.once('loaded', callback);
                return true;
            }
            var loaded = clientWrapper.load();
            if (loaded === true) {
                clientWrapper.once('loaded', callback);
                return true;
            }
            return false;
        },

        /**
         * loaded
         * 
         * @access  public
         * @param   String serviceKey
         * @return  Boolean
         */
        loaded: function(serviceKey) {
            var clientWrapper = __getClientWrapper(serviceKey),
                loaded = clientWrapper.loaded();
            return loaded;
        },

        /**
         * setupAws
         * 
         * @see     https://github.com/aws/aws-sdk-js/issues/781
         * @see     https://github.com/aws/aws-sdk-js/issues/1688
         * @access  public
         * @return  void
         */
        setupAws: function() {
            AWS.S3.prototype.customizeRequests(function(request) {
                if (request.operation === 'putObject') {
                    request.on('extractData', function(response) {
                        var managedUpload = request._managedUpload;
                        if (DataUtils.valid(managedUpload) === true) {
                            response.data.custom = {
                                requestId: response.requestId
                            }
                        }
                    });
                    request.on('extractError', function(response) {
                        var managedUpload = request._managedUpload;
                        if (DataUtils.valid(managedUpload) === true) {
                            response.data.custom = {
                                requestId: response.requestId
                            }
                        }
                    });
                }
            });
        },

        /**
         * setupS3
         * 
         * Check for skew issues.
         * 
         * @access  public
         * @return  void
         */
        setupS3: function() {
            (function() {
                RequestUtils.alive(function() {
                    var model = Stencil.getModel('S3Upload');
                    model.performSkewCheck();
                });
            }).delay(__skewCheckDelay);
        },

        /**
         * waitFor
         * 
         * Waits for a specific script to load by showing a busy modal with a
         * message, and once loaded, hides it. Also contains logic incase the
         * script doesn't load after X seconds. If that occurs, simply show an
         * alert and unbind the callback.
         * 
         * @access  public
         * @param   String serviceKey
         * @return  void
         */
        waitFor: function(serviceKey) {
            var msg = Config.getMessage('dependency.pending'),
                timeout,
                callback = function() {
                    TimeoutPool.clear(timeout);
                    App.getBusy().hide();
                },
                clientWrapper = __getClientWrapper(serviceKey);
            timeout = (function() {
                Stencil.alert('dependency.failed');
                Stencil.kill();
                clientWrapper.unbind('loaded', callback);
            }).delay(__maxScriptWaitMilliseconds);
            App.getBusy().show(msg);
            clientWrapper.once('loaded', callback);
        }
    });
})();
window.DependencyLoader.push('Base', function() {

    /**
     * ServerRequest
     * 
     * @events  complete
     *          error
     *          success
     *          success/false
     *          success/true
     * @extends Base
     */
    window.ServerRequest = Base.extend({

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'serverRequest')
         */
        _classType: 'serverRequest',

        /**
         * _cacheResponse
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _cacheResponse: false,

        /**
         * _data
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _data: {},

        /**
         * _dataType
         * 
         * @access  protected
         * @var     String (default: 'json')
         */
        _dataType: 'json',

        /**
         * _excludeSecurityData
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _excludeSecurityData: false,

        /**
         * _method
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _method: null,

        /**
         * _path
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _path: null,

        /**
         * _reflectionEventContext
         * 
         * @access  protected
         * @var     null|mixed (default: null)
         */
        _reflectionEventContext: null,

        /**
         * _reflectionEventSet
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _reflectionEventSet: {},

        /**
         * _signature
         * 
         * @access  protected
         * @var     Object (default: null)
         */
        _signature: null,

        /**
         * _timeout
         * 
         * @access  protected
         * @var     Number (default: null)
         */
        _timeout: null,

        /**
         * _url
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _url: null,

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._data = {};
            this._reflectionEventSet = {};
            this._super();
            this._addSuccessListeners();
        },

        /**
         * _addErrorListener
         * 
         * @access  protected
         * @param   String key
         * @return  void
         */
        _addErrorListener: function(key) {
            var callback = this._errorListeners[key].proxy(this);
            this.once({
                'error': callback
            });
        },

        /**
         * _addErrorListeners
         * 
         * The logic here is that we only want to add standard error listeners
         * if no specific error listener has been defined.
         * 
         * @access  protected
         * @return  Boolean
         */
        _addErrorListeners: function() {
            if (this._hasErrorListeners() === true) {
                return false;
            }
            this._addErrorListener('alive');
            this._addErrorListener('log');
            this._addErrorListener('track');
            return true;
        },

        /**
         * _addReflectionEventSetListeners
         * 
         * @access  protected
         * @return  void
         */
        _addReflectionEventSetListeners: function() {
            var reflectionEventSet = this._reflectionEventSet,
                context = this._reflectionEventContext,
                serverRequestEventName;
            for (serverRequestEventName in reflectionEventSet) {
                this.once(serverRequestEventName, function(event) {
                    var contextEvents = reflectionEventSet[event.type],
                        index;
                    for (index in contextEvents) {
                        context.triggerHandler(contextEvents[index]);
                    }
                });
            }
        },

        /**
         * _addSuccessFalseListener
         * 
         * @access  protected
         * @param   String callbackKey
         * @return  void
         */
        _addSuccessFalseListener: function(callbackKey) {
            var callback = this._getSuccessCallback(callbackKey).proxy(this);
            this.once({
                'success/false': callback
            });
        },

        /**
         * _addSuccessListener
         * 
         * @access  protected
         * @param   String callbackKey
         * @return  void
         */
        _addSuccessListener: function(callbackKey) {
            var callback = this._getSuccessCallback(callbackKey).proxy(this);
            this.once({
                'success': callback
            });
        },

        /**
         * _addSuccessListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSuccessListeners: function() {
            this._addSuccessListener('overrides');
            this._addSuccessListener('services');
            this._addSuccessListener('success');
            this._addSuccessListener('version');
            this._addSuccessFalseListener('validators/csrfToken');
            this._addSuccessFalseListener('validators/invalidData');
            this._addSuccessFalseListener('validators/maintenanceMode');
            this._addSuccessFalseListener('validators/sessionAccount');
        },

        /**
         * _errorListeners
         * 
         * @access  protected
         * @var     Object
         */
        _errorListeners: {

            /**
             * alive
             * 
             * @access  protected
             * @param   jQuery event
             * @param   String textStatus
             * @return  void
             */
            alive: function(event, textStatus) {
                var signature = this._signature;
                RequestUtils.alive(function() {
                    var code = signature.line,
                        reference = signature.basename;
                    Stencil.error(code, reference);
                });
            },

            /**
             * log
             * 
             * @access  protected
             * @param   jQuery event
             * @param   String textStatus
             * @return  void
             */
            log: function(event, textStatus) {
                var msg = 'ServerRequest Error error',
                    signature = this._signature;
                LogUtils.log.object(Stencil, msg, true);
                LogUtils.log.object(Stencil, signature, true);
                LogUtils.log.object(Stencil, textStatus, true);
            },

            /**
             * track
             * 
             * @access  protected
             * @param   jQuery event
             * @param   String textStatus
             * @return  void
             */
            track: function(event, textStatus) {
                var action = 'ServerRequest Error',
                    signature = this._signature,
                    data = this._requestProperties.data,
                    url = this._requestProperties.url;
                Track.event(action, {
                    _code: signature.line,
                    _reference: signature.basename,
                    _data: JSON.stringify(data),
                    _url: url,
                    _textStatus: textStatus
                });
            }
        },

        /**
         * _getCachedResponse
         * 
         * @access  protected
         * @return  mixed
         */
        _getCachedResponse: function() {
            var cacheKey = this._getCacheKey(),
                cachedResponse = Stencil.get(cacheKey);
            return cachedResponse;
        },

        /**
         * _getCacheKey
         * 
         * @access  protected
         * @return  String
         */
        _getCacheKey: function() {
            var previousExcludeSecurityDataValue = this._excludeSecurityData;
            this._excludeSecurityData = true;
            var cacheMap = {
                    data: this._requestProperties.data.apply(this),
                    dataType: this._requestProperties.dataType.apply(this),
                    type: this._requestProperties.type.apply(this),
                    url: this._requestProperties.url.apply(this)
                },
                cacheKey = JSON.stringify(cacheMap);
            this._excludeSecurityData = previousExcludeSecurityDataValue;
            return cacheKey;
        },

        /**
         * _getJQueryRequestProperties
         * 
         * @access  protected
         * @return  Object
         */
        _getJQueryRequestProperties: function() {
            var requestProperties = this._getRequestProperties();
            return requestProperties;
        },

        /**
         * _getRequestProperties
         * 
         * @access  protected
         * @return  Object
         */
        _getRequestProperties: function() {
            var properties = {};
            properties.cache = true;
            properties.crossdomain = false;
            properties.data = this._requestProperties.data.apply(this);
            properties.dataType = this._requestProperties.dataType.apply(this);
            properties.error = this._requestProperties.error.apply(this);
            properties.success = this._requestProperties.success.apply(this);
            properties.timeout = this._requestProperties.timeout.apply(this);
            properties.type = this._requestProperties.type.apply(this);
            properties.url = this._requestProperties.url.apply(this);
            return properties;
        },

        /**
         * _getSecurityData
         * 
         * @access  protected
         * @return  Object
         */
        _getSecurityData: function() {
            var currentUnixTimestamp = DTUtils.getTimestamp(),
                securityData = {
                    csrf: Config.getCSRFToken(),
                    time: {
                        unix: {
                            full: currentUnixTimestamp,
                            simple: Math.floor(currentUnixTimestamp)
                        }
                    },
                    version: Stencil.get('version')
                };
            return securityData;
        },

        /**
         * _getSuccessCallback
         * 
         * @access  protected
         * @param   String callbackKey
         * @return  Function
         */
        _getSuccessCallback: function(callbackKey) {
            var callback = this._successListeners[callbackKey];
            if (StringUtils.contains(callbackKey, 'validators/') === true) {
                callbackKey = callbackKey.replace(/^validators\//, '');
                callback = this._successListeners.validators[callbackKey];
            }
            return callback;
        },

        /**
         * _getTimeout
         * 
         * @access  protected
         * @return  Number in milliseconds
         */
        _getTimeout: function() {
            if (this._timeout !== null) {
                var timeout = this._timeout;
                return timeout;
            }
            var timeout = RequestUtils.get.timeout();
            return timeout;
        },

        /**
         * _hasErrorListeners
         * 
         * I believe this method exists to prevent error listeners from being
         * added to the instance if errors are already being handled elsewhere.
         * The only example I could find at the time of documentation for this
         * is in MediaAccessor objects, whereby if a bounding box request fails,
         * it's handled seperately and should not automatically be handled by
         * the instance's error handlers.
         * 
         * @see     https://stackoverflow.com/a/2518441/115025
         * @access  protected
         * @return  Boolean
         */
        _hasErrorListeners: function() {
            var events = jQuery._data(this, 'events'),
                hasErrorListeners = events['error'] !== undefined;
            if (hasErrorListeners === true) {
                return true;
            }
            var reflectionEventSet = this._reflectionEventSet;
            hasErrorListeners = reflectionEventSet.error !== undefined;
            return hasErrorListeners;
        },

        /**
         * _makeRequest
         * 
         * @throws  Error
         * @access  protected
         * @return  void
         */
        _makeRequest: function() {
            if (this._signature === null) {
                var msg = 'Signature not defined for ServerRequest';
                throw new Error(msg);
            }
            var properties = this._getJQueryRequestProperties();
            if (this._cacheResponse === false) {
                jQuery.ajax(properties);
                return true;
            }
            var cachedResponse = this._getCachedResponse();
            if (cachedResponse === undefined) {
                this.once({
                    'success': function(event, response) {
                        this._setCachedResponse(response);
                    }
                });
                jQuery.ajax(properties);
                return true;
            }
            var success = this._requestProperties.success.apply(this),
                response = cachedResponse;
            success.apply(this, [response]);
            return false;
        },

        /**
         * _requestProperties
         * 
         * @access  protected
         * @var     Object
         */
        _requestProperties: {

            /**
             * data
             * 
             * @access  protected
             * @return  Object
             */
            data: function() {
                var securityData = this._getSecurityData(),
                    data = DataUtils.clone(this._data),
                    requestData = {};
                if (this._excludeSecurityData === true) {
                    requestData.data = data;
                    return requestData;
                }
                requestData.security = securityData;
                requestData.data = data;
                return requestData;
            },

            /**
             * dataType
             * 
             * @access  protected
             * @return  String
             */
            dataType: function() {
                var dataType = this._dataType;
                return dataType;
            },

            /**
             * error
             * 
             * @access  protected
             * @return  Function
             */
            error: function() {
                var callback = function(jqXHR, textStatus, errorThrown) {
                    this.triggerHandler('complete');
                    this.triggerHandler('error', [textStatus]);
                };
                callback = callback.proxy(this);
                return callback;
            },

            /**
             * success
             * 
             * @access  protected
             * @return  Function
             */
            success: function() {
                var callback = function(response) {
                    this.triggerHandler('complete');
                    this.triggerHandler('success', [response]);
                };
                callback = callback.proxy(this);
                return callback;
            },

            /**
             * timeout
             * 
             * @access  protected
             * @return  Number in milliseconds
             */
            timeout: function() {
                var timeout = this._getTimeout();
                return timeout;
            },

            /**
             * type
             * 
             * @access  protected
             * @return  String
             */
            type: function() {
                var method = this._method;
                return method;
            },

            /**
             * url
             * 
             * @access  protected
             * @return  String
             */
            url: function() {
                if (this._url === null) {
                    var path = this._path;
                    return path;
                }
                var url = this._url;
                return url;
            }
        },

        /**
         * _setCachedResponse
         * 
         * @access  protected
         * @param   mixed response
         * @return  void
         */
        _setCachedResponse: function(response) {
            var cacheKey = this._getCacheKey();
            Stencil.set(cacheKey, response);
        },

        /**
         * _successListeners
         * 
         * @access  protected
         * @var     Object
         */
        _successListeners: {

            /**
             * overrides
             * 
             * @access  protected
             * @param   jQuery event
             * @param   mixed response
             * @return  Boolean
             */
            overrides: function(event, response) {
                if (typeof response !== 'object') {
                    return false;
                }
                var config = response.config;
                if (config === undefined) {
                    return false;
                }
                var overrides = config.overrides,
                    collection = Stencil.get('overrides');
                if (collection === undefined) {
                    return false;
                }
                collection.empty();
                collection.map(overrides);
                return true;
            },

            /**
             * services
             * 
             * @access  protected
             * @param   jQuery event
             * @param   mixed response
             * @return  Boolean
             */
            services: function(event, response) {
                if (typeof response !== 'object') {
                    return false;
                }
                var config = response.config;
                if (config === undefined) {
                    return false;
                }
                var services = config.services;
                Config.set('services', services);
                return true;
            },

            /**
             * success
             * 
             * @access  protected
             * @param   jQuery event
             * @param   mixed response
             * @return  Boolean
             */
            success: function(event, response) {
                if (typeof response === 'object') {
                    if (response.success === true) {
                        this.triggerHandler('success/true', [response]);
                        return true;
                    }
                    this.triggerHandler('success/false', [response]);
                    return false;
                }
                return false;
            },

            /**
             * validators
             * 
             * @access  protected
             * @var     Object
             */
            validators: {

                /**
                 * csrfToken
                 * 
                 * @access  protected
                 * @param   jQuery event
                 * @param   mixed response
                 * @return  Boolean
                 */
                csrfToken: function(event, response) {
                    var error = Stencil.extractError(response);
                    if (error.validator === false) {
                        return false;
                    }
                    if (error.validator[1] === 'validCSRFToken') {
                        Stencil.alert('security.failedCSRFTokenCheck');
                        Stencil.kill();
                        return true;
                    }
                    return false;
                },

                /**
                 * invalidData
                 * 
                 * @access  protected
                 * @param   jQuery event
                 * @param   mixed response
                 * @return  Boolean
                 */
                invalidData: function(event, response) {
                    var error = Stencil.extractError(response);
                    if (error.validator === false) {
                        return false;
                    }
                    if (error.validator[1] === 'validData') {
                        Stencil.alert('security.failedDataIntegrityCheck');
                        Stencil.kill();
                        return true;
                    }
                    return false;
                },

                /**
                 * maintenanceMode
                 * 
                 * @access  protected
                 * @param   jQuery event
                 * @param   mixed response
                 * @return  Boolean
                 */
                maintenanceMode: function(event, response) {
                    var error = Stencil.extractError(response);
                    if (error.validator === false) {
                        return false;
                    }
                    if (error.validator[1] === 'notInMaintenanceMode') {
                        Stencil.alert('app.maintenance');
                        Stencil.kill();
                        return true;
                    }
                    return false;
                },

                /**
                 * sessionAccount
                 * 
                 * @access  protected
                 * @param   jQuery event
                 * @param   mixed response
                 * @return  Boolean
                 */
                sessionAccount: function(event, response) {
                    var error = Stencil.extractError(response);
                    if (error.validator === false) {
                        return false;
                    }
                    if (error.validator[1] === 'sessionAccountExists') {
                        Stencil.alert('account.sessionAccount.false');
                        Stencil.kill();
                        return true;
                    }
                    return false;
                }
            },

            /**
             * version
             * 
             * I set the version variable here, but only once, so that if and/or
             * when there's an issue, I could (in theory) track the bug to a
             * specific version/commit.
             * 
             * I believe at the moment, this version value is sent to the
             * server, so if there's an issue with a _GET request, it can be
             * helpful to have the version string.
             * 
             * The reason I don't update it as AJAX request responses come in is
             * because then I wouldn't know which actual JS library (which can
             * be connected to a version/commit value) the user was running
             * under when an issue came up.
             * 
             * @access  protected
             * @param   jQuery event
             * @param   mixed response
             * @return  Boolean
             */
            version: function(event, response) {
                if (Stencil.get('version') !== undefined) {
                    return false;
                }
                if (typeof response !== 'object') {
                    return false;
                }
                var version = response.version;
                if (version === undefined) {
                    return false;
                }
                Stencil.set('version', version);
                return true;
            }
        },

        /**
         * _wait
         * 
         * @note    The redirecting check is to accommodate a Safari bug whereby
         *          if the browser is currently redirecting (eg. a download has
         *          been triggered), we should wait to perform any XHR requests.
         * @access  protected
         * @return  Boolean
         */
        _wait: function(method) {
            if (Stencil.get('redirecting') === true) {
                Stencil.once({
                    'redirect/complete': this[method].proxy(this)
                });
                return true;
            }
            return false;
        },

        /**
         * blockFailedValidation
         * 
         * When called, this method will add an event listener which, which when
         * a request fails via a validation rule, will kill the app.
         * 
         * @access  public
         * @return  void
         */
        blockFailedValidation: function() {
            this.once({
                'success/false': function(event, response) {
                    var error = Stencil.extractError(response),
                        signature = this._signature,
                        code = (signature.line) + '-' + (error.code),
                        reference = error.reference;
                    Stencil.error(code, reference);
                }
            });
        },

        /**
         * cacheResponse
         * 
         * When this method is called, it will cache any response retrieved, as
         * well as attempt to check if a cached response for this request has
         * already been stored.
         * 
         * @access  public
         * @return  void
         */
        cacheResponse: function() {
            this._cacheResponse = true;
        },

        /**
         * delete
         * 
         * @access  public
         * @return  Boolean
         */
        delete: function() {
            if (this._wait('delete') === true) {
                return false;
            }
            this._addErrorListeners();
            this._addReflectionEventSetListeners();
            this._method = 'delete';
            this._makeRequest();
            return true;
        },

        /**
         * excludeSecurityData
         * 
         * @access  public
         * @return  void
         */
        excludeSecurityData: function() {
            this._excludeSecurityData = true;
        },

        /**
         * get
         * 
         * @access  public
         * @return  Boolean
         */
        get: function() {
            if (this._wait('get') === true) {
                return false;
            }
            this._addErrorListeners();
            this._addReflectionEventSetListeners();
            this._method = 'get';
            this._makeRequest();
            return true;
        },

        /**
         * logFailedValidation
         * 
         * When called, this method will add an event listener which, which when
         * a request fails via a validation rule, will log the code and
         * reference to the console.
         * 
         * @access  public
         * @return  void
         */
        logFailedValidation: function() {
            this.once({
                'success/false': function(event, response) {
                    var error = Stencil.extractError(response),
                        signature = this._signature,
                        code = (signature.line) + '-' + (error.code),
                        reference = error.reference;
                    LogUtils.log.simple(code, true);
                    LogUtils.log.simple(reference, true);
                }
            });
        },

        /**
         * patch
         * 
         * @access  public
         * @return  Boolean
         */
        patch: function() {
            if (this._wait('patch') === true) {
                return false;
            }
            this._addErrorListeners();
            this._addReflectionEventSetListeners();
            this._method = 'patch';
            this._makeRequest();
            return true;
        },

        /**
         * post
         * 
         * @access  public
         * @return  Boolean
         */
        post: function() {
            if (this._wait('post') === true) {
                return false;
            }
            this._addErrorListeners();
            this._addReflectionEventSetListeners();
            this._method = 'post';
            this._makeRequest();
            return true;
        },

        /**
         * removeErrorListener
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        removeErrorListener: function(key) {
            var callback = this._errorListeners[key].proxy(this);
            this.unbind('error', callback);
        },

        /**
         * removeErrorListeners
         * 
         * @access  public
         * @return  void
         */
        removeErrorListeners: function() {
            var errorListeners = this._errorListeners,
                index;
            for (index in errorListeners) {
                this.removeErrorListener(index);
            }
        },

        /**
         * setData
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        setData: function(data) {
            this._data = data;
        },

        /**
         * setDataType
         * 
         * @access  public
         * @param   String dataType
         * @return  void
         */
        setDataType: function(dataType) {
            this._dataType = dataType;
        },

        /**
         * setEvents
         * 
         * @access  public
         * @param   Object events
         * @return  void
         */
        setEvents: function(events) {
            var eventName, callback;
            for (eventName in events) {
                callback = events[eventName];
                this.once(eventName, callback);
            }
        },

        /**
         * setOptions
         * 
         * @access  public
         * @param   Object options
         * @return  void
         */
        setOptions: function(options) {
            if (options.blockFailedValidation !== undefined) {
                this.blockFailedValidation();
            }
            if (options.cacheResponse !== undefined) {
                this.cacheResponse();
            }
            if (options.data !== undefined) {
                this.setData(options.data);
            }
            if (options.events !== undefined) {
                this.setEvents(options.events);
            }
            if (options.logFailedValidation !== undefined) {
                this.logFailedValidation();
            }
            if (options.path !== undefined) {
                this.setPath(options.path);
            }
            if (options.reflectionEventContext !== undefined) {
                this.setReflectionEventContext(options.reflectionEventContext);
            }
            if (options.reflectionEventSet !== undefined) {
                this.setReflectionEventSet(options.reflectionEventSet);
            }
            if (options.signature !== undefined) {
                this.setSignature(options.signature);
            }
            if (options.timeout !== undefined) {
                this.setTimeout(options.timeout);
            }
        },

        /**
         * setPath
         * 
         * @access  public
         * @param   String path
         * @return  void
         */
        setPath: function(path) {
            this._path = path;
        },

        /**
         * setReflectionEventContext
         * 
         * @access  public
         * @param   mixed context
         * @return  void
         */
        setReflectionEventContext: function(context) {
            this._reflectionEventContext = context;
        },

        /**
         * setReflectionEventSet
         * 
         * Helper method that accepts a map whereby the keys define local events
         * to listen to, and the values define an array of events to reflect
         * those events back to.
         * 
         * It's intended purpose is simply to clean up events against
         * ServerRequest instances which merely act as proxies for other events.
         * 
         * @access  public
         * @param   Object reflectionEventSet
         * @return  void
         */
        setReflectionEventSet: function(reflectionEventSet) {
            this._reflectionEventSet = reflectionEventSet;
        },

        /**
         * setSignature
         * 
         * @access  public
         * @param   Object signature
         * @return  void
         */
        setSignature: function(signature) {
            this._signature = signature;
        },

        /**
         * setTimeout
         * 
         * @access  public
         * @param   Number timeout in milliseconds
         * @return  void
         */
        setTimeout: function(timeout) {
            this._timeout = timeout;
        },

        /**
         * setUrl
         * 
         * @access  public
         * @param   String url
         * @return  void
         */
        setUrl: function(url) {
            this._url = url;
        }
    });
});

/**
 * Track
 * 
 * Acts as a wrapper for whatever the analytics engine is, via it's associated
 * BaseClientWrapper instance.
 * 
 * @abstract
 */
window.Track = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'track')
     */
    var __classType = 'track';

    /**
     * __getAnalyticsClientWrapper
     * 
     * @access  private
     * @var     SegmentClientWrapper
     */
    var __getAnalyticsClientWrapper = function() {
        var clientWrapper = ClientWrappers.get('segment');
        return clientWrapper;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Track')
     */
    var __string = 'Track';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * alias
         * 
         * @access  public
         * @return  void
         */
        alias: function() {
            var clientWrapper = __getAnalyticsClientWrapper(),
                success = clientWrapper.setAlias();
            return success;
        },

        /**
         * disable
         * 
         * @access  public
         * @return  Boolean
         */
        disable: function() {
            var clientWrapper = __getAnalyticsClientWrapper(),
                success = clientWrapper.disable();
            return success;
        },

        /**
         * enabled
         * 
         * @access  public
         * @return  Boolean
         */
        enabled: function() {
            var clientWrapper = __getAnalyticsClientWrapper(),
                success = clientWrapper.enabled();
            return success;
        },

        /**
         * event
         * 
         * @access  public
         * @param   String action
         * @param   undefined|Object properties
         * @return  Boolean
         */
        event: function(action, properties) {
            properties = DataUtils.getDefaultValue(properties, {});
            var clientWrapper = __getAnalyticsClientWrapper(),
                success = clientWrapper.trackEvent(action, properties);
            return success;
        },

        /**
         * page
         * 
         * @access  public
         * @return  Boolean
         */
        page: function(path) {
            var clientWrapper = __getAnalyticsClientWrapper(),
                success = clientWrapper.trackPage(path);
            return success;
        },

        /**
         * user
         * 
         * @access  public
         * @return  Boolean
         */
        user: function() {
            var clientWrapper = __getAnalyticsClientWrapper(),
                success = clientWrapper.trackUser();
            return success;
        }
    });
})();

/**
 * User
 * 
 * @fires   login
 *          signup
 * @abstract
 */
window.User = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'user')
     */
    var __classType = 'user';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'User')
     */
    var __string = 'User';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * admin
         * 
         * Returns whether or not the logged in user (if any) is an admin.
         * 
         * @access  public
         * @return  Boolean
         */
        admin: function() {
            if (User.exists() === false) {
                return false;
            }
            var user = Stencil.get('user');
            return user.setting('admin').toInt() === 1;
        },

        /**
         * blockedFromCheckout
         * 
         * @access  public
         * @return  Boolean
         */
        blockedFromCheckout: function() {
            var host = Stencil.get('user').get('email').split('@').pop(),
                security = Config.get('security'),
                emailProvidersBlockedFromCheckout = security.emailProvidersBlockedFromCheckout;
            if (ArrayUtils.contains(host, emailProvidersBlockedFromCheckout) === false) {
                return false;
            }
            return true;
        },

        /**
         * customer
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        // customer: function() {
        //     return Stencil.get('user').customer();
        // },

        /**
         * editor
         * 
         * @access  public
         * @return  Boolean
         */
        editor: function() {
            if (User.exists() === false) {
                return false;
            }
            var user = Stencil.get('user');
            return user.setting('editor').toInt() === 1;
        },

        /**
         * exists
         * 
         * Returns whether a user exists (aka. not a guest account). Initially
         * only had a false check, but there was an edge-case whereby this
         * method was being called before <Stencil.set> was called. When that
         * happened, the stored valued was <undefined>. I ran into this
         * edge-case when preparing logic for syncing image JSON data in the
         * ImageAccessor.
         * 
         * @access  public
         * @return  Boolean
         */
        exists: function() {
            var user = Stencil.get('user');
            return user !== false && user !== undefined;
        },

        /**
         * frozen
         * 
         * @access  public
         * @return  Boolean
         */
        frozen: function() {
            if (User.exists() === false) {
                return false;
            }
            var user = Stencil.get('user'),
                frozen = user.setting('frozen').toInt() === 1;
            return frozen;
        },

        /**
         * login
         * 
         * Performs the neccessary logic to log the user in, including
         * analytics, account reloading and firing events.
         * 
         * @note    Logic is very sensitive to ordering. Be careful :/
         * @access  public
         * @return  void
         */
        login: function() {
            var user = Stencil.get('user');
            Stencil.account().reload();
            Track.user();
            Track.event('Logged in');
            user.on({
                'change': Track.user
            });
            Stencil.account().on({
                'change': Track.user
            });
            User.triggerHandler('login', [user]);
            // Stencil.account().reload();
            Stencil.account().syncFavorites();

            // Get watermarks and turn on the ones that ought to be turned on
            var watermarks = Stencil.account().collection('watermarks'),
                // styles,
                active;
            watermarks.each(
                function(index, watermark) {
                    // styles = JSON.parse(watermark.setting('styles'));
                    active = watermark.setting('active').toInt() === 1;
                    if (active === true) {
                        watermark.addToCanvas(false);
                    }
                }
            );

            // // Delete all layers, excluding watermarks
            // var iD = Canvases.Preview.getImageDocument();
            // jQuery.each(iD.getLayers(false), function(index, layer) {
            //     layer.triggerHandler('delete');
            // });

            // // 
            // var draft = Stencil.account().draft();
            // draft.setToImage(image);
            // var document = draft.json();

            // // Set image document
            // Canvases.Preview.prepareAndDraw(document);
        },

        /**
         * logout
         * 
         * @see     https://segment.com/docs/libraries/analytics.js/
         * @see     http://stackoverflow.com/questions/21137286/what-should-i-do-when-users-log-out
         * @todo    Implement the same flow/logic that you do below for logging
         *          out when the app is open via an external chrome extension for
         *          the Alert and Error modal flows. At the moment, it simply
         *          changes the path of the parent page. Works for users that are
         *          at getstencil.com/app, but for those using the app through
         *          the extension, it's taking them to a new, unintented, page.
         *          Have the app slide down, and back up? Also, do this for the
         *          admin area when cancelling a user:
         *          https://i.imgur.com/lwStqly.png
         *          Will get annoying pretty fast :/
         * @access  public
         * @param   Function callback
         * @return  void
         */
        logout: function(callback) {

            // Messaging
            var msg = Config.getMessage('user.logout');
            App.getBusy().show(msg);
            AudioUtils.play('ill-be-back.mp3');

            // 
            var path = '/users/logout';
            RequestUtils.ajax({
                signature: {"basename":"User.js","line":203},
                url: path,
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        Stencil.kill();

                        // Callback delay
                        callback = callback || function() {
                            // var path = '/app',
                            var path = UserAgentUtils.getLogoutPath(),
                                options = Stencil.getOptions();
                            if (options.source.external === true) {
                                if (options.source.extension === true) {
                                    if (options.source.chrome === true) {
                                        var slide = Config.default('slide');
                                        path = '/app?external&extension&' +
                                            'chrome';
                                        App.hide();
                                        (function() {
                                            RequestUtils.postMessage(
                                                'message.app.logout'
                                            );
                                            window.location.assign(path);
                                        }).delay(slide);
                                    }
                                }
                            } else {
                                window.location.assign(path);
                            }
                        };

                        // Reset and bail
                        ClientWrappers.get('segment').reset();
                        callback.delay(1000);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '240-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * signup
         * 
         * Performs the neccessary logic to sign a user up within the app,
         * including analytics, property updating and firing events.
         * 
         * @note    Logic is very sensitive to ordering. Be careful :/
         * @note    Delay below is to ensure alias call is made before
         *          user/identify call
         * @access  public
         * @return  void
         */
        signup: function() {
            var user = Stencil.get('user');
            Stencil.account().set({
                'guest': 0
            });
            Track.alias();
            Track.user.delay(5 * 1000);
            Track.event('Signed up');
            user.on({
                'change': Track.user
            });
            Stencil.account().on({
                'change': Track.user
            });
            User.triggerHandler('signup', [user]);
        },

        /**
         * trackShareASaleConversion
         * 
         * @access  public
         * @return  Boolean
         */
        trackShareASaleConversion: function() {
            if (Track.enabled() === false) {
                return false;
            }
            if (Config.serviceAvailable('shareASale') === false) {
                return false;
            }
            if (Stencil.account().get('upgrades').length > 1) {
                return false;
            }
            return true;
        },

        /**
         * trackTapfiliateConversion
         * 
         * Ensures that Tapfiliate conversion operations to not happen if:
         * - Tapfiliate service is turned off (eg. they're down)
         * - the window.tap property is undefined (likely aggressive AdBlocker)
         * - The user has more than one upgrade record (conversion tracking is
         *   not available if a user upgrades, downgrades, and then upgrades
         *   again)
         * 
         * @access  public
         * @return  Boolean
         */
        trackTapfiliateConversion: function() {
            if (Config.serviceAvailable('tapfiliate') === false) {
                return false;
            }
            if (window.tap === undefined) {
                return false;
            }
            if (Stencil.account().get('upgrades').length > 1) {
                return false;
            }
            return true;
        },

        /**
         * upgrade
         * 
         * @note    The properties here aren't prepended with an underscore
         *          since the naming convention here is important for conversion
         *          tracking with Facebook and AdRoll
         * @note    Revenue and value are both tracked, since different ad
         *          networks expect different key names
         * @note    The triggerHandler call needs to happen first to ensure the
         *          UpgradeAccessor is available. See here:
         *          https://i.imgur.com/iBEqG4F.png
         * @note    window.tap !== undefined check is to prevent error with ad
         *          blockers
         * @access  public
         * @param   false|Object stripeResponse
         * @return  void
         */
        upgrade: function(stripeResponse) {
            Account.triggerHandler('upgrade', [Stencil.account()]);
            Track.user();
            if (stripeResponse !== false) {
                var upgrade = Stencil.account().upgrade(),
                    centsPaid = false;

                // Charge went through
                if (stripeResponse.charge !== false) {
                    centsPaid = stripeResponse.charge.amount.toInt();
                }
                // Likely no charge, but will be one when trial converts
                else if (stripeResponse.upcomingInvoice !== false) {
                    centsPaid = stripeResponse.upcomingInvoice.amount_due.toInt();
                }

                // Helper to determine if Tapfiliate tracking should be running
                if (User.trackTapfiliateConversion() === true) {
                    var identifier = upgrade.getTapfiliateCommissionTypeIdentifier(),
                        metaData = {
                            email: Stencil.get('user').get('email'),
                            id: Stencil.get('user').get('id'),
                            key: Stencil.get('user').get('key')
                        };
                    ClientWrappers.get('tapfiliate').trackConversion(
                        upgrade.get('key'),
                        centsPaid / 100,
                        {
                            meta_data: metaData
                        },
                        identifier,
                        function(conversion) {
                            upgrade.push(
                                'settings.tapfiliateConversionId',
                                conversion.id
                            );
                        }
                    );
                }

                // Helper to determine if ShareASale tracking should be running
                if (User.trackShareASaleConversion() === true) {
                // if (true) {
                    var identifier = upgrade.getShareASaleCommissionTypeIdentifier(),
                        merchantId = Config.get('shareASale').auth.id,
                        transType = 'sale',
                        upgradeKey = upgrade.get('key'),
                        amount = centsPaid / 100,
                        url = 'https://shareasale.com/sale.cfm?' +
                            'amount=' + (amount) + '&' +
                            'tracking=' + (upgradeKey) + '&' +
                            'transtype=' + (transType) + '&' +
                            'merchantID=' + (merchantId);
                    ImageUtils.load.url(url);
                }

                // Track event
                Track.event('Upgraded', {
                    currency: 'USD',
                    revenue: centsPaid / 100,
                    value: centsPaid
                });
            }
        }
    });
})();

/**
 * ArrayUtils
 * 
 * @abstract
 */
window.ArrayUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ArrayUtils')
     */
    var __string = 'ArrayUtils';

    // Public
    return {

        /**
         * clone
         * 
         * @see     https://www.hacksparrow.com/javascript-convert-arguments-to-array.html
         * @see     http://stackoverflow.com/questions/3775480/is-there-a-method-to-clone-an-array-in-jquery
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        clone: function(arr) {
            if (DataUtils.valid(arr.slice) === false) {
                var clone = Array.prototype.slice.call(arr);
                return clone;
            }
            var clone = arr.slice(0);
            return clone;
        },

        /**
         * contains
         * 
         * @access  public
         * @param   mixed value
         * @param   Array arr
         * @return  Boolean
         */
        contains: function(value, arr) {
            return ArrayUtils.inArray(value, arr) === true;
        },

        /**
         * insertSpacesIntoCamelCase
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        insertSpacesIntoCamelCase: function(arr) {
            arr = ArrayUtils.clone(arr);
            var index;
            for (index in arr) {
                arr[index] = StringUtils.insertSpacesIntoCamelCase(arr[index]);
            }
            return arr;
        },

        /**
         * inArray
         * 
         * @access  public
         * @param   mixed value
         * @param   Array arr
         * @return  Boolean
         */
        inArray: function(value, arr) {
            var index = jQuery.inArray(value, arr);
            return index !== -1;
        },

        /**
         * last
         * 
         * @access  public
         * @param   Array arr
         * @return  false|mixed
         */
        last: function(arr) {
            var length = arr.length
                index = length - 1;
            if (length === 0) {
                return false;
            }
            var last = arr[index];
            return last;
        },

        /**
         * lowercase
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        lowercase: function(arr) {
            arr = ArrayUtils.clone(arr);
            var index;
            for (index in arr) {
                arr[index] = arr[index].toLowerCase();
            }
            return arr;
        },

        /**
         * merge
         * 
         * @access  public
         * @return  Array
         */
        merge: function() {
            var arrs = [],
                args = arguments,
                index;
            for (index in args) {
                arrs.push(
                    ArrayUtils.clone(args[index])
                );
            }
            return [].concat.apply([], arrs);
        },

        /**
         * random
         * 
         * @access  public
         * @param   Array arr
         * @return  mixed
         */
        random: function(arr) {
            var index = Math.floor(Math.random() * arr.length),
                value = arr[index];
            return value;
        }
    };
})();

/**
 * AudioUtils
 * 
 * @abstract
 */
window.AudioUtils = (function() {

    /**
     * __getAudioSourceUrls
     * 
     * @access  private
     * @param   String basename
     * @return  Array
     */
    var __getAudioSourceUrls = function(basename) {
        var urls = [],
            url = RequestUtils.url.audio(basename);
        urls.push(url);
        return urls;
    };

    /**
     * __playSounds
     * 
     * @access  private
     * @return  Boolean
     */
    var __playSounds = function() {
        if (User.admin() === true) {
            return true;
        }
        if (Config.getRole() === 'local') {
            return true;
        }
        if (Config.getRole() === 'dev') {
            return true;
        }
        return false;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'AudioUtils')
     */
    var __string = 'AudioUtils';

    // Public
    return {

        /**
         * play
         * 
         * @access  public
         * @param   String basename
         * @return  Boolean
         */
        play: function(basename) {
            if (__playSounds() === false) {
                return false;
            }
            var urls = __getAudioSourceUrls(basename),
                sound = new Howl({
                    src: urls
                });
            sound.play();
            return true;
        }
    };
})();

/**
 * CanvasElementUtils
 * 
 * @abstract
 */
window.CanvasElementUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'CanvasElementUtils')
     */
    var __string = 'CanvasElementUtils';

    // Public
    return {

        /**
         * centerAndClip
         * 
         * Method added to the HTMLCanvasElement which returns a new
         * CanvasHTMLElement that has as it's image as the current one,
         * centered, and with any bleed cut off.
         * 
         * @access  public
         * @param   HTMLCanvasElement canvas
         * @param   Number width
         * @param   Number height
         * @return  HTMLCanvasElement
         */
        centerAndClip: function(canvas, width, height) {
            var clippedCanvas = document.createElement('canvas'),
                ctx = clippedCanvas.getContext('2d');
            clippedCanvas.width = width;
            clippedCanvas.height = height;
            var ratios = {
                    clipped: width / height,
                    current: canvas.width / canvas.height
                },
                scale,
                properties = {};

            // Taller image
            if (ratios.clipped > ratios.current) {
                scale = width / canvas.width;
                properties.sx = 0;
                properties.sy = ((canvas.height - height / scale) / 2);
                properties.swidth = width / scale;
                properties.sheight = clippedCanvas.height / scale;
            }
            // Wider image
            else {
                scale = height / canvas.height;
                properties.sx = ((canvas.width - width / scale) / 2);
                properties.sy = 0;
                properties.swidth = clippedCanvas.width / scale;
                properties.sheight = height / scale;
            }

            // Done
            ctx.drawImage(
                canvas,
                properties.sx,
                properties.sy,
                properties.swidth,
                properties.sheight,
                0,
                0,
                width,
                height
            );
            return clippedCanvas;
        },

        /**
         * resizeToMax
         * 
         * Resizes the canvas, proportionately, to a maximum width and/or
         * height. It will not blow up the canvas beyond what it's native
         * width/height is, though.
         * 
         * @access  public
         * @param   HTMLCanvasElement canvas
         * @param   Number|false width
         * @param   Number|false height
         * @return  HTMLCanvasElement
         */
        resizeToMax: function(canvas, width, height) {
            var resizedCanvas = document.createElement('canvas'),
                ctx = resizedCanvas.getContext('2d');
            if (width === false && height === false) {
                var msg = 'Invalid argments; both cannot be false';
                throw new Error(msg);
            }
            if (width === false) {
                if (canvas.height <= height) {
                    resizedCanvas.width = canvas.width;
                    resizedCanvas.height = canvas.height;
                    ctx.drawImage(canvas, 0, 0);
                    return resizedCanvas;
                }
                var scale = height / canvas.height;
                resizedCanvas.width = canvas.width * scale;
                resizedCanvas.height = height;
                ctx.drawImage(canvas, 0, 0, canvas.width * scale, height);
                return resizedCanvas;
            }
            if (height === false) {
                if (canvas.width <= width) {
                    resizedCanvas.width = canvas.width;
                    resizedCanvas.height = canvas.height;
                    ctx.drawImage(canvas, 0, 0);
                    return resizedCanvas;
                }
                var scale = width / canvas.width;
                resizedCanvas.width = width;
                resizedCanvas.height = canvas.height * scale;
                ctx.drawImage(canvas, 0, 0, width, canvas.height * scale);
                return resizedCanvas;
            }
            var ratios = {
                current: canvas.width / canvas.height,
                max: width / height
            };
            if (ratios.current < ratios.max) {
                return CanvasElementUtils.resizeToMax(canvas, false, height);
            }
            return CanvasElementUtils.resizeToMax(canvas, width, false);
        },

        /**
         * trimTransparentPixels
         * 
         * Helper method, used by vector layers, to trim whitespace from a
         * canvas and return back details on what was trimmed (eg. boundaries),
         * along with details on the trimmed canvas.
         * 
         * @see     https://gist.github.com/remy/784508
         * @access  public
         * @param   HTMLCanvasElement canvas
         * @return  Object
         */
        trimTransparentPixels: function(canvas) {
            var ctx = canvas.getContext('2d'),
                pixels = ctx.getImageData(0, 0, canvas.width, canvas.height),
                bounds = {
                    top: null,
                    left: null,
                    right: null,
                    bottom: null
                };

            for (var i = 0, l = pixels.data.length, x, y; i < l; i += 4) {
                if (pixels.data[i + 3] === 0) {
                    continue;
                }
                x = (i / 4) % canvas.width;
                y = ~~((i / 4) / canvas.width);

                if (bounds.top === null) {
                    bounds.top = y;
                }

                if (bounds.left === null) {
                    bounds.left = x;
                } else if (x < bounds.left) {
                    bounds.left = x;
                }

                if (bounds.right === null) {
                    bounds.right = x;
                } else if (bounds.right < x) {
                    bounds.right = x;
                }

                if (bounds.bottom === null) {
                    bounds.bottom = y;
                } else if (bounds.bottom < y) {
                    bounds.bottom = y;
                }
            }

            /**
             * See comment for this. Ran into myself when comparing this trim
             * method to Photoshop's
             * 
             * @see     https://gist.github.com/remy/784508
             */
            ++bounds.bottom;
            ++bounds.right;

            // Done
            return {
                ratio: (bounds.right - bounds.left) / (bounds.bottom - bounds.top),
                width: bounds.right - bounds.left,
                height: bounds.bottom - bounds.top,
                bounds: bounds,
                canvas: canvas
            };
        }
    };
})();

/**
 * CategoryUtils.js
 * 
 * @abstract
 */
window.CategoryUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'CategoryUtils')
     */
    var __string = 'CategoryUtils';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * account
         * 
         * @access  public
         * @var     Object
         */
        account: {

            /**
             * all
             * 
             * @access  public
             * @param   Object properties
             * @return  Array
             */
            all: function(properties) {
                properties = properties || {};
                var categories = Stencil.get('account').collection('categories');
                return categories.filter(function(index, category) {
                    var index;
                    for (index in properties) {
                        if (category.get(index) !== properties[index]) {
                            return false;
                        }
                    }
                    return true;
                });
            },

            /**
             * custom
             * 
             * @access  public
             * @param   String type
             * @return  Array
             */
            custom: function(type) {
                var properties = {
                    custom: 1
                };
                properties[type] = 1
                return CategoryUtils.account.all(properties);
            },

            /**
             * favorites
             * 
             * @access  public
             * @param   String type
             * @return  false|CategoryAccessor
             */
            favorites: function(type) {
                var properties = {
                    favorites: 1
                };
                properties[type] = 1
                return CategoryUtils.account.one(properties);
            },

            /**
             * list
             * 
             * @access  public
             * @param   String type
             * @return  false|CategoryAccessor
             */
            list: function(type) {
                var properties = {
                    all: 1
                };
                properties[type] = 1
                return CategoryUtils.account.one(properties);
            },

            /**
             * one
             * 
             * @access  public
             * @param   Object properties
             * @return  false|CategoryAccessor
             */
            one: function(properties) {
                properties = properties || {};
                var categories = CategoryUtils.account.all(properties);
                if (categories.length === 0) {
                    return false;
                }
                return categories.shift();
            }
        },

        /**
         * global
         * 
         * @access  public
         * @var     Object
         */
        global: {

            /**
             * all
             * 
             * @access  public
             * @param   Object properties
             * @return  Array
             */
            all: function(properties) {
                properties = properties || {};
                var categories = Stencil.get('globalCategories');
                return categories.filter(function(index, category) {
                    var index;
                    for (index in properties) {
                        if (category.get(index) !== properties[index]) {
                            return false;
                        }
                    }
                    return true;
                });
            },

            /**
             * featured
             * 
             * @access  public
             * @param   String type
             * @return  false|CategoryAccessor
             */
            featured: function(type) {
                var properties = {
                    featured: 1
                };
                properties[type] = 1;
                return CategoryUtils.global.one(properties);
            },

            /**
             * one
             * 
             * @access  public
             * @param   Object properties
             * @return  false|CategoryAccessor
             */
            one: function(properties) {
                properties = properties || {};
                var categories = CategoryUtils.global.all(properties);
                if (categories.length === 0) {
                    return false;
                }
                return categories.shift();
            },

            /**
             * type
             * 
             * @access  public
             * @param   String type
             * @param   undefined|Boolean featured
             * @return  Array
             */
            type: function(type, featured) {
                var properties = {};
                properties[type] = 1;
                if (featured !== undefined) {
                    properties.featured = +featured;
                }
                return CategoryUtils.global.all(properties);
            }
        },

        /**
         * universal
         * 
         * @access  public
         * @var     Object
         */
        universal: {

            /**
             * all
             * 
             * @access  public
             * @param   Object properties
             * @return  Array
             */
            all: function(properties) {
                var global = CategoryUtils.global.all(properties),
                    account = CategoryUtils.account.all(properties);
                return jQuery.merge(global, account);
            },

            /**
             * one
             * 
             * @access  public
             * @param   Object properties
             * @return  false|CategoryAccessor
             */
            one: function(properties) {
                var all = CategoryUtils.universal.all(properties);
                if (all.length === 0) {
                    return false;
                }
                return all.shift();
            }
        }
    });
})();

/**
 * ColorUtils
 * 
 * This class is designed to help with color manipulation. The big challenge
 * here is that since starting to use this library, it's disappeared from the
 * internet. So while it's functional now, may want to switch to a new library
 * in the future that is properly documented.
 * 
 * @note    The relevant jquery-minicolors commit (for the current version of
 *          2.1.13) is here:
 *          https://github.com/claviska/jquery-minicolors/commit/17c9dd45b64e0e768c7eeef3108f75b5e76189c9
 *          I'm documenting this here because the /releases page for the repo
 *          doesn't have that version, and I believe at the time (3.5 years
 *          ago), I simply grabbed the source of the library directly from
 *          master (wohoops).
 * @see     https://i.imgur.com/jDDgdL2r.jpg
 * @see     http://cache.preserve.io/5g18q0pw/index.html
 * @abstract
 */
window.ColorUtils = (function() {

    /**
     * __getSanitizedColor
     * 
     * Simply returns a Color instance for the passed in color string. I do some
     * light cleanup here because in the past, there were bugs whereby an rgb or
     * rbga color was invalidally formatted/parsed, and resulted in one of the
     * rgba or rgba color values being rendered as an NaN (Not a Number) value.
     * So I strip any of those out, and lowercase it, just to have things
     * standardarized as much as possible.
     * 
     * It's worth noting that on 16 April 2018, I cleaned out the database of
     * image json setting values that have NaN values in them, so this actually
     * shouldn't happen again. But it doesn't hurt to keep this in incase there
     * are formatting/parsing issues in the future.
     * 
     * Additionally: a default Color object representing the color black is set.
     * This is to ensure that if there are any issues parsing a color string, a
     * backup/default color is still returned.
     * 
     * I found that if people entered invalid hex code values (eg. #0z0z0z),
     * the jquery.minicolors widget would still pass that value along. This
     * would result in a failure to parse.
     * 
     * @see     https://i.imgur.com/lyxAUM2.png
     * @see     https://i.imgur.com/UXwU4ed.png
     * @see     https://i.imgur.com/RXrYKel.png
     * @note    Doing some "smart" replacement of hex code values, since I
     *          noticed a couple errors via Sentry. See screenshot below:
     * @see     https://i.imgur.com/3fR0cgs.png
     * @access  private
     * @param   String colorStr
     * @return  Color
     */
    var __getSanitizedColor = function(colorStr) {
        if (typeof colorStr !== 'string') {
            colorStr = 'rgba(0, 0, 0, 1)';
        }
        if (colorStr.match(/^#/) !== null) {
            colorStr = colorStr.replace(/o/i, '0');
            colorStr = colorStr.replace(/i/i, '1');
            colorStr = colorStr.replace(/l/i, '1');
            colorStr = colorStr.replace(/s/i, '5');
        }
        colorStr = colorStr.toLowerCase();
        colorStr = colorStr.replace(/NaN/gi, '0');
        var color = pusher.color('rgba(0, 0, 0, 1)');
        try {
            color = pusher.color(colorStr);
        } catch (err) {
        }
        return color;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ColorUtils')
     */
    var __string = 'ColorUtils';

    // Public
    return {

        /**
         * addSpaces
         * 
         * Formats either an rgb or rgba color to ensure consistent spacing.
         * This is important because it allows standardization between
         * libraries and rgba-sources to ensure conditionals can be written
         * without having to worry about formatting issues.
         * 
         * @access  public
         * @param   String str
         * @return  String
         */
        addSpaces: function(str) {
            var spaced = str.replace(/\,([0-9]+)/g, ', $1');
            return spaced;
        },

        /**
         * convert
         * 
         * @access  public
         * @param   String colorStr
         * @param   String outputType
         * @param   undefined|Number opacity
         * @return  String
         */
        convert: function(colorStr, outputType, opacity) {
            if (outputType === 'hex') {
                outputType = 'hex6';
            }
            outputType = outputType.toLowerCase();
            var color = __getSanitizedColor(colorStr);
            if (opacity !== undefined) {
                color = color.alpha(opacity);
            }
            if (outputType === 'rgb' || outputType === 'rgba') {
                return ColorUtils.addSpaces(
                    color.html(outputType)
                );
            }
            return color.html(outputType).toLowerCase();
        },

        /**
         * getAlpha
         * 
         * @access  public
         * @param   String colorStr
         * @return  Number
         */
        getAlpha: function(colorStr) {
            var color = ColorUtils.getColor(colorStr);
            return color.alpha();
        },

        /**
         * getBlack
         * 
         * @access  public
         * @param   undefined|String outputType (default: 'rgba')
         * @param   undefined|Number opacity (default: 1)
         * @return  String
         */
        getBlack: function(outputType, opacity) {
            outputType = DataUtils.getDefaultValue(outputType, 'rgba');
            opacity = DataUtils.getDefaultValue(opacity, 1);
            return ColorUtils.convert('black', outputType, opacity);
        },

        /**
         * getColor
         * 
         * @access  public
         * @param   String colorStr
         * @return  Color
         */
        getColor: function(colorStr) {
            var color = __getSanitizedColor(colorStr);
            return color;
        },

        /**
         * getContrastingColorStr
         * 
         * @access  public
         * @param   String colorStr
         * @param   String outputType
         * @return  String
         */
        getContrastingColorStr: function(colorStr, outputType) {
            var color = __getSanitizedColor(colorStr),
                contrastingColor = color.contrastWhiteBlack();
            if (outputType === 'rgb' || outputType === 'rgba') {
                return ColorUtils.addSpaces(
                    contrastingColor.html(outputType)
                );
            }
            return contrastingColor.html(outputType).toLowerCase();
        },

        /**
         * getWhite
         * 
         * @access  public
         * @param   undefined|String outputType (default: 'rgba')
         * @param   undefined|Number opacity (default: 1)
         * @return  String
         */
        getWhite: function(outputType, opacity) {
            outputType = DataUtils.getDefaultValue(outputType, 'rgba');
            opacity = DataUtils.getDefaultValue(opacity, 1);
            return ColorUtils.convert('white', outputType, opacity);
        }
    };
})();

/**
 * DataUtils
 * 
 * @abstract
 */
window.DataUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'DataUtils')
     */
    var __string = 'DataUtils';

    // Public
    return {

        /**
         * clone
         * 
         * @access  public
         * @param   Object source
         * @return  Object
         */
        clone: function(source) {
            var clone = jQuery.extend(true, {}, source);
            return clone;
        },

        /**
         * convertDataURLContentType
         * 
         * @access  public
         * @param   String dataURL
         * @param   String contentType
         * @param   Function callback
         * @return  void
         */
        convertDataURLContentType: function(dataURL, contentType, callback) {
            var img = document.createElement('img');
            img.onload = function() {
                var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                canvas.width = this.width;
                canvas.height = this.height;
                ctx.drawImage(this, 0, 0, this.width, this.height);
                callback(canvas.toDataURL(contentType, 1.0));
            };
            img.src = dataURL;
        },

        /**
         * convertGoogleFontNames
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        convertGoogleFontNames: function(arr) {
            var index;
            for (index in arr) {
                arr[index] = arr[index].replace(':n4', '');
                arr[index] = arr[index].replace(':n7', ':b');
                arr[index] = arr[index].replace(':i4', ':i');
                arr[index] = arr[index].replace(':i7', ':bi');
            }
            return arr;
        },

        /**
         * copyToClipboard
         * 
         * @access  public
         * @param   String content
         * @return  Boolean
         */
        copyToClipboard: function(content) {
            if (UserAgentUtils.supports.clipboard.copy() === false) {
                return false;
            }
            var $element = jQuery('<input type="text" />'),
                element = $element[0];
            $(document.body).append($element);
            $element.val(content);
            element.select();
            document.execCommand('copy');
            element.blur();
            $element.remove();
            return true;
        },

        /**
         * cropDataURL
         * 
         * @see     https://stackoverflow.com/questions/34242155/how-to-crop-canvas-todataurl
         * @access  public
         * @param   String dataURL
         * @param   Number width
         * @param   Number height
         * @param   String contentType
         * @param   Function callback
         * @return  void
         */
        cropDataURL: function(dataURL, width, height, contentType, callback) {
            var img = new Image();
            img.onload = function() {
                var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    quality = 1.0;
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
                callback(canvas.toDataURL(contentType, quality));
            };
            img.src = dataURL;
        },

        /**
         * dataURLToBlob
         * 
         * @see     http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
         * @access  public
         * @param   String dataURL
         * @return  Blob
         */
        dataURLToBlob: function(dataURL) {
            var byteString;
            if (dataURL.split(',')[0].indexOf('base64') >= 0) {
                byteString = atob(dataURL.split(',')[1]);
            } else {
                byteString = unescape(dataURL.split(',')[1]);
            }
            var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0],
                ab = new ArrayBuffer(byteString.length),
                ia = new Uint8Array(ab);
            for (var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            try {
                return new Blob([ab], {type: mimeString});
            } catch (e) {
                var BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder,
                    bb = new BlobBuilder();
                bb.append(ab);
                return bb.getBlob(mimeString);
            }
        },

        /**
         * getBypassedDataTransferObject
         * 
         * This is a helper method to get around browser restrictions that
         * prevent having access to the drag-data. I get around this by encoding
         * data as a string, and then accessing it after. The reason I have to
         * look for the term bypass, is because Safari prepends any data in the
         * <types> property with a seemingly-random string. So I search for this.
         * 
         * If I need more context for this while debugging, console.log the type
         * in both Chrome and Safari to see what I mean, and how things work.
         * 
         * It's important to know that due to how JSON encoding works,
         * case-sensitivity is lost. So be sure that any checks against the
         * return-data is done in lowercase.
         * 
         * @see     http://stackoverflow.com/questions/11065803/determine-what-is-being-dragged-from-dragenter-dragover-events
         * @access  public
         * @param   Object dataTransfer
         * @return  false|Object
         */
        getBypassedDataTransferObject: function(dataTransfer) {
            if (DataUtils.valid(dataTransfer) === false) {
                return false;
            }
            if (DataUtils.valid(dataTransfer.types) === false) {
                return false;
            }
            var type, index;
            for (index in dataTransfer.types) {
                type = dataTransfer.types[index];
                if (type.match(/^bypass/) !== null) {
                    return JSON.parse(type.replace(/^bypass/, ''));
                }
            }
            return false;
        },

        /**
         * getDefaultValue
         * 
         * @access  public
         * @param   undefined|mixed value
         * @param   mixed defaultValue
         * @return  mixed
         */
        getDefaultValue: function(value, defaultValue) {
            if (value === undefined) {
                return defaultValue;
            }
            return value;
        },

        /**
         * getItemExtension
         * 
         * @access  public
         * @param   File|Blob item
         * @return  String
         */
        getItemExtension: function(item) {
            var name = item.name,
                extension = name.replace(/^(.+)\.([a-z]{3,4})$/i, '$2').trim().toLowerCase();
            return extension;
        },

        /**
         * getRandomString
         * 
         * @see     http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
         * @access  public
         * @param   Number length (default: 10)
         * @return  String
         */
        getRandomString: function(length) {
            length = DataUtils.getDefaultValue(length, 10);
            var str = '',
                range = '0123456789abcdefghijklmnopqrstuvwxyz',
                i = 0;
            for (i; i < length; i++) {
                str += range.charAt(Math.floor(Math.random() * range.length));
            }
            return str;
        },

        /**
         * getUrlsAsBlobs
         * 
         * @access  public
         * @param   Array urls
         * @param   Function callback
         * @return  void
         */
        getUrlsAsBlobs: function(urls, callback) {
            RequestUtils.ajax({
                signature: {"basename":"DataUtils.js","line":246},
                url: '/utils/proxy',
                data: {
                    urls: urls
                },
                type: 'GET',
                success: function(response) {
                    if (response.success === true) {
                        var blobs = [];
                        for (var index in response.data.files) {
                            var file = response.data.files[index],
                                content = file.content,
                                str = 'data:' + (file.contentType) +
                                    ';base64,' + (file.content),
                                blob = DataUtils.dataURLToBlob(str);
                            blob.name = file.filename;
                            blobs.push(blob);
                        }
                        callback(blobs);
                    } else {
                        callback(false);
                    }
                }
            });
        },

        /**
         * guessItemContentType
         * 
         * @access  public
         * @param   File|Blob item
         * @return  String
         */
        guessItemContentType: function(item) {
            var type = item.type;
            if (type !== '') {
                return type;
            }
            var name = item.name;
            if (name.match(/\.png$/i) !== null) {
                return 'image/png';
            }
            if (name.match(/\.jpg$/i) !== null) {
                return 'image/jpeg';
            }
            if (name.match(/\.jpeg$/i) !== null) {
                return 'image/jpeg';
            }
            if (name.match(/\.gif$/i) !== null) {
                return 'image/gif';
            }
            if (name.match(/\.svg$/i) !== null) {
                return 'image/svg';
            }
            return '';
        },

        /**
         * merge
         * 
         * @access  public
         * @return  Object
         */
        merge: function() {
            var objs = arguments,
                args = [true, {}];
            args = ArrayUtils.merge(args, objs);
            return jQuery.extend.apply(jQuery, args);
        },

        /**
         * photoVendor
         * 
         * @access  public
         * @param   String vendorName
         * @return  Boolean
         */
        photoVendor: function(vendorName) {
            var photoVendorNames = [
                    'Pexels',
                    'Pixabay',
                    'Unsplash'
                ];
            if (ArrayUtils.contains(vendorName, photoVendorNames) === false) {
                return false;
            }
            return true;
        },

        /**
         * render
         * 
         * @see     https://stackoverflow.com/questions/5653207/remove-html-comments-with-regex-in-javascript
         * @access  public
         * @param   String viewName
         * @param   undefined|Object data (default: {})
         * @return  jQuery
         */
        render: function(viewName, data) {
            data = DataUtils.getDefaultValue(data, {});
            var $script = $('script[name="' + (viewName) + '"]'),
                markup = $script.html(),
                compiler = _.template(markup),
                rendered = compiler(data).trim(),
                parsed = jQuery.parseHTML(rendered),
                $element = $(parsed);
            return $element;
        },

        /**
         * requestMediaObject
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  Boolean
         */
        requestMediaObject: function(key, callback) {
            var accessor = Stencil.getAccessor(key);
            if (accessor !== false) {
                callback.apply(this, [accessor]);
                return false;
            }
            var model = Stencil.getModel('Media');
            model.read(key, (function(data) {
                var accessor = model.setAccessor(data.object);
                callback.apply(this, [accessor]);
            }).proxy(this));
            return true;
        },

        /**
         * resizeDataURL
         * 
         * @see     http://stackoverflow.com/questions/20958078/resize-a-base-64-image-in-javascript-without-using-canvas
         * @see     https://stackoverflow.com/questions/23481210/resize-the-canvas-output-image-to-a-specific-size-width-height
         * @access  public
         * @param   String dataURL
         * @param   Number width
         * @param   Number height
         * @param   String contentType
         * @param   Function callback
         * @return  void
         */
        resizeDataURL: function(dataURL, width, height, contentType, callback) {
            var img = document.createElement('img');
            img.onload = function() {
                var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(this, 0, 0, width, height);
                callback(canvas.toDataURL(contentType, 1.0));
            };
            img.src = dataURL;
        },

        /**
         * valid
         * 
         * @access  public
         * @param   mixed value
         * @return  Boolean
         */
        valid: function(value) {
            if (value === undefined) {
                return false;
            }
            if (value === null) {
                return false;
            }
            return true;
        }
    };
})();

/**
 * DownloadUtils
 * 
 * @abstract
 */
window.DownloadUtils = (function() {

    /**
     * __openWindow
     * 
     * Returns whether or not a download redirect should be accomplished by
     * opening a new window. At the moment, this is limited to user agents that
     * are experience Stencil via a browser extension, and they're on a host
     * that has a content security policy that blocks downloads.
     * 
     * @access  private
     * @return  Boolean
     */
    var __openWindow = function() {
        if (UserAgentUtils.extension() === false) {
            return false;
        }
        if (UserAgentUtils.hasCSP() === false) {
            return false;
        }
        return true;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'DownloadUtils')
     */
    var __string = 'DownloadUtils';

    // Public
    return {

        /**
         * attemptDownload
         * 
         * @access  public
         * @param   String path
         * @param   String cookieKey
         * @return  void
         */
        attemptDownload: function(path, cookieKey) {
            var intervals = {},
                checks = {
                    cookie: function() {
                        if (RequestUtils.cookies.get(cookieKey) !== undefined) {
                            IntervalPool.clear(intervals.cookie);
                            RequestUtils.cookies.remove(cookieKey);
                            Stencil.set('redirecting', false);
                            Stencil.triggerHandler('redirect/complete');
                        }
                    },
                    connections: function() {
                        if (XHRPool.length() === 0) {
                            IntervalPool.clear(intervals.connections);
                            Stencil.triggerHandler('redirect/start');
                            Stencil.set('redirecting', true);
                            if (__openWindow() === true) {
                                window.open(path);
                            } else {
                                window.location.assign(path);
                            }
                            intervals.cookie = checks.cookie.interval(50);
                        }
                    }
                };
            intervals.connections = checks.connections.interval(50);
        }
    };
})();

/**
 * DTUtils
 * 
 * @abstract
 */
window.DTUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'DTUtils')
     */
    var __string = 'DTUtils';

    // Public
    return {

        /**
         * getTimestamp
         * 
         * Returns a timestamp Number value, but with the milliseconds appended
         * as decimals. eg 1540750008.501
         * 
         * @access  public
         * @return  Number
         */
        getTimestamp: function() {
            var timestamp = new Date().getTime() / 1000;
            return timestamp;
        },

        /**
         * moment
         * 
         * @access  public
         * @var     Object
         */
        moment: {

            /**
             * calendar
             * 
             * @access  public
             * @param   Number timestamp
             * @return  String
             */
            calendar: function(timestamp) {
                timestamp = timestamp.toInt();
                timestamp = timestamp * 1000;
                var formatted = moment(timestamp).calendar();
                return formatted;
            }
        },

        /**
         * setup
         * 
         * @access  public
         * @var     Object
         */
        setup: {

            /**
             * moment
             * 
             * @access  public
             * @return  void
             */
            moment: function() {
                moment.locale('en', {
                    calendar: {
                        lastDay: '[Yday @] LT',
                        sameDay: '[Today @] LT',
                        nextDay: '[Tomorrow @] LT',
                        lastWeek: 'ddd [@] LT',
                        nextWeek: 'ddd [@] LT',
                        sameElse: 'L @ LT'
                    }
                });
            }
        },

        /**
         * timestampWithin
         * 
         * @access  public
         * @param   Number earlierTimestamp
         * @param   Number laterTimestamp
         * @param   Number range
         * @return  Boolean
         */
        timestampWithin: function(earlierTimestamp, laterTimestamp, range) {
            var timestampWithin = (laterTimestamp - earlierTimestamp) <= range;
            return timestampWithin;
        }
    };
})();

/**
 * ElectronUtils
 * 
 * @abstract
 */
window.ElectronUtils = (function() {

    /**
     * __getRandomString
     * 
     * @access  private
     * @return  String
     */
    var __getRandomString = function() {
        return DataUtils.getRandomString();
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ElectronUtils')
     */
    var __string = 'ElectronUtils';

    // Public
    return {

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  Promise
         */
        get: function(key) {
            return new Promise(function(resolve, reject) {
                var signature = __getRandomString(),
                    requestObj = {
                        action: 'get',
                        key: key,
                        signature: signature
                    };
                if (StringUtils.validObject('window.electron') === true) {
                    window.electron.ipcRenderer.once(function(obj) {
                        if (obj.requestObj.signature === requestObj.signature) {
                            if (obj.success === true) {
                                resolve(obj.data);
                            } else {
                                var msg = obj.errors[0].message,
                                    err = new Error(msg);
                                reject(err);
                            }
                        }
                    });
                    window.electron.ipcRenderer.send(requestObj);
                } else {
                    var msg = 'window.electron is not valid',
                        err = new Error(msg);
                    reject(err);
                }
            });
        }
    };
})();

/**
 * ElementUtils
 * 
 * @abstract
 */
window.ElementUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ElementUtils')
     */
    var __string = 'ElementUtils';

    // Public
    return {

        /**
         * clearSelectedText
         * 
         * @see     http://stackoverflow.com/questions/6562727/is-there-a-function-to-deselect-all-text-using-javascript
         * @access  public
         * @return  void
         */
        clearSelectedText: function() {
            window.getSelection().removeAllRanges();
        },

        /**
         * changeTooltip
         * 
         * @access  public
         * @param   jQuery $element
         * @param   String content
         * @return  void
         */
        changeTooltip: function($element, content) {
            var originalContent = $element.attr('data-original-title'),
                $tip = $element.data('bs.tooltip').$tip;
            $element.attr('data-original-title', content);
            $element.tooltip('show');
            $tip.removeClass('fade');
            $element.one({
                'hidden.bs.tooltip': function(event) {
                    $element.attr('data-original-title', originalContent);
                }
            });
        },

        /**
         * getFormData
         * 
         * @access  public
         * @param   jQuery $form
         * @param   Boolean cleanNames (default: true)
         * @return  Object
         */
        getFormData: function($form, cleanNames) {
            cleanNames = DataUtils.getDefaultValue(cleanNames, true);
            var serializedObject = $form.serializeObject(),
                index,
                key;
            if (cleanNames === false) {
                return serializedObject;
            }
            for (index in serializedObject) {
                key = index.replace(/^data\[(.+)\]$/, '$1');
                serializedObject[key] = serializedObject[index];
                delete serializedObject[index];
            }
            return serializedObject;
        },

        /**
         * select
         * 
         * @access  public
         * @param   jQuery $element
         * @return  void
         */
        select: function($element) {
            (function() {
                $element.select();
            }).delay(0);
        },

        /**
         * nonTabletAutoFocus
         * 
         * @access  public
         * @param   jQuery $element
         * @return  Boolean
         */
        nonTabletAutoFocus: function($element) {
            if (UserAgentUtils.is.tablet() === true) {
                return false;
            }
            $element.focusable().focus();
            return true;
        }
    };
})();

/**
 * ExchangeTokenUtils
 * 
 * @abstract
 */
window.ExchangeTokenUtils = (function() {

    /**
     * __storage
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __storage = {};

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ExchangeTokenUtils')
     */
    var __string = 'ExchangeTokenUtils';

    // Public
    return {

        /**
         * retrieve
         * 
         * @access  public
         * @param   String token
         * @return  mixed
         */
        retrieve: function(token) {
            var value = __storage[token];
            return value;
        },

        /**
         * store
         * 
         * @access  public
         * @param   mixed value
         * @return  String
         */
        store: function(value) {
            var key = DataUtils.getRandomString();
            key = key.toLowerCase();
            __storage[key] = value;
            return key;
        }
    };
})();

/**
 * ImageStateUtils
 * 
 * @note    JSONUtils.parse is used to prevent unintentionally attempting to
 *          parse JSON that is invalid, which in some cases looked to be an
 *          empty string. I believe this is due to images have a default value
 *          of an empty string for setting.json and setting.watermarks. See
 *          images.inc.php for details on those cases.
 * @abstract
 */
window.ImageStateUtils = (function() {

    /**
     * __expandJsonProperties
     * 
     * Loops over object properties, recursively, and if valid JSON is found,
     * expands that out so that the comparison can be accurately made.
     * 
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __expandJsonProperties = function(obj) {
        for (var index in obj) {
            if (typeof obj[index] === 'object') {
                __expandJsonProperties(obj[index]);
            }
            if (JSONUtils.valid(obj[index]) === true) {
                obj[index] = JSON.parse(obj[index]);
            }
        }
    };

    /**
     * __format
     * 
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __format = function(obj) {
        __normalizeLayers(obj);
        __removeFalsePositiveProperties(obj);
        __expandJsonProperties(obj);
    };

    /**
     * __getBackgroundBitmapImageLayer
     * 
     * @note    Null is returned if a backgroundBitmapImage layer could not be
     *          found, which at the moment, I don't fully understand how that's
     *          possible.
     * @access  private
     * @param   String json
     * @return  Object
     */
    var __getBackgroundBitmapImageLayer = function(json) {
        var parsed = JSONUtils.parse(json),
            layers = [],
            layer,
            index,
            backgroundBitmapImage = null;
        if (parsed !== null) {
            layers = parsed.layers;
        }
        for (index in layers) {
            layer = layers[index];
            if (layer.type === 'image') {
                if (layer.background === true) {
                    backgroundBitmapImage = layer;
                    break;
                }
            }
        }
        return {
            all: layers,
            backgroundBitmapImage: backgroundBitmapImage
        };
    };

    /**
     * __getForegroundVectorLayers
     * 
     * @access  private
     * @param   String json
     * @return  Object
     */
    var __getForegroundVectorLayers = function(json) {
        var parsed = JSONUtils.parse(json),
            layers = [],
            layer,
            index,
            vectors = [];
        if (parsed !== null) {
            layers = parsed.layers;
        }
        for (index in layers) {
            layer = layers[index];
            if (layer.type === 'image') {
                if (layer.vector === true) {
                    vectors.push(layer);
                }
            }
        }
        return {
            all: layers,
            vectors: vectors
        };
    };

    /**
     * __getWatermarkLayers
     * 
     * @note    The layers check below is done because this method can be called
     *          from an object that has a layers sub-property, as well as just
     *          an array of watermarks. I'm not positive on the exact context.
     * @see     https://i.imgur.com/7sYVjLQ.jpg
     * @access  private
     * @param   String json
     * @return  Array
     */
    var __getWatermarkLayers = function(json) {
        if (json === '') {
            return [];
        }
        if (DataUtils.valid(json) === false) {
            return [];
        }
        if (JSONUtils.valid(json) === false) {
            return [];
        }
        var parsed = JSON.parse(json);
        if (parsed.layers === undefined) {
            return parsed;
        }
        return parsed.layers;
    };

    /**
     * __match
     * 
     * Using the Underscore.js isEqual function because it takes care of
     * recursively checking properties for matches, regardless of the order of
     * those properties within the comparitive objects.
     * 
     * @see     https://underscorejs.org/#isEqual
     * @access  private
     * @param   Object first
     * @param   Object second
     * @param   Boolean log
     * @return  Boolean
     */
    var __match = function(first, second, log) {
        if (log === true) {
            LogUtils.log.simple('Pre-format', true);
            LogUtils.log.simple(JSON.stringify(first), true);
            LogUtils.log.simple(JSON.stringify(second), true);
            LogUtils.log.time();
        }
        __format(first);
        __format(second);
        if (log === true) {
            LogUtils.log.time();
            LogUtils.log.simple('Post-format', true);
            LogUtils.log.simple(JSON.stringify(first), true);
            LogUtils.log.simple(JSON.stringify(second), true);
        }
        var match = _.isEqual(first, second);
        return match;
    };

    /**
     * __normalizeBackgroundBitmapImageLayer
     * 
     * @note    False is returned if a backgroundBitmapImage layer could not be
     *          found, which at the moment, I don't fully understand how that's
     *          possible.
     * @access  private
     * @param   Object obj
     * @return  Boolean
     */
    var __normalizeBackgroundBitmapImageLayer = function(obj) {
        var json = obj.settings.json,
            response = __getBackgroundBitmapImageLayer(json),
            all = response.all,
            backgroundBitmapImage = response.backgroundBitmapImage;
        if (backgroundBitmapImage === null) {
            return false;
        }

        // Filters
        if (backgroundBitmapImage.filters !== undefined) {
            var index,
                filter;
            for (index in backgroundBitmapImage.filters) {
                filter = backgroundBitmapImage.filters[index];
                if (typeof filter === 'string') {
                    backgroundBitmapImage.filters[index] = {
                        type: filter,
                        properties: {}
                    };
                } else {
                    var properties = filter.properties;
                    if (DataUtils.valid(properties) === false) {
                        properties = {};
                    }
                    backgroundBitmapImage.filters[index] = {
                        type: filter.type,
                        properties: properties
                    };
                }
            }
        }

        // Zoom
        if (backgroundBitmapImage.styles.zoom === undefined) {
            backgroundBitmapImage.styles.zoom = 1;
        }

        // Finished
        obj.settings.json = JSON.stringify({
            layers: all
        });
        return true;
    };

    /**
     * __normalizeForegroundVectorLayers
     * 
     * @see     https://i.imgur.com/XZcco5Q.png
     *          https://i.imgur.com/4SEUkuj.png
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __normalizeForegroundVectorLayers = function(obj) {
        var json = obj.settings.json,
            response = __getForegroundVectorLayers(json),
            all = response.all,
            vectors = response.vectors,
            index,
            vector;
        for (index in vectors) {
            layer = vectors[index];
            if (layer.color === undefined) {
                layer.color = false;
            }
            if (layer.filters === undefined) {
                layer.filters = [];
            }
        }
        obj.settings.json = JSON.stringify({
            layers: all
        });
    };

    /**
     * __normalizeLayers
     * 
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __normalizeLayers = function(obj) {
        __normalizeBackgroundBitmapImageLayer(obj);
        __normalizeForegroundVectorLayers(obj);
        __normalizeWatermarkLayers(obj);
    };

    /**
     * __normalizeWatermarkLayers
     * 
     * @see     https://i.imgur.com/ukg9etg.png
     *          https://i.imgur.com/agqKo1t.png
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __normalizeWatermarkLayers = function(obj) {
        var json = obj.settings.watermarks,
            watermarks = __getWatermarkLayers(json),
            index,
            watermark;
        for (index in watermarks) {
            watermark = watermarks[index];
            delete watermark.locked;
            if (watermark.vector === undefined) {
                watermark.vector = false;
            }
            if (watermark.color === undefined) {
                watermark.color = false;
            }
            if (watermark.cropSourceKey === undefined) {
                watermark.cropSourceKey = '';
            }
            if (watermark.filters === undefined) {
                watermark.filters = [];
            }
        }
        obj.settings.watermarks = JSON.stringify(watermarks);
    };

    /**
     * __removeFalsePositiveProperties
     * 
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __removeFalsePositiveProperties = function(obj) {
        __removeFrame(obj);
        __removeSourceImageId(obj);
    };

    /**
     * __removeFrame
     * 
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __removeFrame = function(obj) {
        delete obj.frame;
    };

    /**
     * __removeSourceImageId
     * 
     * @access  private
     * @param   Object obj
     * @return  void
     */
    var __removeSourceImageId = function(obj) {
        delete obj.sourceImageId;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ImageStateUtils')
     */
    var __string = 'ImageStateUtils';

    // Public
    return {

        /**
         * match
         * 
         * Returns whether two images "match", in the sense that they represent
         * the same rendered Stencil image, regardless (for example) of the
         * order of layer properties.
         * 
         * This became a problem while designing the cropping feature, when I
         * realized that if I make a change to the order of layer properties,
         * the StageFooterView would fail to validate a changeCanvas check
         * properly.
         * 
         * Documentation from StageFooterView:
         * 
         * This validation method is intended to determine whether the draft is
         * different than the source image defined (if any).
         * 
         * If a saved image is defined, it then checks whether it's
         * configuration (which is the same as the draft's source image) is
         * different than the draft. If that check passes, then we return true:
         * the canvas has changed.
         * 
         * Originally, I thought I would have to check 3rd-party resources to
         * see if, for example, a Pixabay:123 resource was in fact the same as a
         * asst123 resource. The concern was that if a user clicks a Pixabay
         * photo, and then saves it right away, when the /save call came back,
         * it would swap out the new draft's image-key property, and thus be
         * seen as different relative to the source image. The reason this is no
         * longer an issue is because the way /save call listeners work, is the
         * source image would have _it's_ image-key property swapped out too. So
         * in fact, the two canvases would be the same from a programmtic/json
         * perspective.
         * 
         * Something that _could_ be done is right now, if you click a Pixabay
         * image, and save it, the resource-hash is replaced with the asset key
         * (via the /save call). But if the user then continues navigating
         * through the search results, if they make their way _back_ to the
         * initial image, it will be seen as different because the asset key and
         * resource-hash do not seem to match up.
         * 
         * While this is an edge-case, it is something that could be
         * improved.
         * 
         * @access  public
         * @param   ImageAccessor first
         * @param   ImageAccessor second
         * @param   undefined|Boolean log (defualt: false)
         * @return  Boolean
         */
        match: function(first, second, log) {
            log = DataUtils.getDefaultValue(log, false);
            var configurations = {
                    first: first.getConfiguration(),
                    second: second.getConfiguration()
                },
                match = __match(
                    configurations.first,
                    configurations.second,
                    log
                );
            return match;
        },

        /**
         * test
         * 
         * @access  public
         * @return  Boolean
         */
        test: function() {
            var draft = Stencil.account().draft(),
                lastSavedImage = Footer.getLastSavedImage(),
                match = ImageStateUtils.match(draft, lastSavedImage, true);
            return match;
// (function() {
//     var check = false;
//     if (Canvases.Ghost.getImage() !== null) {
//         var json = {
//                 draft: Stencil.account().draft().json(),
//                 ghost: Canvases.Ghost.getImage().json()
//             };
//         check = JSON.stringify(json.draft) === JSON.stringify(json.ghost);
//     }
//     console.log(check);
// })();
        }
    };
})();

/**
 * ImageUtils
 * 
 * @see     https://github.com/thumbor/thumbor/wiki/Configuration
 * @see     https://aws.amazon.com/answers/web-applications/serverless-image-handler/
 * @see     https://docs.aws.amazon.com/solutions/latest/serverless-image-handler/welcome.html
 * @abstract
 */
window.ImageUtils = (function() {

    /**
     * __cloudinaryCropperImageQualityValue
     * 
     * @access  private
     * @var     Number (default: 75)
     */
    var __cloudinaryCropperImageQualityValue = 75;

    /**
     * __defaultCropperImageServiceProvider
     * 
     * @access  private
     * @var     String (default: 'cloudinary')
     */
    var __defaultCropperImageServiceProvider = 'cloudinary';

    /**
     * __getCropperImageServiceProvider
     * 
     * Returns the service provider that should be used for cropping, depending
     * on properties of the accessor associated with the key (depending on
     * whether the accessor can be found).
     * 
     * @access  private
     * @param   String key
     * @return  String
     */
    var __getCropperImageServiceProvider = function(key) {
        var accessor = Stencil.getAccessor(key),
            serviceProvider = __defaultCropperImageServiceProvider;
        if (accessor === false) {
            return serviceProvider;
        }
        if (accessor.is.upload.apply(accessor) === true) {
            if (accessor.get('animated').toInt() === 1) {
                return 's3';
            }
        }
        var contentType = accessor.get('contentType');
        if (contentType === 'image/jpeg') {
            var thumborMaxImagePixels = __getThumborMaxImagePixels(),
                resolution = accessor.getResolution();
            if (resolution === null) {
                return 'cloudinary';
            }
            if (resolution < thumborMaxImagePixels) {
                return 'thumbor';
            }
        }
        return serviceProvider;
    };

    /**
     * __getThumborMaxImagePixels
     * 
     * @access  private
     * @return  Number
     */
    var __getThumborMaxImagePixels = function() {
        var thumborMaxImagePixels = Config.default('thumborMaxImagePixels').toInt();
        return thumborMaxImagePixels;
    };

    /**
     * __loadPaths
     * 
     * @access  private
     * @param   Array paths
     * @param   Boolean crossOrigin
     * @param   Function success
     * @param   Function error
     * @return  void
     */
    var __loadPaths = function(paths, crossOrigin, success, error) {
        var index, path, url, urls = [];
        for (index in paths) {
            path = paths[index];
            url = RequestUtils.url.static(path);
            urls.push(url);
        }
        __loadUrls(urls, crossOrigin, success, error);
    };

    /**
     * __loadUrls
     * 
     * @access  private
     * @param   Array urls
     * @param   Boolean crossOrigin
     * @param   Function success
     * @param   Function error
     * @param   undefined|Array references (default: [])
     * @return  Boolean
     */
    var __loadUrls = function(urls, crossOrigin, success, error, references) {
        references = DataUtils.getDefaultValue(references, []);

        // All done
        if (urls.length === 0) {
            var args = [references];
            success.apply(ImageUtils, args);
            return true;
        }

        // Request url
        urls = ArrayUtils.clone(urls);
        var url = urls.shift(),
            imageRequest = new ImageRequest(url, crossOrigin),
            image = imageRequest.getImage();
        references.push(image);
        imageRequest.once({
            'error': function(event, reference) {
                var args = [reference];
                error.apply(ImageUtils, args);
            },
            'load': function(event, reference) {
                __loadUrls(urls, crossOrigin, success, error, references);
            }
        });
        imageRequest.request();
        return true;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ImageUtils')
     */
    var __string = 'ImageUtils';

    /**
     * __thumborCropperImageQualityValue
     * 
     * @access  private
     * @var     Number (default: 50)
     */
    var __thumborCropperImageQualityValue = 50;

    /**
     * __thumborQualityValue
     * 
     * @access  private
     * @var     Number (default: 80)
     */
    var __thumborQualityValue = 80;

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * applyCropTransformation
         * 
         * @access  public
         * @param   String url
         * @param   Object cropPositionData
         * @return  String
         */
        applyCropTransformation: function(url, cropPositionData) {

            // Invalid position data
            if (cropPositionData === undefined) {
                return url;
            }
            if (cropPositionData.x === undefined) {
                return url;
            }

            // Crop
            var transformations = [];
            transformations.push(
                'x_' + (cropPositionData.x).toInt() +
                ',y_' + (cropPositionData.y).toInt() +
                ',w_' + (cropPositionData.width).toInt() +
                ',h_' + (cropPositionData.height).toInt() +
                ',c_crop'
            );

            // Mask
            if (cropPositionData.shape === 'mask') {
                var maskKey =cropPositionData.maskKey,
                    mask = ImageUtils.getCropperMaskByKey(maskKey);
                if (mask !== null) {
                    var objectKey = mask.objectKey,
                        proxy = mask.proxy,
                        maskObjectKey = (proxy) + '/' + (objectKey);
                    maskObjectKey = maskObjectKey.replace('/', ':', maskObjectKey);
                    var pieces = [
                            'l_' + (maskObjectKey),
                            'fl_cutter.relative',
                            'w_1.0',
                            'h_1.0'
                        ],
                        transformation = pieces.join(',');
                    transformations.push(transformation);
                }
            }

            // Radius
            if (cropPositionData.styles.radius === '100000px') {
                transformations.push('r_100000');
            } else if (cropPositionData.styles.radius === '50%') {
                transformations.push('r_max');
            }

            // Format
            if (cropPositionData.styles.radius === '100000px') {
                transformations.push('f_png');
            } else if (cropPositionData.styles.radius === '50%') {
                transformations.push('f_png');
            } else if (cropPositionData.shape === 'mask') {
                transformations.push('f_png');
            }

            // Apply
            var transformation = '/image/upload';
            transformation += '/' + (transformations.join('/'));
            url = url.replace(/\/image\/upload/, transformation);
            return url;
        },

        /**
         * getCropperBoundingBoxImageUrl
         * 
         * Returns the url that should be used when requesting the bounding box
         * for an image url. This is different than getCropperImageUrl, in that
         * an s3 url may be returned from this method (to ensure animated gifs
         * return the proper bounding box data), whereas an s3 url should likely
         * not be used on the front end.
         * 
         * @access  public
         * @param   String key
         * @return  String
         */
        getCropperBoundingBoxImageUrl: function(key) {
            var provider = __getCropperImageServiceProvider(key);
            if (provider === 's3') {
                var url = RequestUtils.url.s3(key);
                return url;
            }
            var url = ImageUtils.getCropperImageUrl(key);
            return url;
        },

        /**
         * getCropperImageUrl
         * 
         * Returns the url that should be used within the cropper when
         * attempting to crop an image.
         * 
         * @throws  Error
         * @note    Quality argument used to lower payload size. In example
         *          image, was able to lower from 7.2mb to 563kb
         * @see     https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/s3.local/upldmkzdychn
         * @see     https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/q_75/s3.local/upldmkzdychn
         * @see     https://cloudinary.com/documentation/image_transformations#adjusting_image_quality
         * @access  public
         * @param   String key
         * @return  String
         */
        getCropperImageUrl: function(key) {
            var provider = __getCropperImageServiceProvider(key);
            if (provider === 'cloudinary') {
                var url = ImageUtils.url.cloudinary(key, {
                    type: 'simple',
                    quality: __cloudinaryCropperImageQualityValue
                });
                return url;
            }
            if (provider === 's3') {
                var url = ImageUtils.url.cloudinary(key, {
                    type: 'simple',
                    quality: __cloudinaryCropperImageQualityValue
                });
                return url;
            }
            if (provider === 'thumbor') {
                var url = ImageUtils.url.thumbor(key, {
                    type: 'simple',
                    quality: __thumborCropperImageQualityValue
                });
                return url;
            }
            var msg = 'Invalid service request';
            throw new Error(msg);
        },

        /**
         * getCropperMaskByKey
         * 
         * @access  public
         * @param   String key
         * @return  Object|null
         */
        getCropperMaskByKey: function(key) {
            var masks = Config.default('cropperMasks'),
                index,
                mask;
            for (index in masks) {
                mask = masks[index];
                if (mask.key === key) {
                    return mask;
                }
            }
            return null;
        },

        /**
         * getFrameUrl
         * 
         * Returns an image (referenced by passed in parameter) that perfectly
         * fits the canvas by using Cloudinary's new API feature to dynamically
         * resize image to a minimum width or height depending on the aspect
         * ratio of the original image compared to the aspect ratio of the
         * selected Frame).
         * 
         * If you need to revert, see the following commit:
         * dacd90d55129ea8017bfe76abb58fbb6631ebc31
         * 
         * @access  public
         * @param   String key
         * @param   CanvasView canvas
         * @return  String
         */
        getFrameUrl: function(key, canvas) {
            var ratio = UserAgentUtils.getDevicePixelRatio(),
                dimensions = canvas.getRenderedDimensions(),
                width = dimensions.width.ceil(),
                height = dimensions.height.ceil(),
                url;
            width *= ratio;
            height *= ratio;
            url = ImageUtils.url.thumb(key, {
                type: 'minimum',
                ratio: Frame.getRatio().round(1),
                width: width.round(0),
                height: height.round(0)
            });
            return url;
        },

        /**
         * getRandomSadFaceFontClass
         * 
         * @access  public
         * @return  String
         */
        getRandomSadFaceFontClass: function() {
            var classes = [
                    'sif-emoji-sad',
                    'sif-emoji-sad-2',
                    'sif-emoji-sad-3',
                    'sif-emoji-sad-4',
                    'sif-emoji-sad-5',
                    'sif-emoji-sad-6'
                ],
                fontClass = ArrayUtils.random(classes);
            return fontClass;
        },

        /**
         * getThumbDimensions
         * 
         * Dumb logic which assumes that if the device pixel ratio is not equal
         * to 1, then it's a retina monitor and the thumb size should be twice
         * as large.
         * 
         * Obviously quite flawed, since people can zoom in/out, and there are
         * now screens that have device pixel ratios of 3 or greater. But it
         * works for the most part.
         * 
         * The intention of this is to speed up requests, and lower memory, for
         * devices that don't require retina-sized images.
         * 
         * @see     https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/if_ar_gt_1.0,h_146,c_scale/if_else,w_100,c_scale/s3.local/asst2acf2efd
         * @access  public
         * @return  Object
         */
        getThumbDimensions: function() {
            var dimensions = {
                width: 304,
                height: 212
            };
            if (UserAgentUtils.getDevicePixelRatio() === 1) {
                dimensions = {
                    width: 152,
                    height: 106
                };
            }
            return dimensions;
        },

        /**
         * load
         * 
         * @access  public
         * @var     Object
         */
        load: {

            /**
             * path
             * 
             * @access  public
             * @param   String path
             * @param   Boolean crossOrigin (default: false)
             * @param   undefined|Function success (default: function(reference) {})
             * @param   undefined|Function error (default: function(reference) {})
             * @return  void
             */
            path: function(path, crossOrigin, success, error) {
                crossOrigin = DataUtils.getDefaultValue(crossOrigin, false);
                success = DataUtils.getDefaultValue(success, function(reference) {});
                error = DataUtils.getDefaultValue(error, function(reference) {});
                var paths = [path];
                ImageUtils.load.paths(paths, crossOrigin, function(references) {
                    var reference = references[0],
                        args = [reference];
                    success.apply(ImageUtils, args);
                });
            },

            /**
             * paths
             * 
             * @access  public
             * @param   Array paths
             * @param   Boolean crossOrigin (default: false)
             * @param   undefined|Function success (default: function(references) {})
             * @param   undefined|Function error (default: function(reference) {})
             * @return  void
             */
            paths: function(paths, crossOrigin, success, error) {
                crossOrigin = DataUtils.getDefaultValue(crossOrigin, false);
                success = DataUtils.getDefaultValue(success, function(references) {});
                error = DataUtils.getDefaultValue(error, function(reference) {});
                __loadPaths(paths, crossOrigin, success, error);
            },

            /**
             * url
             * 
             * @access  public
             * @param   String url
             * @param   Boolean crossOrigin (default: false)
             * @param   undefined|Function success (default: function(reference) {})
             * @param   undefined|Function error (default: function(reference) {})
             * @return  void
             */
            url: function(url, crossOrigin, success, error) {
                crossOrigin = DataUtils.getDefaultValue(crossOrigin, false);
                success = DataUtils.getDefaultValue(success, function(reference) {});
                error = DataUtils.getDefaultValue(error, function(reference) {});
                var urls = [url];
                ImageUtils.load.urls(urls, crossOrigin, function(references) {
                    var reference = references[0],
                        args = [reference];
                    success.apply(ImageUtils, args);
                }, error);
            },

            /**
             * urls
             * 
             * @access  public
             * @param   Array urls
             * @param   Boolean crossOrigin (default: false)
             * @param   undefined|Function success (default: function(references) {})
             * @param   undefined|Function error (default: function(reference) {})
             * @return  void
             */
            urls: function(urls, crossOrigin, success, error) {
                crossOrigin = DataUtils.getDefaultValue(crossOrigin, false);
                success = DataUtils.getDefaultValue(success, function(references) {});
                error = DataUtils.getDefaultValue(error, function(reference) {});
                __loadUrls(urls, crossOrigin, success, error);
            }
        },

        /**
         * url
         * 
         * @access  public
         * @var     Object
         */
        url: {

            /**
             * cloudinary
             * 
             * @access  public
             * @param   String key
             * @param   Object options
             * @return  String|false
             */
            cloudinary: function(key, options) {

                /**
                 * Thumbs used in the editor.
                 * 
                 */
                if (options.type === 'thumb') {
                    var thumbDimensions = ImageUtils.getThumbDimensions(),
                        width = thumbDimensions.width,
                        height = thumbDimensions.height,
                        proxy = options.proxy || 'stencil',
                        url = ImageUtils.url.cloudinary(key, {
                            proxy: proxy,
                            type: 'minimum',
                            ratio: '1.0',
                            width: width,
                            height: height
                        });
                    return url;
                }

                // Set up CloudinaryReqeustClientWrapper object
                var request = new CloudinaryRequestClientWrapper(),
                    proxyKey = options.proxy || 'stencil',
                    quality = options.quality || null;
                request.setObjectKey(key);
                request.setProxy(proxyKey);
                request.setQuality(quality);

                /**
                 * Routes the resource through Cloudinary.
                 * 
                 */
                if (options.type === 'simple') {
                    var url = request.getUrl();
                    return url;
                }

                /**
                 * Uses Cloudinary's new conditioning to return an image of
                 * minimum width or height depending on the aspect ratio of the
                 * original image, compared to the option which is passed in.
                 * Used very conveniently to compare against the selected
                 * Frame's aspect ratio.
                 */
                if (options.type === 'minimum') {
                    var ratio = options.ratio || '1.0';
                    request.if('ar', 'gt', ratio).then(function() {
                        request.scaleHeight(options.height);
                    });
                    request.else().then(function() {
                        request.scaleWidth(options.width);
                    });
                    var url = request.getUrl();
                    return url;
                }

                /**
                 * Scales the image to a specific width or height, depending on
                 * which dimension type is passed in. Both can't be passed in.
                 */
                if (options.type === 'scale') {
                    if (options.width !== undefined) {
                        request.width(options.width);
                        var url = request.getUrl();
                        return url;
                    }
                    if (options.height !== undefined) {
                        request.height(options.height);
                        var url = request.getUrl();
                        return url;
                    }
                    return false;
                }

                // Oh ho!
                return false;
            },

            /**
             * thumb
             * 
             * @note    thumborSafeMode is a config variable to ensure that
             *          requests are only routed through the Thumbor service
             *          when specific criteria are met (eg. jpeg, not too big,
             *          etc).
             * @access  public
             * @param   String key
             * @param   Object options
             * @return  String|false
             */
            thumb: function(key, options) {

                /**
                 * Routes the image through CloudFront. Currently only being
                 * used by vectors (since Cloudinary does not process vectors
                 * well), and for legacy image uploads, when clicked, to
                 * determine their width/height and save it to the db.
                 */
                if (options.type === 'original') {
                    var url = RequestUtils.url.cloudFront(key);
                    return url;
                }

                /**
                 * Cloudinary
                 * 
                 */
                var thumbService = Config.default('thumbService');
                if (thumbService === 'cloudinary') {
                    var url = ImageUtils.url.cloudinary(key, options);
                    return url;
                }

                /**
                 * Thumbor
                 * 
                 */
                var thumborSafeMode = Config.default('thumborSafeMode');
                if (thumborSafeMode === false) {
                    var url = ImageUtils.url.thumbor(key, options);
                    return url;
                }

                /**
                 * Cloudinary fallback (can't access properties)
                 * 
                 */
                var accessor = Stencil.getAccessor(key);
                if (accessor === false) {
                    var url = ImageUtils.url.cloudinary(key, options);
                    return url;
                }

                /**
                 * Thumbor Safe Mode
                 * 
                 */

                // Only use Thumbor if it's a jpeg (png/gifs are a bit bunk atm)
                var contentType = accessor.get('contentType');
                if (contentType !== 'image/jpeg') {
                    var url = ImageUtils.url.cloudinary(key, options);
                    return url;
                }

                // Check types
                var thumborMaxImagePixels = __getThumborMaxImagePixels(),
                    resolution = accessor.getResolution();
                if (options.type === 'thumb') {
                    if (resolution === null) {
                        var url = ImageUtils.url.cloudinary(key, options);
                        return url;
                    }
                    if (resolution < thumborMaxImagePixels) {
                        if (options.useCloudinary !== true) {
                            var url = ImageUtils.url.thumbor(key, options);
                            return url;
                        }
                    }
                    var url = ImageUtils.url.cloudinary(key, options);
                    return url;
                }

                // Images
                // if (key.match(/^img0/) !== null) {
                //     if (resolution === null) {
                //         return ImageUtils.url.cloudinary(key, options);
                //     }
                //     // if (resolution < thumborMaxImagePixels) {
                //     //     return ImageUtils.url.thumbor(key, options);
                //     // }
                //     return ImageUtils.url.cloudinary(key, options);
                // }

                /**
                 * Cloudinary fallback
                 * 
                 */
                var url = ImageUtils.url.cloudinary(key, options);
                return url;
            },

            /**
             * thumbor
             * 
             * @access  public
             * @param   String key
             * @param   Object options
             * @return  String|false
             */
            thumbor: function(key, options) {

                // Set up ThumborRequestClientWrapper object
                var request = new ThumborRequestClientWrapper(),
                    distributionKey = options.proxy || 'stencil',
                    quality = options.quality || __thumborQualityValue;
                request.setHost(distributionKey);
                request.setObjectKey(key);
                request.setQuality(quality);

                /**
                 * Thumbs used in the editor.
                 * 
                 */
                if (options.type === 'thumb') {
                    var thumbDimensions = ImageUtils.getThumbDimensions(),
                        width = thumbDimensions.width,
                        height = thumbDimensions.height;
                    request.fullFit(width, height);
                    var url = request.getUrl();
                    return url;
                }

                /**
                 * Routes the directly resource through Thumbor.
                 * 
                 */
                if (options.type === 'simple') {
                    var url = request.getUrl();
                    return url;
                }

                /**
                 * Used very conveniently to compare against the selected
                 * Frame's aspect ratio.
                 */
                if (options.type === 'minimum') {
                    request.fullFit(options.width, options.height);
                    var url = request.getUrl();
                    return url;
                }

                /**
                 * Scales the image to a specific width or height, depending on
                 * which dimension type is passed in. Both can't be passed in.
                 */
                if (options.type === 'scale') {
                    if (options.width !== undefined) {
                        request.width(options.width);
                        var url = request.getUrl();
                        return url;
                    }
                    if (options.height !== undefined) {
                        request.height(options.height);
                        var url = request.getUrl();
                        return url;
                    }
                }
                return false;
            }
        }
    });
})();

/**
 * JSONUtils
 * 
 * @abstract
 */
window.JSONUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'JSONUtils')
     */
    var __string = 'JSONUtils';

    // Public
    return {

        /**
         * parse
         * 
         * @access  public
         * @param   String str
         * @return  null|String
         */
        parse: function(str) {
            if (JSONUtils.valid(str) === false) {
                return null;
            }
            var parsed = JSON.parse(str);
            return parsed;
        },

        /**
         * valid
         * 
         * @access  public
         * @param   String str
         * @return  Boolean
         */
        valid: function(str) {
            try {
                JSON.parse(str);
                return true;
            } catch(e) {}
            return false;
        }
    };
})();

/**
 * LogUtils
 * 
 * Notice that I check for alwaysLog first. This is partially to
 * accommodate the case where a call to /import fails. In that case,
 * it is likely that the config file will not be availble, and thus
 * the next check will fail. This should probably be more elegant.
 * 
 * @abstract
 */
window.LogUtils = (function() {

    /**
     * __colors
     * 
     * @see     http://www.w3schools.com/cssref/css_colornames.asp
     * @access  private
     * @var     Object
     */
    var __colors = {
        'classTypes' : {
            'accessor':             'orange',
            'account':              'green',
            'baseClientWrapper':    'dodgerblue',
            'collection':           'red',
            'drawing':              'blueviolet',
            'layer':                'cadetblue',
            'model':                'brown',
            'router':               'purple',
            'stencil':              'chocolate',
            'user':                 'darkolivegreen',
            'view':                 'blue'
        },
        'simple':   'crimson'
    };

    /**
     * __counter
     * 
     * @access  private
     * @var     Number (default: 0)
     */
    var __counter = 0;

    /**
     * __format
     * 
     * @access  private
     * @param   mixed msg
     * @param   String type
     * @param   String label
     * @return  Array
     */
    var __format = function(msg, type, label) {
        var color = __getColor(type),
            timestamp = __getTimestamp(),
            msgs = [];
        msgs.push('%c' + (timestamp) + '  ' + (label));
        msgs.push('color:' + (color) + ';');
        msgs.push(msg);
        return msgs;
    };

    /**
     * __getColor
     * 
     * @access  private
     * @param   String type
     * @return  String
     */
    var __getColor = function(type) {
        if (__colors.classTypes[type] !== undefined) {
            var color = __colors.classTypes[type];
            return color;
        }
        var color = __colors.simple;
        return color;
    };

    /**
     * __getTimestamp
     * 
     * Returns a string which represents the timestamp, up to the microsecond.
     * 
     * @access  private
     * @return  String
     */
    var __getTimestamp = function() {
        var timestamp = moment().format('HH:mm:ss (0.SSSS)');
        return timestamp;
    };

    /**
     * __log
     * 
     * @access  private
     * @return  Boolean
     */
    var __log = function() {
        if (__loggingEnable() === true) {
            return true;
        }
        var account = Stencil.account();
        if (account === undefined) {
            return false;
        }
        if (account.userAccount() === undefined) {
            return false;
        }
        if (account.userAccount().setting('logging').toInt() === 1) {
            return true;
        }
        return false;
    };

    /**
     * __loggingEnable
     * 
     * @access  private
     * @return  Boolean
     */
    var __loggingEnable = function() {
        var ready = Config.ready();
        if (ready === false) {
            return false;
        }
        var enabled = Config.default('logging');
        return enabled;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'LogUtils')
     */
    var __string = 'LogUtils';

    /**
     * __writeToConsole
     * 
     * @access  private
     * @param   Array arr
     * @return  void
     */
    var __writeToConsole = function(arr) {
        if (window.console !== undefined) {
            if (window.console.log !== undefined) {
                window.console.log.apply(window.console, arr);
                ++__counter;
            }
        }
    };

    // Public
    return {

        /**
         * log
         * 
         * @access  public
         * @var     Object
         */
        log: {

            /**
             * object
             * 
             * @access  public
             * @param   Object obj
             * @param   undefined|mixed msg (default: '(no message)')
             * @param   undefined|Boolean override (default: false)
             * @return  void
             */
            object: function(obj, msg, override) {
                msg = DataUtils.getDefaultValue(msg, '(no message)');
                override = DataUtils.getDefaultValue(override, false);
                if (__log() === true || override === true) {
                    var classType = obj.getClassType(),
                        label = obj.toString();
                    msg = __format(msg, classType, label);
                    __writeToConsole(msg);
                }
            },

            /**
             * simple
             * 
             * @access  public
             * @param   undefined|mixed msg (default: '(no message)')
             * @param   undefined|Boolean override (default: false)
             * @return  void
             */
            simple: function(msg, override) {
                msg = DataUtils.getDefaultValue(msg, '(no message)');
                override = DataUtils.getDefaultValue(override, false);
                if (__log() === true || override === true) {
                    msg = __format(msg, 'simple', 'Simple');
                    __writeToConsole(msg);
                }
            },

            /**
             * time
             * 
             * @access  public
             * @return  void
             */
            time: function() {
                var now = new Date().getTime(),
                    msgs = [now];
                __writeToConsole(msgs);
            }
        },

        /**
         * trace
         * 
         * @access  public
         * @return  Boolean
         */
        trace: function() {
            if (DataUtils.valid(window.console) === false) {
                return false;
            }
            if (DataUtils.valid(window.console.trace) === false) {
                return false;
            }
            window.console.trace();
            return true;
        }
    };
})();

/**
 * ModalUtils
 * 
 * Handles modal interaction (opening, closing).
 * 
 * @abstract
 */
window.ModalUtils = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'modalUtils')
     */
    var __classType = 'modalUtils';

    /**
     * __getAdminContentContainer
     * 
     * @access  private
     * @return  jQuery
     */
    var __getAdminContentContainer = function() {
        var $container = App.find('.modal.admin .outer > .inner > .content');
        return $container;
    };

    /**
     * __getAppContentContainer
     * 
     * @access  private
     * @return  jQuery
     */
    var __getAppContentContainer = function() {
        var $container = App.find('> div.content');
        return $container;
    };

    /**
     * __getCheckoutContentContainer
     * 
     * @access  private
     * @return  jQuery
     */
    var __getCheckoutContentContainer = function() {
        var $container = App.find('.modal.checkout .outer > .inner > .content');
        return $container;
    };

    /**
     * __getSettingsContentContainer
     * 
     * @access  private
     * @return  jQuery
     */
    var __getSettingsContentContainer = function() {
        var $container = App.find('.modal.settings .outer > .inner > .content');
        return $container;
    };

    /**
     * __getShareContentContainer
     * 
     * @access  private
     * @return  jQuery
     */
    var __getShareContentContainer = function() {
        var $container = App.find('.modal.share .outer > .inner > .content');
        return $container;
    };

    /**
     * __openModals
     * 
     * @access  private
     * @var     Array (default: [])
     */
    var __openModals = [];

    /**
     * __showAddAdminModal
     * 
     * @access  private
     * @param   String modalName
     * @return  jQuery
     */
    var __showAddAdminModal = function(modalName) {
        var templateName = (modalName) + 'Modal',
            viewName = (modalName) + 'ModalView',
            $modal = DataUtils.render(templateName),
            adminModal = ModalUtils.get('Admin'),
            modal = new window[viewName]($modal, adminModal);
        __openModals.push(modal);
        __getAdminContentContainer().append($modal);
        ElementUtils.nonTabletAutoFocus($modal);
        modal.show();
        return modal;
    };

    /**
     * __showSimpleModal
     * 
     * @access  private
     * @param   String modalName
     * @param   undefined|Object data (default: {})
     * @return  jQuery
     */
    var __showSimpleModal = function(modalName, data) {
        data = DataUtils.getDefaultValue(data, {});
        var templateName = (modalName) + 'Modal',
            viewName = (modalName) + 'ModalView',
            $modal = DataUtils.render(templateName, data),
            modal = new window[viewName]($modal);
        __openModals.push(modal);
        __getAppContentContainer().append($modal);
        // ElementUtils.nonTabletAutoFocus($modal);
        modal.show();
        return modal;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ModalUtils')
     */
    var __string = 'ModalUtils';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * close
         * 
         * Closes all modals that are currently open. Updating of the local
         * __openModals array is done by the Modal close event listener (see
         * Modal.js).
         * 
         * @access  public
         * @return  void
         */
        close: function() {
            $(__openModals).each(
                function(index, modal) {
                    modal.triggerHandler('close');
                }
            );
        },

        /**
         * closeExcept
         * 
         * Initiates a close, but excludes closing certain types of modals (for
         * dependency reasons)
         * 
         * @example ModalUtils.closeExcept(['Share'])
         * @note    Ensure <ModalView> trailing string is not included
         * @access  public
         * @param   Array types
         * @return  void
         */
        closeExcept: function(types) {
            var constructors = [];
            $(types).each(
                function(index, type) {
                    type += 'ModalView';
                    constructors.push(window[type]);
                }
            );
            $(__openModals).each(
                function(index, modal) {
                    if (constructors.indexOf(modal.constructor) === -1) {
                        modal.triggerHandler('close');
                    }
                }
            );
        },

        /**
         * get
         * 
         * @example ModalUtils.get('Share')
         * @note    Ensure <ModalView> trailing string is not included
         * @access  public
         * @param   String type
         * @return  false|ModalView
         */
        get: function(type) {
            type += 'ModalView';
            var modal = false;
            $(__openModals).each(
                function(index, modalView) {
                    if (modalView.constructor === window[type]) {
                        modal = modalView;
                    }
                }
            );
            return modal;
        },

        /**
         * getOpen
         * 
         * Returns a reference to the array containing all the open modals
         * 
         * @access  public
         * @return  Array
         */
        getOpen: function() {
            return __openModals;
        },

        /**
         * showAddCategory
         * 
         * @access  public
         * @return  AddCategoryModalView
         */
        showAddCategory: function() {
            var modalName = 'AddCategory',
                modal = __showAddAdminModal(modalName);
            return modal;
        },

        /**
         * showAddCoupon
         * 
         * @access  public
         * @return  AddCouponModalView
         */
        showAddCoupon: function() {
            var modalName = 'AddCoupon',
                modal = __showAddAdminModal(modalName);
            return modal;
        },

        /**
         * showAddPromoSet
         * 
         * @access  public
         * @return  AddPromoSetModalView
         */
        showAddPromoSet: function() {
            var modalName = 'AddPromoSet',
                modal = __showAddAdminModal(modalName);
            return modal;
        },

        /**
         * showAddVectorSet
         * 
         * @access  public
         * @return  AddVectorSetModalView
         */
        showAddVectorSet: function() {
            var modalName = 'AddVectorSet',
                modal = __showAddAdminModal(modalName);
            return modal;
        },

        /**
         * showAdmin
         * 
         * @access  public
         * @return  AdminModalView
         */
        showAdmin: function() {
            var modalName = 'Admin',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showAlert
         * 
         * @access  public
         * @param   String code
         * @param   Object settings
         * @return  AlertModalView
         */
        showAlert: function(code, settings) {
            var $modal = DataUtils.render('AlertModal', {
                    settings: settings,
                    code: code
                }),
                modal = new AlertModalView($modal, settings);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showApplyCategories
         * 
         * @access  public
         * @param   String type
         * @param   Accessor accessor
         * @return  ApplyCategoriesModalView
         */
        showApplyCategories: function(type, accessor) {
            var $modal = DataUtils.render('ApplyCategoriesModal', {
                    type: type,
                    accessor: accessor
                }),
                modal = new ApplyCategoriesModalView($modal, accessor);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showApplyCoupon
         * 
         * @access  public
         * @param   CheckoutModalView checkoutModal
         * @param   String code
         * @return  ApplyCouponModalView
         */
        showApplyCoupon: function(checkoutModal, code) {
            var $modal = DataUtils.render('ApplyCouponModal', {
                    plan: checkoutModal.getPlan(),
                    code: code || false
                }),
                modal = new ApplyCouponModalView($modal, checkoutModal);
            __openModals.push(modal);
            __getCheckoutContentContainer().append($modal);
            $modal.focusable().focus().select();
            // __getAppContentContainer().append($couponCode);
            modal.show();
            return modal;
        },

        /**
         * showAssetsReimport
         * 
         * @access  public
         * @return  AssetsReimportModalView
         */
        showAssetsReimport: function() {
            var $modal = DataUtils.render('AssetsReimportModal'),
                modal = new AssetsReimportModalView($modal);
            __openModals.push(modal);
            __getAdminContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showBrowser
         * 
         * @access  public
         * @return  BrowserModalView
         */
        showBrowser: function() {
            var modalName = 'Browser',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showCacheRefresh
         * 
         * @access  public
         * @return  CacheRefreshModalView
         */
        showCacheRefresh: function() {
            var $modal = DataUtils.render('CacheRefreshModal'),
                modal = new CacheRefreshModalView($modal);
            __openModals.push(modal);
            __getAdminContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showCancelAccount
         * 
         * @access  public
         * @param   AccountAccessor account
         * @return  CancelAccountModalView
         */
        showCancelAccount: function(account) {
            var $modal = DataUtils.render('CancelAccountModal', {
                    account: account
                }),
                modal = new CancelAccountModalView($modal, account);
            __openModals.push(modal);
            __getAdminContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showCheckout
         * 
         * @access  public
         * @param   String plan
         * @param   String interval
         * @param   String type
         * @return  CheckoutModalView
         */
        showCheckout: function(plan, interval, type) {
            var $modal = DataUtils.render('CheckoutModal', {
                    plan: plan,
                    interval: interval,
                    type: type
                }),
                modal = new CheckoutModalView($modal, plan, interval, type);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showChromeExtensionInstalled
         * 
         * @access  public
         * @return  ChromeExtensionInstalledModalView
         */
        showChromeExtensionInstalled: function() {
            var modalName = 'ChromeExtensionInstalled',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showClearCanvasConfirm
         * 
         * @note    href attribute is needed in order to focus
         * @access  public
         * @param   Object data
         * @return  ClearCanvasConfirmModalView
         */
        showClearCanvasConfirm: function(data) {
            var $modal = DataUtils.render('ClearCanvasConfirmModal', data),
                modal = new ClearCanvasConfirmModalView($modal);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            if (User.admin() === true) {
                var $first = $modal.find('a.button').first();
                $first.attr('href', '#');
                $first.focus();
            }
            modal.show();
            return modal;
        },

        /**
         * showCookies
         * 
         * @access  public
         * @return  CookiesModalView
         */
        showCookies: function() {
            var modalName = 'Cookies',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showConfirm
         * 
         * @note    href attribute is needed in order to focus
         * @access  public
         * @param   Object copy
         * @return  ConfirmModalView
         */
        showConfirm: function(copy) {
            var defaultCopy = {
                yes: 'Yes',
                no: 'No',
                ctaClassName: 'icon sift sift-warning'
            };
            copy = DataUtils.merge(defaultCopy, copy);
            var $modal = DataUtils.render('ConfirmModal', {
                    copy: copy
                }),
                modal = new ConfirmModalView($modal);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            if (User.admin() === true) {
                var $first = $modal.find('a.button').first();
                $first.attr('href', '#');
                $first.focus();
            }
            modal.show();
            return modal;
        },

        /**
         * showConfirmDelete
         * 
         * @access  public
         * @param   String h1
         * @param   undefined|String h2 (default: 'This cannot be undone')
         * @return  ConfirmModalView
         */
        showConfirmDelete: function(h1, h2) {
            h2 = DataUtils.getDefaultValue(h2, 'This cannot be undone');
            var modal = this.showConfirm({
                h1: h1,
                h2: h2
            });
            modal.show();
            return modal;
        },

        /**
         * showConfirmMobile
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  ConfirmMobileModalView
         */
        showConfirmMobile: function(shareModal, image) {
            var $modal = DataUtils.render('ConfirmMobileModal'),
                modal = new ConfirmMobileModalView($modal, shareModal, image);
            __openModals.push(modal);
            __getShareContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showConnections
         * 
         * @access  public
         * @param   String network
         * @return  ConnectionsModalView
         */
        showConnections: function(network) {
            var $modal = DataUtils.render('ConnectionsModal', {
                    network: network
                }),
                settings = this.get('Settings'),
                modal = new ConnectionsModalView($modal, network);
            __openModals.push(modal);
            __getSettingsContentContainer().append($modal);
            modal.show();
            modal.refresh();
            return modal;
        },

        /**
         * showCountdown
         * 
         * @access  public
         * @param   Boolean onboard
         * @return  CountdownModalView
         */
        showCountdown: function(onboard) {
            var $relative = App.getStage().find('header .quota.bar:visible'),
                $modal = DataUtils.render('CountdownModal', {
                    account: Stencil.account(),
                    onboard: onboard
                }),
                modal = new CountdownModalView(
                    $modal,
                    'up',
                    $relative
                );
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            modal.position();
            return modal;
        },

        /**
         * showCreateCollection
         * 
         * @access  public
         * @param   String type
         * @param   Boolean showAutoFeaturingMessaging
         * @return  CreateCollectionModalView
         */
        showCreateCollection: function(type, showAutoFeaturingMessaging) {
            var data = {
                    type: type,
                    showAutoFeaturingMessaging: showAutoFeaturingMessaging
                },
                modalName = 'CreateCollection',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showCropDownload
         * 
         * @access  public
         * @param   String key
         * @param   Object cropPositionData
         * @return  CropDownloadModalView
         */
        showCropDownload: function(key, cropPositionData) {
            var $modal = DataUtils.render('CropDownloadModal', {
                    key: key,
                    cropPositionData: cropPositionData
                }),
                modal = new CropDownloadModalView($modal, key, cropPositionData);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showCropLink
         * 
         * @access  public
         * @return  CropLinkModalView
         */
        showCropLink: function() {
            var modalName = 'CropLink',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showCropper
         * 
         * @access  public
         * @param   String key
         * @return  CropperModalView
         */
        showCropper: function(key) {
            var $modal = DataUtils.render('CropperModal'),
                modal = new CropperModalView($modal, key);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showDelinquent
         * 
         * @access  public
         * @return  DelinquentModalView
         */
        showDelinquent: function() {
            var modalName = 'Delinquent',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showDownload
         * 
         * @access  public
         * @param   String key
         * @param   Boolean forceRemoteDownload
         * @return  DownloadModalView
         */
        showDownload: function(key, forceRemoteDownload) {
            var image = Stencil.getAccessor(key),
                $modal = DataUtils.render('DownloadModal', {
                    image: image
                }),
                modal = new DownloadModalView(
                    $modal,
                    image,
                    forceRemoteDownload
                );
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showError
         * 
         * @access  public
         * @param   String code
         * @param   String reference
         * @return  ErrorModalView
         */
        showError: function(code, reference) {
            var data = {
                    code: code,
                    reference: reference
                },
                modalName = 'Error',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showExtras
         * 
         * @access  public
         * @return  ExtrasModalView
         */
        showExtras: function() {
            var modalName = 'Extras',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showGoogleFonts
         * 
         * @access  public
         * @return  GoogleFontsModalView
         */
        showGoogleFonts: function() {
            var modalName = 'GoogleFonts',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showLegacy
         * 
         * @access  public
         * @return  LegacyModalView
         */
        showLegacy: function() {
            var modalName = 'Legacy',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showLegacyImageNormalize
         * 
         * @access  public
         * @param   String key
         * @return  LegacyImageNormalizeModalView
         */
        showLegacyImageNormalize: function(key) {
            var image = Stencil.getAccessor(key),
                $modal = DataUtils.render('LegacyImageNormalizeModal', {
                    image: image
                }),
                modal = new LegacyImageNormalizeModalView($modal, image);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showLogin
         * 
         * @access  public
         * @param   String type
         * @param   false|String redirect
         * @return  LoginModalView
         */
        showLogin: function(type, redirect) {
            var $modal = DataUtils.render('LoginModal', {
                    redirect: redirect,
                    type: type
                }),
                modal = new LoginModalView($modal, type, redirect);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            if ($modal.find('[name="data[email]"]').val() !== '') {
                if (UserAgentUtils.is.tablet() === false) {
                    $modal.find('[type="password"]').focus();
                }
            } else {
                if (UserAgentUtils.is.tablet() === false) {
                    $modal.find('[name="data[email]"]').focus();
                }
            }
            modal.show();
            return modal;
        },

        /**
         * showOnboard
         * 
         * @access  public
         * @return  OnboardModalView
         */
        showOnboard: function() {
            var $relative = App.getStage().find('footer span.focus'),
                $highlight = $relative.find('a'),
                $modal = DataUtils.render('OnboardModal'),
                modal = new OnboardModalView(
                    $modal,
                    'down',
                    $relative,
                    $highlight
                );
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            modal.position();
            return modal;
        },

        /**
         * showOnboarding
         * 
         * @access  public
         * @param   String key
         * @return  OnboardingModalView
         */
        showOnboarding: function(key) {
            var hash = {
                    'backgroundSelected': 'BackgroundSelectedOnboardingModal',
                    'foregroundSelected': 'ForegroundSelectedOnboardingModal'
                },
                templateName = hash[key],
                $modal = DataUtils.render(templateName),
                modal = new OnboardingModalView($modal);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showOrientation
         * 
         * @access  public
         * @return  OrientationModalView
         */
        showOrientation: function() {
            var modalName = 'Orientation',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showPassword
         * 
         * @access  public
         * @param   String type
         * @param   false|String redirect
         * @return  PasswordModalView
         */
        showPassword: function(type, redirect) {
            var $modal = DataUtils.render('PasswordModal', {
                    redirect: redirect,
                    type: type
                }),
                modal = new PasswordModalView($modal, type, redirect);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showPlanSwitch
         * 
         * @access  public
         * @param   String plan
         * @return  PlanSwitchModalView
         */
        showPlanSwitch: function(plan) {
            var data = {
                    plan: plan
                },
                modalName = 'PlanSwitch',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showPlanSwitched
         * 
         * @access  public
         * @param   String plan
         * @return  PlanSwitchedModalView
         */
        showPlanSwitched: function(plan) {
            var data = {
                    plan: plan
                },
                modalName = 'PlanSwitched',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showPlans
         * 
         * @access  public
         * @return  PlansModalView
         */
        showPlans: function(settings) {
            var data = {
                    type: settings.curtain === true ? 'curtain' : 'default'
                },
                modalName = 'Plans',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showPromo
         * 
         * @access  public
         * @param   String|false partner
         * @param   String type
         * @param   false|String redirect
         * @return  PromoModalView
         */
        showPromo: function(partner, type, redirect) {
            var $modal = DataUtils.render('PromoModal', {
                    partner: partner,
                    redirect: redirect,
                    type: type
                }),
                modal = new PromoModalView($modal, type, redirect);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            if ($modal.find('[name="data[name]"]').val() !== '') {
                if (UserAgentUtils.is.tablet() === false) {
                    $modal.find('[name="data[code]"]').focus();
                }
            } else {
                if (UserAgentUtils.is.tablet() === false) {
                    $modal.find('[name="data[name]"]').focus();
                }
            }
            modal.show();
            return modal;
        },

        /**
         * showRename
         * 
         * @access  public
         * @param   Accessor accessor
         * @param   String columnName
         * @return  RenameModalView
         */
        showRename: function(accessor, columnName) {
            var data = {
                    accessor: accessor,
                    columnName: columnName
                },
                modalName = 'Rename',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showRightClick
         * 
         * @access  public
         * @return  RightClickModalView
         */
        showRightClick: function() {
            var $relative = App.getStage().find('.canvas-container.preview-canvas-container'),
                // $highlight = App.getStage().find(
                $highlight = App.find(
                    '.canvas-container.preview-canvas-container, ' +
                    '.toolbar.text'
                ),
                $modal = DataUtils.render('RightClickModal'),
                modal = new RightClickModalView(
                    $modal,
                    'down',
                    $relative,
                    $highlight
                );
// LogUtils.log.simple($highlight.length, true);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            modal.position();
            return modal;
        },

        /**
         * showSearchUsers
         * 
         * @access  public
         * @param   AdminUsersView section
         * @return  SearchUsersModalView
         */
        showSearchUsers: function(section) {
            var $modal = DataUtils.render('SearchUsersModal'),
                modal = new SearchUsersModalView($modal, section);
            __openModals.push(modal);
            __getAdminContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showSent
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  ImageSentModalView
         */
        showSent: function(shareModal, image) {
            var $modal = DataUtils.render('ImageSentModal'),
                modal = new ImageSentModalView($modal, shareModal, image);
            __openModals.push(modal);
            __getShareContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showServicesSettings
         * 
         * @access  public
         * @return  ServicesModalView
         */
        showServicesSettings: function() {
            var $modal = DataUtils.render('ServicesSettingsModal'),
                modal = new ServicesSettingsModalView($modal);
            __openModals.push(modal);
            __getAdminContentContainer().append(
                $modal
            );
            modal.show();
            return modal;
        },

        /**
         * showSettings
         * 
         * @access  public
         * @return  SettingsModalView
         */
        showSettings: function() {
            var modalName = 'Settings',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showShare
         * 
         * @access  public
         * @param   ImageAccessor image
         * @return  ShareModalView
         */
        showShare: function(image) {
            var $modal = DataUtils.render('ShareModal', {
                    image: image
                }),
                modal = new ShareModalView($modal, image);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showShareError
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @param   ConnectionAccessor connection
         * @return  ShareErrorModalView
         */
        showShareError: function(shareModal, image, connection) {
            var $modal = DataUtils.render('ShareErrorModal', {
                    connection: connection
                }),
                modal = new ShareErrorModalView(
                    $modal,
                    shareModal,
                    image,
                    connection
                );
            __openModals.push(modal);
            __getShareContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showShareSuccess
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ShareAccessor share
         * @return  ShareSuccessModalView
         */
        showShareSuccess: function(shareModal, share) {
            var $modal = DataUtils.render('ShareSuccessModal', {
                    share: share
                }),
                modal = new ShareSuccessModalView($modal, shareModal, share);
            __openModals.push(modal);
            __getShareContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showSignup
         * 
         * @access  public
         * @param   String type
         * @param   false|String redirect
         * @return  SignupModalView
         */
        showSignup: function(type, redirect) {
            var data = {
                image: {
                    data: false
                },
                redirect: redirect,
                type: type
            };
            if (type === 'save') {
                var draft = Stencil.account().draft(),
                    configuration = draft.getConfiguration(),
                    hash = StringUtils.getHash(
                        JSON.stringify(configuration)
                    );
                data.image.data = draft.getSrc({
                    hash: hash
                });
            }
            var $modal = DataUtils.render('SignupModal', data),
                modal = new SignupModalView($modal, type, redirect);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showTemplatePreview
         * 
         * @access  public
         * @param   TemplateAccessor template
         * @return  TemplatePreviewModalView
         */
        showTemplatePreview: function(template) {
            var url = template.getPreviewThumbImageUrl(),
                $modal = DataUtils.render('TemplatePreviewModal', {
                    template: template
                }),
                modal = new TemplatePreviewModalView($modal, template);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            modal.position();
            return modal;
        },

        /**
         * showTutorials
         * 
         * @access  public
         * @param   String section
         * @return  TutorialsModalView
         */
        showTutorials: function(section) {
            var tutorials = Config.get('tutorials'),
                $modal = DataUtils.render('TutorialsModal', {
                    tutorials: tutorials
                }),
                modal = new TutorialsModalView($modal, tutorials);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showUpdateUser
         * 
         * @access  public
         * @param   String key
         * @param   AdminUsersView section
         * @return  UpdateUserModalView
         */
        showUpdateUser: function(key, section) {
            var $modal = DataUtils.render('UpdateUserModal', {
                    user: Stencil.getAccessor(key)
                }),
                modal = new UpdateUserModalView($modal, key, section);
            __openModals.push(modal);
            __getAdminContentContainer().append($modal);
            ElementUtils.nonTabletAutoFocus($modal);
            modal.show();
            return modal;
        },

        /**
         * showUpgrade
         * 
         * @access  public
         * @param   String plan
         * @param   String interval
         * @param   String reason
         * @return  UpgradeModalView
         */
        showUpgrade: function(plan, interval, reason) {
            var data = {
                    plan: plan,
                    interval: interval,
                    reason: reason
                },
                modalName = 'Upgrade',
                modal = __showSimpleModal(modalName, data);
            return modal;
        },

        /**
         * showUpgraded
         * 
         * @access  public
         * @param   String plan
         * @return  UpgradedModalView
         */
        showUpgraded: function(plan) {
            var $modal = DataUtils.render('UpgradedModal', {
                    plan: plan
                }),
                modal = new UpgradedModalView($modal, plan);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        },

        /**
         * showWelcomeTour
         * 
         * @access  public
         * @return  WelcomeModalView
         */
        showWelcomeTour: function() {
            var modalName = 'WelcomeTour',
                modal = __showSimpleModal(modalName);
            return modal;
        },

        /**
         * showYouTubeVideo
         * 
         * @access  public
         * @param   String youTubeSlug
         * @param   Object options
         * @return  YouTubeVideoModalView
         */
        showYouTubeVideo: function(youTubeSlug, options) {
            var $modal = DataUtils.render('YouTubeVideoModal', {
                    youTubeSlug: youTubeSlug,
                    options: options
                }),
                modal = new YouTubeVideoModalView($modal, youTubeSlug, options);
            __openModals.push(modal);
            __getAppContentContainer().append($modal);
            modal.show();
            return modal;
        }
    });
})();

/**
 * NotificationUtils
 * 
 * @abstract
 */
window.NotificationUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'NotificationUtils')
     */
    var __string = 'NotificationUtils';

    /**
     * __valid
     * 
     * @access  private
     * @return  Boolean
     */
    var __valid = function() {
        if (UserAgentUtils.is.chrome() !== true && UserAgentUtils.is.firefox() !== true) {
            return false;
        }
        if (UserAgentUtils.supports.localStorage() === false) {
            return false;
        }
        if (UserAgentUtils.supports.notifications() === false) {
            return false;
        }
        return true;
    };

    // Public
    return {

        /**
         * prompt
         * 
         * @access  public
         * @return  Boolean
         */
        prompt: function() {
            if (__valid() === false) {
                return false;
            }
            var nativeNotifications = Config.default('nativeNotifications');
            if (nativeNotifications === false) {
                return false;
            }
            var relativeTime = Config.default('nativeNotificationMinRelativeTime');
            if (Stencil.account().createdBefore(relativeTime) !== true) {
                return false;
            }
            if (window.Notification.permission === 'granted') {
                return false;
            }
            if (window.Notification.permission === 'denied') {
                return false;
            }
            window.Notification.requestPermission(function(permission) {
                if (permission === 'granted') {
                    Stencil.account().push('settings.grantedNativeNotifications', 1);
                    var notificationObject = Config.get('notifications').current;
                    localStorage.setItem('stencil.nativeNotificationLastShown', notificationObject.stamp);
                    // RequestUtils.cookies.set(
                    //     'nativeNotificationLastShown',
                    //     notificationObject.stamp
                    // );
                    return true;
                }
                return false;
            });
            return true;
        },

        /**
         * show
         * 
         * As it's currently being used, this method does not have access to
         * standard app related calls (like Config.default) since it's called
         * before the app has been initiated (via Stencil.init).
         * 
         * @access  public
         * @param   Object notificationObject
         * @return  void
         */
        show: function(notificationObject) {
            if (__valid() === false) {
                return false;
            }
            var $body = $('body');
            if ($body.hasClass('external') === false) {
                return false;
            }
            if ($body.hasClass('extension') === false) {
                return false;
            }
            if (window.Notification.permission !== 'granted') {
                return false;
            }
            // var lastShown = RequestUtils.cookies.get('nativeNotificationLastShown');
            var lastShown = localStorage.getItem('stencil.nativeNotificationLastShown');
            if (lastShown === notificationObject.stamp) {
                return false;
            }
            // RequestUtils.cookies.set('nativeNotificationLastShown', notificationObject.stamp);
            localStorage.setItem('stencil.nativeNotificationLastShown', notificationObject.stamp);
            var notification = new Notification(notificationObject.title, {
                icon: notificationObject.icon,
                body: notificationObject.body,
            });
            notification.onclick = function() {
                window.open(notificationObject.url);
            };
            (function() {
                notification.close();
            }).delay(notificationObject.timeout);
        }
    };
})();

/**
 * NumberUtils
 * 
 * @abstract
 */
window.NumberUtils = (function() {

    /**
     * Properties
     * 
     */

    /**
     * __string
     * 
     * @access  private
     * @var     Number (default: 'NumberUtils')
     */
    var __string = 'NumberUtils';

    // Public
    return {

        /**
         * floor
         * 
         * @access  public
         * @param   String|Number value
         * @return  Number
         */
        floor: function(value) {
            return Math.floor(value.toFloat());
        }
    };
})();

/**
 * RequestUtils
 * 
 * @abstract
 */
window.RequestUtils = (function() {

    /**
     * __cookieDuration
     * 
     * The number of days cookies should be stored for.
     * 
     * @access  private
     * @var     Number (default: 365)
     */
    var __cookieDuration = 365;

    /**
     * __defaultTimeoutDuration
     * 
     * The number of milliseconds before an AJAX request should time out.
     * 
     * @note    Only used by the initial /connect call; thereafter, config
     *          timeout is used
     * @access  private
     * @var     Number (default: 27.5 * 1000) in milliseconds (aka 27.5 seconds)
     */
    var __defaultTimeoutDuration = 27.5 * 1000;

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'RequestUtils')
     */
    var __string = 'RequestUtils';

    /**
     * __timeoutDuration
     * 
     * @access  private
     * @var     null|Number (default: null)
     */
    var __timeoutDuration = null;

    /**
     * __getPingInterval
     * 
     * @access  private
     * @return  Number
     */
    var __getPingInterval = function() {
        var security = Config.get('security'),
            pingInterval = security.pingInterval;
        return pingInterval;
    };

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * addMessageListener
         * 
         * Manages the addition (and callback) of cross-window messaging events.
         * Performs some simple validation to ensure the message being received
         * includes valid JSON content.
         * 
         * @note    { check below is to ensure properly formatted JSON is being
         *          sent. This is sometimes not the case when the user has
         *          extensions installed. They can call parent frames with
         *          string-data that will break the below parsing.
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        addMessageListener: function(callback) {
            window.addEventListener('message', function(event) {
                if (DataUtils.valid(event) === false) {
                    return false;
                }
                var data = event.data;
                if (DataUtils.valid(data) === false) {
                    return false;
                }
                if (data[0] !== '{') {
                    return false;
                }
                if (JSONUtils.valid(data) === false) {
                    return false;
                }
                var parsed = JSONUtils.parse(data),
                    action = parsed.action;
                if (DataUtils.valid(action) === false) {
                    return false;
                }
                callback(parsed);
                return true;
            });
        },

        /**
         * ajax
         * 
         * Proxy for ajax calls. Initially created to facilitate a Safari bug
         * whereby ajax calls were being killed when a location change happens
         * (which included downloading an image). To deal with that, I am
         * checking to see if a redirect is happening, and if it is, I delay the
         * ajax call until after (by listening for the redirect/complete event).
         * 
         * That being said, it is also nice to have all the logic in one place.
         * Should result in a cleaner development experience.
         * 
         * @todo!!  Update default error handler to work independent of AppView
         *          having been intantiated. This will probably require a Logging
         *          helper class. The value of modifying things is to ensure that
         *          a logging method is always accessible regardless of whether
         *          the app view has been instantiated (eg. /import or /sign
         *          fails).
         * @access  public
         * @param   Object obj
         * @return  void
         */
        ajax: function(obj) {
            if (Stencil.get('redirecting') === true) {
                Stencil.once({
                    'redirect/complete': RequestUtils.ajax.proxy(Stencil, [obj])
                });
            } else {

                // Data formatting and csrf
                var data = obj.data || {};
                data = {
                    data: data
                };

                // Security
                var currentUnixTimestamp = DTUtils.getTimestamp();
                data.security = {
                    csrf: Config.getCSRFToken(),
                    time: {
                        unix: {
                            full: currentUnixTimestamp,
                            simple: Math.floor(currentUnixTimestamp)
                        }
                    },
                    version: Stencil.get('version')
                };

                // Dump the data if nothing should be passed on (eg. icons)
                if (obj.excludeDefaultData === true) {
                    data = {};
                }

                // Timeout
                var timeoutDuration = RequestUtils.get.timeout();

                // Call
                jQuery.ajax({
                    // cache: obj.cache || false,
                    cache: obj.cache === undefined ? true: obj.cache,
                    crossdomain: obj.crossdomain || false,
                    url: obj.url,
                    type: obj.type,
                    data: data,
                    error: obj.error || function(jqXHR, textStatus, errorThrown) {

                        // Segment tracking
                        Track.event('Ajax Error (Stencil)', {
                            _code: obj.signature.line,
                            _reference: obj.signature.basename,
                            _data: JSON.stringify(obj.data || {}),
                            _url: obj.url,
                            _textStatus: textStatus
                        });

                        // Console logging
                        LogUtils.log.object(Stencil, 'jQuery AJAX error', true);
                        LogUtils.log.object(Stencil, obj.signature, true);
                        LogUtils.log.object(Stencil, arguments, true);

                        // Connection check
                        RequestUtils.alive(function() {
                            var code = obj.signature.line,
                                reference = obj.signature.basename;
                            Stencil.error(code, reference);
                        });
                    },
                    success: [
                        function(response) {

                            // Version storage
                            if (Stencil.get('version') === undefined) {
                                if (typeof response === 'object') {
                                    var version = response.version;
                                    if (version !== undefined) {
                                        Stencil.set('version', version);
                                    }
                                }
                            }

                            // Config services
                            if (typeof response === 'object') {
                                var config = response.config;
                                if (config !== undefined) {
                                    var services = config.services;
                                    Config.set('services', services);
                                }
                            }

                            // Override objects
                            if (typeof response === 'object') {
                                var config = response.config;
                                if (config !== undefined) {
                                    var overrides = config.overrides,
                                        collection = Stencil.get('overrides');
                                    if (collection !== undefined) {
                                        collection.empty();
                                        collection.map(overrides);
                                    }
                                }
                            }
                        },
                        function(response) {
                            if (typeof response === 'object') {
                                if (response.success === true) {
                                    if (obj.success !== undefined) {
                                        obj.success.apply(obj, [response]);
                                    }
                                } else {
                                    var error = Stencil.extractError(response);

                                    // Maintenace mode
                                    if (
                                        error.validator !== false
                                        && error.validator[1] === 'notInMaintenanceMode'
                                    ) {
                                        Stencil.alert('app.maintenance');
                                        Stencil.kill();
                                    }
                                    // Data integrity failure
                                    else if (
                                        error.validator !== false
                                        && error.validator[1] === 'validData'
                                    ) {
                                        Stencil.alert('security.failedDataIntegrityCheck');
                                        Stencil.kill();
                                    } 
                                    // Data integrity failure
                                    else if (
                                        error.validator !== false
                                        && error.validator[0] === 'AccountValidator'
                                        && error.validator[1] === 'sessionAccountExists'
                                    ) {
                                        Stencil.alert('account.sessionAccount.false');
                                        Stencil.kill();
                                    }
                                    // Data integrity failure
                                    else if (
                                        error.validator !== false
                                        && error.validator[0] === 'SecurityValidator'
                                        && error.validator[1] === 'validCSRFToken'
                                    ) {
                                        Stencil.alert('security.failedCSRFTokenCheck');
                                        Stencil.kill();
                                    }
                                    // Otherwise..
                                    else {
                                        obj.success.apply(obj, [response]);
                                    }
                                }
                            } else {
                                if (obj.success !== undefined) {
                                    obj.success.apply(obj, [response]);
                                }
                            }
                        }
                    ],
                    dataType: obj.dataType || 'json',
                    timeout: obj.timeout || timeoutDuration
                    // timeout: obj.timeout || 10 * 1000
                });
            }
        },

        /**
         * alive
         * 
         * Attempts to load a small image to determine if a connection to the
         * server can be made. If yes, the callback is run. Otherwise, an alert
         * is shown informing them that they need to reload the app. At the
         * moment, trying to load from imgur instead of static file on app
         * server, since if they can't reach imgur, it's almost certain their
         * connection is donw. But if they can't reach static file on app
         * server, it's possible that app server is down, instead of internet
         * connection.
         * 
         * Stencil.set call is made against alive-key to prevent Stencil.alert
         * from tracking the alert (via Segment).
         * 
         * @todo!   Tier this so connection tests are made to both a local static
         *          asset as well as one on a 3rd-party site (eg. imgur).
         * @note    Keep in mind some countries (eg. Turkey) can block certain
         *          domains (eg. imgur).
         * @access  public
         * @param   Function callback
         * @return  void
         */
        alive: function(callback) {
            var path = '/app/static/images/200.png',
                imageRequest = new ImageRequest(),
                src = path;
            if (Config.getRole() === 'local') {
                src = 'https://getstencil.com' + (src);
            }
            src = (src) + '?' + DataUtils.getRandomString();
            imageRequest.once({
                'error': function(event, image) {
                    Track.disable();
                    Stencil.set('alive', false);
                    Stencil.alert('connection');
                    Stencil.kill();
                },
                'load': function(event, image) {
                    callback();
                }
            });
            imageRequest.setSource(src);
            imageRequest.request();
        },

        /**
         * cookies
         * 
         * @access  public
         * @var     Object
         */
        cookies: {

            /**
             * get
             * 
             * @access  public
             * @param   String key
             * @return  mixed
             */
            get: function(key) {
                var value = Cookies.get(key);
                return value;
            },

            /**
             * remove
             * 
             * @access  public
             * @param   String key
             * @return  void
             */
            remove: function(key) {
                Cookies.remove(key, {
                    path: '/',
                    domain: ''
                });
            },

            /**
             * set
             * 
             * @access  public
             * @param   String key
             * @param   mixed value
             * @return  void
             */
            set: function(key, value) {
                Cookies.set(key, value, {
                    domain: '',
                    expires: __cookieDuration,
                    path: '/',
                    secure: true
                });
            }
        },

        /**
         * get
         * 
         * @access  public
         * @var     Object
         */
        get: {

            /**
             * timeout
             * 
             * Centralized the timeout lookup, so that if the app hasn't fully
             * loaded yet, the JavaScript-defined default value is used, but if
             * the app has loaded, then the Config-based value is used.
             * 
             * The exception to all this is that when a timeout has been
             * explicitly defined in this RequestUtils class, then that is used.
             * 
             * The reason we have to check for the config existing is
             * because the initial /connect call does not have access to the
             * app config.
             * 
             * @access  public
             * @return  Number
             */
            timeout: function() {
                var config = Stencil.get('config');
                if (config === undefined) {
                    var timeoutDuration = __defaultTimeoutDuration;
                    return timeoutDuration;
                }
                if (__timeoutDuration === null) {
                    timeoutDuration = Config.get('runtime').timeout - (5 * 1000);
                    return timeoutDuration;
                }
                return __timeoutDuration;
            }
        },

        /**
         * ping
         * 
         * @access  public
         * @return  void
         */
        ping: function() {
            var path = '/app/ping',
                signature = {"basename":"RequestUtils.js","line":431},
                request = new ServerRequest();
            request.setOptions({
                path: path,
                signature: signature
            });
            request.get();
            request.removeErrorListeners();
        },

        /**
         * postMessage
         * 
         * @access  protected
         * @param   String action
         * @return  void
         */
        postMessage: function(action) {
            var message = JSON.stringify({
                action: action
            });
            window.parent.postMessage(message, '*');
        },

        /**
         * report
         * 
         * @access  public
         * @param   String subject
         * @param   mixed msg
         * @param   undefined|Boolean includeCommonReportingData (default: true)
         * @return  void
         */
        report: function(subject, msg, includeCommonReportingData) {
            includeCommonReportingData = DataUtils.getDefaultValue(includeCommonReportingData, true);
            var request = new ServerRequest();
            request.setOptions({
                data: {
                    msg: JSON.stringify(msg),
                    subject: subject,
                    includeCommonReportingData: includeCommonReportingData
                },
                path: '/admin/report',
                signature: {"basename":"RequestUtils.js","line":474}            });
            request.post();
        },

        /**
         * set
         * 
         * @access  public
         * @var     Object
         */
        set: {

            /**
             * timeout
             * 
             * @access  public
             * @param   null|Number duration in milliseconds
             * @return  void
             */
            timeout: function(duration) {
                __timeoutDuration = duration;
            }
        },

        /**
         * setup
         * 
         * @access  public
         * @var     Object
         */
        setup: {

            /**
             * ping
             * 
             * @access  public
             * @return  void
             */
            ping: function() {
                var interval = __getPingInterval();
                RequestUtils.ping.interval(interval);
            }
        },

        /**
         * url
         * 
         * @access  public
         * @var     Object
         */
        url: {

            /**
             * audio
             * 
             * @access  public
             * @param   String basename
             * @return  String
             */
            audio: function(basename) {
                var path = '/app/static/audio/' + (basename),
                    url = RequestUtils.url.static(path);
                return url;
            },

            /**
             * cloudFront
             * 
             * @access  public
             * @param   String key
             * @return  String
             */
            cloudFront: function(key) {
                var aws = Config.get('aws'),
                    distribution = aws.cloudFront.distributions.s3.app.stencil,
                    host = distribution.host,
                    path = '/' + (key),
                    url = 'https://' + (host) + (path);
                return url;
            },

            /**
             * favicon
             * 
             * @access  public
             * @param   String domain
             * @return  String
             */
            favicon: function(domain) {
                var url = 'https://www.google.com/s2/favicons?domain=' +
                    (domain);
                return url;
            },

            /**
             * image
             * 
             * @access  public
             * @param   String path
             * @return  String
             */
            image: function(path) {
                var url = RequestUtils.url.static(path);
                return url;
            },

            /**
             * s3
             * 
             * Returns the path to original S3 file.
             * 
             * @access  public
             * @param   String objectKey
             * @return  String
             */
            s3: function(objectKey) {
                var aws = Config.get('aws'),
                    bucket = aws.s3.buckets.app.stencil,
                    bucketRegion = bucket.region,
                    bucketName = bucket.name,
                    host = 's3-' + (bucketRegion) + '.amazonaws.com',
                    path = '/' + (bucketName) + '/' + (objectKey),
                    url = 'https://' + (host) + (path);
                return url;
            },

            /**
             * static
             * 
             * @access  public
             * @param   String path
             * @return  String
             */
            static: function(path) {
                var host = Config.getStaticHost(),
                    url = 'https://' + (host) + (path);
                return url;
            }
        }
    });
})();

/**
 * StatUtils
 * 
 * @abstract
 */
window.StatUtils = (function() {

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'StatUtils')
     */
    var __string = 'StatUtils';

    // Public
    return {

        /**
         * getGraphicSearchGatewaysCount
         * 
         * @access  public
         * @return  String
         */
        getGraphicSearchGatewaysCount: function() {
            var graphicSearchGateways = Config.default('graphicSearchGateways'),
                count = 0;
            if (ArrayUtils.contains('Iconfinder', graphicSearchGateways) === true) {
                count += Config.get('iconfinder').total;
            }
            if (ArrayUtils.contains('Icons8', graphicSearchGateways) === true) {
                count += Config.get('icons8').total;
            }
            if (ArrayUtils.contains('TheNounProject', graphicSearchGateways) === true) {
                count += Config.get('theNounProject').total;
            }
            var lowerBound = count.roundToLower(100000),
                formatted = lowerBound.commas();
            return formatted;
        },

        /**
         * getPhotoSearchGatewaysCount
         * 
         * @access  public
         * @return  String
         */
        getPhotoSearchGatewaysCount: function() {
            var photoSearchGateways = Config.default('photoSearchGateways'),
                count = 0;
            if (ArrayUtils.contains('Pexels', photoSearchGateways) === true) {
                count += Config.get('pexels').total;
            }
            if (ArrayUtils.contains('Pixabay', photoSearchGateways) === true) {
                count += Config.get('pixabay').total;
            }
            if (ArrayUtils.contains('Unsplash', photoSearchGateways) === true) {
                count += Config.get('unsplash').total;
            }
            var lowerBound = count.roundToLower(100000),
                formatted = lowerBound.commas();
            return formatted;
        },

        /**
         * getQuoteSearchGatewaysCount
         * 
         * @access  public
         * @return  String
         */
        getQuoteSearchGatewaysCount: function() {
            var quoteSearchGateways = Config.default('quoteSearchGateways'),
                count = 0;
            if (ArrayUtils.contains('Algolia', quoteSearchGateways) === true) {
                count += Config.get('algolia').total;
            }
            var lowerBound = count.roundToLower(10000),
                formatted = lowerBound.commas();
            return formatted;
        }
    };
})();

/**
 * StringUtils
 * 
 * @abstract
 */
window.StringUtils = (function() {

    /**
     * __accentSets
     * 
     * @access  public
     * @var     Object
     */
    var __accentSets = [
        {to: 'a', from: '[ÀÁÂÃÄÅÆĀĂĄẠẢẤẦẨẪẬẮẰẲẴẶ]'},
        {to: 'c', from: '[ÇĆĈČ]'},
        {to: 'd', from: '[ÐĎĐÞ]'},
        {to: 'e', from: '[ÈÉÊËĒĔĖĘĚẸẺẼẾỀỂỄỆ]'},
        {to: 'g', from: '[ĜĞĢǴ]'},
        {to: 'h', from: '[ĤḦ]'},
        {to: 'i', from: '[ÌÍÎÏĨĪĮİỈỊ]'},
        {to: 'j', from: '[Ĵ]'},
        {to: 'ij', from: '[Ĳ]'},
        {to: 'k', from: '[Ķ]'},
        {to: 'l', from: '[ĹĻĽŁ]'},
        {to: 'm', from: '[Ḿ]'},
        {to: 'n', from: '[ÑŃŅŇ]'},
        {to: 'o', from: '[ÒÓÔÕÖØŌŎŐỌỎỐỒỔỖỘỚỜỞỠỢǪǬƠ]'},
        {to: 'oe', from: '[Œ]'},
        {to: 'p', from: '[ṕ]'},
        {to: 'r', from: '[ŔŖŘ]'},
        {to: 's', from: '[ßŚŜŞŠ]'},
        {to: 't', from: '[ŢŤ]'},
        {to: 'u', from: '[ÙÚÛÜŨŪŬŮŰŲỤỦỨỪỬỮỰƯ]'},
        {to: 'w', from: '[ẂŴẀẄ]'},
        {to: 'x', from: '[ẍ]'},
        {to: 'y', from: '[ÝŶŸỲỴỶỸ]'},
        {to: 'z', from: '[ŹŻŽ]'},
        {to: '-', from: '[·/_,:;\']'}
    ];

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'StringUtils')
     */
    var __string = 'StringUtils';

    // Public
    return {

        /**
         * contains
         * 
         * @access  public
         * @param   String haystack
         * @param   String needle
         * @return  Boolean
         */
        contains: function(haystack, needle) {
            var contains = haystack.indexOf(needle) !== -1;
            return contains;
        },

        /**
         * getHash
         * 
         * Simple hashing algorithm so I can hash strings and compare them to
         * one another to determine if anything's changed.
         * 
         * @note    The escape call needs to be used to prevent issues with
         *          unicode characters throwing issues within the md5 function.
         *          Specifically, the md5 vendor library makes use of
         *          encodeURIComponent, and when certain characters
         *          (eg. '\uD800') are passed in, it bails with a URIError:
         *          https://i.imgur.com/JGlAFZi.jpg
         *          Calling escape will convert non-alphan-numeric characters to
         *          "safe" characters, which prevents the issues seen above.
         * @see     https://i.imgur.com/JGlAFZi.jpg
         * @see     https://stackoverflow.com/questions/2670037/how-to-remove-invalid-utf-8-characters-from-a-javascript-string
         * @see     https://github.com/tc39/ecma262/issues/944
         * @see     https://github.com/blueimp/JavaScript-MD5
         * @see     https://stackoverflow.com/a/7616484/115025
         * @access  public
         * @param   String str
         * @return  String
         */
        getHash: function(str) {
            str = escape(str);
            var hash = md5(str);
            return hash;
        },

        /**
         * getQueryDataString
         * 
         * @access  public
         * @param   Object queryData
         * @return  String
         */
        getQueryDataString: function(queryData) {
            var queryDataString = jQuery.param(queryData);
            return queryDataString;
        },

        /**
         * insertSpacesIntoCamelCase
         * 
         * @access  public
         * @param   String str
         * @return  String
         */
        insertSpacesIntoCamelCase: function(str) {
            var spaced = str.replace(/([A-Z])/g, ' $1').trim();
            return spaced;
        },

        /**
         * replaceAll
         * 
         * @access  public
         * @param   String str
         * @param   Object obj
         * @return  String
         */
        replaceAll: function(str, obj) {
            var tmp = str.toString(),
                key;
            for (key in obj) {
                tmp = tmp.replace(key, obj[key]);
            }
            return tmp;
        },

        /**
         * sentenceCase
         * 
         * @see     https://stackoverflow.com/questions/7225407/convert-camelcasetext-to-sentence-case-text
         * @access  public
         * @param   String str
         * @return  String
         */
        sentenceCase: function(str) {
            var result = str.replace(/([A-Z])/g, ' $1'),
                finalResult = result.charAt(0).toUpperCase() + result.slice(1); // capitalize the first letter - as an example.
            return finalResult;
        },

        /**
         * lcfirst
         * 
         * @see     http://locutus.io/php/strings/lcfirst/
         * @access  public
         * @param   String str
         * @return  String
         */
        lcfirst: function(str) {
            str += ''
            var f = str.charAt(0).toLowerCase();
            return (f) + str.substr(1);
        },

        /**
         * slugify
         * 
         * @see     https://gist.github.com/mathewbyrne/1280286
         * @access  public
         * @param   String str
         * @param   Number limit
         * @return  String
         */
        slugify: function(str, limit) {
            var index, set, regExp;
            for (index in __accentSets) {
                set = __accentSets[index];
                regExp = new RegExp(set.from, 'gi');
                str = str.replace(regExp, set.to);
            }
            limit = limit.toInt();
            str = str.trim();
            str = str.toLowerCase();
            str = str.replace(/'/g, '');
            str = str.replace(/&amp;/g, '&');
            str = str.replace(/&/g, '-and-');
            str = str.replace(/[^a-zA-Z0-9-]/g, ' ');
            str = str.replace(/-/g, ' ');
            str = str.replace(/[\s]{2,}/g, ' ');
            str = str.trim();
            str = str.replace(/ /g, '-');
            str = str.slice(0, limit);
            return str;
        },

        /**
         * ucfirst
         * 
         * @see     https://stackoverflow.com/questions/1026069/how-do-i-make-the-first-letter-of-a-string-uppercase-in-javascript
         * @access  public
         * @param   String str
         * @return  String
         */
        ucfirst: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        },

        /**
         * url
         * 
         * @access  public
         * @param   String str
         * @return  Boolean
         */
        url: function(str) {
            if (str.match(/^http[s]?\:\/\//) === null) {
                return false;
            }
            return true;
        },

        /**
         * validMethod
         * 
         * Helper method to check whether a method call against an object is
         * valid to be made, by checking whether the object and method
         * themselves exist. For example:
         * 
         * StringUtils.validMethod('document.addEventListener') === true
         * StringUtils.validMethod('document.addEventListener') === false
         * 
         * @access  public
         * @param   String str
         * @return  Boolean
         */
        validMethod: function(str) {
            var pieces = str.split('.'),
                index,
                reference = window;
            for (index in pieces) {
                reference = reference[pieces[index]];
                if (reference === undefined) {
                    return false;
                }
            }
            return reference.constructor === Function;
        },

        /**
         * validObject
         * 
         * @access  public
         * @param   String str
         * @return  Boolean
         */
        validObject: function(str) {
            var pieces = str.split('.'),
                index,
                reference = window;
            for (index in pieces) {
                reference = reference[pieces[index]];
                if (reference === undefined) {
                    return false;
                }
            }
            return reference.constructor === Object;
        }
    };
})();

/**
 * UserAgentUtils
 * 
 * @todo!    Modernize with Modernizr
 *           For detecting italic support in the canvas (used in text drawings):
 *           http://stackoverflow.com/questions/14489363/detect-bold-and-italic-support
 * @abstract
 */
window.UserAgentUtils = (function() {

    /**
     * __italic
     * 
     * @access  private
     * @var     undefined|Boolean (default: undefined)
     */
    var __italic = undefined;

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'UserAgentUtils')
     */
    var __string = 'UserAgentUtils';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * extension
         * 
         * Returns whether or not the app is currently being accessed via a
         * browser extension.
         * 
         * @access  public
         * @return  Boolean
         */
        extension: function() {
            return App.getElement().hasClass('external') === true
                && App.getElement().hasClass('extension') === true;
        },

        /**
         * getDevicePixelRatio
         * 
         * @access  public
         * @return  Number
         */
        getDevicePixelRatio: function() {
            return window.devicePixelRatio || 1;
        },

        /**
         * getLogoutPath
         * 
         * @access  public
         * @return  String
         */
        getLogoutPath: function() {
            var path = '/?bye';
            if (Stencil.getOptions().source.electron === true) {
                path = '/app/login?curtain&electron';
            }
            return path;
        },

        /**
         * getOrientation
         * 
         * @access  public
         * @return  false|String
         */
        getOrientation: function() {
            if (UserAgentUtils.is.ipad() === false) {
                return false;
            }
            var orientation = window.orientation;
            if (orientation === 0 || orientation === 180) {
                return 'portrait';
            }
            return 'landscape';
        },

        /**
         * hasCSP
         * 
         * @access  public
         * @return  Boolean
         */
        hasCSP: function() {
            var blacklist = [
                    'mail.google.com'
                ],
                params = Stencil.get('messageParams'),
                hostname;
            if (params !== undefined) {
                if (params.parent !== undefined) {
                    if (params.parent.location !== undefined) {
                        if (params.parent.location.hostname !== undefined) {
                            hostname = params.parent.location.hostname;
                        }
                    }
                }
            }
            if (ArrayUtils.contains(hostname, blacklist) === false) {
                return false;
            }
            return true;
        },

        /**
         * is
         * 
         * @access  public
         * @return  Object
         */
        is: {

            /**
             * chrome
             * 
             * @access  public
             * @return  Boolean
             */
            chrome: function() {
                return /chrom(e|ium)/.test(navigator.userAgent.toLowerCase());
            },

            /**
             * edge
             * 
             * @access  public
             * @return  Boolean
             */
            edge: function() {
                return / edge/.test(navigator.userAgent.toLowerCase()) === true;
            },

            /**
             * electron
             * 
             * @access  public
             * @return  Boolean
             */
            electron: function() {
                return / electron/.test(navigator.userAgent.toLowerCase()) === true;
            },

            /**
             * firefox
             * 
             * @access  public
             * @return  Boolean
             */
            firefox: function() {
                return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            },

            /**
             * ie
             * 
             * @see     http://blogs.msdn.com/b/ieinternals/archive/2013/09/21/internet-explorer-11-user-agent-string-ua-string-sniffing-compatibility-with-gecko-webkit.aspx
             * @sample  'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)'
             * @sample  'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; .NET4.0E; .NET4.0C; rv:11.0) like Gecko'
             * @access  public
             * @return  Boolean
             */
            ie: function() {
                var userAgent = navigator.userAgent;
                return userAgent.match(/msie/i) !== null
                    || userAgent.match(/trident\/7/i) !== null;
            },

            /**
             * ipad
             * 
             * @access  public
             * @return  Boolean
             */
            ipad: function() {
                return navigator.userAgent.match(/iPad/i) !== null;
            },

            /**
             * mac
             * 
             * @access  public
             * @return  Boolean
             */
            mac: function() {
                return navigator.appVersion.indexOf('Mac') !== -1;
            },

            /**
             * safari
             * 
             * @see     http://stackoverflow.com/questions/7944460/detect-safari-browser
             * @access  public
             * @return  Boolean
             */
            safari: function() {
                return /^((?!chrome).)*safari/i.test(navigator.userAgent);
            },

            /**
             * tablet
             * 
             * Returns whether the visitor is experiencing the app on a tablet.
             * 
             * @access  public
             * @return  Boolean
             */
            tablet: function() {
                return UserAgentUtils.is.ipad() === true;
            }
        },

        /**
         * supports
         * 
         * @access  public
         * @return  Object
         */
        supports: {

            /**
             * adownload
             * 
             * @access  public
             * @return  Boolean
             */
            adownload: function() {
                return Modernizr.adownload !== false;
            },

            /**
             * canvas
             * 
             * @access  public
             * @return  Object
             */
            canvas: {

                /**
                 * italic
                 * 
                 * Tests whether the browser supports faux-italic text in canvas
                 * when the font itself does not have an italic version (or else
                 * the italic version has not been loaded into memory).
                 * 
                 * I do this by using the native font Impact, which does not
                 * have a bold or italic version, drawing it to a canvas, and
                 * checking whether anything about the canvas bit-data is
                 * different.
                 * 
                 * @see     http://stackoverflow.com/questions/14489363/detect-bold-and-italic-support
                 * @see     http://stackoverflow.com/questions/15128803/cannot-draw-italic-text-in-firefox-canvas
                 * @access  public
                 * @return  Boolean
                 */
                italic: function() {
                    if (__italic === undefined) {
                        var canvas = document.createElement('canvas'),
                            context = canvas.getContext('2d'),
                            raw = {};
                        canvas.width = 1000;
                        canvas.height = 30;
                        context.font = 'normal 16px impact';
                        context.fillText('string', 10, 20);
                        raw.normal = canvas.toDataURL('image/png');
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.font = 'italic 16px impact';
                        context.fillText('string', 10, 20);
                        raw.italic = canvas.toDataURL('image/png');
                        __italic = raw.normal !== raw.italic;
                    }
                    return __italic;
                }
            },

            /**
             * chromeWebstore
             * 
             * @access  public
             * @return  Boolean
             */
            chromeWebstore: function() {
                return ClientWrappers.get('chromeWebstore').available();
            },

            /**
             * clipboard
             * 
             * @access  public
             * @var     Object
             */
            clipboard: {

                /**
                 * copy
                 * 
                 * @see     https://alligator.io/js/copying-to-clipboard/
                 * @access  public
                 * @return  Boolean
                 */
                copy: function() {
                    return document.queryCommandSupported('copy');
                }
            },

            /**
             * cookies
             * 
             * @access  public
             * @return  Boolean
             */
            cookies: function() {
                return Modernizr.cookies !== false;
            },

            /**
             * css
             * 
             * @access  public
             * @return  Object
             */
            css: {

                /**
                 * masks
                 * 
                 * @see     https://gist.github.com/trey/1827930
                 * @access  public
                 * @return  Boolean
                 */
                masks: function() {
                    return document.body.style['-webkit-mask-repeat'] !== undefined;
                },

                /**
                 * scrollbars
                 * 
                 * @access  public
                 * @return  Boolean
                 */
                scrollbars: function() {
                    return Modernizr.cssscrollbar === true;
                }
            },

            /**
             * file
             * 
             * @see     https://modernizr.com/download?filereader-dontmin&q=filere
             * @access  public
             * @return  Boolean
             */
            file: function() {
                return !!(window.File && window.FileList && window.FileReader);
            },

            /**
             * localStorage
             * 
             * @access  public
             * @return  Boolean
             */
            localStorage: function() {
                return Modernizr.localstorage !== false;
            },

            /**
             * notifications
             * 
             * @access  public
             * @return  Boolean
             */
            notifications: function() {
                var supported = DataUtils.valid(window.Notification) === true;
                return supported;
            },

            /**
             * woff2
             * 
             * @access  public
             * @return  Boolean
             */
            woff2: function() {
                return supportsWoff2 === true;
            }
        },

        /**
         * valid
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            return Modernizr.cors === true
                && Modernizr.imgcrossorigin === true;
        }
    });
})();
window.DependencyLoader.push('Base', function() {

    /**
     * Drawing
     * 
     * @events  change/angle
     *          change/position
     *          change/scale
     * @extends Base
     */
    window.Drawing = Base.extend({

        /**
         * _boxInRatio
         * 
         * @access  protected
         * @var     Number (default: 0.25)
         */
        _boxInRatio: 0.25,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'drawing')
         */
        _classType: 'drawing',

        /**
         * _cotton
         * 
         * @access  protected
         * @var     null|fabric.Object (default: null)
         */
        _cotton: null,

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _layer
         * 
         * @access  protected
         * @var     Layer (default: null)
         */
        _layer: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return {
                'change/position': function() {
                    this._layer.on({
                        'change/position': function(event, position) {
                            var objects = this.getCanvas().getCotton().getObjects();
                            jQuery.each(objects, function(index, object) {
                                object.setCoords();
                            });
                        }
                    });
                },
                'delete': function() {
                    this._layer.on({
                        'delete': function(event) {
                            if (this._drawing.drawn() === true) {
                                var cotton = this.getCotton(),
                                    drawing = this._drawing;
                                drawing.magnets.demagnetize.apply(drawing);
                                    // backdrop = cotton.backdrop;
                                // if (backdrop !== undefined) {
                                    // cotton.clearBackdrop();
                                // }
                                cotton.remove();
                                Toolbars.hide();
                            }
                        }
                    });
                },

                /**
                 * Nudging
                 * 
                 */
                'move': function() {
                    this._layer.on({
                        'move/up': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/right': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/down': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/left': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                },
                'order': function() {
                    this._layer.on({
                        'change/order': function(event, forward) {
                            this.getCanvas().render();
                        }
                    });
                },
                'position': function() {
                    this._layer.on({
                        'position/restored': function(event) {

                            // Top
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();

                            // Left
                            cotton = this.getCotton();
                            drawing = this._drawing;
                            left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                }
            };
        },

        /**
         * _outline
         * 
         * @access  protected
         * @var     fabric.Rect (default: null)
         */
        _outline: null,

        /**
         * _rotateIconPath
         * 
         * @access  protected
         * @var     String (default: '/app/static/images/icons/rotate.v3.small.png')
         */
        _rotateIconPath: '/app/static/images/icons/rotate.v3.small.png',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Drawing')
         */
        _string: 'Drawing',

        /**
         * init
         * 
         * @access  public
         * @param   Layer layer
         * @return  void
         */
        init: function(layer) {
            this._super();
            this._layer = layer;
            this._preloadRotateIcon();
            this._setupListeners();
            this.magnets = this.magnets();
            this.relative = this.relative();
        },

        /**
         * _addBoxInListeners
         * 
         * Ensures that when an object is boxed in, it's left / top coordinates
         * are properly set.
         * 
         * @access  protected
         * @return  void
         */
        _addBoxInListeners: function() {
            this._cotton.on({
                'boxedIn': function(options) {
                    this.trigger('moving/manual');
                }
            });
        },

        /**
         * _addMoveListeners
         * 
         * Returns a 2-decimal-place position coordinate (left/top).
         * 
         * @note    The image property check, and the deleted property check,
         *          are performed to ensure that after a layer has been
         *          "deleted", we don't keep tracking (and triggered) background
         *          position changes.
         * @access  protected
         * @return  void
         */
        _addMoveListeners: function() {
            var _this = this,
                closure = function(options) {
                    if (_this._layer.toString() == 'BackgroundBitmapImageLayer') {
                        var image = _this._layer.getProperty('image');
                        if (image !== false) {
                            var position = {
                                left: (this.getRelativeLeft() * 100).round(4),
                                top: (this.getRelativeTop() * 100).round(4)
                            };
                            _this._layer.triggerHandler('change/position', [position]);
                        }
                    } else {
                        if (_this._layer.get('deleted') !== true) {
                            var position = {
                                left: (this.getRelativeLeft() * 100).round(4),
                                top: (this.getRelativeTop() * 100).round(4)
                            };
                            _this._layer.triggerHandler('change/position', [position]);
                        }
                    }
                };
            this._cotton.on({
                'moving': closure.proxy(this._cotton),
                'moving/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addRotateListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRotateListeners: function() {
            var _this = this,
                closure = function(event) {
                    var angle = this.getAngle().round(4);
                    _this._layer.triggerHandler('change/angle', [angle]);
                };
            this._cotton.on({
                'rotating': closure.proxy(this._cotton),
                'rotating/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addSnapListeners
         * 
         * Listens for snap events on the fabric object to ensure that the saved
         * top / left value is exactly the magnet-value. Without this listener,
         * the drawing would appear to snap, but once saved, the value would be
         * off. It'd also affect keyboard-shortcut nudging, since the
         * layer-stored left/top value wouldn't be the actual value that is seen
         * in the canvas/UI.
         * 
         * The same applies to snap / angle
         * 
         * @access  protected
         * @return  void
         */
        _addSnapListeners: function() {
            this._cotton.on({
                'snap/angle': function(options) {
                    this.trigger('rotating/manual');
                },
                'snap/position': function(options) {
                    this.trigger('moving/manual');
                },
                'snap/scale': function(options) {
                    this.trigger('scaling/manual');
                }
            });
        },

        /**
         * _getContrastingColor
         * 
         * @access  protected
         * @param   String colorStr
         * @return  String either black or white as an rgb string
         */
        _getContrastingColor: function(colorStr) {
            return ColorUtils.getContrastingColorStr(
                colorStr,
                'rgb'
            );
        },

        /**
         * _getDefaultOptions
         * 
         * Worth noting is that the only time the originX or originY values will
         * not be set to center is in the case of a TextLayer in a legacy image.
         * This is because positioning was determined by the top + left
         * coordinate rather than center-point. If this is ever the case, right
         * after drawing the text will be converted to be use the center +
         * center origin.
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaultOptions: function() {
            var white = ColorUtils.getWhite('rgba'),
                black = ColorUtils.getBlack('rgba'),
                defaultOptions = {
                    stencilCornerFillColor: white,
                    stencilCornerStrokeColor: black,
                    stencilBorderColor1: black,
                    stencilBorderColor2: white,
                    stencilRotatingPointColor1: black,
                    stencilRotatingPointColor2: white,
                    // perPixelTargetFind: true,
                    borderColor: black,
                    cornerSize: UserAgentUtils.is.tablet() === true ? 30 : 12,
                    hasRotatingPoint: false,
                    padding: UserAgentUtils.is.tablet() === true ? 10 : 0,
                    originX: 'center',
                    originY: 'center',
                    rotatingPointOffset: 20,
                    transparentCorners: false,
                    lockSkewingX: true,
                    lockSkewingY: true
                };
            return defaultOptions;
        },

        /**
         * _preloadRotateIcon
         * 
         * @access  protected
         * @return  void
         */
        _preloadRotateIcon: function() {
            var path = this._rotateIconPath,
                callback = function(reference) {
                    var image = reference;
                    Stencil.set('rotateIconImageReference', image);
                },
                crossOrigin = true;
            ImageUtils.load.path(path, crossOrigin, callback);
        },

        /**
         * _setupListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupListeners: function() {
            var _this = this;
            this._listeners = this._listeners();
            jQuery.each(
                this._listeners,
                function(type, listener) {
                    listener.apply(_this);
                }
            );
        },

        /**
         * _setupOutline
         * 
         * @access  protected
         * @return  void
         */
        _setupOutline: function() {
            if (
                this.magnets.highlight === true
                && this.getCanvas() !== Canvases.Ghost
            ) {
                var cottons = {
                    centers: {
                        top: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        right: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        bottom: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        left: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        })
                    },
                    red: new fabric.Rect({
                        selectable: false,
                        visible: false,
                        stroke: 'rgba(255, 0, 0, 1)',
                        strokeDashArray: [5, 5],
                        strokeWidth: 1,
                        fill: ColorUtils.getBlack('rgba', 0),
                        left: 200,
                        top: 200,
                        width: 50,
                        height: 50
                    }),
                    white: new fabric.Rect({
                        selectable: false,
                        visible: false,
                        stroke: ColorUtils.getWhite('rgba'),
                        strokeDashArray: [0, 5, 5, 0],
                        strokeWidth: 1,
                        fill: ColorUtils.getBlack('rgba', 0),
                        left: 200,
                        top: 200,
                        width: 50,
                        height: 50
                    })
                };
                this.getCanvas().getCotton().add(cottons.centers.top);
                this.getCanvas().getCotton().add(cottons.centers.right);
                this.getCanvas().getCotton().add(cottons.centers.bottom);
                this.getCanvas().getCotton().add(cottons.centers.left);
                this.getCanvas().getCotton().add(cottons.red);
                this.getCanvas().getCotton().add(cottons.white);
                this._outline = cottons;

                /** 
                 * resize
                 * 
                 * Moves the outline and center points to the relevant positions
                 * for a drawing.
                 * 
                 * @access  private
                 * @return  void
                 */
                var resize = function() {

                    // Reposition centers
                    this.setCoords();
                    var bounding = this.getBoundingRect();
                    cottons.centers.top.set({
                        left: bounding.left + (bounding.width / 2).round(0) - 2 - 1 - 0.5,
                        top: bounding.top - 2
                    });
                    cottons.centers.right.set({
                        left: bounding.left + bounding.width - 2,
                        top: bounding.top + (bounding.height / 2).round(0) - 2
                    });
                    cottons.centers.bottom.set({
                        left: bounding.left + (bounding.width / 2).round(0) - 2 - 1 - 0.5,
                        top: bounding.top + bounding.height - 2
                    });
                    cottons.centers.left.set({
                        left: bounding.left - 2,
                        top: bounding.top + (bounding.height / 2).round(0) - 2
                    });

                    // Reposition borders
                    cottons.red.set({
                        left: bounding.left,
                        top: bounding.top,
                        width: bounding.width,
                        height: bounding.height
                    });
                    cottons.white.set({
                        left: bounding.left,
                        top: bounding.top,
                        width: bounding.width,
                        height: bounding.height
                    });
                };
                this.on({
                    'refresh': function(event) {
                        resize.apply(this._cotton);
                    }
                });
                this._cotton.on({
                    'changed': resize.proxy(this._cotton),
                    'removed': function() {
                        cottons.centers.top.remove();
                        cottons.centers.right.remove();
                        cottons.centers.bottom.remove();
                        cottons.centers.left.remove();
                        cottons.red.remove();
                        cottons.white.remove();
                    },
                    'moving': resize.proxy(this._cotton),
                    'resize/outline': resize.proxy(this._cotton),
                    'rotating': resize.proxy(this._cotton),
                    'scaling': resize.proxy(this._cotton)
                });
                this._layer.on({
                    'refresh/dimensions': resize.proxy(this._cotton)
                });
                this._cotton.canvas.on({
                    'mouse:move': function() {
                        cottons.centers.top.set('visible', false);
                        cottons.centers.right.set('visible', false);
                        cottons.centers.bottom.set('visible', false);
                        cottons.centers.left.set('visible', false);
                        cottons.red.set('visible', false);
                        cottons.white.set('visible', false);
                    }
                });
                resize.apply(this._cotton);
            }
        },

        /**
         * autoAlign
         * 
         * Centers the drawing both vertically and horizontally in the canvas.
         * Then triggers the appropriate style changes in the Layer to ensure
         * it's properly saved.
         * 
         * @access  public
         * @return  void
         */
        autoAlign: function() {
            var backgroundRectangleLayer = Canvases.Preview.getBackgroundRectangleLayer(),
                boundingRect = backgroundRectangleLayer.getCotton().getBoundingRect(),
                middlePoint = {
                    x: boundingRect.width / 2,
                    y: boundingRect.height / 2
                };
            this._cotton.set({
                left: middlePoint.x,
                top: middlePoint.y
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    left: ((middlePoint.x * 100) / dimensions.width).round(4),
                    top: ((middlePoint.y * 100) / dimensions.height).round(4)
                };
            this._layer.setStyles(relative);
            Canvases.Preview.render();
            this.triggerHandler('refresh');
        },

        /**
         * bb
         * 
         * Bounding box controls.
         * 
         * @todo!   Look into whether this is needed
         * @access  public
         * @var     Object
         */
        bb: {

            /**
             * hide
             * 
             * @access  public
             * @return  Drawing
             */
            hide: function() {
                var type = this._string;
                if (type === 'BackgroundRectangleDrawing') {
                    return this;
                }
                this._cotton.hasBorders = false;
                this._cotton.hasControls = false;
                this._cotton.hasRotatingPoint = false;
                this._cotton.canvas.renderAll();
                return this;
            },

            /**
             * show
             * 
             * @access  public
             * @return  Drawing
             */
            show: function() {
                var type = this._string;
                if (type === 'BackgroundRectangleDrawing') {
                    return this;
                }
                this._cotton.hasBorders = true;
                this._cotton.hasControls = true;
                this._cotton.hasRotatingPoint = true;
                this._cotton.canvas.renderAll();
                return this;
            }
        },

        /**
         * drawn
         * 
         * @access  public
         * @return  Boolean
         */
        drawn: function() {
            return this._drawn === true;
        },

        /**
         * getCanvas
         * 
         * @access  public
         * @return  CanvasView
         */
        getCanvas: function() {
            return this._layer.getCanvas();
        },

        /**
         * getCotton
         * 
         * @access  public
         * @return  fabric.Object
         */
        getCotton: function() {
            return this._cotton;
        },

        /**
         * getLayer
         * 
         * @access  public
         * @return  Layer
         */
        getLayer: function() {
            return this._layer;
        },

        /**
         * getOutline
         * 
         * @access  public
         * @return  null|Object
         */
        getOutline: function() {
            return this._outline;
        },

        /**
         * highlight
         * 
         * @access  public
         * @param   Object options
         * @return  Boolean
         */
        highlight: function(options) {
            if (this.magnets.highlight === false) {
                return false;
            }
            this._outline.red.setVisible(true);
            this._outline.white.setVisible(true);
            if (Account.highlightCenterGuidesOnSnap() === false) {
                return true;
            }
            if (options.showHorizontalLineCenters === true) {
                this._outline.centers.top.setVisible(true);
                this._outline.centers.bottom.setVisible(true);
                return true;
            }
            if (options.showVerticalLineCenters === true) {
                this._outline.centers.right.setVisible(true);
                this._outline.centers.left.setVisible(true);
                return true;
            }
            return true;
        },

        /**
         * magnets
         * 
         * Wrapper object for magnet-related functions. Ensure that the proper
         * context is defined against functions called within this object.
         * 
         * @access  public
         * @var     Function
         */
        magnets: function() {
            return {

                /**
                 * angles
                 * 
                 * Magnetizes a drawing to 45-degree angles so long as the
                 * canvas is not a Ghost (useless there).
                 * 
                 * @access  protected
                 * @return  void
                 */
                angles: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        var threshold = this.magnets.thresholds.rotating;
                        this._cotton.snapToAngleOnRotate(
                            threshold.angle,
                            threshold.pixels
                        );
                    }
                },

                /**
                 * demagnetize
                 * 
                 * Demagnetizes a drawing by removing it from the array of
                 * drawings stored within the canvas fabric object.
                 * Demagnetizing prevents other drawings from snapping to it.
                 * 
                 * @access  protected
                 * @return  void
                 */
                demagnetize: function() {
                    var _this = this,
                        drawings = this._cotton.canvas.magnets.drawings;
                    jQuery.each(drawings, function(index, drawing) {
                        if (drawing === _this) {
                            drawings.splice(index, 1);
                        }
                    });
                },

                /**
                 * highlight
                 * 
                 * @access  protected
                 * @var     Boolean (default: true)
                 */
                highlight: true,

                /**
                 * inbound
                 * 
                 * Ensures other drawings can be snapped to this one by adding
                 * the drawing to the array of drawings stored within the canvas
                 * fabric object. A check between the current and ghost canvas
                 * is made to ensure drawings that are temporary (eg. created
                 * during the ghost rendering process) are not added, since
                 * there's no point for those to be magnetized (and doing so
                 * causes issues since those drawings are never formally
                 * deleted, which results in drawings not available in the
                 * preview canvas being snapped to).
                 * 
                 * @access  protected
                 * @return  void
                 */
                inbound: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        this._setupOutline();
                        this._cotton.canvas.magnets.drawings.push(this);
                    }
                },

                /**
                 * outbound
                 * 
                 * Ensures the drawing can be snapped to other drawings by
                 * adding listeners on the fabric object. A check is made
                 * between the current ghost canvas to prevent adding the events
                 * when it's the ghost canvas being rendered. Not useful there.
                 * 
                 * @access  protected
                 * @return  void
                 */
                outbound: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        var snapToDrawingsOnScale = Config.default('snapToDrawingsOnScale');
                        this._cotton.snapToDrawingsOnMove();
                        if (snapToDrawingsOnScale === true) {
                            this._cotton.snapToDrawingsOnScale();
                        }
                    }
                },

                /**
                 * thresholds
                 * 
                 * @note    Order here reflects how I visualize them in my head,
                 *          rather than alphabetically.
                 * @access  protected
                 * @var     Object
                 */
                thresholds: {
                    moving: {
                        pixels: {
                            horizontal: {
                                centerToCenter: 6,
                                // centerToLeft: 6
                                // centerToRight: 6,

                                leftToCenter: 6,// Helpful for collages
                                leftToLeft: 6,
                                leftToRight: 6,

                                rightToCenter: 6,// Helpful for collages
                                rightToLeft: 6,
                                rightToRight: 6
                            },
                            vertical: {
                                centerToCenter: 6,
                                // centerToTop: 6,
                                // centerToBottom: 6,

                                topToCenter: 6,// Helpful for collages
                                topToTop: 6,
                                topToBottom: 6,

                                bottomToCenter: 6,// Helpful for collages
                                bottomToTop: 6,
                                bottomToBottom: 6
                            }
                        }
                    },
                    rotating: {
                        angle: 45,
                        pixels: 5
                    },
                    scaling: {
                        pixels: 6
                    }
                }
            };
        },

        /**
         * relative
         * 
         * @access  protected
         * @var     Function
         */
        relative: function() {
            return {

                /**
                 * left
                 * 
                 * @access  public
                 * @return  Number
                 */
                left: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('left').toFloat() / 100,
                        pixels = (dimensions.width * percentage).round(4);
                    return pixels;
                },

                /**
                 * top
                 * 
                 * @access  public
                 * @return  Number
                 */
                top: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('top').toFloat() / 100,
                        pixels = (dimensions.height * percentage).round(4);
                    return pixels;
                },

                /**
                 * width
                 * 
                 * @access  public
                 * @return  Number
                 */
                width: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('width').toFloat() / 100,
                        pixels = (dimensions.width * percentage).round(4);
                    return pixels;
                }
            };
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            this.getCanvas().getCotton().setActiveObject(this._cotton);
        }
    });
});
window.DependencyLoader.push('BitmapImageDrawing', function() {

    /**
     * BackgroundBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.BackgroundBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundBitmapImageDrawing')
         */
        _string: 'BackgroundBitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   BackgroundBitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addFiltersListeners();
            this._addMoveListeners();
            this._addSelectListeners();
            this._addSnapListeners();
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    Toolbars.show('backgroundBitmapImage');
                }
            });
        },

        /**
         * _getDefaultOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaultOptions: function() {
            var defaultOptions = {
                hasBorders: false,
                hasControls: false,
                padding: 0
            };
            defaultOptions = DataUtils.merge(this._super(), defaultOptions);
            return defaultOptions;
        },

        /**
         * _getInvisibleImageUrl
         * 
         * @access  protected
         * @return  String
         */
        _getInvisibleImageUrl: function() {
            var path = '/app/static/images/invisible.png',
                url = RequestUtils.url.static(path);
            return url;
        },

        /**
         * _getMediaKeyUrl
         * 
         * See ImageUtils.js for detailed documentation on the <getFrameUrl>
         * method. In short, it attempts to determine the ideal URL to use,
         * given the canvas' width / height.
         * 
         * @access  protected
         * @return  String
         */
        _getMediaKeyUrl: function() {
            var cropSourceKey = this._layer.getProperty('cropSourceKey');
            if (cropSourceKey === '') {
                var key = this._layer.getProperty('image'),
                    canvas = this.getCanvas(),
                    url = ImageUtils.getFrameUrl(key, canvas);
                return url;
            }
            if (DataUtils.valid(cropSourceKey) === false) {
                var key = this._layer.getProperty('image'),
                    canvas = this.getCanvas(),
                    url = ImageUtils.getFrameUrl(key, canvas);
                return url;
            }
            var canvas = this.getCanvas(),
                url = ImageUtils.getFrameUrl(cropSourceKey, canvas);
            url = this._applyCropTransformation(url);
            return url;
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    flipX: layer.getStyle('flipX') === true,
                    flipY: layer.getStyle('flipY') === true,
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    zoom: layer.getStyle('zoom')
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * _getUrl
         * 
         * Attempts to load the image url for this layer, based on the image
         * property. If no image property defined (aka. false), or else it
         * points to a resource accessor that isn't in memory (can happen if
         * they switch to a resource, the image configuration gets saved, and
         * then they reload the page before the resource has been converted to
         * an asset), false is returned.
         * 
         * @access  protected
         * @return  false|String
         */
        _getUrl: function() {

            /**
             * No image defined in the layer, so send back false (which will
             * result in the empty image being drawn, and hidden).
             */
            var key = this._layer.getProperty('image');
            if (key === false) {
                return false;
            }

            // Asset, image or upload key
            if (key.match(/^asst/) !== null) {
                var url = this._getMediaKeyUrl();
                return url;
            }
            if (key.match(/^img0/) !== null) {
                var url = this._getMediaKeyUrl();
                return url;
            }
            if (key.match(/^upld/) !== null) {
                var url = this._getMediaKeyUrl();
                return url;
            }

            /**
             * Not an asset, image or upload record; this ought to mean it's a
             * resource. Check if it's in memory. If it's not, then it's likely
             * an invalid pointer to a 3rd-party resource that for some reason
             * did not get converted to an asset.
             * 
             * Otherwise, send back the small version of the 3rd-party resource.
             */
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                return false;
            }
            var url = accessor.url('small');
            return url;
        },

        /**
         * _loadImage
         * 
         * Attempts to load the image for this layer. If no image is explicitly
         * defined, callback is passed an image object, but with visible set to
         * false to ensure it's hidden.
         * 
         * @note    Cloudinary bails when half-pixel width / height values are
         *          passed in, so I always round up (<ceil> call). Not sure
         *          eactly how this affects scrubbing.
         * @access  protected
         * @param   Function callback
         * @return  Boolean
         */
        _loadImage: function(callback) {

            /** 
             * Grab the url for the image to load. If no valid image found (can
             * happen when no image was selected, or else referencing an invalid
             * 3rd-party resource), then substitute the invisible image, and 
             * mark the image as not-visible.
             */
            var url = this._getUrl(),
                fallbackToInvisibleImage = (function(event, image) {
                    this._loadInvisibleImage(function(image) {
                        callback({
                            image: image,
                            visible: false
                        });
                    });
                }).proxy(this);
            if (url === false) {
                fallbackToInvisibleImage();
                return false;
            }

            /** 
             * Image found
             * 
             */

            // Preload the image
            var crossOrigin = true,
                imageRequest = new ImageRequest(url, crossOrigin);
            imageRequest.once({
                'error': fallbackToInvisibleImage,
                'load': function(event, image) {
                    callback({
                        image: image,
                        visible: true
                    });
                }
            });
            imageRequest.request();
            return true;
        },

        /**
         * _loadInvisibleImage
         * 
         * Loads the backup invisible (1px by 1px) image, to be used when either
         * no image is set in the layer, or else one of the urls failed when
         * loading.
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _loadInvisibleImage: function(callback) {
            var url = this._getInvisibleImageUrl(),
                crossOrigin = true,
                imageRequest = new ImageRequest(url, crossOrigin);
            imageRequest.once({
                'error': function(event, image) {
                    var code = 'bbi172',
                        reference = 'backgroundBitmapImage';
                    Stencil.error(code, reference);
                },
                'load': function(event, image) {
                    callback(image);
                }
            });
            imageRequest.request();
        },

        /**
         * _resize
         * 
         * Notice that the resize event (and the property value) isn't triggered
         * until after the canvas itself has been rendered. This is to ensure
         * that any filters set against the image have been processed.
         * 
         * @see     https://i.imgur.com/eOpBX73.png
         * @access  protected
         * @return  void
         */
        _resize: function() {
            this.triggerHandler('resize/start');
            var _this = this,
                cotton = this._cotton;
            this._resizing = true;
            this._loadImage(function(response) {
                var image = response.image;
                cotton.setElement(
                    image,
                    function() {
                        cotton.setCoords();
                        _this._scaleToFrame();
                        _this.getCanvas().once({
                            'render': function(event) {
                                _this._resizing = false;
                                _this.triggerHandler('resize/complete');
                            }
                        });
                        _this.getCanvas().render();
                    }
                );
            });
        },

        /**
         * _scaleToFrame
         * 
         * @access  protected
         * @return  void
         */
        _scaleToFrame: function() {
            var dimensions = this.getCanvas().getRenderedDimensions(),
                ratio = this._cotton.width / this._cotton.height,
                zoom = this._getOptions().zoom;
            if (ratio > Frame.getRatio()) {
                this._cotton.scaleToHeight(dimensions.height * zoom);
            } else {
                this._cotton.scaleToWidth(dimensions.width * zoom);
            }
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions();
            this._loadImage(function(response) {

                // Fabric basics
                var cotton = new fabric.Image(response.image);
                layer.getCanvas().getCotton().add(cotton);
                _this._cotton = cotton;

                // Options (including visibility incase image removed)
                options.visible = response.visible;
                cotton.set(options);
                _this._scaleToFrame();

                // Filters
                _this._drawFilters();

                /**
                 * Note that while I add handlers like in other drawings, I do
                 * not call this.magnets.inbound, since the background rectangle
                 * view does the job of presenting an object that can have other
                 * layers snapped to it.
                 */
                _this._addListeners();
                cotton.makeSlidable();

                // Event dispatching
                _this._drawn = true;
                _this.triggerHandler('draw', [_this]);
            });
        },

        /**
         * refresh
         * 
         * @see     Resizing: http://jsfiddle.net/7gvJG/70/
         * @access  public
         * @return  void
         */
        refresh: function() {
            var url = this._getUrl();
            this._scaleToFrame();
            if (url !== false) {
                this._cotton.set({
                    'visible': true
                });
            }
            this._cotton.set({
                left: this.relative.left.apply(this),
                top: this.relative.top.apply(this)
            });
            this._scale();
            this._scaleToFrame();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * reload
         * 
         * This method has only one responsibility: to reload the image that is
         * set in the layer. To do so, it calls the helper _loadImage method,
         * and once the image has been loaded into memory, calls the
         * fabric-native setElement method.
         * 
         * It then calls refresh in order to have the image's width or height
         * scaled to the proper canvas-dimension, before scaling the image
         * itself (which itself calls the _resize method).
         * 
         * The issue with this flow is that it seems multiple calls to
         * _loadImage and setElement are made, since it's done below, and then
         * in the refresh method (via the _scale / _resize methods). Not sure
         * what's ideal here :/
         * 
         * @access  public
         * @return  void
         */
        reload: function() {
            var cotton = this._cotton,
                refresh = this.refresh.proxy(this);
            this._loadImage(function(response) {
                var image = response.image;
                cotton.setElement(image, refresh);
            });
        }
    });
});
window.DependencyLoader.push('RectangleDrawing', function() {

    /**
     * BackgroundRectangleDrawing
     * 
     * @extends RectangleDrawing
     */
    window.BackgroundRectangleDrawing = RectangleDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundRectangleDrawing')
         */
        _string: 'BackgroundRectangleDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   RectangleLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement. Other controls go through the
         * toolbar.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addSelectListeners();
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    Toolbars.show('backgroundRectangle');
                }
            });
        },

        /**
         * _getDefaultOptions
         * 
         * Note that although the Rectangle fabric drawing's bounding box cannot
         * be seen (because it's set to the exact dimensions of the canvas), it
         * is important for it's padding to be set to 0, otherwise layers snap
         * incorrectly when moving.
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaultOptions: function() {
            var defaultOptions = {
                hasBorders: false,
                hasControls: false,
                hasRotatingPoint: false,
                hoverCursor: 'default',
                lockMovementX: true,
                lockMovementY: true,
                moveCursor: 'default',
                padding: 0,
                selectable: true
            };
            defaultOptions = DataUtils.merge(this._super(), defaultOptions);
            return defaultOptions;
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    fill: layer.getStyle('backgroundColor'),
                    height: this.relative.height.apply(this),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var options = this._getOptions(),
                cotton = new fabric.Rect(options);
            this.getCanvas().getCotton().add(cotton);
            this._cotton = cotton;
            this.magnets.inbound.apply(this);
            this._addListeners();
            this._drawn = true;
            this.triggerHandler('draw', [this]);
            // this._cotton.on({
            //     'moving': function() {
            //         this.set({
            //             hoverCursor: 'default'
            //         });
            //     }
            // });
        },

        /**
         * highlight
         * 
         * Overwrites the Drawing::highlight method in order to use the Html
         * guides as the target for highlighting.
         * 
         * @access  public
         * @param   Object options
         * @return  Boolean
         */
        highlight: function(options) {
            if (this.magnets.highlight === false) {
                return false;
            }
            if (Account.highlightCenterGuidesOnSnap() === false) {
                return false;
            }
            var $guides = App.getElement().find('div.guides'),
                $verticalGuide = $guides.find('div.vertical'),
                $horizontalGuide = $guides.find('div.horizontal');
            if (options.showHorizontalLineCenters === true) {
                $verticalGuide.removeClass('hidden');
                return true;
            }
            if (options.showVerticalLineCenters === true) {
                $horizontalGuide.removeClass('hidden');
                return true;
            }
            return false;
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var options = this._getOptions();
            this._cotton.set(options);
            this._cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * relative
         * 
         * @access  public
         * @var     Object
         */
        relative: function() {
            return DataUtils.merge(this._super(), {
                /**
                 * height
                 * 
                 * @access  public
                 * @return  Number
                 */
                height: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('height').toInt() / 100,
                        pixels = (dimensions.height * percentage).round(4);
                    return pixels;
                }
            })
        }
    });
});
window.DependencyLoader.push('ImageDrawing', function() {

    /**
     * BitmapImageDrawing
     * 
     * @events  resize/start
     *          resize/complete
     *          applyFilters/complete
     *          applyFilters/start
     * @see     http://jsperf.com/lanczos-resampling
     * @see     https://www.viget.com/articles/instagram-style-filters-in-html5-canvas
     * @see     http://stackoverflow.com/questions/2303690/resizing-an-image-in-an-html5-canvas?lq=1
     * @extends ImageDrawing
     */
    window.BitmapImageDrawing = ImageDrawing.extend({

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Object
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'filters': function() {
                    this._layer.on({
                        'filter/add': function(event, obj) {
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                type = obj.type,
                                properties = obj.properties || {},
                                filter;
                            filter = drawing._filter[type].apply(this, [properties]);
                            filter.set('_stencilType', type);
                            cotton.filters.push(filter);
                            this.getCanvas().render();
                        },
                        'filter/remove': function(event, obj) {
                            var cotton = this.getCotton(),
                                filters = cotton.filters || [];
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].get('_stencilType') === obj.type) {
                                    filters.splice(i, 1);
                                }
                            }
                            this.getCanvas().render();
                        },
                        'filter/update': function(event, obj) {
                            var cotton = this.getCotton(),
                                rawFilters = cotton.get('filters'),
                                index, rawFilter;
                            for (index in rawFilters) {
                                rawFilter = rawFilters[index];
                                if (rawFilter.get('_stencilType') === obj.type) {
                                    if (obj.type === 'blur') {
                                        var radius = obj.properties.strength / 3,
                                            dimensions = this.getCanvas().getRenderedDimensions();
                                        radius *= dimensions.width;
                                        radius /= 365;
                                        radius = radius.round(0);
                                        rawFilter.options.args = [radius];
                                    } else if (obj.type === 'colorOverlay') {
                                        // LogUtils.log.simple(JSON.stringify(obj), true);
                                        rawFilter.color = obj.properties.color;
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'darken') {
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'lighten') {
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'opacity') {
                                        rawFilter.opacity = (100 - obj.properties.strength) / 100;
                                    }
                                }
                            }
                            this.getCanvas().render();
                        },
                    });
                }//,
                // 'colorOverlay': function() {
                //     this._layer.on({
                //         'change/colorOverlay': function(event, colorOverlay) {
                //             // var drawing = this._drawing,
                //             //     cotton = drawing.getCotton();
                //             // drawing.refreshStroke();
                //             // drawing.refreshShadow();
                //             // // cotton.trigger('changed');
                //             // this.triggerHandler('refresh/dimensions');
                //             // this.getCanvas().render();
                //         },
                //         'clear/colorOverlay': function(event) {
                //             // var drawing = this._drawing,
                //             //     cotton = this.getCotton();
                //             // drawing.refreshShadow();
                //             // cotton.setStroke(null);
                //             // cotton.setStrokeWidth(0);
                //             // // cotton.trigger('changed');
                //             // this.triggerHandler('refresh/dimensions');
                //             // this.getCanvas().render();
                //         }
                //     });
                // }
            });
        },

        /**
         * _resizing
         * 
         * @access  protected
         * @var     false|Boolean (default: false)
         */
        _resizing: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BitmapImageDrawing')
         */
        _string: 'BitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   BitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addFiltersListeners
         * 
         * @access  protected
         * @return  void
         */
        _addFiltersListeners: function() {
            var _this = this;
            this.on({
                'resize/start': function(event) {
                    var key = 'bitmapImageResizings',
                        bitmapImageResizings = Stencil.get(key) || 0;
                    Stencil.set(key, bitmapImageResizings);
                    if (this._layer.getProperty('filters').length > 0) {
                        bitmapImageResizings++;
                        Stencil.set(key, bitmapImageResizings);
                        var content = App.getStage().getContent();
                        content.interaction.block.apply(content);
                    }
                },
                'resize/complete': function(event) {
                    var key = 'bitmapImageResizings',
                        bitmapImageResizings = Stencil.get(key);
                    if (this._layer.getProperty('filters').length > 0) {
                        bitmapImageResizings--;
                        Stencil.set(key, bitmapImageResizings);
                        if (bitmapImageResizings === 0) {
                            var content = App.getStage().getContent();
                            content.interaction.unblock.apply(content);
                        }
                    }
                }
            });
            this._cotton.on({
                'applyFilters/complete': function() {
                    _this.triggerHandler('applyFilters/complete');
                },
                'applyFilters/start': function() {
                    _this.triggerHandler('applyFilters/start');
                }
            });
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._super();
            this._addFiltersListeners();
        },

        /**
         * _applyCropTransformation
         * 
         * @access  protected
         * @param   String url
         * @return  String
         */
        _applyCropTransformation: function(url) {
            var cropPositionData = this._layer.getProperty('cropPositionData');
            url = ImageUtils.applyCropTransformation(url, cropPositionData);
            return url;
        },

        /**
         * _drawFilters
         * 
         * @note    A check is made against the _filter object to ensure the
         *          filter-by-type is actually defined as a method, to prevent
         *          legacy images that used filters that are not supported (eg.
         *          colorsize) from breaking things.
         * @access  protected
         * @return  void
         */
        _drawFilters: function() {
            var _this = this,
                filters = this._layer.getProperty('filters'),
                filter,
                cotton = this._cotton,
                properties;
            jQuery.each(filters, function(index, obj) {
                if (_this._filter[obj.type] !== undefined) {
                    properties = obj.properties || {};
                    filter = _this._filter[obj.type].apply(_this, [properties]);
                    filter.set('_stencilType', obj.type);
                    cotton.filters.push(filter);
                    _this._layer.set({'renderFilters': true});
                }
            });
        },

        /**
         * _filter
         * 
         * @access  protected
         * @var     Object
         */
        _filter: {
            _1977: function(properties) {
                return new fabric.Image.filters.Caman('1977');
            },
            blur: function(properties) {
                var radius = 5;
                if (typeof properties.strength !== 'undefined') {
                    radius = properties.strength / 3;
                }
                var dimensions = this.getCanvas().getRenderedDimensions();
                radius *= dimensions.width;
                radius /= 365;
                return new fabric.Image.filters.Caman(
                    'stackBlur',
                    {
                        args: [
                            radius.round(0)
                        ]
                    }
                );
            },
            brannan: function(properties) {
                return new fabric.Image.filters.Caman('brannan');
            },
            bw: function() {
                return new fabric.Image.filters.Grayscale();
            },
            clarity: function(properties) {
                return new fabric.Image.filters.Caman('clarity');
            },
            /**
             * colorOverlay
             * 
             * @note    The ColorUtils call below is to ensure that whatever
             *          color is stored in the properties object, it is stored
             *          in the proper rgba format. There was a case on
             *          production whereby somehow the rgba value became
             *          rgba(,,,). The call below ensures a valid rgba value is
             *          always referenced.
             * @see     https://i.imgur.com/PMr715t.jpg
             * @access  private
             * @param   Object properties
             * @return  Object
             */
            colorOverlay: function(properties) {
                var color = ColorUtils.getBlack('rgba'),
                    strength = 0.5;
                if (typeof properties.color !== 'undefined') {
                    color = properties.color;
                    color = ColorUtils.convert(color, 'rgba');
                }
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: color,
                    opacity: strength
                });
            },
            // concentrate: function(properties) {
            //     return new fabric.Image.filters.Caman('concentrate');
            // },
            // crossProcess: function(properties) {
            //     return new fabric.Image.filters.Caman('crossProcess');
            // },
            darken: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: '#000000',
                    opacity: strength
                });
            },
            // glowingSun: function(properties) {
            //     return new fabric.Image.filters.Caman('glowingSun');
            // },
            gotham: function(properties) {
                return new fabric.Image.filters.Caman('gotham');
            },
            // grungy: function(properties) {
            //     return new fabric.Image.filters.Caman('grungy');
            // },
            // hazyDays: function(properties) {
            //     return new fabric.Image.filters.Caman('hazyDays');
            // },
            hefe: function(properties) {
                return new fabric.Image.filters.Caman('hefe');
            },
            // hemingway: function(properties) {
            //     return new fabric.Image.filters.Caman('hemingway');
            // },
            // herMajesty: function(properties) {
            //     return new fabric.Image.filters.Caman('herMajesty');
            // },
            // jarques: function(properties) {
            //     return new fabric.Image.filters.Caman('jarques');
            // },
            lighten: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: '#ffffff',
                    opacity: strength
                });
            },
            lomo: function(properties) {
                return new fabric.Image.filters.Caman('lomo');
            },
            lordKelvin: function(properties) {
                return new fabric.Image.filters.Caman('lordKelvin');
            },
            // love: function(properties) {
            //     return new fabric.Image.filters.Caman('love');
            // },
            // oldBoot: function(properties) {
            //     return new fabric.Image.filters.Caman('oldBoot');
            // },
            opacity: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = (100 - properties.strength) / 100;
                }
                return new fabric.Image.filters.Fade({
                    // drawing: this,
                    opacity: strength
                });
            },
            // orangePeel: function(properties) {
            //     return new fabric.Image.filters.Caman('orangePeel');
            // },
            // pinhole: function(properties) {
            //     return new fabric.Image.filters.Caman('pinhole');
            // },
            nashville: function(properties) {
                return new fabric.Image.filters.Caman('nashville');
            },
            // nostalgia: function(properties) {
            //     return new fabric.Image.filters.Caman('nostalgia');
            // },
            sepia: function() {
                // return new fabric.Image.filters.Sepia();
                // return new fabric.Image.filters.Sepia2();
                return new fabric.Image.filters.Caman('sepia');
            },
            sinCity: function(properties) {
                return new fabric.Image.filters.Caman('sinCity');
            },
            sunrise: function(properties) {
                return new fabric.Image.filters.Caman('sunrise');
            },
            vintage: function(properties) {
                return new fabric.Image.filters.Caman('vintage');
            },
            xPro: function(properties) {
                return new fabric.Image.filters.Caman('xPro');
            }
        },

        /**
         * _getMediaKeyUrl
         * 
         * @access  protected
         * @param   Number width
         * @return  String
         */
        _getMediaKeyUrl: function(width) {
            var key = this._layer.getProperty('image'),
                cropSourceKey = this._layer.getProperty('cropSourceKey'),
                ratio = UserAgentUtils.getDevicePixelRatio(),
                url;
            width *= ratio;
            url = ImageUtils.url.thumb(key, {
                type: 'scale',
                width: width.round(0)
            });
            if (cropSourceKey === '') {
                return url;
            }
            if (DataUtils.valid(cropSourceKey) === false) {
                return url;
            }
            url = ImageUtils.url.thumb(cropSourceKey, {
                type: 'scale',
                width: width.round(0)
            });
            url = this._applyCropTransformation(url);
            return url;
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * _resize
         * 
         * Loads in a resized version of the image, relative to the width value
         * for the layer. Note that since this is the parent-class for various
         * ImageLayer types, not all require a width-parameter to be sent to the
         * _getUrl method. Those that do not need it (at the moment,
         * VectorImageLayer since a width is not needed for resample there, and
         * BackgroundBitmapImageLayer, as the width is automatically determined
         * based on the Frame and preview-canvas sizing), simply ignore it.
         * 
         * @access  protected
         * @return  void
         */
        _resize: function() {
            this.triggerHandler('resize/start');
            this._resizing = true;
            var _this = this,
                cotton = this._cotton,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            this._cotton.setSrc(
                url,
                function() {
                    cotton.setCoords();
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();
                    layer.getCanvas().render();
                    _this._resizing = false;
                    _this.triggerHandler('resize/complete');
                },
                {
                    crossOrigin: 'anonymous'
                }
            );
        },

        /**
         * _scale
         * 
         * This is a helper method to facilitate some race-conditions that were
         * going on. This logic is also employed in BackgroundBitmapImageLayer
         * layers. The race-condition was that when the user resized the browser
         * too fast, it was possible for multiple resize-flows to happen. When
         * that was the case, sometimes the first resize-flow would be slow in
         * loading the new-sized image asset (done via the setSrc method below).
         * This would sometimes result in the wrong image being rendered after
         * the user let go of their mouse, simply because the second-resize-flow
         * would return faster than the first. This would be common if the
         * second-resize dimensions pointed to an image that was already in
         * cache.
         * 
         * So the logic here is intended to force the application to wait until
         * a resize has happened before initiating a new one. It's essentially
         * chaining them. While this isn't ideal for memory, it's suitable for
         * now.
         * 
         * Hypothetically, a more performative flow would be to cancel the
         * initial resize (if one is going on), and start with this new one.
         * 
         * It's also worth noting that with this logic, it's possible to
         * reproduce a janky experience whereby if the user resizes their window
         * fast-enough, images can shift between the wrong and right dimensions.
         * This is again because of race-conditions. The above
         * hypothetical-approach would address this.
         * 
         * @access  protected
         * @return  void
         */
        _scale: function() {
            this._resizing !== true ? this._resize() : this.once({
                'resize/complete': this._resize.proxy(this)
            });
        },

        /**
         * refresh
         * 
         * Resizes position properties of the layer relative to the new canvas
         * size (which comes into play via the _getOptions method).
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var cotton = this._cotton,
                options = this._getOptions();
            cotton.set({
                left: options.left,
                top: options.top
            });
            var scaledWidth = this._getScaledWidth();
            cotton.scaleToWidth(scaledWidth);
            var scaleX = (cotton.scaleX * this._layer.getStyle('stretchX')).round(4),
                scaleY = (cotton.scaleY * this._layer.getStyle('stretchY')).round(4);
            cotton.setScaleX(scaleX);
            cotton.setScaleY(scaleY);
            cotton.setCoords();
            this._scale();
            cotton.scaleToWidth(scaledWidth);
            this.triggerHandler('refresh', [this]);
        }
    });
});
window.DependencyLoader.push('VectorImageDrawing', function() {

    /**
     * ColorVectorImageDrawing
     * 
     * @extends VectorImageDrawing
     */
    window.ColorVectorImageDrawing = VectorImageDrawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'opacityStrength': function() {
                    this._layer.on({
                        'change/opacityStrength': function(event, opacityStrength) {
                            var cotton = this.getCotton(),
                                opacityValue = ((100 - opacityStrength) / 100).round(2);
                            cotton.setOpacity(opacityValue);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorVectorImageDrawing')
         */
        _string: 'ColorVectorImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   VectorImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('colorVectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    opacity: layer.getStyle('opacity').toFloat(),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        }
    });
});
window.DependencyLoader.push('BitmapImageDrawing', function() {

    /**
     * ForegroundBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.ForegroundBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ForegroundBitmapImageDrawing')
         */
        _string: 'ForegroundBitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   ForegroundBitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addMoveListeners
         * 
         * @access  protected
         * @return  void
         */
        _addMoveListeners: function() {
            this._super();
            var transformed = false;
            this._cotton.on({
                'moving': function(event) {
                    if (transformed === false) {
                        transformed = true;
                        this.set({
                            opacity: 0.7
                        });
                        Canvases.Preview.render();
                    }
                },
                'modified': function(event) {
                    transformed = false;
                    this.set({
                        opacity: 1
                    });
                    Canvases.Preview.render();
                }
            });
        },

        /**
         * _addScaleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            this._super();
            var delay = Config.getResizeDelay('foregroundBitmapImage');
            this._cotton.on({
                'scaling': _.debounce(this._scale.proxy(this), delay),
                'scaling/manual': _.debounce(this._scale.proxy(this), delay)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('foregroundBitmapImage');
                }
            });
        },

        /**
         * _getUrl
         * 
         * @access  protected
         * @param   Number width
         * @return  String
         */
        _getUrl: function(width) {

            // Asset, image or upload key
            var key = this._layer.getProperty('image');
            if (key.match(/^asst/) !== null) {
                var url = this._getMediaKeyUrl(width);
                return url;
            }
            if (key.match(/^img0/) !== null) {
                var url = this._getMediaKeyUrl(width);
                return url;
            }
            if (key.match(/^upld/) !== null) {
                var url = this._getMediaKeyUrl(width);
                return url;
            }

            /**
             * Not an asset, image or upload record; this ought to mean it's a
             * resource. Check if it's in memory. If it's not, then it's likely
             * an invalid pointer to a 3rd-party resource that for some reason
             * did not get converted to an asset.
             * 
             * Otherwise, send back the small version of the 3rd-party resource.
             */
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                return false;
            }
            var url = accessor.url('small');
            return url;
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            fabric.util.loadImage(
                url,
                function(image) {

                    // Fabric basics
                    var cotton = new fabric.Image(image);
                    layer.getCanvas().getCotton().add(cotton);
                    _this._cotton = cotton;

                    /**
                     * Options
                     * 
                     * I set the general options first. I then set the width by
                     * scaling the object to the desired value. Finally, I set
                     * the angle *_after_* the width has been set. If I set the
                     * angle first, the width is decreased.
                     */
                    var angle = options.angle;
                    delete options.angle;
                    delete options.width;
                    cotton.set(options);
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    cotton.setAngle(angle);

                    // Scaling
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();

                    // Filters
                    _this._drawFilters();

                    // Events
                    _this._addListeners();
                    _this.magnets.angles.apply(_this);
                    _this.magnets.outbound.apply(_this);
                    cotton.boxIn(_this._boxInRatio);
                    _this.magnets.inbound.apply(_this);

                    // Done drawing; trigger event
                    _this._drawn = true;
                    _this.triggerHandler('draw', [_this]);
                },
                this,
                {
                    crossOrigin: 'anonymous'
                }
            );
        }
    });
});
window.DependencyLoader.push('Drawing', function() {

    /**
     * ImageDrawing
     * 
     * @extends Drawing
     */
    window.ImageDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Object
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'flip': function() {
                    this._layer.on({
                        'flip/x': function(event, flip) {
                            var cotton = this.getCotton();
                            cotton.setFlipX(flip);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'flip/y': function(event, flip) {
                            var cotton = this.getCotton();
                            cotton.setFlipY(flip);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageDrawing')
         */
        _string: 'ImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   ImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addBoxInListeners();
            this._addMoveListeners();
            this._addRotateListeners();
            this._addScaleListeners();
            this._addSelectListeners();
            this._addSnapListeners();
        },

        /**
         * _addScaleListeners
         * 
         * This is a complicated beast. Scaling a VectorImageDrawing affects the
         * positioning (left/right), flip properties (since it can be stretched
         * beyond/above/below an axis/fold) and scale properties. The below
         * logic interprets scaling, and finds the lowest scale value for the
         * x/y axis. I do this to ensure I get _some_ width value stored in the
         * layer. I then normalize the stretch and width values relative to that
         * scaling value. The width and left/top styles are then normalized
         * relative to the canvas dimensions.
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            var _this = this,
                closure = function(event) {

                    // Dimensions
                    var scaleX = this.scaleX,
                        scaleY = this.scaleY,
                        flipX = this.flipX,
                        flipY = this.flipY,
                        factor = Math.min(scaleX, scaleY),
                        width = (this.width * factor).round(4),
                        stretchX = (scaleX / factor).round(4),
                        stretchY = (scaleY / factor).round(4);

                    // Adjust width to be relative
                    var current = _this.getCanvas().getRenderedDimensions();
                    width = ((width / current.width) * 100).round(4);

                    // Adjust left/right to be relative
                    var left = ((this.left / current.width) * 100).round(4),
                        top = ((this.top / current.height) * 100).round(4);
                    // width = (current.width * percentage).round(4);

                    // Done
                    var dimensions = {
                        left: left,
                        top: top,
                        width: width,
                        stretchX: stretchX,
                        stretchY: stretchY,
                        flipX: flipX,
                        flipY: flipY
                    };
                    _this._layer.triggerHandler('change/dimensions', [dimensions]);
                };
            this._cotton.on({
                'scaling': closure.proxy(this._cotton),
                'scaling/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _getScaledWidth
         * 
         * This function returns the adjusted width for the cotton object,
         * taking into consideration the size of the bounding rectangle. Most of
         * the time, nothing is actually changed, since the bounding rectangle
         * and the cotton object width are the same. But on tablets, for
         * example, it is different, since padding is added to layers. Because
         * of this, the bounding rectangle dimensions are increased.
         * 
         * A funny gotcha is that when the cotton object is initially drawn (in
         * the draw method), regardless of whether there is padding defined,
         * the bounding rectangle dimensions match that of the cotton object
         * itself. I believe this is because the canvas hasn't been rendered
         * (via the renderAll method against the canvas cotton object). So while
         * I'm calling this helper-method from within the draw logic, it is
         * irrelevant (at least right now). This may change later depending on
         * the flow I do for rendering cotton objects, or else for some other
         * unforeseen reason.
         * 
         * @access  protected
         * @return  Number
         */
        _getScaledWidth: function() {
            var options = this._getOptions(),
                width = options.width,
                cotton = this._cotton,
                boundingRectFactor = cotton.getBoundingRect().width / cotton.getWidth();
            return (width * boundingRectFactor).round(4);
        },

        /**
         * animate
         * 
         * @note    There's a bug here with some icons (VectorImage drawings),
         *          whereby if it's made up of many paths, some of them might not
         *          animate. This can be seen with this icon:
         *          https://i.imgur.com/sOPbC4d.png
         *          It's really subtle, but it's there.
         * @note    I have to detect the initial opacity, because for
         *          ColorVectorImageDrawing's the opacity can be controlled, and
         *          before, I was simply setting the opacity to 1 for this
         *          animation, which was creating inconsistencies when a
         *          ColorVectorImageLayer was cloned (and the original had an
         *          opacity value that was not set to 1).
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton(),
                top = this._cotton.get('top'),
                opacity = this._cotton.get('opacity');
            this._cotton.animate('top', top, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: top - 50,
                onChange: cotton.renderAll.bind(cotton)
            });
            this._cotton.animate('opacity', opacity, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: Math.max(0.2, opacity - 0.7),
                onChange: cotton.renderAll.bind(cotton)
            });
        }
    });
});
window.DependencyLoader.push('Drawing', function() {

    /**
     * RectangleDrawing
     * 
     * @extends Drawing
     */
    window.RectangleDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Object
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'backgroundColor': function() {
                    this._layer.on({
                        'change/backgroundColor': function(event, backgroundColor, removed) {
                            var cotton = this.getCotton();
                            cotton.setColor(backgroundColor);
                            this.getCanvas().render();
                        },
                        'clear/backgroundColor': function(event) {
                            var cotton = this.getCotton(),
                                transparentBlack = ColorUtils.getBlack('rgba', 0);
                            cotton.setColor(transparentBlack);
                            this.getCanvas().render();
                        },
                        'reset/backgroundColor': function(event) {
                            var cotton = this.getCotton(),
                                white = ColorUtils.getWhite('rgba');
                            cotton.setColor(white);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RectangleDrawing')
         */
        _string: 'RectangleDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   RectangleLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        }
    });
});
window.DependencyLoader.push('Drawing', function() {

    /**
     * TextDrawing
     * 
     * @fires   draw
     *          refresh
     *          preview/fontFamily
     * @extends Drawing
     */
    window.TextDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'align': function() {
                    this._layer.on({
                        'change/align': function(event, position) {
                            var cotton = this.getCotton();
                            cotton.setTextAlign(position);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'backdropColor': function() {
                    this._layer.on({
                        'change/backdropColor': function(event, backdropColor) {
                            var cotton = this.getCotton(),
                                backdropStretch = this.getStyle('backdropStretch');
                            cotton.addBackdrop(backdropColor, backdropStretch);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'change/backdropStretch': function(event, backdropStretch) {
                            var cotton = this.getCotton(),
                                backdropColor = this.getStyle('backdropColor');
                            cotton.addBackdrop(backdropColor, backdropStretch);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'clear/backdropColor': function(event) {
                            var cotton = this.getCotton();
                            cotton.clearBackdrop();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                    });
                },
                'bold': function() {
                    this._layer.on({
                        'change/bold': function(event, on) {
                            var _this = this,
                                fontFamily = this.getStyle('fontFamily'),
                                drawing = this._drawing,
                                cotton = drawing.getCotton();

                            // Load font
                            var fontsCollection = Stencil.account().collection('fonts'),
                                font = fontsCollection.findByFamilyName(fontFamily);
                            font.loadFull(function() {
                                var weight = 'normal';
                                if (on === true) {
                                    weight = 'bold';
                                }
                                cotton.setFontWeight(weight);
                                drawing.refreshStroke();
                                drawing.refreshShadow();
                                // cotton.trigger('changed');
                                _this.triggerHandler('refresh/dimensions');
                                _this.getCanvas().render();
                            });
                        },
                        'revert/bold': function(event) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setFontWeight('normal');
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'shadowStrength': function() {
                    this._layer.on({
                        'change/shadowStrength': function(event, shadowStrength) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'fontFamily': function() {
                    this._layer.on({

                        /**
                         * (anonymous)
                         * 
                         * @access  private
                         * @param   Object event
                         * @param   FontAccessor font
                         * @return  void
                         */
                        'change/fontFamily': function(event, font) {
                            var fontFamily = font.get('familyName'),
                                cotton = this.getCotton();
                            cotton.setFontFamily(fontFamily);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @access  private
                         * @param   Object event
                         * @param   FontAccessor font
                         * @return  void
                         */
                        'preview/fontFamily': function(event, font) {
                            var fontFamily = font.get('familyName');
                            this._cotton.setFontFamily(fontFamily);
                            // this._cotton.trigger('changed');
                            this.getLayer().triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'fontSize': function() {
                    this._layer.on({
                        'change/fontSize': function(event, fontSize) {
                            var drawing = this._drawing,
                                size = drawing.relative.fontSize.apply(drawing),
                                cotton = drawing.getCotton();
                            cotton.setFontSize(size);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'italic': function() {
                    this._layer.on({
                        'change/italic': function(event, on) {
                            var _this = this,
                                fontFamily = this.getStyle('fontFamily'),
                                drawing = this._drawing,
                                cotton = drawing.getCotton();

                            // Load font
                            var fontsCollection = Stencil.account().collection('fonts'),
                                font = fontsCollection.findByFamilyName(fontFamily);
                            font.loadFull(function() {
                                var style = 'normal';
                                if (on === true) {
                                    style = 'italic';
                                }
                                cotton.setFontStyle(style);
                                drawing.refreshStroke();
                                drawing.refreshShadow();
                                // cotton.trigger('changed');
                                _this.triggerHandler('refresh/dimensions');
                                _this.getCanvas().render();
                            });
                        },
                        'revert/italic': function(event) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setFontStyle('normal');
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'lineHeight': function() {
                    this._layer.on({
                        'change/lineHeight': function(event, lineHeight) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setLineHeight(lineHeight);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'strokeColor': function() {
                    this._layer.on({
                        'change/strokeColor': function(event, strokeColor) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'clear/strokeColor': function(event) {
                            var drawing = this._drawing,
                                cotton = this.getCotton();
                            drawing.refreshShadow();
                            cotton.setStroke(null);
                            cotton.setStrokeWidth(0);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'textColor': function() {
                    this._layer.on({
                        'change/textColor': function(event, textColor) {
                            var cotton = this.getCotton();
                            cotton.setColor(textColor);
                            this._drawing.refreshShadow();
                            this.getCanvas().render();
                        }
                    });
                },
                'underline': function() {
                    this._layer.on({
                        'change/underline': function(event, on) {
                            var decoration = '',
                                drawing = this._drawing,
                                cotton = drawing.getCotton();
                            if (on === true) {
                                decoration = 'underline';
                            }
                            cotton.setTextDecoration(decoration);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TextDrawing')
         */
        _string: 'TextDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   TextLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement. Other controls go through the
         * text toolbar.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addBoxInListeners();
            this._addMoveListeners();
            this._addRotateListeners();
            this._addScaleListeners();
            this._addSelectListeners();
            this._addSnapListeners();
            this._addTextChangeListeners();
        },

        /**
         * _addScaleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            var _this = this,
                closure = function(event) {
                    _this._layer.triggerHandler(
                        'change/dimensions',
                        [_this.getDimensions()]
                    );
                    _this._layer.setChangeOperationType('scaled');
                };
            this._cotton.on({
                'scaling': closure.proxy(this._cotton),
                'scaling/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('text');
                }
            });
        },

//         /**
//          * _addSelectListeners
//          * 
//          * So this was something I was playing with on January 5th, 2016, to
//          * make selecting a layer smarter. It was attempting to do the
//          * following:
//          * When an object was selected, check if there are any other layers
//          * that have an exact pixel of the object clicked (hence the usage of
//          * the <isTargetTransparent> method). The <containsPoint> might not
//          * be required? Hmm. Not sure. When a pixel was found, I waited 0
//          * milliseconds, and switched to that one. Noticed the bounding box
//          * appeared for a moment, so this may not be the most elegant
//          * solution. Don't delete this code, since I'll probably want to come
//          * back to it post-launch.
//          * 
//          * @see      https://github.com/kangax/fabric.js/issues/601
//          * @see      https://github.com/kangax/fabric.js/issues/28
//          * @see      http://stackoverflow.com/questions/19033989/fabric-js-containspoint-function-to-find-if-the-point-is-inside-the-actual-conte
//          * @see      https://groups.google.com/forum/#!topic/fabricjs/OhMkv6Mmpgo
//          * @access  protected
//          * @return  void
//          */
//         _addSelectListeners: function() {
//             var _this = this;
//             this._cotton.on({
//                 'selected': function(options) {
//                     var layers = [];
//                     if (options.e !== undefined) {
// LogUtils.log.simple(_this._layer, true);
//                         var point = new fabric.Point(
//                             options.e.layerX,
//                             options.e.layerY
//                         );
//                         layers = Canvases.Preview.getImageDocument().filter(
//                             function(index, layer) {
//                                 var cotton = layer.getCotton();
//                                 return layer.getStyle('order').toInt() !== 0
//                                     && layer !== _this._layer
//                                     && cotton.containsPoint(point) === true
//                                     && Canvases.Preview.getCotton().isTargetTransparent(
//                                         cotton,
//                                         options.e.layerX,
//                                         options.e.layerY
//                                     ) === false;
//                             }
//                         );
//                     }
// LogUtils.log.simple(layers, true);
//                     if (layers.length === 0) {
//                         Canvases.Preview.setSelectedLayer(_this._layer);
//                         _this.bb.show.apply(_this);
//                         Toolbars.getToolbar('text').show();
//                         Toolbars.getToolbar('vectorImage').hide();
//                         Toolbars.getToolbar('watermarkBitmapImage').hide();
//                     } else {
//                         var layer = layers[0],
//                             _fabric = layer.getCotton();
// // LogUtils.log.simple([layer, _fabric], true);
//                         setTimeout(function() {
//                             Canvases.Preview.setSelectedLayer(layer);
//                             Canvases.Preview.getCotton().setActiveObject(_fabric);
//                         }, 0);
//                     }
//                 }
//             });
//         },

        /**
         * _addTextChangeListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTextChangeListeners: function() {
            var _this = this;
            this._cotton.on({
                'changed': function(event) {
                    var text = this.getText();
                    _this._layer.triggerHandler('change/text', [text]);
                }
            });
        },

        /**
         * _getBackdropPaddingFactor
         * 
         * @access  protected
         * @return  Number
         */
        _getBackdropPaddingFactor: function() {
            var backdropPaddingFactor = this._layer.getStyle(
                'backdropPaddingFactor'
            );
            if (backdropPaddingFactor === undefined) {
                return Config.default('backdropPaddingFactor').toFloat();
            }
            return backdropPaddingFactor.toFloat();
        },

        /**
         * _getDefaultOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaultOptions: function() {
            var defaultOptions = {
                cursorColor: ColorUtils.getBlack('rgba'),
                cursorDelay: 1000,
                cursorDuration: 200,
                cursorWidth: 1,
                editingBorderColor: ColorUtils.getBlack('rgba', 0.25),
                strokeLineCap: 'round',
                strokeLineJoin: 'round'
            };
            defaultOptions = DataUtils.merge(this._super(), defaultOptions);
            return defaultOptions;
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {

            // Formatting
            var layer = this._layer,
                fontWeight = 'normal',
                fontStyle = 'normal',
                textDecoration = '';
            if (layer.getStyle('bold') === true) {
                fontWeight = 'bold';
            }
            if (layer.getStyle('italic') === true) {
                fontStyle = 'italic';
            }
            if (layer.getStyle('underline') === true) {
                textDecoration = 'underline';
            }

            // Options
            var options = {
                    angle: layer.getStyle('angle').toFloat(),
                    backdropPaddingFactor: this._getBackdropPaddingFactor(),
                    fill: layer.getStyle('textColor'),
                    fontFamily: layer.getStyle('fontFamily'),
                    fontSize: this.relative.fontSize.apply(this),
                    fontStyle: fontStyle,
                    fontWeight: fontWeight,
                    left: this.relative.left.apply(this),
                    lineHeight: layer.getStyle('lineHeight').toFloat(),
                    shadow: this.relative.shadow.apply(this),
                    textAlign: layer.getStyle('align'),
                    top: this.relative.top.apply(this),
                    textDecoration: textDecoration,
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * _getStrokeWidth
         * 
         * Since the fontSize style is relative to the canvas width, I only need
         * to multiply the number by an arbitrary constant to get a good looking
         * stroke across the board.
         * 
         * @access  protected
         * @return  Number
         */
        _getStrokeWidth: function() {
            var size = this.relative.fontSize.apply(this),
            // var size = this._cotton.get('fontSize'),
                strokeWidthDividingFactor = this._getStrokeWidthDividingFactor();
            return (size * strokeWidthDividingFactor).round(4);
        },

        /**
         * _getStrokeWidthDividingFactor
         * 
         * @access  protected
         * @return  Number
         */
        _getStrokeWidthDividingFactor: function() {
            var strokeWidthDividingFactor = this._layer.getStyle(
                'strokeWidthDividingFactor'
            );
            if (strokeWidthDividingFactor === undefined) {
                return Config.default('strokeWidthDividingFactor').toFloat();
            }
            return strokeWidthDividingFactor.toFloat();
        },

        /**
         * _reposition
         * 
         * Changes the left and top style values for the text layer, as well as
         * the drawn cotton-position styles, to be in sync with how positioning
         * worked with Share As Image.
         * 
         * @access  protected
         * @return  void
         */
        _reposition: function() {

            // Left
            if (this._layer.getStyle('repositionLeft') === true) {
                this._layer.setStyle('repositionLeft', false);

                // UI
                var width = Math.min(this._cotton.width, this._cotton._getTextWidth() * 1.05),
                    left = this._cotton.left + width / 2;
                this._cotton.set({
                    width: width,
                    left: left
                });
                this._cotton.setCoords();

                // Layer
                var dimensions = this.getCanvas().getRenderedDimensions(),
                    relative = {
                        width: ((width * 100) / dimensions.width).round(4),
                        left: ((left * 100) / dimensions.width).round(4)
                    };
                this._layer.setStyles(relative);
            }
            // Top
            if (this._layer.getStyle('repositionTop') === true) {
                this._layer.setStyle('repositionTop', false);

                // UI
                var height = this._cotton._getTextHeight(),
                    top = this._cotton.top + height / 2;
                this._cotton.set({top: top});
                this._cotton.setCoords();

                // Layer
                var dimensions = this.getCanvas().getRenderedDimensions(),
                    relative = (top * 100) / dimensions.height;
                this._layer.setStyle('top', relative.round(4));
            }
        },

        /**
         * _setStroke
         * 
         * @access  protected
         * @param   String strokeColor
         * @return  void
         */
        _setStroke: function(strokeColor) {
            var strokeWidth = this._getStrokeWidth();
            this._cotton.setStrokeWidth(strokeWidth);
            this._cotton.setStroke(strokeColor);
        },

        /**
         * animate
         * 
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton(),
                top = this._cotton.get('top');
            this._cotton.animate('top', top, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: top - 50,
                onChange: cotton.renderAll.bind(cotton)
            });
            this._cotton.animate('opacity', 1, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
            if (this._layer.getStyle('backdropColor') !== false) {
                var backdrop = this._cotton.get('backdrop');
                top = backdrop.get('top');
                backdrop.animate('top', top, {
                    duration: 500,
                    easing: fabric.util.ease.easeOutBounce,
                    from: top - 50,
                    onChange: cotton.renderAll.bind(cotton)
                });
                backdrop.animate('opacity', 1, {
                    duration: 500,
                    easing: fabric.util.ease.easeOutBounce,
                    from: 0.3,
                    onChange: cotton.renderAll.bind(cotton)
                });
            }
        },

        /**
         * draw
         * 
         * Controls visibility is explicitly set here to restrict manipulation
         * to width and rotation.
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                text = layer.getProperty('text'),
                fontFamily = layer.getStyle('fontFamily');

            // Fallback to default if font is no longer available
            var fontsCollection = Stencil.account().collection('fonts'),
                font = fontsCollection.findByFamilyName(fontFamily);
            if (font === false) {
                var appDefaultFontFamily = Stencil.account().getDefaultFontFamily();
                font = fontsCollection.findByFamilyName(appDefaultFontFamily);
                layer.setStyle('fontFamily', appDefaultFontFamily);
            }

            // Let's do this!
            var options = this._getOptions();
            font.loadFull(function() {

                // Backdrop
                _this.on({
                    'refresh': function(event) {
                        this.refreshBackdrop();
                    }
                });

                // Fabric basics
                var cotton = new fabric.Textbox(text, options);
                layer.getCanvas().getCotton().add(cotton);
                _this._cotton = cotton;
                _this._cotton.originalPadding = options.padding;

                // Controls
                cotton.setControlsVisibility({
                    ml: true,
                    mr: true,
                    mtr: true
                });

                // Events
                _this._addListeners();
                _this.magnets.angles.apply(_this);
                _this.magnets.outbound.apply(_this);
                cotton.boxIn(_this._boxInRatio);
                _this.magnets.inbound.apply(_this);

                /**
                 * Reposition the image if it's from Share As Image and was
                 * normalized.
                 */
                if (
                    layer.getStyle('repositionLeft') === true
                    || layer.getStyle('repositionTop') === true
                ) {
                    _this._reposition();
                }

                /**
                 * Stroke
                 * 
                 * This should be before the backdrop addition, since the stroke
                 * often affects the dimensions of the bounding box. Ran into
                 * this issue in Firefox when the order was reversed. Notice the
                 * spacing around the backdrop:
                 * https://i.imgur.com/KzHpKxe.png
                 * 
                 */
                _this.refreshStroke();
                _this.refreshShadow();

                // Backdrop
                var backdropColor = layer.getStyle('backdropColor');
                if (backdropColor !== false) {
                    var backdropStretch = layer.getStyle('backdropStretch');
                    cotton.addBackdrop(backdropColor, backdropStretch);
                }

                // Done drawing; trigger event
                _this._drawn = true;
                _this.triggerHandler('draw', [_this]);
            });
        },

        /**
         * getDimensions
         * 
         * @access  public
         * @return  Object
         */
        getDimensions: function() {
            var current = this.getCanvas().getRenderedDimensions(),
                left = ((this._cotton.left / current.width) * 100).round(4),
                top = ((this._cotton.top / current.height) * 100).round(4);
            return {
                left: left,
                top: top,
                width: (this._cotton.getRelativeWidth() * 100).round(4)
            };
        },

        /**
         * refresh
         * 
         * At the moment, refresh is only used on window resizing. When this
         * happens, the canvas dimensions may change. To accommodate for this,
         * only styles that are defined relative to the canvas size need to be
         * refreshed. These include:
         * - fontSize
         * - left
         * - top
         * - width
         * 
         * Additionally, the backdrop needs to be updated, so if one is defined
         * I manually call the position method.
         * 
         * Finally, I refresh the stroke since it's affected by the font size
         * applied to the layer, which may have been affected in the canvas
         * refresh.
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var layer = this._layer,
                options = this._getOptions();
            this._cotton.set({
                fontSize: options.fontSize,
                left: options.left,
                top: options.top,
                shadow: options.shadow,
                width: options.width
            });

            // Refresh stroke (since font size may have changed)
            this.refreshStroke();
            this.refreshShadow();

            // Done
            this._cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * refreshBackdrop
         * 
         * @access  public
         * @return  void
         */
        refreshBackdrop: function() {
            var backdropColor = this._layer.getStyle('backdropColor');
            if (backdropColor !== false) {
                this._cotton.positionBackdrop();
            }
        },

        /**
         * refreshShadow
         * 
         * @access  public
         * @return  void
         */
        refreshShadow: function() {
            var shadow = this.relative.shadow.apply(this);
            this._cotton.setShadow(shadow);
        },

        /**
         * refreshStroke
         * 
         * Helper method that sets the stroke on the cotton-object. Note that
         * although this method is only called from within this file, it is
         * public because some places where it's called, it's being done so
         * where the context is a different object (specifically, a TextLayer
         * instance).
         * 
         * @access  public
         * @return  void
         */
        refreshStroke: function() {
            var strokeColor = this._layer.getStyle('strokeColor');
            if (strokeColor !== false) {
                this._setStroke(strokeColor);
            }
        },

        /**
         * relative
         * 
         * @access  public
         * @var     Object
         */
        relative: function() {
            return DataUtils.merge(this._super(), {

                /**
                 * fontSize
                 * 
                 * This calculation method works differently than others, since the
                 * fontSize is on a scale of 20 to 400, rather than a percentage or
                 * decimal value. So I determine the ratio of the canvas width to
                 * the frame, and determine the appropriate font size.
                 * 
                 * @access  public
                 * @return  Number
                 */
                fontSize: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        fontSize = this._layer.getStyle('fontSize').toFloat();
                    return (fontSize / 100 / 10) * dimensions.width;
                },

                /**
                 * shadow
                 * 
                 * @access  public
                 * @return  String
                 */
                shadow: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        textColor = this._layer.getStyle('textColor'),
                        strokeColor = this._layer.getStyle('strokeColor'),
                        shadow = {
                            offsetX: this._layer.getStyle('shadowOffsetX') || 4,
                            offsetY: this._layer.getStyle('shadowOffsetY') || 4,
                            blur: this._layer.getStyle('shadowBlur') || 10,
                            color: this._layer.getStyle('shadowColor') || this._getContrastingColor(textColor),
                            strength: this._layer.getStyle('shadowStrength') === undefined ? 0 : this._layer.getStyle('shadowStrength')
                        };
                    if (strokeColor !== false) {
                        shadow.color = this._getContrastingColor(strokeColor);
                    }
                    shadow.strength /= 100
                    shadow.color = shadow.color.replace('rgb', 'rgba');
                    shadow.color = shadow.color.replace(')', ', ' + (shadow.strength) + ')');
                    var factor = (1 / 100 / 2) * this.relative.fontSize.apply(this);// * UserAgentUtils.getDevicePixelRatio(),
                        strokePadding = 0;
                    if (strokeColor !== false) {
                        strokePadding = this._getStrokeWidth() * 0.5;
                    }
                    shadow.offsetX = (shadow.offsetX * factor);
                    shadow.offsetY = (shadow.offsetY * factor);
                    shadow.blur = (shadow.blur * factor).round(0);
                    var offsetX = ((shadow.offsetX + strokePadding) * UserAgentUtils.getDevicePixelRatio()).round(0),
                        offsetY = ((shadow.offsetY + strokePadding) * UserAgentUtils.getDevicePixelRatio()).round(0),
                        blur = (shadow.blur),
                        color = shadow.color,
                        properties = [
                            (offsetX) + 'px',
                            (offsetY) + 'px',
                            (blur) + 'px',
                            color
                        ];
                    return properties.join(' ');
                }
            });
        },

        /**
         * repositionRelativeTo
         * 
         * Used with quotes to position a drawing directly below another
         * drawing.
         * 
         * @access  public
         * @param   Drawing drawing
         * @return  void
         */
        repositionRelativeTo: function(drawing) {
            var rect = drawing.getCotton().getBoundingRect(),
                buffer = 4,
                adjusted = (rect.top + rect.height + this._cotton.getBoundingRect().height / 2) * ((100 + buffer) / 100);
            this._cotton.set({
                top: adjusted
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    top: ((adjusted * 100) / dimensions.height).round(4)
                };
            this._layer.setStyles(relative);
        },

        /**
         * trim
         * 
         * @access  public
         * @return  void
         */
        trim: function() {
            var width = this._cotton._getTextWidth(),
                buffer = 30,
                adjusted = width * ((100 + buffer) / 100);
            this._cotton.set({
                width: adjusted
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    width: ((adjusted * 100) / dimensions.width).round(4)
                };
            this._layer.setStyles(relative);
        }
    });
});
window.DependencyLoader.push('ImageDrawing', function() {

    /**
     * VectorImageDrawing
     * 
     * @extends ImageDrawing
     */
    window.VectorImageDrawing = ImageDrawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'fillColor': function() {
                    this._layer.on({
                        'change/fillColor': function(event, fillColor) {
                            var cotton = this.getCotton();
                            cotton.setFillColor(fillColor);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorImageDrawing')
         */
        _string: 'VectorImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   VectorImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('vectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    angle: layer.getStyle('angle').toFloat(),
                    fill: layer.getStyle('fillColor'),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * _getUrl
         * 
         * Returns the path to the vector's stored asset, or else assumes that
         * the accessor for this vector (eg. The Noun Project) is on the page.
         * In the latter case, it's likely to be a ResourceAccessor.
         * 
         * In the case where the image is an asset, I go directly to S3 instead
         * of through Cloudinary, as it seems Cloudinary doesn't serve SVGs
         * properly.
         * 
         * If the image isn't an asset, then, at the moment, it's likely a
         * resource (eg. The Noun Project), in which case I just grab the svg
         * url directly.
         * 
         * @access  protected
         * @return  String|false
         */
        _getUrl: function() {
            var image = this._layer.getProperty('image'),
                accessor;
            if (image.match(/^asst/) !== null) {
                // return RequestUtils.url.s3(key);
                var key = (image) + '.svg',
                    url = RequestUtils.url.cloudFront(key);
                return url;
            }
            if (image.match(/^upld/) !== null) {
                // return RequestUtils.url.s3(key);
                var key = (image) + '.svg',
                    url = RequestUtils.url.cloudFront(key);
                return url;
            }
            accessor = Stencil.getAccessor(image);
            if (accessor !== false) {
                return accessor.url('svg');
            }
            return false;
        },

        /**
         * _prepare
         * 
         * @access  protected
         * @var     Object
         */
        _prepare: {

            /**
             * _prepare.clip
             * 
             * @see     https://i.imgur.com/KvUG12A.png
             * @access  protected
             * @param   Number width
             * @param   Number height
             * @return  void
             */
            clip: function(width, height) {

                /**
                 * clip
                 * 
                 * Some icons were coming in as sprites. As a result, drawing an
                 * icon could result in a bunch of other icons being written. I
                 * tried to get around this by using the isContainedWithinObject
                 * and  isContainedWithinRect methods against the PathGroup
                 * object, but it didn't work well, possibly because paths
                 * pivotel to the desired icon started/ended outside of the
                 * object / rectangle. To get around this, I simply clip the
                 * vector according to it's width/height. The reason I have to
                 * set x / y as negative values is because the origin is set as
                 * center / center.
                 * 
                 * @access  private
                 * @param   CanvasRenderingContext2D ctx
                 * @return  void
                 */
                var clip = function(ctx) {
                    var x = -width / 2,
                        y = -height / 2;
                    ctx.rect(x, y, width, height);
                };
                this._cotton.setClipTo(clip);
            },

            /**
             * _prepare.draw
             * 
             * @access  protected
             * @param   Boolean fresh
             * @return  void
             */
            draw: function(fresh) {

                // Options
                var layer = this._layer,
                    cotton = this._cotton,
                    options = this._getOptions(),
                    width = options.width,
                    fill = options.fill;

                /**
                 * Checks whether this is a "fresh" addition to the canvas
                 * (an addition via the Preview.addVectorImagelayer method). If
                 * it is, it checks the ratio, and if it's a really tall image,
                 * it maxes out the height to 25% of the height of the canvas.
                 */
                if (fresh === true) {
                    if (cotton.getRatio() < 1) {
                        var height = 25,
                            dimensions = layer.getCanvas().getRenderedDimensions(),
                            percentage = height / 100,
                            pixels = (dimensions.height * percentage).round(4),
                            adjustedWidth;
                        width = pixels * cotton.getRatio();
                        adjustedWidth = ((width / dimensions.width) * 100).round(4);
                        layer.setStyles({
                            'width': adjustedWidth
                        });

                        // Update change history with new value
                        var undoHistory = ChangeHistory.history.undo(),
                            index = undoHistory.length - 1,
                            operation = undoHistory[index],
                            imageKey = this._layer.getProperty('image'),
                            json = operation.configuration.settings.json,
                            regExp,
                            pattern = '(' + (imageKey) + '".+?"width":)15';
                            replacement = '$1' + (adjustedWidth);
                        regExp = new RegExp(pattern);
                        json = json.replace(regExp, replacement);
                        operation.configuration.settings.json = json;
                        ChangeHistory.replaceLastUndoOperation(operation);
                    }
                }

                // Set options
                var angle = options.angle;
                delete options.angle;
                delete options.fill;
                delete options.width;
                cotton.set(options);
                var scaled = this._getScaledWidth();
                cotton.scaleToWidth(scaled);
                cotton.setAngle(angle);

                // Scaling
                var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                    scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                cotton.setScaleX(scaleX);
                cotton.setScaleY(scaleY);
                cotton.setCoords();

                // Color
                if (fill !== undefined) {
                    cotton.setFillColor(fill);
                }

                // Controls
                this._addListeners();

                // Cashmere
                this.magnets.angles.apply(this);
                this.magnets.outbound.apply(this);
                cotton.boxIn(this._boxInRatio);
                this.magnets.inbound.apply(this);

                // Event dispatching
                this._drawn = true;
                this.triggerHandler('draw', [this]);
            },

            /**
             * _prepare.shapes
             * 
             * @access  protected
             * @param   Array shapes
             * @return  Array
             */
            shapes: function(shapes) {

                /**
                 * Stripping out any shapes that are text to deal with
                 * issues like the following:
                 * https://i.imgur.com/JHXI3Vi.png
                 * https://i.imgur.com/HHnupvi.png
                 * 
                 * @note    Not sure if there are any icons that are using text
                 *          paths as part of their image. Hope not :/
                 * @note    May not be needed, since I'm using a clipping
                 *          function now (which out to hide any text that might
                 *          be contained in a sprite).
                 */
                shapes = jQuery.grep(shapes, function(shape, index) {
                    return shape.type !== 'text';
                });

                /**
                 * Adjust for stroke
                 * 
                 * Some icons (for example, the ice cream below), are 100%
                 * composed of strokes. So when I set the strokeWidth for all
                 * fabric objects to 0, it messed these ones up. So here, I
                 * check to see whether a stroke is defined on any of the
                 * shapes, and if so, set the stroke for that shape (not
                 * PathGroup) to 1.
                 * 
                 * @see     https://i.imgur.com/oVD08Pn.png
                 *          https://s3-us-west-2.amazonaws.com/app.local.getstencil.com/asst5afa89ce.svg
                 */
                jQuery.each(shapes, function(index, shape) {
                    if (shape.stroke && shape.stroke !== '') {
                        if (
                            shape.strokeWidth === undefined
                            || shape.strokeWidth === null
                            || shape.strokeWidth === 0
                        ) {
                            shape.strokeWidth = 1;
                        }
                    }
                });

                // 
                return shapes;
            },

            /**
             * _prepare.trim
             * 
             * Oh, trim-method. This one was gnarly, and took a long time to get
             * right. It scales a vector to 400px wide, and then sets up a
             * temporary canvas. The canvas has it's width and height set to
             * match the vector, and then a fabric-canvas is made from it. I
             * then add the vector to the canvas and proceed to run the trim
             * helper function to determine the exact fit.
             * 
             * The tricky thing is that fabric now automatically scales things
             * according to whether the client is using a retina monitor. So
             * after the trim comes back, I need to devide the number by the
             * pixel ratio, otherwise it's too high when i transform the vector
             * paths.
             * 
             * Note that the 400px-wide vector setting is to try and get the
             * best possible fidelity in terms of the truest fit. The higher
             * that width, the more specific the trim function is, but it's also
             * a heavy computation, thus the note below to look into web
             * workers.
             * 
             * When the value is too high, it causes a lag in the animation of
             * the icon dropping into the canvas, likely because the browser's
             * memory is full (hmm, look into this). It was especially noticable
             * with retina devices (Adam's monitor), because when the temporary
             * canvas is drawn, retina has 4-times more pixels (which requires
             * 4-times more computations).
             * 
             * @todo    Look into using web workers here since it can cause lag
             *          https://blog.idrsolutions.com/2012/09/how-to-draw-svg-on-html-5-canvas-and-why-you-might-want-to/
             * @access  protected
             * @param   Function callback
             * @return  void
             */
            trim: function(callback) {
                // this._cotton.scaleToWidth(200);
                this._cotton.scaleToWidth(400);
                // this._cotton.scaleToWidth(600);
                var factor = this._cotton.getScaleX(),
                    width = this._cotton.getWidth(),
                    height = this._cotton.getHeight(),
                    element = document.createElement('canvas'),
                    ratio = UserAgentUtils.getDevicePixelRatio(),
                    ctx = element.getContext('2d');
                element.setAttribute('width', width);
                element.setAttribute('height', height);
                var canvas = new fabric.Canvas(element);
                canvas.add(this._cotton);
                var details = CanvasElementUtils.trimTransparentPixels(element);
                details.width /= ratio;
                details.height /= ratio;
                details.bounds.left /= ratio;
                details.bounds.top /= ratio;
                canvas.remove(this._cotton);
                callback({
                    ratio: details.width / details.height,
                    width: details.width / factor,
                    height: details.height / factor,
                    bounds: {
                        left: details.bounds.left / factor,
                        top: details.bounds.top / factor
                    }
                });
            },

            /**
             * _prepare.xml
             * 
             * @access  protected
             * @param   String xml
             * @return  String
             */
            xml: function(xml) {

                /**
                 * Strips out any <clipPath> tags to prevent issues with
                 * some icons. This one specifically had an issue:
                 * https://i.imgur.com/MbMAx9w.png
                 */
                xml = xml.replace(/\<clipPath.*\<\/clipPath>/gi, '');

                /**
                 * Strips out any <image> tags to prevent issues with
                 * some icons. This one specifically had an issue:
                 * https://i.imgur.com/JmhmhaS.jpg
                 * 
                 * @see     https://stackoverflow.com/a/7124811/115025
                 * @see     https://stackoverflow.com/a/7124976/115025
                 * @see     https://stackoverflow.com/questions/1979884/how-to-use-javascript-regex-over-multiple-lines
                 */
                xml = xml.replace(/<image[\s\S]*?<\/image>/gi, '');

                /**
                 * Strips out any <switch> tags, which was causing some issues.
                 * Noticed with this icon:
                 * https://i.imgur.com/lIFE8wO.png
                 * 
                 * @see     https://jsfiddle.net/bsnsd6ku/
                 */
                xml = xml.replace(/\<switch\>(.*)\<\/switch\>/gi, '$1');

                /**
                 * Fix any translate calls that were not set up
                 * properly. Specifically, some TNP icons were coming
                 * through with:
                 * transform="translate(-273.07-554.7)
                 * 
                 * This is an invalid translate / transform value, since
                 * there needs to be a space between the two values. To
                 * get around this, check when two negative translate /
                 * transform values are defined, and insert a space when
                 * there isn't one.
                 * 
                 * @see     http://stackoverflow.com/questions/34683134/svg-on-canvas-using-fabricjs-cant-be-seen-because-of-transform-translate-rul
                 * @see     https://i.imgur.com/nDtRJ62.png
                 */
                // if (transform.match(/translate\(\-[0-9\.]+,?\-[0-9\.]+/) === null) {
                xml = xml.replace(
                    /translate\((\-?[0-9\.]+)(\-{1}[0-9\.]+)\)/gi,
                    'translate($1 $2)'
                );

                // Done for now
                return xml;
            }
        },

        /**
         * draw
         * 
         * @note    Filtering out text nodes to prevent the following:
         *          vector, but rather part of a sprite. Sometimes these sprites
         *          would include the following shapes:
         *          rect
         *          text
         *          line
         *          path
         *          polygon
         *          circle
         *          See: https://i.imgur.com/jldKsgt.png
         * @see     https://m.alphasights.com/killing-cors-preflight-requests-on-a-react-spa-1f9b04aa5730#.h1516nbjv
         * @see     http://www.w3schools.com/tags/canvas_rect.asp
         * @see     http://fabricjs.com/clipping/
         * @see     https://github.com/kangax/fabric.js/issues/2555
         * @see     http://fabricjs.com/clipping/
         * @todo    Implement some sort of caching so that if multiple versions
         *          of the same vector on the canvas, it doesn't fire multiple
         *          ajax requests. Simplest would be to create a helper method
         *          that checks for a layer with the same src, and if found,
         *          grabs the pathing info from it and uses that instead. This
         *          will also speed up the Ghost canvas, which would make
         *          Google+Firefox downloading even faster (when I get around to
         *          it). See <svgCache> in fabric.js. At the moment, it's not so
         *          bad, since the browser is caching them, resulting in a 4ms
         *          local lookup: https://i.imgur.com/aTggRQX.png
         *          This 4ms delay may not seem like much, but if there are a
         *          bunch of icons in the canvas, it's multipled, along with the
         *          delay in the http request itself.
         * @param   Boolean fresh
         * @access  public
         * @return  void
         */
        draw: function(fresh) {

            // Overhead
            var _this = this,
                layer = this._layer,
                url = this._getUrl();

            // Something went wrong
            if (url === false) {
                Stencil.alert('svg.load.fail.2');
                layer.triggerHandler('delete');
            }
            // Preload (to check CORS, since TNP sometimes flakes)
            else {
                var signature = {"basename":"VectorImage.js","line":492};
                RequestUtils.ajax({
                    excludeDefaultData: true,
                    signature: signature,
                    cache: true,
                    crossDomain: true,
                    url: url,
                    type: 'GET',

                    /**
                     * error
                     * 
                     * Shows the alert, and if there is an active XHR call,
                     * decrements the count to ensure the user can reload the page
                     * if they'd like to. I need to do this because there are two
                     * ways in which this request can fail:
                     * 1) The preflight request fails because of a CORS issue. When
                     *    outbound preflight calls are made, I do not believe jQuery
                     *    increments the <active> count. Because of this, I don't
                     *    decrement the count here.
                     * 2) The preflight goes through successfully, but the actual
                     *    request for data (GET) fails. When this is the case, I
                     *    need to decrement the count since the <active> property
                     *    would have been incremented.
                     * @todo    The logic below simply communicates to the user that
                     *          the icon isn't available, instead of failing
                     *          silently. The real issue is that if it does fail,
                     *          it's likely because of a hiccup on The Noun Project's
                     *          side, in that it's not passing the proper CORS
                     *          headers. I've seen this with AWS before. Once that
                     *          happens, the user caches the request. So there may
                     *          not be a way for them to eventually get that icon
                     *          unless they clear their cache. One possible way would
                     *          be to change the layer src value by appending a cache
                     *          busting value (eg. random=123), and trying again with
                     *          that before erroring out. Then, each time they click
                     *          on the icon, it'll try another random one. For this
                     *          to work, thought, this new src value will need to be
                     *          set in the layer and saved. Hard to test this.
                     * @access  private
                     * @param   Object jqXHR
                     * @param   String textStatus
                     * @param   String errorThrown
                     * @return  void
                     */
                    error: function(jqXHR, textStatus, errorThrown) {
                        App.log('jQuery AJAX error', true);
                        App.log(signature, true);
                        App.log(arguments, true);
                        Stencil.alert('svg.load.fail');
                        layer.triggerHandler('delete');
                    },
                    success: function(xml) {
                        xml = _this._prepare.xml.apply(_this, [xml]);
                        // Try/catch to deal with this: https://i.imgur.com/sie609w.png
                        // https://i.imgur.com/yFLEYVM.png
                        try {
                            fabric.loadSVGFromString(
                                xml,
                                function(shapes, passed) {
                                    shapes = _this._prepare.shapes.apply(_this, [shapes]);
                                    var cotton = fabric.util.groupSVGElements(
                                        shapes,
                                        passed
                                    );
                                    _this._cotton = cotton;
                                    _this._prepare.trim.apply(_this, [function(details) {
                                        _this._cotton.set({
                                            width: details.width,
                                            height: details.height
                                        });
                                        var transformMatrix;
                                        jQuery.each(_this._cotton.paths, function(index, path) {
                                            transformMatrix = path.transformMatrix || [1, 0, 0, 1, 0, 0];
                                            path.setTransformMatrix([
                                                transformMatrix[0],
                                                transformMatrix[1],
                                                transformMatrix[2],
                                                transformMatrix[3],
                                                transformMatrix[4] - details.bounds.left,
                                                transformMatrix[5] - details.bounds.top
                                            ]);
                                        });

                                        // 
                                        layer.getCanvas().getCotton().add(cotton);
                                        // if (_this._cotton.paths.length > 1) {
                                            _this._prepare.clip.apply(
                                                _this,
                                                [
                                                    details.width,
                                                    details.height
                                                ]
                                            );
                                        // }
                                        _this._prepare.draw.apply(_this, [fresh]);
                                    }]);
                                }
                            );
                        } catch (err) {
                        }
                    },
                    dataType: 'text'
                });
            }
        },

        /**
         * refresh
         * 
         * This method is essentially the same as the one in the ImageLayer
         * class. The exception is that there isn't a call to _scale (which is
         * a proxy for a call to _resize), since the VectorImageLayer layers are
         * references to vectors, which for scaling, only require to have their
         * width set (which is done via the _getScaleWidth method).
         * 
         * The _getScaleWidth method takes care of cases where padding is
         * defined (eg. on tablets).
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var cotton = this._cotton,
                options = this._getOptions();
            cotton.set({
                left: options.left,
                top: options.top
            });
            var scaled = this._getScaledWidth();
            cotton.scaleToWidth(scaled);
            var scaleX = (cotton.scaleX * this._layer.getStyle('stretchX')).round(4),
                scaleY = (cotton.scaleY * this._layer.getStyle('stretchY')).round(4);
            cotton.setScaleX(scaleX);
            cotton.setScaleY(scaleY);
            cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        }
    });
});
window.DependencyLoader.push('BitmapImageDrawing', function() {

    /**
     * WatermarkBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.WatermarkBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkBitmapImageDrawing')
         */
        _string: 'WatermarkBitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   WatermarkBitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addScaleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            this._super();
            var delay = Config.getResizeDelay('watermarkBitmapImage');
            this._cotton.on({
                'scaling': _.debounce(this._scale.proxy(this), delay),
                'scaling/manual': _.debounce(this._scale.proxy(this), delay)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('watermarkBitmapImage');
                }
            });
        },

        /**
         * _getUrl
         * 
         * @access  protected
         * @param   Number width
         * @return  String
         */
        _getUrl: function(width) {
            var url = this._getMediaKeyUrl(width);
            return url;
        },

        /**
         * animate
         * 
         * Fades the watermark in, using an easeOutBack transition. I'm noting
         * this because the transition is different than other drawings, which
         * use easeOutBounce. The issue with that is when it's just an opacity
         * change / fade, the opacity fades but bounces for a second at the end
         * when I use the easeOutBounce transition. The easeOutBack transition
         * has the same initial momentum, but doesn't have the opacity bounce at
         * the end. That being said, I am using that transition in other
         * drawings for opacity, but only when the bounce is applied with a
         * movement transition (eg. top). In that case, it makes sense that the
         * opacity bounces at the same bounce the position does.
         * 
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton();
            this._cotton.animate('opacity', 1, {
                duration: 750,
                easing: fabric.util.ease.easeOutBack,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            fabric.util.loadImage(
                url,
                function(image) {

                    // Fabric basics
                    var cotton = new fabric.Image(image);
                    layer.getCanvas().getCotton().add(cotton);
                    _this._cotton = cotton;

                    // Set controls visibility to prevent stretching knobs
                    cotton.setControlsVisibility({
                        tl: true,
                        tr: true,
                        br: true,
                        bl: true,
                        ml: false,
                        mt: false,
                        mr: false,
                        mb: false,
                        mtr: true
                    });

                    /**
                     * Options
                     * 
                     * I set the general options first. I then set the width by
                     * scaling the object to the desired value. Finally, I set
                     * the angle *_after_* the width has been set. If I set the
                     * angle first, the width is decreased.
                     */
                    var angle = options.angle;
                    delete options.angle;
                    delete options.width;
                    cotton.set(options);
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    cotton.setAngle(angle);

                    // Scaling
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();

                    // Filters
                    _this._drawFilters();

                    // Events
                    _this._addListeners();
                    _this.magnets.angles.apply(_this);
                    _this.magnets.outbound.apply(_this);
                    cotton.boxIn(_this._boxInRatio);
                    _this.magnets.inbound.apply(_this);

                    // Done drawing; trigger event
                    _this._drawn = true;
                    _this.triggerHandler('draw', [_this]);
                },
                this,
                {
                    crossOrigin: 'anonymous'
                }
            );
        }
    });
});
window.DependencyLoader.push('VectorImageDrawing', function() {

    /**
     * WatermarkColorVectorImageDrawing
     * 
     * @extends VectorImageDrawing
     */
    window.WatermarkColorVectorImageDrawing = VectorImageDrawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'opacityStrength': function() {
                    this._layer.on({
                        'change/opacityStrength': function(event, opacityStrength) {
                            var cotton = this.getCotton(),
                                opacityValue = ((100 - opacityStrength) / 100).round(2);
                            cotton.setOpacity(opacityValue);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkColorVectorImageDrawing')
         */
        _string: 'WatermarkColorVectorImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   WatermarkColorVectorImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('watermarkColorVectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    opacity: layer.getStyle('opacity').toFloat(),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * animate
         * 
         * Fades the watermark in, using an easeOutBack transition. I'm noting
         * this because the transition is different than other drawings, which
         * use easeOutBounce. The issue with that is when it's just an opacity
         * change / fade, the opacity fades but bounces for a second at the end
         * when I use the easeOutBounce transition. The easeOutBack transition
         * has the same initial momentum, but doesn't have the opacity bounce at
         * the end. That being said, I am using that transition in other
         * drawings for opacity, but only when the bounce is applied with a
         * movement transition (eg. top). In that case, it makes sense that the
         * opacity bounces at the same bounce the position does.
         * 
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton();
            this._cotton.animate('opacity', 1, {
                duration: 750,
                easing: fabric.util.ease.easeOutBack,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
        }
    });
});
window.DependencyLoader.push('VectorImageDrawing', function() {

    /**
     * WatermarkVectorImageDrawing
     * 
     * @extends VectorImageDrawing
     */
    window.WatermarkVectorImageDrawing = VectorImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkVectorImageDrawing')
         */
        _string: 'WatermarkVectorImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   WatermarkVectorImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('watermarkVectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                options = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    // opacity: layer.getStyle('opacity').toFloat(),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaultOptions = this._getDefaultOptions();
            options = DataUtils.merge(defaultOptions, options);
            return options;
        },

        /**
         * animate
         * 
         * Fades the watermark in, using an easeOutBack transition. I'm noting
         * this because the transition is different than other drawings, which
         * use easeOutBounce. The issue with that is when it's just an opacity
         * change / fade, the opacity fades but bounces for a second at the end
         * when I use the easeOutBounce transition. The easeOutBack transition
         * has the same initial momentum, but doesn't have the opacity bounce at
         * the end. That being said, I am using that transition in other
         * drawings for opacity, but only when the bounce is applied with a
         * movement transition (eg. top). In that case, it makes sense that the
         * opacity bounces at the same bounce the position does.
         * 
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton();
            this._cotton.animate('opacity', 1, {
                duration: 750,
                easing: fabric.util.ease.easeOutBack,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
        }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * ImageDocument
     * 
     * @extends Base
     */
    window.ImageDocument = Base.extend({

        /**
         * _canvas
         * 
         * @access  protected
         * @var     false|CanvasView (default: false)
         */
        _canvas: false,

        /**
         * _document
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _document: {},

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'imageDocument')
         */
        _classType: 'imageDocument',

        /**
         * _image
         * 
         * @access  protected
         * @var     ImageAccessor (default: false)
         */
        _image: false,

        /**
         * _layers
         * 
         * Keeps track of all layers, including those that contain order-style
         * values (eg. any kind of TextLayer, VectorImage or
         * ForegroundBitmapImage).
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _layers: [],

        /**
         * init
         * 
         * @access  public
         * @param   Object document
         * @param   ImageAccessor image
         * @param   CanvasView canvas
         * @return  void
         */
        init: function(document, image, canvas) {
            this._super();
            this._layers = [];
            this._document = document;
            this._image = image;
            this._canvas = canvas;
        },

        /**
         * _mergeActiveWatermarks
         * 
         * Loops over all the watermarks that are currently available to the
         * account, and merges active ones into the document.
         * 
         * Any watermarks that are found with invalidly formatted settings data
         * (eg. JSON is malformed), will get excluded.
         * 
         * @access  protected
         * @return  void
         */
        _mergeActiveWatermarks: function() {
            var document = this._document,
                watermarks = Stencil.account().collection('watermarks').all(),
                cropPositionData,
                filters,
                styles,
                active,
                layerProperties = {},
                watermark,
                index;
            for (index in watermarks) {
                watermark = watermarks[index];

                // Active check
                active = watermark.setting('active').toInt() === 1;
                if (active === false) {
                    continue;
                }

                // Valid JSON setting checks
                cropPositionData = watermark.setting('cropPositionData');
                if (JSONUtils.valid(cropPositionData) === false) {
                    continue;
                }
                filters = watermark.setting('filters');
                if (JSONUtils.valid(filters) === false) {
                    continue;
                }
                styles = watermark.setting('styles');
                if (JSONUtils.valid(styles) === false) {
                    continue;
                }

                // Add watermark properties to document
                cropPositionData = JSON.parse(cropPositionData);
                filters = JSON.parse(filters);
                styles = JSON.parse(styles);
                styles.order = document.layers.length - 2;
                layerProperties = {
                    color: watermark.get('color').toInt() === 1,
                    cropPositionData: cropPositionData,
                    cropSourceKey: watermark.setting('cropSourceKey'),
                    filters: filters,
                    image: watermark.get('key'),
                    styles: styles,
                    type: 'image',
                    vector: watermark.get('vector').toInt() === 1,
                    watermark: true
                };
                document.layers.push(layerProperties);
            }
        },

        /**
         * _mergeEmbeddedWatermarks
         * 
         * Loops over all the watermarks that are currently available to the
         * account, and merges the ones that are contained within the
         * ImageAccessor, into the document.
         * 
         * @access  protected
         * @return  void
         */
        _mergeEmbeddedWatermarks: function() {
            var document = this._document,
                watermarks = Stencil.account().collection('watermarks').all(),
                image = this._image,
                cropPositionData,
                filters,
                styles,
                layerProperties = {},
                watermark,
                index;
            for (index in watermarks) {
                watermark = watermarks[index];
                if (image.containsWatermark(watermark) === false) {
                    if (watermark.setting('active').toInt() === 1) {
                        watermark.set({
                            'settings.active': 0
                        });
                        watermark.save(['settings.active']);
                    }
                    continue;
                }
                if (watermark.setting('active').toInt() === 0) {
                    watermark.set({
                        'settings.active': 1
                    });
                    watermark.save(['settings.active']);
                }
                var documentWatermark = image.getDocumentWatermark(watermark);
                cropPositionData = documentWatermark.cropPositionData;
                filters = documentWatermark.filters;
                styles = documentWatermark.styles;
                styles.order = document.layers.length - 2;
                layerProperties = {
                    color: documentWatermark.color === true,
                    cropPositionData: cropPositionData,
                    cropSourceKey: watermark.setting('cropSourceKey'),
                    filters: filters,
                    image: watermark.get('key'),
                    styles: styles,
                    type: 'image',
                    vector: documentWatermark.vector === true,
                    watermark: true
                };
                document.layers.push(layerProperties);
            }
        },

        /**
         * addLayer
         * 
         * Simply pushes a Layer object into the ImageDocument's layers array.
         * 
         * @access  public
         * @param   Layer layer
         * @return  void
         */
        addLayer: function(layer) {
            this._layers.push(layer);
            this._image.setConfiguration();
        },

        /**
         * deleteAllLayers
         * 
         * @access  public
         * @return  void
         */
        deleteAllLayers: function() {
            for (var x = this._layers.length - 1; x >= 0; x--) {
                this._layers[x].triggerHandler('delete');
            }
            this._image.triggerHandler('delete/all/finish');
        },

        /**
         * each
         * 
         * Runs an interator function against all the layers, with the
         * ImageDocument set as the context.
         * 
         * @access  public
         * @param   Function iterator
         * @return  void
         */
        each: function(iterator) {
            jQuery.each(this._layers, (function(index, layer) {
                iterator.apply(this, [index, layer]);
            }).proxy(this));
        },

        /**
         * filter
         * 
         * Applies a filter function to the layers, returning whichever ones
         * pass the test. Filter function has the ImageDocument set as the
         * context.
         * 
         * @access  public
         * @param   Function filter
         * @return  Array
         */
        filter: function(filter) {
            var matching = [];
            jQuery.each(this._layers, (function(index, layer) {
                if (filter.apply(this, [index, layer]) === true) {
                    matching.push(layer);
                }
            }).proxy(this));
            return matching;
        },

        /**
         * find
         * 
         * Searches through layers for a specific Layer object. Currently
         * supports searching properties and styles on layers. Returns false if
         * no match could be found.
         * 
         * @access  public
         * @param   String type
         * @param   String key
         * @param   mixed value
         * @return  false|Layer
         */
        find: function(type, key, value) {
            var filtered = this.filter(function(index, layer) {
                if (type === 'property') {
                    return layer.getProperty(key) === value;
                }
                if (type === 'style') {
                    return layer.getStyle(key) === value;
                }
                return false;
            });
            if (filtered.length === 0) {
                return false;
            }
            return filtered[0];
        },

        /**
         * getBackgroundBitmapImageLayer
         * 
         * @access  public
         * @return  BackgroundBitmapImageLayer
         */
        getBackgroundBitmapImageLayer: function() {
            var layers = this.filter(function(index, layer) {
                return layer.getProperty('background') === true
                    && layer.getProperty('type') === 'image';
            });
            return layers[0];
        },

        /**
         * getBackgroundRectangleLayer
         * 
         * @access  public
         * @return  BackgroundRectangleLayer
         */
        getBackgroundRectangleLayer: function() {
            var layers = this.filter(function(index, layer) {
                return layer.getProperty('background') === true
                    && layer.getProperty('type') === 'rectangle';
            });
            return layers[0];
        },

        /**
         * getBottomOrderedLayer
         * 
         * Returns the layer that has the lowest order-style value. At the
         * moment, I don't allow specification on whether watermark layers
         * could be returned, since there isn't a way to move watermarks that
         * far back anyhow.
         * 
         * @access  public
         * @return  Layer|false
         */
        getBottomOrderedLayer: function() {
            var layers = this.filter(function(index, layer) {
                return layer.getProperty('background') !== true
                    && layer.getStyle('order') === 0;
            });
            if (layers.length > 0) {
                return layers[0];
            }
            return false;
        },

        /**
         * getBwVectorImageLayers
         * 
         * @note    I check that the color property is not equal to true, rather
         *          than checking if it's set to false, because there was a time
         *          whereby the color property didn't exist on these layers. So
         *          if I were to check for a false value, previously saved
         *          images would cause inconsistencies.
         *          Note that I also address this in VectorImageLayer through
         *          the _normalizeProperties method, so this may be redundant.
         * @access  public
         * @return  Array
         */
        getBwVectorImageLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') === true
                    && layer.getProperty('color') !== true;
            });
        },

        /**
         * getCanvas
         * 
         * @access  public
         * @return  CanvasView
         */
        getCanvas: function() {
            return this._canvas;
        },

        /**
         * getDocument
         * 
         * @access  public
         * @return  Object
         */
        getDocument: function() {
            return this._document;
        },

        /**
         * getForegroundBitmapImageLayers
         * 
         * @access  public
         * @return  Array
         */
        getForegroundBitmapImageLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('background') !== true
                    && layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') !== true
                    && layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getLayers
         * 
         * Returns all layers in the image document, possibly including
         * watermarks.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Array
         */
        getLayers: function(includeWatermarks) {
            if (includeWatermarks === true) {
                return this._layers;
            }
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getLockedLayers
         * 
         * @access  public
         * @return  Array
         */
        getLockedLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('locked') === true;
            });
        },

        /**
         * getOrderedLayers
         * 
         * Returns layers that have a order-style property assigned to them,
         * which by nature excludes the background rectangle and background
         * image. Watermarks may be included in the check.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Array
         */
        getOrderedLayers: function(includeWatermarks) {
            return this.filter(function(index, layer) {
                if (includeWatermarks === true) {
                    return layer.getProperty('background') !== true;
                }
                return layer.getProperty('background') !== true
                    && layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getTextLayers
         * 
         * @access  public
         * @return  Array
         */
        getTextLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'text';
            });
        },

        /**
         * getTheNounProjectVectorImageLayers
         * 
         * @note    The below logic does not account for TNP icons that are added
         *          to the canvas, a page refresh happens, and at the time of
         *          running this method, the accessor referencing this
         *          resource/asset is not available in memory. This is because
         *          the image document does not contain details on what type
         *          of resource/asset it is inherently (other than the key).
         * @access  public
         * @return  Array
         */
        getTheNounProjectVectorImageLayers: function() {
            return this.filter(function(index, layer) {
                var isVectorImageLayer = layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') === true;
                if (isVectorImageLayer === true) {
                    var imageKey = layer.getProperty('image'),
                        accessor = Stencil.getAccessor(imageKey);
                    if (accessor === false) {
                        return false;
                    }
                    if (imageKey.match(/^asst/) !== null) {
                        return accessor.get('resourceType') === 'TheNounProject';
                    }
                    return accessor.get('platform') === 'TheNounProject';
                }
                return false;
            });
        },

        /**
         * getTopOrderedLayer
         * 
         * Returns the layer that has the highest order-style value, possibly
         * including watermarks.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Layer|false
         */
        getTopOrderedLayer: function(includeWatermarks) {
            var orderedLayers = this.getOrderedLayers(includeWatermarks).length,
                layers = this.filter(function(index, layer) {
                    return layer.getProperty('background') !== true
                        && layer.getStyle('order') === orderedLayers - 1;
                });
            if (layers.length > 0) {
                return layers[0];
            }
            return false;
        },

        /**
         * getWatermarkBitmapLayers
         * 
         * @access  public
         * @return  Array
         */
        getWatermarkBitmapLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') === true
                    && layer.getProperty('vector') !== true;
            });
        },

        /**
         * getWatermarkLayers
         * 
         * Returns _only_ watermark layers, which contrasts with the getLayers
         * method when true is passed in, which will return all layers
         * _including_ watermark layers.
         * 
         * @access  public
         * @return  Array
         */
        getWatermarkLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') === true;
            });
        },

        /**
         * getWatermarkLayersJson
         * 
         * Returns an object of all the watermark layer's properties as JSON.
         * I am not removing the order style-property, since at the moment, this
         * is only being used to track watermark json in an ImageAccessor to
         * determine if the image has changed, at which point the order of
         * watermarks is important.
         * 
         * @access  public
         * @return  Object
         */
        getWatermarkLayersJson: function() {
            var json = {
                    layers: []
                },
                layers = this.getWatermarkLayers();
            jQuery.each(layers, function(index, layer) {
                json.layers.push(layer.getProperties());
            });
            return json;
        },

        /**
         * json
         * 
         * Returns the JSON representation of the document.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Object
         */
        json: function(includeWatermarks) {
            var json = {
                    layers: []
                },
                layers = this.getLayers(includeWatermarks);
            jQuery.each(layers, function(index, layer) {
                json.layers.push(layer.getProperties());
            });
            return json;
        },

        /**
         * mergeWatermarks
         * 
         * @access  public
         * @return  Boolean
         */
        mergeWatermarks: function() {
            if (Stencil.get('smartToggleWatermarks') === true) {
                this._mergeEmbeddedWatermarks();
                return true;
            }
            Stencil.set('smartToggleWatermarks', false);
            this._mergeActiveWatermarks();
            return true;
        },

        /**
         * removeLayer
         * 
         * After removal, loops over the layers, and ensures that a proper
         * order-value is set (since removing a layer changes the order-values
         * across the board).
         * 
         * I only retrieve the ordered layers (for adjusting order-style
         * values), since the background rectangle and background image layers
         * would never be affected by a layer being removed (since they don't
         * have a order-style property, and their order can't actually be
         * changed).
         * 
         * It's important that the layer not be deleted from memory (eg. with a
         * delete call). This is because it might be referenced by a delayed
         * save function (at the moment, only ones I can think of are
         * watermarks). They'll reference the styles / properties of the layer
         * when it goes off and saves things.
         * 
         * @access  public
         * @param   Layer toRemove
         * @return  void
         */
        removeLayer: function(toRemove) {
            this.each(function(index, layer) {
                if (layer === toRemove) {
                    this._layers.splice(index, 1);
                }
            });
            var layers = this.getOrderedLayers(true);
            jQuery.each(layers, function(index, layer) {
                layer.setStyle('order', index);
            });
            this.sortLayers();
            this._image.setConfiguration();
        },

        /**
         * reorderWatermarks
         * 
         * Ensures that the watermarks are the top most layer by adjusting their
         * order-style value. This function works by setting the order of the
         * watermark style value to the index of the watermark among all other
         * watermarks on the canvas, in addition to the number of previous
         * non-watermark layers. You might want to draw this on a piece of paper
         * to help visualize it if you need to.
         * 
         * @access  public
         * @return  void
         */
        reorderWatermarks: function() {
            var ordered = this.getOrderedLayers(false).length,
                watermarks = this.getWatermarkLayers();
            jQuery.each(watermarks, function(index, layer) {
                layer.setStyle('order', index + ordered);
            });
            this.sortLayers();
        },

        /**
         * setImage
         * 
         * @access  public
         * @param   ImageAccessor image
         * @return  void
         */
        setImage: function(image) {
            this._image = image;
        },

        /**
         * setupLayers
         * 
         * @access  public
         * @return  void
         */
        setupLayers: function() {
            var layer,
                klass,
                _this = this;
            this._layers = [];
            jQuery.each(this._document.layers, function(index, properties) {
                klass = false;
                if (properties.type === 'text') {
                    klass = TextLayer;
                } else if (properties.type === 'rectangle') {
                    klass = BackgroundRectangleLayer;
                } else if (properties.type === 'image') {
                    if (properties.watermark === true) {
                        if (properties.vector === true) {
                            if (properties.color === true) {
                                klass = WatermarkColorVectorImageLayer;
                            } else {
                                klass = WatermarkVectorImageLayer;
                            }
                        } else {
                            klass = WatermarkBitmapImageLayer;
                        }
                    } else if (properties.vector === true) {
                        if (properties.color === true) {
                            klass = ColorVectorImageLayer;
                        } else {
                            klass = VectorImageLayer;
                        }
                    } else {
                        if (properties.background === true) {
                            klass = BackgroundBitmapImageLayer;
                        } else {
                            klass = ForegroundBitmapImageLayer;
                        }
                    }
                }
                layer = new klass(properties, _this);
                if (layer.valid() === true) {
                    _this._layers.push(layer);
                }
            });
        },

        /**
         * sortLayers
         * 
         * I had a lot of trouble with this function, and ended up converting it
         * to a simpler (Sergei inspired) algorithm whereby I convert the
         * toString values to integers based on the desired order (background
         * rectangle as 0, background image as 1, followed by the layers with
         * their style order value being used [with 2 being added since the
         * order values start at 0]). Then when I perform the sort, I simply
         * perform it numerically by casting the strings as integers. After the
         * sort has been completed, I revert the _string values.
         * 
         * While this seems more cumbersome, it's much more dependable than what
         * I was doing before. I have no idea how to use the comparison function
         * with properties :/
         * 
         * @access  public
         * @return  void
         */
        sortLayers: function() {
            jQuery.each(this._layers, function(index, layer) {
                layer._previous = layer._string;
                if (
                    layer.getProperty('type') === 'rectangle'
                    && layer.getProperty('background') === true
                ) {
                    layer._string = 0;
                } else if (
                    layer.getProperty('type') === 'image'
                    && layer.getProperty('background') === true
                ) {
                    layer._string = 1;
                } else {
                    layer._string = layer.getStyle('order').toInt() + 2;
                }
            });
            this._layers.sort(function(a, b) {
                return a.toString().toInt() - b.toString().toInt();
            });
            jQuery.each(this._layers, function(index, layer) {
                layer._string = layer._previous;
                delete layer._previous;
            });
        },

        /**
         * syncLockedState
         * 
         * @access  public
         * @return  void
         */
        syncLockedState: function() {
            var lockedLayers = this.getLockedLayers(),
                draft = Stencil.account().draft();
            if (Account.draftIsLocked() === true) {
                if (lockedLayers.length === 0) {
                    draft.set({
                        'settings.locked': 0
                    });
                    draft.save(['settings.locked']);
                }
            } else {
                if (lockedLayers.length > 0) {
                    draft.set({
                        'settings.locked': 1
                    });
                    draft.save(['settings.locked']);
                }
            }
        }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * Layer
     * 
     * @fires   change/angle
     *          change/position
     *          change/scale
     *          set/property
     *          set/property/x
     *          set/style
     *          set/style/x
     *          move/up
     *          move/down
     *          move/right
     *          move/left
     *          refresh/dimensions
     * @extends Base
     */
    window.Layer = Base.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     undefined|String (default: undefined)
         */
        _changeHistoryKeyPrefix: undefined,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'layer')
         */
        _classType: 'layer',

        /**
         * _drawing
         * 
         * @access  protected
         * @var     null|Drawing (default: null)
         */
        _drawing: null,

        /**
         * _imageDocument
         * 
         * @access  protected
         * @var     false|ImageDocument (default: false)
         */
        _imageDocument: false,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return {
                'angle': function() {
                    this.on({
                        'change/angle': function(event, angle) {
                            this.setChangeOperationType('rotated');
                            this.setStyle('angle', angle);
                        }
                    });
                },
                'clone': function() {
                    this.on({
                        'clone': function(event) {
                            this.setChangeOperationType('cloned');
                            this.clone();
                        }
                    });
                },
                'delete': function() {
                    this.on({

                        /*
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() is
                         *          important for the case where a user is dragging
                         *          the layer around, and while they're dragging,
                         *          they click the delete-key. Without the call,
                         *          the canvas change gets registered as a
                         *          move-operation, rather than a delete operation.
                         *          See before/after screenshots below, with the
                         *          code below commented/uncommented out:
                         *          https://i.imgur.com/dgnsQBW.png
                         *          https://i.imgur.com/gCFkf43.png
                         */
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            Canvases.Preview.deselectSelectedLayer();
                            this._imageDocument.removeLayer(this);
                        }
                    });
                },
                'move': function() {
                    this.on({
                        'move/up': function(event) {
                            var height = this.getCanvas().getRenderedDimensions().height,
                                pixel = ((1 / height) * 100).round(4),
                                top = this._properties.styles.top,
                                adjusted = top - pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('top', rounded);
                        },
                        'move/right': function(event) {
                            var width = this.getCanvas().getRenderedDimensions().width,
                                pixel = ((1 / width) * 100).round(4),
                                left = this._properties.styles.left,
                                adjusted = left + pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('left', rounded);
                        },
                        'move/down': function(event) {
                            var height = this.getCanvas().getRenderedDimensions().height,
                                pixel = ((1 / height) * 100).round(4),
                                top = this._properties.styles.top,
                                adjusted = top + pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('top', rounded);
                        },
                        'move/left': function(event) {
                            var width = this.getCanvas().getRenderedDimensions().width,
                                pixel = ((1 / width) * 100).round(4),
                                left = this._properties.styles.left,
                                adjusted = left - pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('left', rounded);
                        }
                    });
                },
                'order': function() {
                    this.on({
                        'change/order': function(event, forward) {
                            if (forward === true) {
                                this.setChangeOperationType('sent:forward');
                                this.bringForward();
                            } else {
                                this.setChangeOperationType('sent:back');
                                this.sendBack();
                            }
                        }
                    });
                },
                'position': function() {
                    this.on({
                        'change/position': function(event, position) {
                            this.setChangeOperationType('moved');
                            this.setStyles({
                                'left': position.left,
                                'top': position.top
                            });
                        }
                    });
                },
                'properties': function() {
                    this.on({
                        'set/property': function(event, name, value, previous) {
                            this._imageDocument.getImage().setConfiguration();
                        },
                        'set/style': function(event, name, value, previous) {
                            this._imageDocument.getImage().setConfiguration();
                        }
                    });
                }
            };
        },

        /**
         * _properties
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _properties: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Layer')
         */
        _string: 'Layer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super();
            this._properties = properties;
            this._setupListeners();
            this._imageDocument = imageDocument;
        },

        /**
         * _setupListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupListeners: function() {
            this._listeners = this._listeners();
            for (var index in this._listeners) {
                this._listeners[index].apply(this);
            }
        },

        /**
         * autoAlign
         * 
         * @access  public
         * @return  void
         */
        autoAlign: function() {
            this.setChangeOperationType('centered');
            this._drawing.autoAlign();
        },

        /**
         * back
         * 
         * Returns whether the layer is the back-most layer, which is currently
         * exclusively used to determine whether or not the front / back buttons
         * should be shown. Because of this, it's not a truly semantic method,
         * since what it really means is "is it the front-most non-background
         * layer". Heads up incase an issue comes up down the line related to
         * this.
         * 
         * Also note that it doesn't take watermarks into consideration at the
         * moment, since they're always the front-most layers.
         * 
         * @access  public
         * @return  Boolean
         */
        back: function() {
            return this === this._imageDocument.getBottomOrderedLayer();
        },

        /**
         * bringForward
         * 
         * Sends the layer one order forward, adjusting the one it replaced to
         * take it's order-value.
         * 
         * @todo!   Detect if the layer is overlapping any other ones, and when
         *          it is, show the layer-UI button options. This might prevent
         *          people from clicking them when there are no overlap layers,
         *          and not noticing a change (and thus not sure what the
         *          buttons do)
         * @access  public
         * @return  void
         */
        bringForward: function() {
            var order = this._properties.styles.order.toInt(),
                layer = this._imageDocument.find(
                    'style',
                    'order',
                    order + 1
                );
            this.setStyle('order', order + 1);
            layer.setStyle('order', order);
            this._imageDocument.sortLayers();
        },

        /**
         * clone
         * 
         * @access  public
         * @return  void
         */
        clone: function() {
            var properties = DataUtils.clone(this._properties),
                canvas = this.getCanvas();
            properties.styles.order = this._imageDocument.getOrderedLayers(false).length;
            properties.styles.left += 5;
            properties.styles.top += 5;
            var layer = new this.constructor(properties, this._imageDocument),
                drawing = layer.getDrawing();
            this._imageDocument.addLayer(layer);
            this._imageDocument.reorderWatermarks();
            drawing.once({
                'draw': function(event) {
                    this.select();
                    canvas.render();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * front
         * 
         * Returns whether the layer is the front-most layer, which is currently
         * exclusively used to determine whether or not the front / back buttons
         * should be shown. Because of this, it's not a truly semantic method,
         * since what it really means is "is it the front-most non-watermark
         * layer". Heads up incase an issue comes up down the line related to
         * this.
         * 
         * @access  public
         * @return  Boolean
         */
        front: function() {
            return this === this._imageDocument.getTopOrderedLayer(false);
        },

        /**
         * getCanvas
         * 
         * @access  public
         * @return  CanvasView
         */
        getCanvas: function() {
            return this._imageDocument.getCanvas();
        },

        /**
         * getCotton
         * 
         * @access  public
         * @return  fabric.Object
         */
        getCotton: function() {
            return this._drawing.getCotton();
        },

        /**
         * getDrawing
         * 
         * @access  public
         * @return  Drawing
         */
        getDrawing: function() {
            return this._drawing;
        },

        /**
         * getImageDocument
         * 
         * @access  public
         * @return  ImageDocument
         */
        getImageDocument: function() {
            return this._imageDocument;
        },

        /**
         * getProperties
         * 
         * @access  public
         * @return  Object
         */
        getProperties: function() {
            return this._properties;
        },

        /**
         * getProperty
         * 
         * @access  public
         * @param   String name
         * @return  mixed
         */
        getProperty: function(name) {
            return this._properties[name];
        },

        /**
         * getStyle
         * 
         * @access  public
         * @param   String name
         * @return  mixed
         */
        getStyle: function(name) {
            return this._properties.styles[name];
        },

        /**
         * getStyles
         * 
         * @access  public
         * @return  Object
         */
        getStyles: function() {
            return this._properties.styles;
        },

        /**
         * goto
         * 
         * @access  public
         * @var     Object
         */
        goto: {

            /**
             * previous
             * 
             * Focuses on the layer in the position lower than the selected
             * one. If no layer is lower, it grabs the top layer. If no layer
             * other than the one already selected is found, nothing happens.
             * 
             * @access  public
             * @return  void
             */
            previous: function() {
                var order = this._properties.styles.order.toInt(),
                    previousLayer = this._imageDocument.find(
                        'style',
                        'order',
                        order - 1
                    );
                if (previousLayer === false) {
                    var activeBackgroundLayer = Canvases.Preview.getActiveBackgroundLayer();
                    activeBackgroundLayer.select();
                } else {
                    if (previousLayer !== this.getCanvas().getSelectedLayer()) {
                        previousLayer.select();
                    }
                }
            },

            /**
             * next
             * 
             * Focuses on the layer in the position higher than the selected
             * one. If no layer is higher, it grabs the bottom layer. If no
             * layer other than the one already selected is found, nothing
             * happens.
             * 
             * @access  public
             * @return  void
             */
            next: function() {
                var order = this._properties.styles.order.toInt(),
                    nextLayer = this._imageDocument.find(
                        'style',
                        'order',
                        order + 1
                    );
                if (nextLayer === false) {
                    var activeBackgroundLayer = Canvases.Preview.getActiveBackgroundLayer();
                    activeBackgroundLayer.select();
                } else {
                    if (nextLayer !== this.getCanvas().getSelectedLayer()) {
                        nextLayer.select();
                    }
                }
            }
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            this._drawing.select();
        },

        /**
         * sendBack
         * 
         * Sends the layer one order back, adjusting the one it replaced to take
         * it's position-value.
         * 
         * @todo!   Detect if the layer is overlapping any other ones, and when
         *          it is, show the layer-UI button options. This might prevent
         *          people from clicking them when there are no overlap layers,
         *          and not noticing a change (and thus not sure what the
         *          buttons do)
         * @access  public
         * @return  void
         */
        sendBack: function() {
            var order = this._properties.styles.order.toInt(),
                layer = this._imageDocument.find(
                    'style',
                    'order',
                    order - 1
                );
            this.setStyle('order', order - 1);
            layer.setStyle('order', order);
            this._imageDocument.sortLayers();
        },

        /**
         * setImageDocument
         * 
         * @access  public
         * @param   ImageDocument imageDocument
         * @return  void
         */
        // setImageDocument: function(imageDocument) {
        //     this._imageDocument = imageDocument;
        // },

        /**
         * setChangeOperationType
         * 
         * This is more or less a proxy for the ChangeHistory setOperatioType
         * method, to simplify the type that is passed. I lookup the type-prefix
         * for this layer, and pass that along.
         * 
         * @access  public
         * @param   String typePrefix
         * @return  void
         */
        setChangeOperationType: function(typePrefix) {
            var changeHistoryKeyPrefix = this._changeHistoryKeyPrefix,
                type = (changeHistoryKeyPrefix) + (typePrefix);
            ChangeHistory.setOperationType(type);
        },

        /**
         * setProperty
         * 
         * @access  public
         * @param   String name
         * @param   String value
         * @return  mixed
         */
        setProperty: function(name, value) {
            var previous = this._properties[name];
            this._properties[name] = value;
            this.triggerHandler('set/property', [name, value, previous]);
            this.triggerHandler('set/property/' + (name), [value, previous]);
        },

        /**
         * setStyle
         * 
         * @access  public
         * @param   String name
         * @param   mixed value
         * @return  void
         */
        setStyle: function(name, value) {
            var previous = this._properties.styles[name];
            this._properties.styles[name] = value;
            this.triggerHandler('set/style', [name, value, previous]);
            this.triggerHandler('set/style/' + (name), [value, previous]);
        },

        /**
         * setStyles
         * 
         * @access  public
         * @param   Object styles
         * @return  void
         */
        setStyles: function(styles) {
            for (var property in styles) {
                this.setStyle(property, styles[property]);
            }
            this.triggerHandler('set/styles', [styles]);
        },

        /**
         * valid
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            return true;
        }
    });
});
window.DependencyLoader.push('BitmapImageLayer', function() {

    /**
     * BackgroundBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.BackgroundBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, background: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, background: true // ',

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'image/changed': function() {
                    this.on({
                        'set/property/image': function(event, value, previous) {
                            if (value === false) {
                                this.setProperty('locked', false);
                            }
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundBitmapImageLayer')
         */
        _string: 'BackgroundBitmapImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new BackgroundBitmapImageDrawing(this);
            this.listenForGatewaySave();
            this.setupGatewaySave();
        },

        /**
         * _hideCotton
         * 
         * @access  protected
         * @return  void
         */
        _hideCotton: function() {
            this.getCotton().set({
                'visible': false
            });
        },

        /**
         * _normalizeProperties
         * 
         * @access  protected
         * @param   Object properties
         * @return  Object
         */
        _normalizeProperties: function(properties) {
            properties = this._super(properties);
            if (properties.styles.zoom === undefined) {
                properties.styles.zoom = 1;
            }
            return properties;
        },

        /**
         * _resetImage
         * 
         * Image is being reset (eg. color being applied to background
         * rectangle). I hide the cotton drawing instead of deleting it, which
         * would be the natual assumption, to ensure the layer is always
         * available.
         * 
         * @access  protected
         * @return  void
         */
        _resetImage: function() {
            this._resetPosition();
            this._hideCotton();
        },

        /**
         * _resetPosition
         * 
         * @access  protected
         * @return  void
         */
        _resetPosition: function() {
            this.setStyles({
                'flipX': false,
                'flipY': false,
                'left': 50,
                'top': 50
            });
            this.getCotton().set({
                'flipX': false,
                'flipY': false
            });
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  BackgroundBitmapImageToolbarView
         */
        getToolbar: function() {
            var toolbar = Toolbars.getToolbar('backgroundBitmapImage');
            return toolbar;
        },

        /**
         * goto
         * 
         * @access  public
         * @var     Object
         */
        goto: {

            /**
             * previous
             * 
             * @access  public
             * @return  void
             */
            previous: function() {
                var topLayer = this._imageDocument.getTopOrderedLayer(true);
                if (topLayer !== false) {
                    topLayer.select();
                }
            },

            /**
             * next
             * 
             * @access  public
             * @return  void
             */
            next: function() {
                var bottomLayer = this._imageDocument.getBottomOrderedLayer(
                    true
                );
                if (bottomLayer !== false) {
                    bottomLayer.select();
                }
            }
        },

        /**
         * listenForGatewaySave
         * 
         * Listens for a save event against the ResourceAccessor that this
         * BackgroundBitmapImageLayer is set to (if any). This listener works a
         * bit differently than the similar one in VectorImageLayer layers, in
         * that it gets called multiple times. Specifically, whenever a
         * 3rd-party resource (eg. Pexels, Pixabay, etc) is set as the
         * background image. This is because these layers work differently than
         * VectorImageLayer layers, in that they're never deleted, just shown /
         * hidden.
         * 
         * That being said, the calls need to exist in the constructor as well
         * to allow for the case when a 3rd-party resource is selected, and
         * before it's saved, a save attempt is made. In that case, when the
         * constructor is called, the image-property will be referencing that
         * 3rd-party resource, and the listener and save attempt logic need to
         * be triggered.
         * 
         * @access  public
         * @return  void
         */
        listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.getProperty('image') === previousKey) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousKey,
                                newKey
                            );
                            _this.setImage(newKey);
                            var canvas = _this.getCanvas(),
                                background = canvas.getBackgroundBitmapImageLayer();
                            if (background.getCanvas() !== Canvases.Ghost) {
                                var drawing = background.getDrawing();
                                drawing.once({
                                    'refresh': function(event) {
                                        canvas.render();
                                    }
                                });
                                drawing.reload();
                            }
                        }
                    }
                });
            }
        },

        /**
         * setImage
         * 
         * This is a helper-method for dealing with times when the
         * image-property for the layer needs to change. It's intention was to
         * reset position-styles when needed, hide the layer which an image was
         * being removed, and change the image-property in the layer.
         * 
         * @access  public
         * @param   String|false image
         * @return  Boolean Returns whether the image property was changed
         */
        setImage: function(image) {

            // The image hasn't changed
            if (image === this._properties.image) {
                return false;
            }

            // Image is being reset/removed
            if (image === false) {
                this._resetImage();
                this.setProperty('image', false);
                return true;
            }

            // New/different asset image
            if (image.match(/^asst/) !== null) {

                // Asset not available in memory
                var asset = Stencil.getAccessor(image);
                if (asset === false) {
                    this._resetPosition();
                    this.setProperty('image', image);
                    return true;
                }

                // Asset data not available
                if (asset.get('resourceType') === undefined) {
                    this._resetPosition();
                    this.setProperty('image', image);
                    return true;
                }

                // Current image matches asset's corresponding resource
                var resourceHash = asset.getResourceHash();
                if (this._properties.image === resourceHash) {
                    this.setProperty('image', image);
                    return true;
                }

                // Asset is different
                this._resetPosition();
                this.setProperty('image', image);
                return true;
            }

            // New/different upload, image or resource image
            this._resetPosition();
            this.setProperty('image', image);
            return true;
        },

        /**
         * setupGatewaySave
         * 
         * Very similar to the save logic setup in VectorImageLayer layers, with
         * the exception that a save call is not made if the image-property is
         * different than the one when this method was initially called. This is
         * because these layers are never deleted, just shown / hidden.
         * 
         * Like the listener method above, this method is called each time the
         * image is changed.
         * 
         * This delay-method is not prone to the issues that VectorImageLayer
         * layers are because of the property-check that is being made below
         * within the delayed function. That check prevents a possible issue
         * whereby the _getResource method was returning an AssetAccessor
         * (instead of a ResourceAccessor), therefore circumventing the issue.
         * 
         * If that check was not being made, then yes, the _getResource lookup
         * would need to be executed before the delay.
         * 
         * @see     https://github.com/onassar/Stencil/blob/9cbc58f42361ee2ddbdeb53c54fd5c64ae2fda75/TurtlePHP/application/webroot/app/static/js/layers/BackgroundBitmapImage.js
         * @see     https://i.imgur.com/seOP36x.png
         * @access  public
         * @return  void
         */
        setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Config.getSaveDelay('resource'),
                    resource = this._getResource(),
                    key = this._properties.image;
                (function() {
                    if (this.getProperty('image') === key) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        },

        /**
         * valid
         * 
         * I'm overriding the parent method because I need to ensure a
         * BackgroundBitmapImageLayer is always part of the image document. So
         * here, I use the parent to check if it's a valid layer (which in this
         * case means that if an image value is defined, it's set to an upload
         * or asset record), and if it's not, I still return true to ensure the
         * layer is not "skipped".
         * 
         * It should not cause any issues, since in the parent <valid> method,
         * it properly updates the image-property for the layer.
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            var image = this._properties.image;
            if (image === false) {
                return true;
            }
            if (this._super() === true) {
                return true;
            }
            return true;
        }
    });
});
window.DependencyLoader.push('RectangleLayer', function() {

    /**
     * BackgroundRectangleLayer
     * 
     * @extends RectangleLayer
     */
    window.BackgroundRectangleLayer = RectangleLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: rectangle, background: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: rectangle, background: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'backgroundColor': function() {
                    this.on({
                        'change/backgroundColor': function(event, backgroundColor, removed) {
                            if (removed === true) {
                                this.setChangeOperationType('backgroundColor:removed');
                            } else {
                                this.setChangeOperationType('backgroundColor:changed');
                            }
                            this.setStyle('backgroundColor', backgroundColor);
                        },
                        'clear/backgroundColor': function(event) {
                            this.setChangeOperationType('backgroundColor:cleared');
                            var transparentBlack = ColorUtils.getBlack('rgba', 0);
                            this.setStyle('backgroundColor', transparentBlack);
                        },
                        'reset/backgroundColor': function(event) {
                            var white = ColorUtils.getWhite('rgba');
                            this.setStyle('backgroundColor', white);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundRectangleLayer')
         */
        _string: 'BackgroundRectangleLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new BackgroundRectangleDrawing(this);
        },

        /**
         * goto
         * 
         * @access  public
         * @var     Object
         */
        goto: {

            /**
             * previous
             * 
             * @access  public
             * @return  void
             */
            previous: function() {
                var topLayer = this._imageDocument.getTopOrderedLayer(true);
                if (topLayer !== false) {
                    topLayer.select();
                }
            },

            /**
             * next
             * 
             * @access  public
             * @return  void
             */
            next: function() {
                var bottomLayer = this._imageDocument.getBottomOrderedLayer(
                    true
                );
                if (bottomLayer !== false) {
                    bottomLayer.select();
                }
            }
        },

        /**
         * hasTransparency
         * 
         * @access  public
         * @return  Boolean
         */
        hasTransparency: function() {
            var backgroundColor = this._properties.styles.backgroundColor,
                opacity = ColorUtils.getAlpha(backgroundColor);
            return opacity !== 1;
        }
    });
});
window.DependencyLoader.push('ImageLayer', function() {

    /**
     * BitmapImageLayer
     * 
     * @extends ImageLayer
     */
    window.BitmapImageLayer = ImageLayer.extend({

        /**
         * _defaultColorOverlayStrength
         * 
         * @access  protected
         * @var     Number (default: 55)
         */
        _defaultColorOverlayStrength: 55,

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'filters': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            var filters = this.getProperty('filters');
                            filters.push(obj);
                            this.setProperty('filters', filters);
                        },
                        'filter/remove': function(event, obj) {
                            var filters = this.getProperty('filters');
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].type === obj.type) {
                                    filters.splice(i, 1);
                                }
                            }
                            this.setProperty('filters', filters);
                        },
                        'filter/update': function(event, obj) {
                            var filters = this.getProperty('filters');
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].type === obj.type) {
                                    filters[i].properties = obj.properties;
                                }
                            }
                            this.setProperty('filters', filters);
                        }
                    });
                },
                'colorOverlay': function() {
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @note    There's a debounce on this because it results
                         *          in bitmap-level changes, which is slow.
                         */
                        'change/colorOverlay': _.debounce(
                            function(event, colorOverlay) {
                                colorOverlay = ColorUtils.convert(colorOverlay, 'rgba');
                                var filter = this.filters.get.apply(this, ['colorOverlay']);
                                this.set({'renderFilters': true});
                                if (filter === false) {
                                    this.setChangeOperationType('filter:colorOverlay:added');
                                    this.triggerHandler('filter/add', [{
                                        type: 'colorOverlay',
                                        properties: {
                                            color: colorOverlay,
                                            strength: this._defaultColorOverlayStrength
                                        }
                                    }]);
                                } else {
                                    this.setChangeOperationType('filter:colorOverlay:set');
                                    filter.properties.color = colorOverlay;
                                    this.triggerHandler('filter/update', [filter]);
                                }

                                // 
                                App.triggerHandler('changeHistory/track');
                                // $range.on({
                                //     'mouseup': function(event) {
                                //         (function() {
                                //             App.triggerHandler('changeHistory/track');
                                //         }).delay(filterResampleDelay);
                                //     }
                                // });
                            },
                            Config.getFilterResampleDelay()
                        ),
                        'clear/colorOverlay': function(event) {
                            var filter = this.filters.get.apply(this, ['colorOverlay']);
                            if (filter !== false) {
                                this.setChangeOperationType('filter:colorOverlay:cleared');
                                this.set({'renderFilters': true});
                                this.triggerHandler('filter/remove', [filter]);
                            }
                        }
                    });
                },
                'customFiltersStrengths': function() {
                    var customFilterTypes = [
                            'blur',
                            'colorOverlay',
                            'darken',
                            'lighten',
                            'opacity'
                        ],
                        _this = this,
                        index,
                        customFilterType,
                        eventType;
                    for (index in customFilterTypes) {
                        customFilterType = customFilterTypes[index];
                        eventType = 'change/' + (customFilterType) + 'Strength';
                        (function(customFilterType) {
                            _this.on(
                                eventType,
                                function(event, strength) {
                                    strength = strength.toInt();
                                    _this.set({'renderFilters': true});
                                    if (strength === 0) {
                                        _this.setChangeOperationType('filter:' + (customFilterType) + ':removed');
                                        this.triggerHandler('filter/remove', [{
                                            type: customFilterType
                                        }]);
                                        if (customFilterType === 'colorOverlay') {
                                            var toolbar = _this.getToolbar();
                                            toolbar.colorOverlay.clear.apply(
                                                toolbar
                                            );
                                        }
                                    } else {
                                        var filter = _this.filters.get.apply(_this, [customFilterType]);
                                        if (filter === false) {
                                            _this.setChangeOperationType('filter:' + (customFilterType) + ':added');
                                            var properties = {
                                                strength: strength
                                            };
                                            if (customFilterType === 'colorOverlay') {
                                                var color = ColorUtils.getBlack('rgba'),
                                                    toolbar = _this.getToolbar();
                                                properties.color = color;
                                                toolbar._set.colorOverlay.apply(toolbar, [color]);
                                                toolbar.colorOverlay.show.apply(toolbar);
                                            }
                                            this.triggerHandler('filter/add', [{
                                                type: customFilterType,
                                                properties: properties
                                            }]);
                                        } else {
                                            _this.setChangeOperationType('filter:' + (customFilterType) + ':set');
                                            filter.properties.strength = strength;
                                            this.triggerHandler('filter/update', [filter]);
                                        }
                                    }
                                }
                            );
                        })(customFilterType);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BitmapImageLayer')
         */
        _string: 'BitmapImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            properties = this._normalizeProperties(properties);
            this._super(properties, imageDocument);
        },

        /**
         * _normalizeProperties
         * 
         * When we first launched Stencil, filters were stored in an array as an
         * array of strings. They were simply strings like "darken", "lighten"
         * etc. However when we introduced the new filters system, we started
         * storing filters as an array of objects, where the object defined the
         * type of filter, along with properties (eg. strength, color, etc).
         * 
         * So we normalize that here to ensure the same object storage pattern,
         * thus making operations against it simpler.
         * 
         * @access  protected
         * @param   Object properties
         * @return  Object
         */
        _normalizeProperties: function(properties) {
            if (properties.filters === undefined) {
                properties.filters = [];
                return properties;
            }
            var filter, index, normalized;
            for (index in properties.filters) {
                filter = properties.filters[index];
                if (typeof filter === 'string') {
                    normalized = {
                        type: filter,
                        properties: {}
                    };
                } else {
                    normalized = {
                        type: filter.type,
                        properties: filter.properties || {}
                    };
                }
                properties.filters[index] = normalized;
            }
            return properties;
        },

        /**
         * filters
         * 
         * @access  public
         * @var     Object
         */
        filters: {

            /**
             * clear
             * 
             * @note    The renderFilters set and render are called after all filters
             *          have been removed to ensure a render isn't done for each one.
             * @access  public
             * @return  void
             */
            clear: function() {
                var filters = this.getProperty('filters'),
                    x = filters.length - 1;
                for (; x >= 0; x--) {
                    this.triggerHandler('filter/remove', [filters[x]]);
                }
                this.set({'renderFilters': true});
                this.getCanvas().render();
            },

            /**
             * get
             * 
             * @access  public
             * @param   String type
             * @return  Object|false
             */
            get: function(type) {
                var filters = this.getProperty('filters'),
                    index;
                for (index in filters) {
                    if (type === filters[index].type) {
                        return filters[index];
                    }
                }
                return false;
            },

            /**
             * sort
             * 
             * @access  public
             * @return  void
             */
            sort: function() {
                var cotton = this.getCotton(),
                    filters = cotton.get('filters');
                filters.sort(function(a, b) {
                    if (a.get('_stencilType') < b.get('_stencilType')) {
                        return -1;
                    }
                    if (a.get('_stencilType') > b.get('_stencilType')) {
                        return 1;
                    }
                    return 0;
                });
            }
        },

        /**
         * getCropBoxPositionData
         * 
         * @access  public
         * @return  Object
         */
        getCropBoxPositionData: function() {
            var defaultCropBoxPositionData = {
                aspectRatio: 1.5,
                locked: 0,
                shape: 'rectangle',
                styles: {
                    radius: '0'
                }
            };
            var cropPositionData = this.getProperty('cropPositionData');
            if (cropPositionData === undefined) {
                return defaultCropBoxPositionData;
            }
            if (cropPositionData.x === undefined) {
                return defaultCropBoxPositionData;
            }
            cropPositionData = DataUtils.clone(cropPositionData);
            cropPositionData.aspectRatio = (cropPositionData.width / cropPositionData.height).round(4);
            cropPositionData.locked = (cropPositionData.aspectRatio === 1) ? 1 : 0;
            if (cropPositionData.locked === 0) {
                cropPositionData.locked = (cropPositionData.shape === 'mask') ? 1 : 0;
            }
            return cropPositionData;
        }
    });
});
window.DependencyLoader.push('ImageLayer', function() {

    /**
     * ColorVectorImageLayer
     * 
     * @extends VectorImageLayer
     */
    window.ColorVectorImageLayer = VectorImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, vector: true, color: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, vector: true, color: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'opacityStrength': function() {
                    this.on({
                        'change/opacityStrength': function(event, opacityStrength) {
                            this.setChangeOperationType('opacityStrength:changed');
                            var opacityValue = ((100 - opacityStrength) / 100).round(2);
                            this.setStyle('opacity', opacityValue);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorVectorImageLayer')
         */
        _string: 'ColorVectorImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new ColorVectorImageDrawing(this);
        }
    });
});
window.DependencyLoader.push('BitmapImageLayer', function() {

    /**
     * ForegroundBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.ForegroundBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, background: false // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, background: false // ',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ForegroundBitmapImageLayer')
         */
        _string: 'ForegroundBitmapImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new ForegroundBitmapImageDrawing(this);
            this._listenForGatewaySave();
            this._setupGatewaySave();
        },

        /**
         * listenForGatewaySave
         * 
         * @access  protected
         * @return  void
         */
        _listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousyKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.get('deleted') === undefined) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousyKey,
                                newKey
                            );
                            _this.getImageDocument().getImage().set({
                                'resourceGatewaySave': '1'
                            });
                            _this.setProperty('image', newKey);
                            var canvas = _this.getCanvas();
                            if (canvas !== Canvases.Ghost) {
                                var drawing = _this.getDrawing();
                                drawing.once({
                                    'refresh': function(event) {
                                        canvas.render();
                                    }
                                });
                                drawing.refresh();
                            }
                        }
                    }
                });
            }
        },

        /**
         * _setupGatewaySave
         * 
         * @note    See layers/VectorImage.js for documentation on this method.
         * @access  protected
         * @return  void
         */
        _setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Config.getSaveDelay('resource'),
                    resource = this._getResource();
                (function() {
                    if (this.get('deleted') === undefined) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  ForegroundBitmapImageToolbarView
         */
        getToolbar: function() {
            var toolbar = Toolbars.getToolbar('foregroundBitmapImage');
            return toolbar;
        }
    });
});
window.DependencyLoader.push('Layer', function() {

    /**
     * ImageLayer
     * 
     * @extends Layer
     */
    window.ImageLayer = Layer.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'delete': function() {
                    this.on({

                        /*
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() is
                         *          important for the case where a user is dragging
                         *          the layer around, and while they're dragging,
                         *          they click the delete-key. Without the call,
                         *          the canvas change gets registered as a
                         *          move-operation, rather than a delete operation.
                         *          See before/after screenshots below, with the
                         *          code below commented/uncommented out:
                         *          https://i.imgur.com/dgnsQBW.png
                         *          https://i.imgur.com/gCFkf43.png
                         */
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            Canvases.Preview.deselectSelectedLayer();
                            this._imageDocument.removeLayer(this);
                            Stencil.account().draft().getImageDocument().syncLockedState();
                        }
                    });
                },
                'dimensions': function() {
                    this.on({
                        'change/dimensions': function(event, dimensions) {
                            this.setChangeOperationType('scaled');
                            this.setStyles({
                                'flipX': dimensions.flipX,
                                'flipY': dimensions.flipY,
                                'left': dimensions.left,
                                'stretchX': dimensions.stretchX,
                                'stretchY': dimensions.stretchY,
                                'top': dimensions.top,
                                'width': dimensions.width
                            });
                        }
                    });
                },
                'flip': function() {
                    this.on({
                        'flip/x': function(event, flip) {
                            this.setChangeOperationType('flipped:x');
                            this.setStyle('flipX', flip);
                        },
                        'flip/y': function(event, flip) {
                            this.setChangeOperationType('flipped:y');
                            this.setStyle('flipY', flip);
                        }
                    });
                },
                'locked': function() {
                    this.on({
                        'set/property/locked': function(event, locked) {
                            Stencil.account().draft().getImageDocument().syncLockedState();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageLayer')
         */
        _string: 'ImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
        },

        /**
         * _getResource
         * 
         * Returns a ResourceAccessor relating to a 3rd-party resource, or else
         * false if it couldn't be found in memory.
         * 
         * @access  protected
         * @return  ResourceAccessor|false
         */
        _getResource: function() {
            var key = this._properties.image;
            return Stencil.getAccessor(key);
        },

        /**
         * _isResource
         * 
         * Checks whether the key specified by the image property value
         * corresponds to a 3rd-party resource, and that it's availabel in
         * memory.
         * 
         * Note that the key equaling false check is only made to accommodate
         * BackgroundBitmapImageLayer layers, which allow for this. This will
         * not ever happy with VectorImageLayer layers.
         * 
         * @access  protected
         * @return  Boolean
         */
        _isResource: function() {
            var key = this._properties.image;
            if (key === false) {
                return false;
            }
            if (key.match(/^asst/) !== null) {
                return false;
            }
            if (key.match(/^img0/) !== null) {
                return false;
            }
            if (key.match(/^upld/) !== null) {
                return false;
            }
            return this._getResource() !== false;
        },

        /**
         * valid
         * 
         * Returns whether the layer has a valid image defined. A valid image is
         * one that points to either an asset or upload record, or else resource
         * accessor. This needs to happen because it's possible that when a user
         * chooses a TNP icon or Pixabay image, something goes wrong when trying
         * to save it and change the image key for the layer from the 3rd party
         * resource id/hash to the Stencil asset. Without this check, it's
         * possible that if something does go wrong, the image document will
         * fail to be drawn.
         * 
         * So for the end user, it's possible that something might appear to be
         * "missing" for them, but it's to prevent larger issues.
         * 
         * In real life, this could happen in the following situation:
         * They click an icon from the search results, and it gets added to the
         * canvas. If something breaks on the server side and the resource can't
         * be saved as an asset, the user will then see the ErrorModal view.
         * After this, they'll reload the page, with an image document that has
         * a layer, which in turn has an image-property referencing a TNP or
         * Pixabay resource. That is when this method is useful; it will ensure
         * that the canvas is still drawn, simply by "skipping" over the defunkt
         * layer (this "skipping" logic is done elsewhere).
         * 
         * Note that if the above situation does occur, it's possible for the
         * layer not to be marked as defunkt, because if the ImageAccessor's
         * <saveConfiguration> method doesn't fire before the ErrorModal UI
         * kills the app, the layer won't actually be saved to the DB. But it is
         * possible, if for instance it takes a long time to save the resource.
         * In that case, the ImageAccessor's saveConfiguration method may have
         * fired, thus saving to the DB, and thus turning the image defunkt.
         * 
         * Another possible case is if the user chooses a Pixabay image, and
         * closes the app before the /save call has gone out, but after the
         * PATCH call has. In that case, the draft is referencing a resource, so
         * when they revisit the app, it could break unless this validiation
         * method is called.
         * 
         * After checking for an asset or upload (via the /^asst/ and /^upld/
         * regular expressions), I check if the image is an accessor on the
         * page, since if the user very-quickly adds a resource to the canvas,
         * and before it's saved as an asset, tries to download the image, the
         * Ghost canvas will be referencing a resource (eg. TheNounProject:123),
         * which is valid, since it's in memory. This therefore needs to pass.
         * 
         * Also note that if the image is invalid, I set the image-property to
         * false. This is to ensure in the next image-saveConfiguration call
         * that goes out, the json for the image no longer references a defunkt
         * image property.
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            var key = this._properties.image;
            if (key.match(/^asst/) !== null) {
                return true;
            }
            if (key.match(/^img0/) !== null) {
                return true;
            }
            if (key.match(/^upld/) !== null) {
                return true;
            }
            if (Stencil.getAccessor(key) !== false) {
                return true;
            }
            this.log('Layer marked as invalid', true);
            this.setProperty('image', false);
            return false;
        }
    });
});
window.DependencyLoader.push('Layer', function() {

    /**
     * RectangleLayer
     * 
     * @extends Layer
     */
    window.RectangleLayer = Layer.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RectangleLayer')
         */
        _string: 'RectangleLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
        }
    });
});
window.DependencyLoader.push('Layer', function() {

    /**
     * TextLayer
     * 
     * @fires   change/fontFamily
     *          change/backdropColor
     *          change/fontSize
     *          change/bold
     *          change/italic
     *          change/underline
     *          change/align
     *          change/textColor
     *          change/text
     *          change/strokeColor
     * @extends Layer
     */
    window.TextLayer = Layer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: text // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: text // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'align': function() {
                    this.on({
                        'change/align': function(event, align) {
                            if (this.getStyle('align') !== align) {
                                this.setChangeOperationType('aligned:' + (align));
                            }
                            this.setStyle('align', align);
                        }
                    });
                },
                'backdropColor': function() {
                    this.on({
                        'change/backdropColor': function(event, backdropColor) {
                            var backdropAdded = this.getStyle('backdropColor') === false;
                            if (backdropAdded === true) {
                                this.setChangeOperationType('backdrop:colorAdded');
                            } else {
                                this.setChangeOperationType('backdrop:colorChanged');
                            }
                            this.setStyle('backdropColor', backdropColor);
                        },
                        'change/backdropStretch': function(event, backdropStretch) {
                            this.setChangeOperationType('backdrop:stretchChanged');
                            this.setStyle('backdropStretch', backdropStretch);
                        },
                        'clear/backdropColor': function(event) {
                            this.setChangeOperationType('backdrop:removed');
                            this.setStyle('backdropColor', false);
                        }
                    });
                },
                'bold': function() {
                    this.on({
                        'change/bold': function(event, bold) {
                            this.setStyle('bold', bold === true);
                            var changeName = 'bold:' + (
                                bold === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        },
                        'revert/bold': function(event) {
                            this.setStyle('bold', false);
                        }
                    });
                },
                /**
                 * Notice tht I'm accessing the fonts dropdown, and initiating a
                 * close call against it. This is because it's possible that a
                 * user selects a text layer, opens up the fonts drop down, and
                 * then presses the delete key on their keyboard. In this case,
                 * it's important to ensure the fonts dropdown is closed.
                 */
                'delete': function() {
                    this.on({

                        /*
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() is
                         *          important for the case where a user is dragging
                         *          the layer around, and while they're dragging,
                         *          they click the delete-key. Without the call,
                         *          the canvas change gets registered as a
                         *          move-operation, rather than a delete operation.
                         *          See before/after screenshots below, with the
                         *          code below commented/uncommented out:
                         *          https://i.imgur.com/dgnsQBW.png
                         *          https://i.imgur.com/gCFkf43.png
                         */
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            Canvases.Preview.deselectSelectedLayer();
                            this._imageDocument.removeLayer(this);
                            Toolbars.getToolbar('text').getFontsDropdown().close();
                        }
                    });
                },
                'dimensions': function() {
                    this.on({
                        'change/dimensions': function(event, dimensions) {
                            this.setStyles({
                                'left': dimensions.left,
                                'top': dimensions.top,
                                'width': dimensions.width
                            });
                        },
                        'refresh/dimensions': function(event) {
                            var dimensions = this._drawing.getDimensions();
                            this.triggerHandler(
                                'change/dimensions',
                                dimensions
                            );
                        }
                    });
                },
                'fontFamily': function() {
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @access  private
                         * @param   Object event
                         * @param   FontAccessor font
                         * @return  void
                         */
                        'change/fontFamily': function(event, font) {
                            this.setChangeOperationType('fontFamilyChanged');
                            var fontFamily = font.get('familyName');
                            this.setStyle('fontFamily', fontFamily);
                        }
                    });
                },
                'fontSize': function() {
                    this.on({
                        'change/fontSize': function(event, fontSize) {
                            this.setChangeOperationType('fontSizeChanged');
                            this.setStyle('fontSize', fontSize);
                        }
                    });
                },
                'italic': function() {
                    this.on({
                        'change/italic': function(event, italic) {
                            this.setStyle('italic', italic === true);
                            var changeName = 'italic:' + (
                                italic === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        },
                        'revert/italic': function(event) {
                            this.setStyle('italic', false);
                        }
                    });
                },
                'lineHeight': function() {
                    this.on({
                        'change/lineHeight': function(event, lineHeight) {
                            this.setChangeOperationType('lineHeightChanged');
                            this.setStyle('lineHeight', lineHeight);
                        }
                    });
                },
                'shadowStrength': function() {
                    this.on({
                        /**
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() call
                         *          below is important to ensure that when the
                         *          shadowStrength is 0, the operation gets
                         *          registered as a removal, rather than a shadow
                         *          strength change. Otherwise the change history
                         *          would say "Drop shadow changed" when in fact it
                         *          was removed (and I believe this may create an
                         *          incorrect entry in the ChangeHistory stack for
                         *          the account).
                         */
                        'change/shadowStrength': function(event, shadowStrength) {
                            if (shadowStrength.toInt() === 0) {
                                ChangeHistory.clearOperationType();
                                this.setChangeOperationType('shadowStrength:removed');
                            } else {
                                if (
                                    this.getStyle('shadowStrength') === undefined
                                    || this.getStyle('shadowStrength').toInt() === 0
                                ) {
                                    this.setChangeOperationType('shadowStrength:added');
                                } else {
                                    this.setChangeOperationType('shadowStrength:changed');
                                }
                            }
                            this.setStyle(
                                'shadowStrength',
                                shadowStrength.toInt()
                            );
                        }
                    });
                },
                'strokeColor': function() {
                    this.on({
                        'change/strokeColor': function(event, strokeColor) {
                            var strokeAdded = this.getStyle('strokeColor') === false;
                            if (strokeAdded === true) {
                                this.setChangeOperationType('strokeColor:added');
                            } else {
                                this.setChangeOperationType('strokeColor:changed');
                            }
                            this.setStyle('strokeColor', strokeColor);
                        },
                        'clear/strokeColor': function(event) {
                            this.setChangeOperationType('strokeColor:removed');
                            this.setStyle('strokeColor', false);
                        }
                    });
                },
                'text': function() {
                    this.on({
                        'change/text': function(event, text) {
                            this.setChangeOperationType('text:changed');
                            this.setProperty('text', text);
                        }
                    });
                },
                'textColor': function() {
                    this.on({
                        'change/textColor': function(event, textColor) {
                            this.setChangeOperationType('textColorChanged');
                            this.setStyle('textColor', textColor);
                        }
                    });
                },
                'underline': function() {
                    this.on({
                        'change/underline': function(event, underline) {
                            this.setStyle('underline', underline === true);
                            var changeName = 'underline:' + (
                                underline === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TextLayer')
         */
        _string: 'TextLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new TextDrawing(this);
        }
    });
});
window.DependencyLoader.push('ImageLayer', function() {

    /**
     * VectorImageLayer
     * 
     * @extends ImageLayer
     */
    window.VectorImageLayer = ImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, vector: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, vector: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                'fillColor': function() {
                    this.on({
                        'change/fillColor': function(event, fillColor) {
                            this.setChangeOperationType('fillColor:changed');
                            this.setStyle('fillColor', fillColor);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorImageLayer')
         */
        _string: 'VectorImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            properties = this._normalizeProperties(properties);
            this._super(properties, imageDocument);
            this._drawing = new VectorImageDrawing(this);
            this._listenForGatewaySave();
            this._setupGatewaySave();
        },

        /**
         * _listenForGatewaySave
         * 
         * Listeners for a save event against a vector resource, and swaps out
         * the image key once returned if the layer has not been deleted.
         * 
         * @access  protected
         * @return  void
         */
        _listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousyKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.get('deleted') === undefined) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousyKey,
                                newKey
                            );
                            _this.getImageDocument().getImage().set({
                                'resourceGatewaySave': '1'
                            });
                            _this.setProperty('image', newKey);
                        }
                    }
                });
            }
        },

        /**
         * _normalizeProperties
         * 
         * @access  protected
         * @param   Object properties
         * @return  Object
         */
        _normalizeProperties: function(properties) {
            if (properties.color === undefined) {
                properties.color = false;
            }
            if (properties.filters === undefined) {
                properties.filters = [];
            }
            return properties;
        },

        /**
         * _setupGatewaySave
         * 
         * Triggers a /save action against an icon after a globally-defined
         * delay if the layer has not been deleted. While the method <save>
         * could be called multiple times (for example, when cloning vectors),
         * it won't matter, since only one call to /save will go out at most.
         * 
         * It is important that the resource is stored as a local variable
         * before the delay, rather than be called from within there, because
         * it is possible (for example, in the case of adding an icon and
         * cloning it before it's been saved to the server) that by the time the
         * delayed-function is executed, the _getResource method points to an
         * AssetAccessor rather than a ResourceAccessor. In that case, calling
         * the save method was causing an error, since the save method on an
         * AssetAccessor is very different than on a ResourceAccessor.
         * 
         * The reason the _getResource method was pointing to the AssetAccessor
         * is because after the first icon had a /save called initiated, once
         * returned, all VectorImageLayer layers that were referencing that TNP
         * icon had their listeners triggered, and swapped out the
         * image-property for the asset. _getResource was thus pointing to an
         * AssetAccessor since it uses the _data.key property to look up the
         * accessor.
         * 
         * @access  protected
         * @return  void
         */
        _setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Config.getSaveDelay('resource'),
                    resource = this._getResource();
                (function() {
                    if (this.get('deleted') === undefined) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        }
    });
});
window.DependencyLoader.push('BitmapImageLayer', function() {

    /**
     * WatermarkBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.WatermarkBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, vector: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, watermark: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {

                /**
                 * Listener for when the WatermarkUploadAccessor associated with
                 * this layer is deleted from an account all together. I simply
                 * trigger a delete event against the layer. The reason I ensure
                 * that the layer has not been deleted is because otherwise,
                 * deleting a watermark could result in triggering delete-events
                 * against all previously added-and-then-removed watermark
                 * layers.
                 * 
                 * Additionally, I ensure that the ImageDocument for the layer
                 * is the same as that of the draft ImageAccessor. This is to
                 * prevent updating layers belong to older ImageDocuments. That
                 * was resulting in a bug when deleting a watermark that was
                 * previously saved, but also resulted in PATCH calls against
                 * all previously saved images, since a layer within that image
                 * had been deleted.
                 */
                'delete/watermark': function() {
                    var layer = this;
                    this.getWatermark().once({
                        'delete': function(event) {
                            if (
                                Stencil.account().draft().getImageDocument() === layer.getImageDocument()
                                && layer.get('deleted') === undefined
                            ) {
                                // var uploadKey = this.get('key');
                                // ChangeHistory.syncWatermark(uploadKey);
                                layer.triggerHandler('delete');
                            }
                        }
                    });
                },

                /**
                 * The listener-key used here is just to communicate that there
                 * is a listener on the delete event, with an intention to
                 * access the draft.
                 * 
                 * When this watermark layer is deleted, I need to ensure that
                 * the draft ImageAccessor has the most up-to-date watermarks
                 * setting value. So I manage that here.
                 */
                'delete/draft': function() {
                    this.on({
                        'delete': function(event) {
                            Stencil.account().draft().setConfiguration();
                        }
                    });
                },
                'filters/sync': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/remove': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/update': function(event, obj) {
                            this.getWatermark().setFilters();
                        }
                    });
                },
                'setStyles': function() {
                    this.on({
                        'set/style': function(event, name, value, previous) {
                            this.getWatermark().setStyles();
                        }
                    });
                },
                'crop': function() {
                    this.on({
                        'set/property/cropPositionData': function(event, name, value, previous) {
                            this.getWatermark().setCropSettings();
                        },
                        'set/property/cropSourceKey': function(event, name, value, previous) {
                            this.getWatermark().setCropSettings();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkBitmapImageLayer')
         */
        _string: 'WatermarkBitmapImageLayer',

        /**
         * init
         * 
         * The below logic that checks whether the canvas that this layer
         * belongs to is the Ghost canvas was discovered when the following bug
         * happened:
         * After an initial save, the styles for the WatermarkUploadAccessor were not
         * getting saved.
         * 
         * This seemed to be happening because after a save (or download, p+s,
         * or save as template), the WatermarkUploadAccessor would reference a
         * different layer (namely, the ephemeral layer that is created for the
         * Ghost canvas). So the styles in that layer were not getting updated
         * as the user manipulated the WatermarkLayer layer.
         * 
         * Tough one to crack (level3) 
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new WatermarkBitmapImageDrawing(this);
            if (this.getCanvas() !== Canvases.Ghost) {
                this.getWatermark().setLayer(this);
                this.getWatermark().markStylesAsSaved();
            }
            this._addCropListener();
        },

        /**
         * _addCropListener
         * 
         * @access  protected
         * @return  void
         */
        _addCropListener: function() {
            this.on({
                'set/property/cropPositionData': function(event, value, previous) {
                    var key = this._properties.image,
                        accessor = Stencil.getAccessor(key),
                        properties = {
                            'settings.crop': 1,
                            'settings.cropPositionData': JSON.stringify(value),
                            'settings.cropSourceKey': accessor.setting('cropSourceKey')
                        };
                    accessor.set(properties);
                }
            });
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  WatermarkBitmapImageToolbarView
         */
        getToolbar: function() {
            var toolbar = Toolbars.getToolbar('watermarkBitmapImage');
            return toolbar;
        },

        /**
         * getWatermark
         * 
         * @access  public
         * @return  WatermarkUploadAccessor
         */
        getWatermark: function() {
            return Stencil.getAccessor(this._properties.image);
        }
    });
});
window.DependencyLoader.push('ImageLayer', function() {

    /**
     * WatermarkColorVectorImageLayer
     * 
     * @extends VectorImageLayer
     */
    window.WatermarkColorVectorImageLayer = VectorImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, watermark: true, vector: true, color: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, watermark: true, vector: true, color: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {

                /**
                 * Listener for when the WatermarkUploadAccessor associated with
                 * this layer is deleted from an account all together. I simply
                 * trigger a delete event against the layer. The reason I ensure
                 * that the layer has not been deleted is because otherwise,
                 * deleting a watermark could result in triggering delete-events
                 * against all previously added-and-then-removed watermark
                 * layers.
                 * 
                 * Additionally, I ensure that the ImageDocument for the layer
                 * is the same as that of the draft ImageAccessor. This is to
                 * prevent updating layers belong to older ImageDocuments. That
                 * was resulting in a bug when deleting a watermark that was
                 * previously saved, but also resulted in PATCH calls against
                 * all previously saved images, since a layer within that image
                 * had been deleted.
                 */
                'delete/watermark': function() {
                    var layer = this;
                    this.getWatermark().once({
                        'delete': function(event) {
                            if (
                                Stencil.account().draft().getImageDocument() === layer.getImageDocument()
                                && layer.get('deleted') === undefined
                            ) {
                                // var uploadKey = this.get('key');
                                // ChangeHistory.syncWatermark(uploadKey);
                                layer.triggerHandler('delete');
                            }
                        }
                    });
                },

                /**
                 * The listener-key used here is just to communicate that there
                 * is a listener on the delete event, with an intention to
                 * access the draft.
                 * 
                 * When this watermark layer is deleted, I need to ensure that
                 * the draft ImageAccessor has the most up-to-date watermarks
                 * setting value. So I manage that here.
                 */
                'delete/draft': function() {
                    this.on({
                        'delete': function(event) {
                            Stencil.account().draft().setConfiguration();
                        }
                    });
                },
                'filters/sync': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/remove': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/update': function(event, obj) {
                            this.getWatermark().setFilters();
                        }
                    });
                },
                'setStyles': function() {
                    this.on({
                        'set/style': function(event, name, value, previous) {
                            this.getWatermark().setStyles();
                        }
                    });
                },

                // 
                'opacityStrength': function() {
                    this.on({
                        'change/opacityStrength': function(event, opacityStrength) {
                            this.setChangeOperationType('opacityStrength:changed');
                            var opacityValue = ((100 - opacityStrength) / 100).round(2);
                            this.setStyle('opacity', opacityValue);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkColorVectorImageLayer')
         */
        _string: 'WatermarkColorVectorImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new WatermarkColorVectorImageDrawing(this);
            if (this.getCanvas() !== Canvases.Ghost) {
                this.getWatermark().setLayer(this);
                this.getWatermark().markStylesAsSaved();
            }
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  WatermarkColorVectorImageToolbarView
         */
        getToolbar: function() {
            var toolbar = Toolbars.getToolbar('watermarkColorVectorImage');
            return toolbar;
        },

        /**
         * getWatermark
         * 
         * @access  public
         * @return  WatermarkUploadAccessor
         */
        getWatermark: function() {
            return Stencil.getAccessor(this._properties.image);
        }
    });
});
window.DependencyLoader.push('ImageLayer', function() {

    /**
     * WatermarkVectorImageLayer
     * 
     * @extends VectorImageLayer
     */
    window.WatermarkVectorImageLayer = VectorImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, watermark: true, vector: true, color: false // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, watermark: true, vector: true, color: false // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {

                /**
                 * Listener for when the WatermarkUploadAccessor associated with
                 * this layer is deleted from an account all together. I simply
                 * trigger a delete event against the layer. The reason I ensure
                 * that the layer has not been deleted is because otherwise,
                 * deleting a watermark could result in triggering delete-events
                 * against all previously added-and-then-removed watermark
                 * layers.
                 * 
                 * Additionally, I ensure that the ImageDocument for the layer
                 * is the same as that of the draft ImageAccessor. This is to
                 * prevent updating layers belong to older ImageDocuments. That
                 * was resulting in a bug when deleting a watermark that was
                 * previously saved, but also resulted in PATCH calls against
                 * all previously saved images, since a layer within that image
                 * had been deleted.
                 */
                'delete/watermark': function() {
                    var layer = this;
                    this.getWatermark().once({
                        'delete': function(event) {
                            if (
                                Stencil.account().draft().getImageDocument() === layer.getImageDocument()
                                && layer.get('deleted') === undefined
                            ) {
                                // var uploadKey = this.get('key');
                                // ChangeHistory.syncWatermark(uploadKey);
                                layer.triggerHandler('delete');
                            }
                        }
                    });
                },

                /**
                 * The listener-key used here is just to communicate that there
                 * is a listener on the delete event, with an intention to
                 * access the draft.
                 * 
                 * When this watermark layer is deleted, I need to ensure that
                 * the draft ImageAccessor has the most up-to-date watermarks
                 * setting value. So I manage that here.
                 */
                'delete/draft': function() {
                    this.on({
                        'delete': function(event) {
                            Stencil.account().draft().setConfiguration();
                        }
                    });
                },
                'filters/sync': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/remove': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/update': function(event, obj) {
                            this.getWatermark().setFilters();
                        }
                    });
                },
                'setStyles': function() {
                    this.on({
                        'set/style': function(event, name, value, previous) {
                            this.getWatermark().setStyles();
                        }
                    });
                },

                // 
                'fillColor': function() {
                    this.on({
                        'change/fillColor': function(event, fillColor) {
                            this.setChangeOperationType('fillColor:changed');
                            this.setStyle('fillColor', fillColor);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkVectorImageLayer')
         */
        _string: 'WatermarkVectorImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new WatermarkVectorImageDrawing(this);
            if (this.getCanvas() !== Canvases.Ghost) {
                this.getWatermark().setLayer(this);
                this.getWatermark().markStylesAsSaved();
            }
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  WatermarkVectorImageToolbarView
         */
        getToolbar: function() {
            var toolbar = Toolbars.getToolbar('watermarkVectorImage');
            return toolbar;
        },

        /**
         * getWatermark
         * 
         * @access  public
         * @return  WatermarkUploadAccessor
         */
        getWatermark: function() {
            return Stencil.getAccessor(this._properties.image);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * AccountModel
     * 
     * @extends Model
     */
    window.AccountModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/accounts')
         */
        _base: '/api/accounts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AccountModel')
         */
        _string: 'AccountModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Account')
         */
        _type: 'Account',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * AssetModel
     * 
     * @extends Model
     */
    window.AssetModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/assets')
         */
        _base: '/api/assets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AssetModel')
         */
        _string: 'AssetModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Asset')
         */
        _type: 'Asset',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * CategoryModel
     * 
     * @extends Model
     */
    window.CategoryModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/categories')
         */
        _base: '/api/categories',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoryModel')
         */
        _string: 'CategoryModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Category')
         */
        _type: 'Category',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * featureObjects
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @return  void
         */
        featureObjects: function(key, data) {
            var path = '/categories/' + (key) + '/featureObjects';
            RequestUtils.ajax({
                signature: {"basename":"Category.js","line":55},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        var category = Stencil.getAccessor(key),
                            index,
                            accessor;
                        for (index in data.objects) {
                            accessor = Stencil.getAccessor(data.objects[index]);
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = '70-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * pin
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        pin: function(key, data) {
            var path = '/categories/' + (key) + '/pin';
            RequestUtils.ajax({
                signature: {"basename":"Category.js","line":88},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        var category = Stencil.getAccessor(key);
                        category.set({
                            pinKey: response.data.category.pinKey
                        });
                    } else {
                        var error = Stencil.extractError(response),
                            code = '100-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * unfeatureObjects
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @return  void
         */
        unfeatureObjects: function(key, data) {
            var path = '/categories/' + (key) + '/featureObjects';
            RequestUtils.ajax({
                signature: {"basename":"Category.js","line":119},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        var category = Stencil.getAccessor(key),
                            index,
                            accessor;
                        for (index in data.objects) {
                            accessor = Stencil.getAccessor(data.objects[index]);
                            category.syncedFeatures.remove.apply(category, [accessor]);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = '134-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * ColorModel
     * 
     * @extends Model
     */
    window.ColorModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/colors')
         */
        _base: '/api/colors',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorModel')
         */
        _string: 'ColorModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Color')
         */
        _type: 'Color',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * ConnectionModel
     * 
     * @extends Model
     */
    window.ConnectionModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/connections')
         */
        _base: '/api/connections',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionModel')
         */
        _string: 'ConnectionModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Connection')
         */
        _type: 'Connection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * CouponModel
     * 
     * @extends Model
     */
    window.CouponModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/coupons')
         */
        _base: '/api/coupons',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CouponModel')
         */
        _string: 'CouponModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Coupon')
         */
        _type: 'Coupon',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * CustomerModel
     * 
     * @extends Model
     */
    window.CustomerModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/customers')
         */
        _base: '/api/customers',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomerModel')
         */
        _string: 'CustomerModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Customer')
         */
        _type: 'Customer',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * FacebookModel
     * 
     * @todo!   Communicate to the user what was added, if anything:
     *          https://i.imgur.com/9SuECDv.png
     * @events  connected
     *          denied
     * @extends Model
     */
    window.FacebookModel = Model.extend({

        /**
         * _callbacks
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _callbacks: {},

        /**
         * _permissions
         * 
         * @note    Breakdown of why below permissions are required
         *          user_posts       Analytics; access shared posts
         *          user_photos      Posting; post to Timeline album
         *          publish_pages    Posting; post to page
         *          manage_pages     Posting; access pages
         *          read_insights    Analytics; access posts on pages
         *          publish_action   Posting: post to profile
         * @see     https://developers.facebook.com/docs/apps/upgrading#v22tov23
         * @access  protected
         * @var     Object
         */
        _permissions: {
            all: [
                'manage_pages',
                'publish_pages'
            ],
            minimum: [
                'manage_pages',
                'publish_pages'
            ]
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FacebookModel')
         */
        _string: 'FacebookModel',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _connect
         * 
         * @todo    Add in timer so that if the busy modal doesn't go away after
         *          x seconds, give option to cancel. This can be useful for
         *          popup blockers where the window is not available, or else
         *          something goes wrong and they need to bail.
         * @todo!   Look into facebooks reauthenticate parameter. Might be a
         *          simpler way to get multiple accounts on:
         *          https://i.imgur.com/GBxeX9p.jpg
         * @access  protected
         * @return  void
         */
        _connect: function() {
            var _this = this;
            RequestUtils.ajax({
                signature: {"basename":"Facebook.js","line":81},
                url: '/facebook/connect',
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        Track.event('Facebook connections added', {
                            _count: response.data.connections.length
                        });
                        var account = Stencil.account(),
                            collection = account.collection('connections');
                        if (response.data.connections.length === 0) {
                            if (collection.length() === 0) {
                                Stencil.alert('services.facebook.pages.noneFound');
                            } else {
                                Stencil.alert('services.facebook.pages.noUniqueFound');
                            }
                        } else {
                            var connections = collection.map(
                                response.data.connections
                            );
                            _this.connected(connections);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = '105-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * _minimum
         * 
         * @see     https://i.imgur.com/rJ4wjwX.png
         * @access  protected
         * @param   Object response
         * @return  Boolean
         */
        _minimum: function(response) {
            if (response.data === undefined) {
                return false;
            }
            if (response.data.length === 0) {
                return false;
            }
            var minimum, x, y, permission;
            for (x = 0; x < this._permissions.minimum.length; x++) {
                minimum = this._permissions.minimum[x];
                for (y = 0; y < response.data.length; ++y) {
                    permission = response.data[y];
                    if (permission.permission === minimum) {
                        if (permission.status === 'granted') {
                            break;
                        }
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * connect
         * 
         * @note    Possible responses:
         *          Object {authResponse: null, status: "not_authorized"}
         *          Object {authResponse: undefined, status: undefined}
         * @note    I do a second call to determine the permissions because the
         *          documented <return_scopes> parameter does not always work.
         *          If it did, I could simply rely on the response from Facebook
         *          to check if the minimum permissions were granted.
         * @see     https://i.imgur.com/4mXm6s2.png
         * @access  public
         * @param   Object callbacks
         * @return  void
         */
        connect: function(callbacks) {
            var clientWrapper = ClientWrappers.get('facebook');
            this._callbacks = callbacks;
            var _this = this,
                permissions = this._permissions.all,
                callback = function(response) {
                    if (
                        response.authResponse !== null
                        && response.authResponse !== undefined
                    ) {
                        clientWrapper.requestPermissions(function(response) {
                            if (_this._minimum(response) === true) {
                                _this._connect();
                            } else {
                                Stencil.alert('facebook.auth.minimum');
                                _this.denied();
                            }
                        });
                    } else {
                        _this.denied();
                    }
                };
            clientWrapper.promptLogin(permissions, callback);
        },

        /**
         * connected
         * 
         * @access  public
         * @param   Array connections
         * @return  void
         */
        connected: function(connections) {
            if (this._callbacks.connected !== undefined) {
                this._callbacks.connected.apply(this, [connections]);
            }
            this.triggerHandler('connected');
        },

        /**
         * denied
         * 
         * @access  public
         * @return  void
         */
        denied: function() {
            if (this._callbacks.denied !== undefined) {
                this._callbacks.denied.apply(this);
            }
            this.triggerHandler('denied');
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * FeatureModel
     * 
     * @extends Model
     */
    window.FeatureModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/features')
         */
        _base: '/api/features',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FeatureModel')
         */
        _string: 'FeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Feature')
         */
        _type: 'Feature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * FontModel
     * 
     * @extends Model
     */
    window.FontModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/fonts')
         */
        _base: '/api/fonts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontModel')
         */
        _string: 'FontModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Font')
         */
        _type: 'Font',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * create
         * 
         * @access  public
         * @param   Object data
         * @param   Function success
         * @param   Function fail
         * @return  ServerRequest
         */
        create: function(data, success, fail) {
            var serverRequest = new ServerRequest();
            serverRequest.setOptions({
                data: data,
                events: {
                    'success/false': function(event, response) {
                        fail(response);
                    },
                    'success/true': function(event, response) {
                        success(response.data);
                    }
                },
                path: this._base,
                signature: {"basename":"Font.js","line":66},
                timeout: 60 * 1000
            });
            serverRequest.post();
            return serverRequest;
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * FrameModel
     * 
     * @extends Model
     */
    window.FrameModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/frames')
         */
        _base: '/api/frames',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FrameModel')
         */
        _string: 'FrameModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Frame')
         */
        _type: 'Frame',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * GoogleFontModel
     * 
     * @extends Model
     */
    window.GoogleFontModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/googleFonts')
         */
        _base: '/googleFonts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontModel')
         */
        _string: 'GoogleFontModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'GoogleFont')
         */
        _type: 'GoogleFont',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * import
         * 
         * @note    Extended timeout since fonts need to be converted
         * @access  public
         * @param   GoogleFontAccessor accessor
         * @return  void
         */
        import: function(accessor) {
            var path = '/googleFonts/import';
            RequestUtils.ajax({
                signature: {"basename":"GoogleFont.js","line":55},
                url: path,
                type: 'POST',
                data: accessor.data(),
                timeout: 60 * 1000,
                success: function(response) {
                    if (response.success === true) {
                        accessor.triggerHandler('import', response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '65-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('FeatureModel', function() {

    /**
     * GraphicFeatureModel
     * 
     * @extends FeatureModel
     */
    window.GraphicFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicFeatureModel')
         */
        _string: 'GraphicFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'GraphicFeature')
         */
        _type: 'GraphicFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'GraphicAsset', data);
        }
    });
});
window.DependencyLoader.push('ResourceModel', function() {

    /**
     * GraphicResourceModel
     * 
     * @extends ResourceModel
     */
    window.GraphicResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicResourceModel')
         */
        _string: 'GraphicResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'GraphicResource')
         */
        _type: 'GraphicResource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'GraphicResource', data);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * ImageModel
     * 
     * @extends Model
     */
    window.ImageModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/images')
         */
        _base: '/api/images',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageModel')
         */
        _string: 'ImageModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Image')
         */
        _type: 'Image',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * draft
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  void
         */
        // draft: function(key, callback) {
        //     // var model = Stencil.getModel('Template');
        //     // model.create({
        //     //     image: key
        //     // }, callback);
        // },

        /**
         * generateShortUrl
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        generateShortUrl: function(key) {
            var path = '/images/' + (key) + '/shortUrl',
                accessor = Stencil.getAccessor(key);
            RequestUtils.ajax({
                signature: {"basename":"Image.js","line":70},
                url: path,
                type: 'POST',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        // accessor.set({
                        //     legacyImporting: 0,
                        //     legacyImported: 1,
                        //     legacyNormalized: 1,
                        //     width: response.data.object.width,
                        //     height: response.data.object.height,
                        //     'settings.json': response.data.object.settings.json
                        // });
                        accessor.set({
                            'settings.shortUrl': response.data.object.settings.shortUrl
                        });
                    } else {
                        var error = Stencil.extractError(response),
                            code = '89-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * getImageById
         * 
         * @access  public
         * @param   Number imageId
         * @return  ImageAccessor|false
         */
        getImageById: function(imageId) {
            var accessors = Stencil.get('accessors'),
                index, accessor;
            for (index in accessors) {
                accessor = accessors[index];
                if (accessor.get('class') !== 'image') {
                    continue;
                }
                if (accessor.get('id').toInt() === imageId.toInt()) {
                    return accessor;
                }
            }
            return false;
        },

        /**
         * markAsUploaded
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        // markAsUploaded: function(key) {
        //     var path = '/images/' + (key) + '/uploaded',
        //         accessor = Stencil.getAccessor(key);
        //     RequestUtils.ajax({
        //         signature: {"basename":"Image.js","line":130},
        //         url: path,
        //         type: 'POST',
        //         data: {},
        //         success: function(response) {
        //             if (response.success === true) {
        //                 // accessor.set({
        //                 //     legacyImporting: 0,
        //                 //     legacyImported: 1,
        //                 //     legacyNormalized: 1,
        //                 //     width: response.data.object.width.toInt(),
        //                 //     height: response.data.object.height.toInt(),
        //                 //     'settings.json': response.data.object.settings.json
        //                 // });
        //                 accessor.set({
        //                     'settings.shortUrl': response.data.object.settings.shortUrl
        //                 })
        //             } else {
        //                 var error = Stencil.extractError(response),
        //                     code = '149-' + (error.code),
        //                     reference = error.reference;
        //                 Stencil.error(code, reference);
        //             }
        //         }
        //     });
        // },

        /**
         * normalize
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        normalize: function(key) {
            var path = '/images/' + (key) + '/normalize',
                accessor = Stencil.getAccessor(key);
            RequestUtils.ajax({
                signature: {"basename":"Image.js","line":168},
                url: path,
                type: 'PATCH',
                data: {
                    json: accessor.setting('json')
                },
                success: function(response) {
                    if (response.success === true) {
                        accessor.set({
                            legacyImporting: 0,
                            legacyImported: 1,
                            legacyNormalized: 1,
                            width: response.data.object.width.toInt(),
                            height: response.data.object.height.toInt(),
                            'settings.json': response.data.object.settings.json
                        });
                        accessor.triggerHandler('normalize');
                    } else {
                        var error = Stencil.extractError(response),
                            code = '187-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * template
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  void
         */
        template: function(key, callback) {
            var model = Stencil.getModel('Template');
            model.create({
                image: key
            }, callback);
        }
    });
});
window.DependencyLoader.push('FeatureModel', function() {

    /**
     * ImageFeatureModel
     * 
     * @extends FeatureModel
     */
    window.ImageFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageFeatureModel')
         */
        _string: 'ImageFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'ImageFeature')
         */
        _type: 'ImageFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Image', data);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * MediaModel
     * 
     * @extends Model
     */
    window.MediaModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/media')
         */
        _base: '/api/media',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'MediaModel')
         */
        _string: 'MediaModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Media')
         */
        _type: 'Media',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _getAccessorType
         * 
         * @throws  Error
         * @access  public
         * @param   Object data
         * @return  String
         */
        _getAccessorType: function(data) {
            var key = data.key;
            if (key.match(/^asst/) !== null) {
                var resourceType = data.resourceType;
                if (data.resourceType === 'AlgoliaQuote') {
                    var accessorType = 'QuoteAsset';
                    return accessorType;
                }
                if (DataUtils.photoVendor(resourceType) === true) {
                    var accessorType = 'PhotoAsset';
                    return accessorType;
                }
                var accessorType = 'GraphicAsset';
                return accessorType;
            }
            if (key.match(/^img0/) !== null) {
                var accessorType = 'Image';
                return accessorType;
            }
            if (key.match(/^upld/) !== null) {
                var accessorType = 'Upload';
                return accessorType;
            }
            var msg = 'Invalid key type for accessorType lookup';
            throw new Error(msg);
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            var key = data.key,
                accessorType = this._getAccessorType(data);
            return Stencil.setAccessor(key, accessorType, data);
        }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * Model
     * 
     * @extends Base
     */
    window.Model = Base.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _base: '',

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'model')
         */
        _classType: 'model',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Model')
         */
        _string: 'Model',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * create
         * 
         * @access  public
         * @param   Object data
         * @param   Function success
         * @param   undefined|Function fail
         * @return  void
         */
        create: function(data, success, fail) {
            fail = DataUtils.getDefaultValue(fail, function(response) {
                var error = Stencil.extractError(response),
                    code = '56-' + (error.code),
                    reference = error.reference;
                Stencil.error(code, reference);
            });
            var path = this._base;
            RequestUtils.ajax({
                signature: {"basename":"Model.js","line":62},
                url: path,
                type: 'POST',
                data: data,
                success: function(response) {
                    if (response.success === true) {
                        success(response.data);
                    } else {
                        fail(response);
                    }
                }
            });
        },

        /**
         * delete
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        delete: function(key) {
            var request = new ServerRequest(),
                events = {
                    'success/true': function(event, response) {
                        var accessor = Stencil.getAccessor(key);
                        accessor.triggerHandler('model/delete');
                    }
                },
                path = (this._base) + '/' + (key),
                signature = {"basename":"Model.js","line":92};
            request.setOptions({
                blockFailedValidation: true,
                events: events,
                logFailedValidation: true,
                path: path,
                signature: signature
            });
            request.delete();
        },

        /**
         * feature
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        feature: function(key, data, callback) {
            var pathname = this._base.replace(/^\/api/, ''),
                path = (pathname) + '/' + (key) + '/feature';
            RequestUtils.ajax({
                signature: {"basename":"Model.js","line":116},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                        var category = Stencil.getAccessor(data.category),
                            accessor = Stencil.getAccessor(key);
                        if (accessor.is.resource.apply(accessor) === true) {
                            accessor.triggerHandler('model/feature');
                            accessor = accessor.getAsset();
                        }
                        accessor.triggerHandler('model/feature');
                        category.syncedFeatures.add.apply(category, [accessor]);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '133-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * getBase
         * 
         * @access  public
         * @return  String
         */
        getBase: function() {
            return this._base;
        },

        /**
         * read
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  void
         */
        read: function(key, callback) {
            var path = (this._base) + '/' + encodeURIComponent(key);
            RequestUtils.ajax({
                signature: {"basename":"Model.js","line":162},
                url: path,
                type: 'GET',
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '170-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            if (data === undefined) {
                console.trace();
            }
            return Stencil.setAccessor(data.key, this._type, data);
        },

        /**
         * unfeature
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        unfeature: function(key, data, callback) {
            var pathname = this._base.replace(/^\/api/, ''),
                path = (pathname) + '/' + (key) + '/feature';
            RequestUtils.ajax({
                signature: {"basename":"Model.js","line":205},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                        var category = Stencil.getAccessor(data.category),
                            accessor = Stencil.getAccessor(key);
                        if (accessor.is.resource.apply(accessor) === true) {
                            accessor.triggerHandler('model/unfeature');
                            accessor = accessor.getAsset();
                        }
                        accessor.triggerHandler('model/unfeature');
                        category.syncedFeatures.remove.apply(category, [accessor]);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '222-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * update
         * 
         * @note    The complicated callback event triggering is to faciliate
         *          events for individual settings being updated. See:
         *          https://i.imgur.com/Tr1UDre.png
         *          Goal is to have change/[name] and update/[name] match
         * @todo    Deprecate callbacks, and instead use events.
         * @todo    Passing in accessor seems redundant, since the key is already
         *          being passed. Instead, use the key to access the accessor,
         *          and fire corresponding event(s).
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Accessor accessor
         * @param   Object callbacks
         * @return  void
         */
        update: function(key, data, accessor, callbacks) {
            var path = (this._base) + '/' + (key);
            RequestUtils.ajax({
                signature: {"basename":"Model.js","line":251},
                url: path,
                type: 'PATCH',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callbacks.success.apply(accessor, [response.data]);
                        jQuery.each(data, function(index1, value1) {
                            if (typeof value1 === 'object') {
                                jQuery.each(value1, function(index2, value2) {
                                    var eventName = 'update/' + (index1) + '.' + (index2);
                                    accessor.triggerHandler(eventName, [value2]);
                                });
                            } else {
                                var eventName = 'update/' + (index1);
                                accessor.triggerHandler(eventName, [value1]);
                            }
                        });
                        accessor.triggerHandler('update', [data]);
                    } else {
                        if (callbacks.error(response) === true) {
                            var error = Stencil.extractError(response),
                                code = '273-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * OverrideModel
     * 
     * @extends Model
     */
    window.OverrideModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/overrides')
         */
        _base: '/api/overrides',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OverrideModel')
         */
        _string: 'OverrideModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Override')
         */
        _type: 'Override',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('FeatureModel', function() {

    /**
     * PhotoFeatureModel
     * 
     * @extends FeatureModel
     */
    window.PhotoFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoFeatureModel')
         */
        _string: 'PhotoFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'PhotoFeature')
         */
        _type: 'PhotoFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            var key = data.key,
                name = 'PhotoAsset',
                accessor = Stencil.setAccessor(key, name, data);
            return accessor;
        }
    });
});
window.DependencyLoader.push('ResourceModel', function() {

    /**
     * PhotoResourceModel
     * 
     * @extends ResourceModel
     */
    window.PhotoResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoResourceModel')
         */
        _string: 'PhotoResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'PhotoResource')
         */
        _type: 'PhotoResource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'PhotoResource', data);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * PromoModel
     * 
     * @extends Model
     */
    window.PromoModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/promos')
         */
        _base: '/api/promos',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoModel')
         */
        _string: 'PromoModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Promo')
         */
        _type: 'Promo',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * PromoSetModel
     * 
     * @extends Model
     */
    window.PromoSetModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/promoSets')
         */
        _base: '/api/promoSets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoSetModel')
         */
        _string: 'PromoSetModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'PromoSet')
         */
        _type: 'PromoSet',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('FeatureModel', function() {

    /**
     * QuoteFeatureModel
     * 
     * @extends FeatureModel
     */
    window.QuoteFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteFeatureModel')
         */
        _string: 'QuoteFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'QuoteFeature')
         */
        _type: 'QuoteFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'QuoteAsset', data);
        }
    });
});
window.DependencyLoader.push('ResourceModel', function() {

    /**
     * QuoteResourceModel
     * 
     * @extends ResourceModel
     */
    window.QuoteResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteResourceModel')
         */
        _string: 'QuoteResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'QuoteResource')
         */
        _type: 'QuoteResource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'QuoteResource', data);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * ResourceModel
     * 
     * @extends Model
     */
    window.ResourceModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/resources')
         */
        _base: '/resources',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceModel')
         */
        _string: 'ResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Resource')
         */
        _type: 'Resource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * save
         * 
         * @note    This method is in the ResourceModel instead of Model, since
         *          at the moment it's exclusively used by resources.
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        save: function(key, data, callback) {
            var events = {
                    'success/true': function(event, response) {
                        callback(response.data);
                    }
                },
                path = '/resources/' + (key) + '/save',
                serverRequest = new ServerRequest(),
                signature =  {"basename":"Resource.js","line":63};
            serverRequest.setOptions({
                blockFailedValidation: true,
                data: data,
                events: events,
                path: path,
                signature: signature,
            });
            serverRequest.post();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * S3UploadModel
     * 
     * @see     https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Config.html
     * @see     https://github.com/aws/aws-sdk-js/issues/877
     * @see     https://github.com/aws/aws-sdk-js/issues/949
     * @see     https://github.com/aws/aws-sdk-js/issues/1162
     * @see     https://github.com/aws/aws-sdk-js/issues/1704
     * @extends Model
     */
    window.S3UploadModel = Model.extend({

        /**
         * _retries
         * 
         * @access  protected
         * @var     Number (default: 0)
         */
        _retries: 0,

        /**
         * _skewCheckPerformed
         * 
         * Tracks whether or not a check for possible skew within the clients
         * system time has occured.
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _skewCheckPerformed: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'S3UploadModel')
         */
        _string: 'S3UploadModel',

        /**
         * _timeout
         * 
         * Default in SDK is two minutes; extending to four here due to possible
         * connection issues with our international users.
         * 
         * @access  protected
         * @var     Number (default: 4 * 60 * 1000) in milliseconds (aka 4
         *          minutes)
         */
        // _timeout: 4 * 60 * 1000,
        _timeout: 0,

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            if (this._dependenciesLoaded() === false) {
                this._forceReload();
            } else {
                this._prepareSDK();
            }
        },

        /**
         * _addProgressListener
         * 
         * Listens for the AWS SDK httpUploadProgress event against the
         * AWS.S3.ManagedUpload instance, and proxies it to an
         * upload/progress event against the passed in media accessor.
         * 
         * @access  protected
         * @param   AWS.S3.ManagedUpload managedUpload
         * @param   MediaAccessor mediaAccessor
         * @return  void
         */
        _addProgressListener: function(managedUpload, mediaAccessor) {
            managedUpload.on(
                'httpUploadProgress',
                function(event) {
                    var eventName = 'upload/progress',
                        args = [event.loaded, event.total];
                    mediaAccessor.triggerHandler(eventName, args);
                }
            );
        },

        /**
         * _dependenciesLoaded
         * 
         * Returns whether the dependencies (which at the time of documentaiton
         * is only AWS) are available.
         * 
         * @access  protected
         * @return  Boolean
         */
        _dependenciesLoaded: function() {
            if (typeof window.AWS === 'undefined') {
                return false;
            }
            return true;
        },

        /**
         * _forceReload
         * 
         * @access  protected
         * @return  void
         */
        _forceReload: function() {
            Stencil.alert('dependency.failed');
            Stencil.kill();
        },

        /**
         * _getBucketName
         * 
         * @access  protected
         * @return  String
         */
        _getBucketName: function() {
            var aws = Config.get('aws'),
                bucketName = aws.s3.buckets.app.stencil.name;
            return bucketName;
        },

        /**
         * _getFailedResponse
         * 
         * @access  protected
         * @return  Object
         */
        _getFailedResponse: function() {
            var failedRuleKey = 'upload.singular.filesize.zero',
                response = {
                    success: false,
                    failedRules: [
                        {
                            key: failedRuleKey
                        }
                    ]
                };
            return response;
        },

        /**
         * _getIdentityPoolName
         * 
         * @access  protected
         * @return  String
         */
        _getIdentityPoolName: function() {
            var aws = Config.get('aws'),
                identityPoolId = aws.cognito.pools.primary.id,
                cognitoRegion = this._getRegion('cognito'),
                identityPoolName = (cognitoRegion) + ':' + (identityPoolId);
            return identityPoolName;
        },

        /**
         * _getRegion
         * 
         * @throws  Error
         * @access  protected
         * @param   String service
         * @return  String
         */
        _getRegion: function(service) {
            var aws = Config.get('aws');
            if (service === 'cognito') {
                var region = aws.cognito.pools.primary.region;
                return region;
            }
            if (service === 's3') {
                var region = aws.s3.buckets.app.stencil.region;
                return region;
            }
            var msg = 'Invalid service name for region lookup';
            throw new Error(msg);
        },

        /**
         * _getSuccessfulResponse
         * 
         * @access  protected
         * @param   AWS.S3.ManagedUpload managedUpload
         * @return  Object
         */
        _getSuccessfulResponse: function(managedUpload) {
            var response = {
                success: true,
                response: {
                    managedUpload: managedUpload
                }
            };
            return response;
        },

        /**
         * _loadManagedUpload
         * 
         * @note    The queueSize property was recently added to try and deal
         *          with connection dropping issues and the long download
         *          duration bug. The idea behind it is that it only allows one
         *          concurrent upload at a time, rather than the default 4
         *          (which may be causing long download duration bugs).
         * @see     https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3/ManagedUpload.html
         * @access  protected
         * @param   Object params
         * @param   AWS.S3 s3
         * @return  AWS.S3.ManagedUpload
         */
        _loadManagedUpload: function(params, s3) {
            var managedUpload = new AWS.S3.ManagedUpload({
                params: params,
                queueSize: 1,
                service: s3
            });
            return managedUpload;
        },

        /**
         * _loadS3Object
         * 
         * @access  protected
         * @return  AWS.S3
         */
        _loadS3Object: function() {
            var region = this._getRegion('s3'),
                s3 = new AWS.S3({
                    region: region,
                    maxRetries: this._retries,
                    httpOptions: {
                        timeout: this._timeout
                    }
                });
            return s3;
        },

        /**
         * _makeRequest
         * 
         * @access  protected
         * @param   AWS.S3 s3
         * @param   AWS.S3.ManagedUpload managedUpload
         * @param   MediaAccessor mediaAccessor
         * @return  void
         */
        _makeRequest: function(s3, managedUpload, mediaAccessor) {
            this._performSkewCheck(s3, function() {
                managedUpload.send(
                    function(err, data) {
                        if (DataUtils.valid(err) === true) {
                            if (err.code === 'RequestAbortedError') {
                                mediaAccessor.triggerHandler('upload/abort', [err]);
                                return false;
                            }
                            App.log('S3 Upload error', true);
                            App.log(arguments, true);
                            mediaAccessor.triggerHandler('upload/error', [err]);
                            return false;
                        }
                        mediaAccessor.triggerHandler('upload/success', [data]);
                        return true;
                    }
                );
            });
        },

        /**
         * _performSkewCheck
         * 
         * Triggers an event handler once the system time skew check has been
         * completed. If skew is found, the systemClockOffset is set to that
         * skew to ensure uploads go forward.
         * 
         * Note that I'm calling against the bucket location even though AWS
         * Support recommended doing a HEAD against the bucket, for two reasons:
         * 1. Permission for a HEAD against the bucket is called ListBucket,
         *    which grants permission to list objects (which should not be
         *    allowed for client machines).
         * 2. HEAD sends no response back, so if that fails for a reason other
         *    than RequestTimeTooSkewed, I will not know, nor will I be able to
         *    log it (since HEADs are not supposed to send any response back).
         * 
         * @access  protected
         * @param   AWS.S3 s3
         * @param   Function callback
         * @return  void
         */
        _performSkewCheck: function(s3, callback) {
            callback = DataUtils.getDefaultValue(callback, function() {});
            if (this._skewCheckPerformed === true) {
                callback();
            } else {
                var params = {
                    Bucket: this._getBucketName()
                };
                this._skewCheckPerformed = true;
                s3.getBucketLocation(params, function(err, data) {
                    if (DataUtils.valid(err) === true) {
                        App.log('Skew check error', true);
                        App.log(arguments, true);
                        Stencil.alert('service.aws.skew.fail');
                        Stencil.kill();
                        return false;
                    }
                    var clientUnixTimestamp = Date.parse(
                        this.httpResponse.headers.date
                    );
                    AWS.config.systemClockOffset = clientUnixTimestamp - new Date();
                    callback();
                });
            }
        },

        /**
         * _prepareSDK
         * 
         * @access  protected
         * @return  void
         */
        _prepareSDK: function() {
            var identityPoolName = this._getIdentityPoolName();
            AWS.config.correctClockSkew = true;
            AWS.config.apiVersions = {
                s3: '2006-03-01'
            };
            AWS.config.region = this._getRegion('cognito');
            AWS.config.credentials = new AWS.CognitoIdentityCredentials({
                IdentityPoolId: identityPoolName
            });
        },

        /**
         * performSkewCheck
         * 
         * Public version of the skew check so that it can be triggered when
         * Stencil loads up. See Scripts class for details.
         * 
         * @access  public
         * @return  void
         */
        performSkewCheck: function() {
            var s3 = this._loadS3Object();
            this._performSkewCheck(s3);
        },

        /**
         * uploadDataURL
         * 
         * @access  public
         * @param   String dataURL
         * @param   String objectKey
         * @param   MediaAccessor mediaAccessor
         * @return  Object
         */
        uploadDataURL: function(dataURL, objectKey, mediaAccessor) {
            var blob = DataUtils.dataURLToBlob(dataURL),
                response = this.uploadObject(blob, objectKey, mediaAccessor);
            return response;
        },

        /**
         * uploadObject
         * 
         * @access  public
         * @param   File|Blob object
         * @param   String objectKey
         * @param   MediaAccessor mediaAccessor
         * @return  Object
         */
        uploadObject: function(object, objectKey, mediaAccessor) {
            var type = DataUtils.guessItemContentType(object),
                params = {
                    Bucket: this._getBucketName(),
                    Key: objectKey,
                    Body: object,
                    ContentType: type,
                    ACL: 'public-read'
                },
                s3 = this._loadS3Object(),
                managedUpload = this._loadManagedUpload(params, s3);
            if (object.size === 0) {
                var response = this._getFailedResponse();
                return response;
            }
            this._addProgressListener(managedUpload, mediaAccessor);
            this._makeRequest(s3, managedUpload, mediaAccessor);
            var response = this._getSuccessfulResponse(managedUpload);
            return response;
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * ShareModel
     * 
     * @extends Model
     */
    window.ShareModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/shares')
         */
        _base: '/api/shares',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareModel')
         */
        _string: 'ShareModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Share')
         */
        _type: 'Share',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * TemplateModel
     * 
     * @extends Model
     */
    window.TemplateModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/templates')
         */
        _base: '/api/templates',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateModel')
         */
        _string: 'TemplateModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Template')
         */
        _type: 'Template',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('FeatureModel', function() {

    /**
     * TemplateFeatureModel
     * 
     * @extends FeatureModel
     */
    window.TemplateFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateFeatureModel')
         */
        _string: 'TemplateFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'TemplateFeature')
         */
        _type: 'TemplateFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Template', data);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * TwitterModel
     * 
     * @todo!   Communicate to the user what was added, if anything:
     *          https://i.imgur.com/9SuECDv.png
     * @events  closed
     *          connected
     *          denied
     * @extends Model
     */
    window.TwitterModel = Model.extend({

        /**
         * _callbacks
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _callbacks: {},

        /**
         * _reference
         * 
         * @access  protected
         * @var     Window (default: null)
         */
        _reference: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TwitterModel')
         */
        _string: 'TwitterModel',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _listenForWindowClose
         * 
         * @access  protected
         * @return  void
         */
        _listenForWindowClose: function() {
            var interval,
                check = function() {
                    if (this._reference.closed === true) {
                        IntervalPool.clear(interval);
                        this.closed();
                    }
                };
            interval = check.interval(100, this);
        },

        /**
         * closed
         * 
         * @access  public
         * @return  void
         */
        closed: function() {
            if (this._callbacks.closed) {
                this._callbacks.closed.apply(this);
            }
            this.triggerHandler('closed');
        },

        /**
         * connect
         * 
         * @access  public
         * @param   Object callbacks
         * @return  void
         */
        connect: function(callbacks) {
            this._callbacks = callbacks;
            this._reference = window.open(
                '/twitter/redirect',
                'Twitter Connect',
                'width=640, height=420'
            );
            this._listenForWindowClose();
        },

        /**
         * connected
         * 
         * @access  public
         * @param   Object response
         * @return  void
         */
        connected: function(response) {
            var account = Stencil.account(),
                collection = account.collection('connections'),
                connections = collection.map(response.data.connections);
            if (this._callbacks.connected) {
                this._callbacks.connected.apply(this, [connections]);
            }
            Track.event('Twitter connection added');
            this.triggerHandler('connected');
        },

        /**
         * denied
         * 
         * @access  public
         * @return  void
         */
        denied: function() {
            if (this._callbacks.denied) {
                this._callbacks.denied.apply(this);
            }
            this.triggerHandler('denied');
        },

        /**
         * setup
         * 
         * @access  public
         * @return  void
         */
        setup: function() {
            var key = 'twitter.connection.connected';
            Stencil.set(key, this.connected.proxy(this));
            key = 'twitter.connection.denied';
            Stencil.set(key, this.denied.proxy(this));
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * UploadModel
     * 
     * @extends Model
     */
    window.UploadModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/uploads')
         */
        _base: '/api/uploads',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadModel')
         */
        _string: 'UploadModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Upload')
         */
        _type: 'Upload',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * overwrite
         * 
         * @access  public
         * @param   String key
         * @param   String url
         * @param   Function callback
         * @return  void
         */
        overwrite: function(key, url, callback) {
            var request = new ServerRequest();
            request.setOptions({
                blockFailedValidation: true,
                data: {
                    url: url
                },
                events: {
                    'success/true': function(event, response) {
                        callback();
                    }
                },
                path: '/uploads/' + (key) + '/overwrite',
                signature: {"basename":"Upload.js","line":66}            });
            request.patch();
        },

        /**
         * sync
         * 
         * Calls /sync against the upload in order to have the width/height of
         * the upload stored in the database, but more importantly, initiated by
         * the server side (instead of downloading the S3-stored image to the
         * client-side, checking the width/height, and then sending that over to
         * the db).
         * 
         * The reason I switched to this approach is I didn't want the user to
         * upload a large (eg. greater than 1mb) image, just to re-download it
         * so that I could store the width/height. The front-end is so finely
         * tuned now that they'll likely never need to reference the original
         * upload, so it just seems like a waste.
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        sync: function(key) {
            var path = '/uploads/' + (key) + '/sync';
            RequestUtils.ajax({
                signature: {"basename":"Upload.js","line":93},
                url: path,
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        var upload = Stencil.getAccessor(key),
                            eventName = 'sync/complete',
                            data = response.data;
                        upload.merge(response.data.object);
                        if (response.data.synced === false) {
                            data = false;
                        }
                        upload.triggerHandler(eventName, [data]);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '108-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('FeatureModel', function() {

    /**
     * UploadFeatureModel
     * 
     * @extends FeatureModel
     */
    window.UploadFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadFeatureModel')
         */
        _string: 'UploadFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'UploadFeature')
         */
        _type: 'UploadFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Upload', data);
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * UpgradeModel
     * 
     * @extends Model
     */
    window.UpgradeModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/upgrades')
         */
        _base: '/api/upgrades',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradeModel')
         */
        _string: 'UpgradeModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Upgrade')
         */
        _type: 'Upgrade',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * UserModel
     * 
     * @extends Model
     */
    window.UserModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/users')
         */
        _base: '/api/users',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserModel')
         */
        _string: 'UserModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'User')
         */
        _type: 'User',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * UserAccountModel
     * 
     * @extends Model
     */
    window.UserAccountModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/userAccounts')
         */
        _base: '/api/userAccounts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserAccountModel')
         */
        _string: 'UserAccountModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'UserAccount')
         */
        _type: 'UserAccount',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('Model', function() {

    /**
     * VectorSetModel
     * 
     * @extends Model
     */
    window.VectorSetModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/vectorSets')
         */
        _base: '/api/vectorSets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorSetModel')
         */
        _string: 'VectorSetModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'VectorSet')
         */
        _type: 'VectorSet',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('UploadModel', function() {

    /**
     * WatermarkModel
     * 
     * @extends UploadModel
     */
    window.WatermarkModel = UploadModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkModel')
         */
        _string: 'WatermarkModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'WatermarkUpload')
         */
        _type: 'WatermarkUpload',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push('UploadFeatureModel', function() {

    /**
     * WatermarkFeatureModel
     * 
     * @extends UploadFeatureModel
     */
    window.WatermarkFeatureModel = UploadFeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkFeatureModel')
         */
        _string: 'WatermarkFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'WatermarkFeature')
         */
        _type: 'WatermarkFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
        // ,

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        // setAccessor: function(data) {
        //     return Stencil.setAccessor(data.key, 'Upload', data);// @todo!!!! WatermarkUploadAccessor?
        // }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * Accessor
     * 
     * @events  delete     
     *          delete/pre
     *          change    When a property or setting is changed (any)
     *          change/<> When a specific property or setting is changed
     *          save      When a property/setting or group of them start to be
     *                    sent to the server
     *          update    After a property/setting or group of them has been
     *                    updated on the backend (aka. patched)
     *          model/feature
     *          model/unfeature
     *          model/delete
     * @extends Base
     */
    window.Accessor = Base.extend({

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'accessor')
         */
        _classType: 'accessor',

        /**
         * _collections
         * 
         * Hash map of collections that the accessor may have attributed with
         * it. For example, an Account has frames, connections, and watermarks.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _collections: {},

        /**
         * _data
         * 
         * The public data returned for this accessor.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _data: {},

        /**
         * _model
         * 
         * Reference to the model responsible for CRUD operations on the
         * accessor.
         * 
         * @access  protected
         * @var     Model (default: null)
         */
        _model: null,

        /**
         * _references
         * 
         * Hash of other accessors attribute with this Accessor. For example,
         * AccountAccessor's have a <draft> Accessor referenced to it, which is
         * an ImageAccessor for the image they're creating.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _references: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Accessor')
         */
        _string: 'Accessor',

        /**
         * _within
         * 
         * Array of collections that the Accessor is part of. For example, a
         * WatermarkUploadAccessor is part of the WatermarksCollection. This is
         * used in the deletion process of an accessor, to ensure it's properly
         * removed from associated collections.
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _within: [],

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super();
            this._collections = {};
            this._references = {};
            this._within = [];
            this._data = data;
        },

        /**
         * collection
         * 
         * Returns the collection stored at <key> in the hash.
         * 
         * @access  public
         * @param   String key
         * @return  Collection
         */
        collection: function(key) {
            return this._collections[key];
        },

        /**
         * data
         * 
         * @access  public
         * @return  Object
         */
        data: function() {
            return this._data;
        },

        /**
         * delete
         * 
         * @note    Order below needs to be that the delete event is triggered
         *          before the accessor is removed from it's associated
         *          collections.
         * @access  public
         * @return  void
         */
        delete: function() {
            this.triggerHandler('delete/pre');
            this.set({
                'deleted': true
            });
            Stencil.globalFeatures.remove(this);
            Account.favorites.remove(this);
            this._model.delete(this._data.key);
            this.triggerHandler('delete');
            this.removeAll();
            var categories = this.universalCategoriesFeaturedIn();
            if (categories.length > 0) {
                var index,
                    category;
                for (index in categories) {
                    category = categories[index];
                    category.features.remove.apply(category, [this]);
                }
            }
        },

        /**
         * deleted
         * 
         * @access  public
         * @return  Boolean
         */
        deleted: function() {
            return this._data.deleted === true;
        },

        /**
         * favorited
         * 
         * @access  public
         * @return  Boolean
         */
        favorited: function() {
            var favorites = Stencil.account().get('favorites'),
                key = this._data.key;
            return favorites.indexOf(key) !== -1;
        },

        /**
         * featuredInCategory
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        featuredInCategory: function(category) {
            var features = category.get('features');
            return ArrayUtils.contains(this._data.key, features) === true;
        },

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        get: function(key) {
            // if (this._data[key] === undefined) {
            //     var msg = 'Invalid key: ' + (key);
            //     throw new Error(msg);
            // }
            return this._data[key];
        },

        /**
         * getModel
         * 
         * @access  public
         * @return  Model
         */
        getModel: function() {
            return this._model;
        },

        /**
         * globalCategoriesFeaturedIn
         * 
         * @access  public
         * @return  Array
         */
        globalCategoriesFeaturedIn: function() {
            var categories = CategoryUtils.global.all(),
                index,
                features,
                matching = [];
            for (index in categories) {
                features = categories[index].get('features');
                if (ArrayUtils.contains(this._data.key, features) === true) {
                    matching.push(categories[index]);
                }
            }
            return matching;
        },

        /**
         * globallyFeatured
         * 
         * @access  public
         * @return  Boolean
         */
        globallyFeatured: function() {
            var globalFeatures = Stencil.get('globalFeatures'),
                key = this._data.key,
                globallyFeatured = globalFeatures.indexOf(key) !== -1;
            return globallyFeatured;
        },

        /**
         * is
         * 
         * @access  public
         * @var     Object
         */
        is: {

            /**
             * asset
             * 
             * @access  public
             * @return  Boolean
             */
            asset: function() {
                if (this.toString() === 'GraphicAssetAccessor') {
                    return true;
                }
                if (this.toString() === 'PhotoAssetAccessor') {
                    return true;
                }
                if (this.toString() === 'QuoteAssetAccessor') {
                    return true;
                }
                return false;
            },

            /**
             * resource
             * 
             * @access  public
             * @return  Boolean
             */
            resource: function() {
                if (this.toString() === 'GraphicResourceAccessor') {
                    return true;
                }
                if (this.toString() === 'PhotoResourceAccessor') {
                    return true;
                }
                if (this.toString() === 'QuoteResourceAccessor') {
                    return true;
                }
                return false;
            },

            /**
             * upload
             * 
             * @access  public
             * @return  Boolean
             */
            upload: function() {
                var valid = this._data.key.match(/^upld/) !== null;
                return valid;
            },

            /**
             * watermark
             * 
             * @access  public
             * @return  Boolean
             */
            watermark: function() {
                if (this.is.upload.apply(this) === false) {
                    return false;
                }
                var valid = this._data.type === 'watermark';
                return valid;
            }
        },

        /**
         * loadCropperDependencies
         * 
         * @access  public
         * @return  Boolean
         */
        loadCropperDependencies: function() {
            return false;
        },

        /**
         * merge
         * 
         * Merges passed in data with the internal <_data> hash.
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        merge: function(data) {
            this._data = DataUtils.merge(this._data, data);
        },

        /**
         * pin
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        pin: function(category) {
            var model = Stencil.getModel('Category');
            model.pin(category.get('key'), {
                objectType: this.get('class').toLowerCase(),
                objectKey:  this.get('key')
            });
            this.triggerHandler('pin', [category]);
        },

        /**
         * pinned
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        pinned: function(category) {
            return category.get('pinKey') === this.get('key');
        },

        /**
         * push
         * 
         * Performs a set and save, so long as the initial value that is being
         * set for a key is different than what's already stored in memory.
         * This is a more performant way of doing things, since it'll prevent
         * server calls if the key is already set to the value. Currently
         * being used with UserAccount settings.
         * 
         * Note that I called it key instead of column, since it could be a
         * setting (eg. settings.name) that is being pushed.
         * 
         * @todo    Update this so it can accept a hash of properties / values.
         *          Once you do that, update ImageAccessor.sync method to
         *          prevent making calls with extraneous data (eg. the frame
         *          changed, but the json didn't. In that case, no point sending
         *          the json to the server and requiring the server to check if
         *          something has changed or not).
         * @access  public
         * @param   String key
         * @param   String value
         * @return  void
         */
        push: function(key, value) {
            var current;
            if (key.indexOf('settings.') === -1) {
                current = this._data[key];
            } else {
                current = this._data.settings[key.split('settings.').pop()];
            }
            if (current !== value) {
                this.set(key, value);
                this.save([key]);
            }
        },

        /**
         * read
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        read: function(callback) {
            var _this = this;
            this._model.read(this._data.key, function(data) {
                callback.apply(_this, [data.object]);
            });
        },

        /**
         * reference
         * 
         * Returns the reference stored at <key> in the hash.
         * 
         * @access  public
         * @param   String key
         * @return  Accessor
         */
        reference: function(key) {
            return this._references[key];
        },

        /**
         * removeAll
         * 
         * Removes the accessor from it's associated collections.
         * 
         * @access  public
         * @return  void
         */
        removeAll: function() {
            var _this = this;
            jQuery.each(this._within, function(index, collection) {
                collection.remove(_this);
            });
        },

        /**
         * save
         * 
         * @example Accessor.save('column')
         *          Accessor.save(['column1', 'column2'])
         *          Accessor.save(['settings.sub'])
         *          Accessor.save(['settings.1', 'settings.2'])
         * @access  public
         * @param   Array columns
         * @param   undefined|Object callbacks
         * @return  void
         */
        save: function(columns, callbacks) {
            var _this = this,
                data = {},
                column;

            // Format callbacks
            if (callbacks === undefined) {
                callbacks = {
                    success: function(data) {},
                    error: function(response) {
                        return true;
                    }
                };
            }
            if (callbacks.success === undefined) {
                callbacks.success = function(data) {};
            }
            if (callbacks.error === undefined) {
                callbacks.error = function(response) {
                    return true;
                };
            }

            // Ensure columns are array
            if (jQuery.isArray(columns) === false) {
                columns = [columns];
            }
            jQuery.each(columns, function(index, column) {
                if (column.indexOf('settings.') === 0) {
                    data.settings = data.settings || {};
                    column = column.split('settings.').pop();
                    data.settings[column] = _this._data.settings[column];
                } else {
                    data[column] = _this._data[column];
                }
            });
            this._model.update(this._data.key, data, this, callbacks);
            this.triggerHandler('save', [columns]);
        },

        /**
         * set
         * 
         * @example Accessor.set('key', 'value')
         *          Accessor.set({key: 'value'})
         * @access  public
         * @param   String|Object key
         * @param   undefined|Number|String value
         * @return  void
         */
        set: function() {

            // Object or key/value arguments
            var args = jQuery.makeArray(arguments),
                data = args[0];
            if (typeof data === 'string') {
                data = {};
                data[args[0]] = args[1];
            }

            // Events
            var handler,
                _this = this;
            jQuery.each(data, function(key, value) {
                handler = 'change/' + (key);
                if (key.indexOf('settings.') === 0) {
                    key = key.split('settings.').pop();
                    _this._data.settings[key] = value;
                } else {
                    _this._data[key] = value;
                }
                _this.triggerHandler(handler, [value]);
            });
            this.triggerHandler('change');
        },

        /**
         * setting
         * 
         * Returns a setting value if one is found, or else throws an error.
         * 
         * @throws  Erro
         * @access  public
         * @param   String key
         * @return  mixed
         */
        setting: function(key) {
            if (this._data.settings[key] === undefined) {
                var msg = 'Invalid key: ' + (key);
                throw new Error(msg);
            }
            return this._data.settings[key];
        },

        /**
         * swap
         * 
         * Swaps out the data for the accessor. Should only be called when an
         * ephemeral key was used, since the previous key will be deleted from
         * memory. At the moment, only used when creating a template, or when a
         * user logs in (which swaps out their temporary account data with
         * whatever is returned).
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        swap: function(data) {
            var all = Stencil.get('accessors'),
                previous = this._data.key;
            this._data = data;
            all[this._data.key] = this;
            delete all[previous];
        },

        /**
         * universalCategoriesFeaturedIn
         * 
         * @access  public
         * @return  Array
         */
        universalCategoriesFeaturedIn: function() {
            var categories = CategoryUtils.universal.all(),
                index,
                features,
                matching = [];
            for (index in categories) {
                features = categories[index].get('features');
                if (ArrayUtils.contains(this._data.key, features) === true) {
                    matching.push(categories[index]);
                }
            }
            return matching;
        },

        /**
         * unpin
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        unpin: function(category) {
            var model = Stencil.getModel('Category');
            model.pin(category.get('key'), {
                objectType: this.get('class').toLowerCase(),
                objectKey:  this.get('key')
            });
            this.triggerHandler('unpin', [category]);
        },

        /**
         * within
         * 
         * Stores the collection in the <within> Array, so that we can keep
         * track of where the Accessor is being used.
         * 
         * @access  public
         * @param   Collection collection
         * @return  void
         */
        within: function(collection) {
            this._within.push(collection);
        }
    });
});
window.DependencyLoader.push(['Accessor', 'AccountModel'], function() {

    /**
     * AccountAccessor
     * 
     * @fires   draft/create
     * @extends Accessor
     */
    window.AccountAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Account'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AccountAccessor')
         */
        _string: 'AccountAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupCategories();
            this._setupColors();
            this._setupConnections();
            this._setupDraft();
            this._setupFonts();
            this._collections.fonts.map(Config.get('fonts'), true);
            this._setupFrames();
            this._collections.frames.map(Frames.all(), true);
            this._setupOrphanFrame();
            this._setupUpgrade();
            this._setupUserAccount();
            this._setupWatermarks();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @param   undefined|Array categories (default: this._data.categories)
         * @return  void
         */
        _setupCategories: function(categories) {
            categories = DataUtils.getDefaultValue(
                categories,
                this._data.categories
            );
            this._collections.categories = this._collections.categories || new CategoriesCollection();
            this._collections.categories.map(categories, true);
        },

        /**
         * _setupColors
         * 
         * @access  protected
         * @return  void
         */
        _setupColors: function() {
            var _this = this;
            this._collections.colors = this._collections.colors || new ColorsCollection();
            jQuery.each(this._data.colors, function(index, color) {
                if (_this._collections.colors.find(color.key) === false) {
                    _this._collections.colors.map(color, true);
                }
            });
        },

        /**
         * _setupConnections
         * 
         * @access  protected
         * @return  void
         */
        _setupConnections: function() {
            this._collections.connections = this._collections.connections || new ConnectionsCollection();
            this._collections.connections.map(this._data.connections, true);
        },

        /**
         * _setupCustomCategories
         * 
         * Adds categories to the area relative context menus and navs.
         * 
         * @access  protected
         * @return  void
         */
        _setupCustomCategories: function() {

            // Add custom categories to account collection
            var allAccountCategories = this._data.categories,
                customCategories = [],
                index,
                category;
            for (index in allAccountCategories) {
                category = allAccountCategories[index];
                if (category.custom.toInt() === 1) {
                    customCategories.push(category);
                }
            }
            this._setupCategories(customCategories);

            // Update area nav and context menus
            var areas = App.getEditor().getAreas(),
                area,
                nav,
                contextMenu,
                collectionResults;
            for (index in areas) {
                area = areas[index];
                if (area.canHaveCollections() === true) {
                    customCategories = CategoryUtils.account.custom(area.getType()).slice().reverse();
                    nav = area.getNav();
                    collectionResults = nav.getCollectionResults();
                    collectionResults.getCollection().add(customCategories);
                    contextMenu = area.getContextMenu();
                    collectionResults = contextMenu.getCollectionResults();
                    collectionResults.getCollection().add(customCategories);
                }
            }
        },

        /**
         * _setupDraft
         * 
         * @access  protected
         * @return  void
         */
        _setupDraft: function() {
            var model = Stencil.getModel('Image');
            this._references.draft = model.setAccessor(
                this._data.draft
            );
        },

        /**
         * _setupFonts
         * 
         * @access  protected
         * @return  void
         */
        _setupFonts: function() {
            this._collections.fonts = this._collections.fonts || new FontsCollection();
            this._collections.fonts.unbind('add');
            this._collections.fonts.on({

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @param   Number position
                 * @return  void
                 */
                'add': function(event, font, position) {
                    if (font.get('uploaded').toInt() === 1) {
                        font.drawStyleSheet();
                    }
                }
            });

            // The following will only map an account's fonts to the collection
            var _this = this;
            jQuery.each(this._data.fonts, function(index, font) {
                if (_this._collections.fonts.find(font.key) === false) {
                    _this._collections.fonts.map(font, true);
                }
            });
        },

        /**
         * _setupFrames
         * 
         * Adds any frames that aren't yet in memory to the account's
         * FramesCollection.
         * 
         * @access  protected
         * @return  void
         */
        _setupFrames: function() {
            var _this = this;
            this._collections.frames = this._collections.frames || new FramesCollection();
            jQuery.each(this._data.frames, function(index, frame) {
                if (_this._collections.frames.find(frame.key) === false) {
                    _this._collections.frames.map(frame, true);
                }
            });
        },

        /**
         * _setupOrphanFrame
         * 
         * @access  protected
         * @return  void
         */
        _setupOrphanFrame: function() {
            var model = Stencil.getModel('Frame');
            this._references.orphanFrame = model.setAccessor({
                class: 'frame',
                type: 'orphan',
                tag: 'backup',
                key: 'frm-orphan',
                label: 'Custom',
                width: 0,
                height: 0
            });
        },

        /**
         * _setupUpgrade
         * 
         * @access  protected
         * @return  void
         */
        _setupUpgrade: function() {
            if (this._data.upgrade !== false) {
                var model = Stencil.getModel('Upgrade');
                this._references.upgrade = model.setAccessor(
                    this._data.upgrade
                );
            }
            Account.once({
                'upgrade': this._setupUpgrade.proxy(this)
            });
        },

        /**
         * _setupUserAccount
         * 
         * @todo!   Look into whether the login / signup events need to be added
         *          below, since if the userAccount is found, we know they're
         *          already logged in.
         * @access  protected
         * @return  void
         */
        _setupUserAccount: function() {
            if (this._data.userAccount !== false) {
                var model = Stencil.getModel('UserAccount');
                this._references.userAccount = model.setAccessor(
                    this._data.userAccount
                );
            }
            User.once({
                'login': this._setupUserAccount.proxy(this),
                'signup': this._setupUserAccount.proxy(this)
            });
        },

        /**
         * _setupWatermarks
         * 
         * @access  protected
         * @return  void
         */
        _setupWatermarks: function() {
            this._collections.watermarks = this._collections.watermarks || new WatermarksCollection();
            this._collections.watermarks.map(this._data.watermarks, true);
        },

        /**
         * cancel
         * 
         * @access  public
         * @param   Boolean later
         * @param   Boolean disapproveLastCommission
         * @param   Function callback
         * @return  void
         */
        cancel: function(later, disapproveLastCommission, callback) {
            var _this = this,
                path = '/accounts/' + (this._data.key) + '/cancel';
            RequestUtils.ajax({
                signature: {"basename":"Account.js","line":287},
                url: path,
                type: 'POST',
                data: {
                    later: (later === true ? 1 : 0),
                    disapproveLastCommission: (
                        disapproveLastCommission === true
                        ? 1
                        : 0
                    )
                },
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '303-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * coupon
         * 
         * Returns whether or not the account used a coupon during upgrading.
         * 
         * @access  public
         * @return  Boolean
         */
        coupon: function() {
            return this.upgrade() !== undefined
                && this.upgrade().get('coupon') !== false;
        },

        /**
         * createdBefore
         * 
         * @example
         *          this.createdBefore('1 day');
         *          this.createdBefore('2 weeks');
         * @access  public
         * @param   String relativeTime
         * @return  Boolean
         */
        createdBefore: function(relativeTime) {
            var period = 'seconds';
            if (relativeTime.match(/minute/) !== null) {
                period = 'minutes';
            } else if (relativeTime.match(/hour/) !== null) {
                period = 'hours';
            } else if (relativeTime.match(/day/) !== null) {
                period = 'days';
            } else if (relativeTime.match(/week/) !== null) {
                period = 'weeks';
            } else if (relativeTime.match(/month/) !== null) {
                period = 'months';
            } else if (relativeTime.match(/year/) !== null) {
                period = 'years';
            }
            var number = relativeTime.replace(/[^0-9]/, '').toInt(),
                comparisonTimestamp = moment().subtract(number, period),
                createdTimestamp = moment.unix(this._data.created);
            return createdTimestamp.isBefore(comparisonTimestamp);
        },

        /**
         * createNewDraft
         * 
         * @access  public
         * @param   ImageAccessor current
         * @return  ImageAccessor
         */
        createNewDraft: function(current) {
            var _this = this,
                model = Stencil.getModel('Image'),
                draft = model.setAccessor({
                    class: 'image',
                    key: DataUtils.getRandomString(),
                    draft: 1,
                    width: current.get('width').toInt(),
                    height: current.get('height').toInt(),
                    sourceImage: current.data(),
                    sourceImageId: current.get('id').toInt(),// careful
                    uploaded: 0,// Needed for preloading elsewhere
                    frame: current.get('frame'),
                    settings: {
                        json: current.setting('json'),
                        watermarks: current.setting('watermarks')
                    },
                    ip: Stencil.account().get('geo').ip
                });
            this._references.draft = draft;
            model.create({
                frame: draft.get('frame'),
                draft: draft.get('draft'),
                width: draft.get('width').toInt(),
                height: draft.get('height').toInt(),
                sourceImageId: draft.getSourceImage().get('id').toInt(),// careful
                settings: {
                    json: draft.setting('json'),
                    watermarks: draft.setting('watermarks')
                }
            }, function(data) {
                draft.swap(data.object);
                _this.triggerHandler('draft/create', [draft]);
            });
            return draft;
        },

        /**
         * orphanFrame
         * 
         * @access  public
         * @return  FrameAccessor
         */
        orphanFrame: function() {
            return this._references.orphanFrame;
        },

        /**
         * delinquent
         * 
         * Returns whether or not the account is in delinquent mode.
         * 
         * @access  public
         * @return  Boolean
         */
        delinquent: function() {
            return this.upgrade() !== undefined
                && this.upgrade().customer() !== undefined
                && this.upgrade().customer().get('delinquent').toInt() === 1;
        },

        /**
         * draft
         * 
         * @access  public
         * @return  ImageAccessor
         */
        draft: function() {
            return this._references.draft;
        },

        /**
         * draftIsLocked
         * 
         * @access  public
         * @return  Boolean
         */
        draftIsLocked: function() {
            return this._references.draft.isLocked();
        },

        /**
         * free
         * 
         * Returns whether or not the account is both not a guest and has not
         * been upgraded.
         * 
         * @access  public
         * @return  Boolean
         */
        free: function() {
            return this.guest() === false
                && this.upgraded() === false
                && User.admin() === false
                && User.editor() === false;
        },

        /**
         * geo
         * 
         * @access  public
         * @return  false|Object
         */
        geo: function() {
            if (
                this._data.geo.country.code === false
                || this._data.geo.country.code === ''
            ) {
                return false;
            }
            return this._data.geo;
        },

        /**
         * getDefaultFontFamily
         * 
         * @access  public
         * @return  String
         */
        getDefaultFontFamily: function() {
            return this.setting('defaultFontFamily');
            // var accountDefaultFontFamily = this.setting('defaultFontFamily'),
            //     fontsCollection = this._collections.fonts,
            //     font = fontsCollection.findByFamilyName(accountDefaultFontFamily);
            // if (font === false) {
            //     return Config.get('font');
            // }
            // return font.get('key');
        },

        /**
         * getImagesRemaining
         * 
         * @note    Can return less than 0, since users can saved a bunch of
         *          images, and then downgrade.
         * @access  public
         * @return  Number
         */
        getImagesRemaining: function() {
            var max = this._data.monthlyMaxImages.toInt(),
                saved = this._data.monthlySavedImages.toInt(),
                bonus = this._data.bonusImages.toInt();
            if (max === 0) {
                return Infinity;
            }
            var left = max - saved + bonus;
            if (left < 0) {
                return 0;
            }
            return max - saved + bonus;
        },

        /**
         * getOnboardingValue
         * 
         * @access  public
         * @param   String key
         * @return  undefined|mixed
         */
        getOnboardingValue: function(key) {
            var jitOnboarding = this.setting('jitOnboarding');
            jitOnboarding = JSON.parse(jitOnboarding);
            return jitOnboarding[key];
        },

        /**
         * getReferralUrl
         * 
         * @access  public
         * @return  Number
         */
        getReferralUrl: function() {
            var host = Config.get('hosts').app;
            return 'https://' + (host) + '/a/ref/' + (this._data.key);
        },

        /**
         * getRefillDate
         * 
         * @note    There are 4 cases here, all of which are covered the same:
         *          - Guests
         *          - Free users
         *          - Upgraded users
         *          - Downgraded free users
         *          I use the account record created date
         * @access  public
         * @return  String
         */
        getRefillDate: function() {
            var format = 'MMMM DD, YYYY \@ h\:mm a',
                micro = this._data.refill.toInt() * 1000;
            return moment(micro).format(format);
        },

        /**
         * getSmsMessagesRemaining
         * 
         * @access  public
         * @return  Number
         */
        getSmsMessagesRemaining: function() {
            var max = this._data.monthlyMaxSmsMessages.toInt(),
                sent = this._data.monthlySentSmsMessages.toInt();
            if (max === 0) {
                return Infinity;
            }
            var left = max - sent;
            if (left < 0) {
                return 0;
            }
            return max - sent;
        },

        /**
         * getFavoritesRemaining
         * 
         * @note    Can return less than 0, since users can favorite a bunch of
         *          objects, and then downgrade.
         * @access  public
         * @return  Number
         */
        getFavoritesRemaining: function() {
            var max = this._data.maxFavorites.toInt();
            if (max === 0) {
                return Infinity;
            }
            return max - this._data.favorites.length;
        },

        /**
         * getUpgradedPath
         * 
         * Returns the path the user should be sent to after an upgrade,
         * depending on what plan and interval they chose. This is abstracted
         * here to lookup the plan and interval, but also because it's used in a
         * conventional checkout flow as well as through a redemption flow. Note
         * also that while the parameters being passed are not currently (at the
         * time of documentation) being used within the application-logic, but
         * are being used by Google Analytics for goal-conversion-tracking.
         * 
         * @access  public
         * @return  String
         */
        getUpgradedPath: function() {
            var plan = this.upgrade().get('plan'),
                interval = this.upgrade().get('interval'),
                gateway = this.upgrade().get('gateway'),
                path = '/app/upgraded/' + (plan) +
                    '?clean=1' +
                    '&interval=' + (interval) +
                    '&gateway=' + (gateway);
            return path;
        },

        /**
         * guest
         * 
         * Returns whether or not the account is a guest.
         * 
         * @access  public
         * @return  Boolean
         */
        guest: function() {
            return this._data.guest.toInt() === 1;
        },

        /**
         * max
         * 
         * @access  public
         * @return  Object
         */
        max: {

            /**
             * bonus
             * 
             * Returns whether or not the account has received the max number of
             * bonus images.
             * 
             * @access  public
             * @return  Boolean
             */
            bonus: function() {
                if (this._data.followBonus.toInt() === 0) {
                    return false;
                }
                if (this._data.tweetBonus.toInt() === 0) {
                    return false;
                }
                if (this._data.shareBonus.toInt() === 0) {
                    return false;
                }
                return true;
            },

            /**
             * favorites
             * 
             * Returns whether or not the account has favorited the maximum
             * number of favorites allowable. Does the check using <= (instead of
             * checking if it equals 0) since when a user is downgraded, it's
             * possible for the number remaining to be less than 0 (eg. if they
             * favorited 20, then downgraded).
             * 
             * @access  public
             * @return  Boolean
             */
            favorites: function() {
                var remaining = this.getFavoritesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            },

            /**
             * images
             * 
             * Returns whether or not the account has saved the maximum number
             * of images (for the month). Does the check using <= (instead of
             * checking if it equals 0) since when a user is downgraded, it's
             * possible for the number remaining to be less than 0 (eg. if they
             * created 20 one month, then downgraded).
             * 
             * @access  public
             * @return  Boolean
             */
            images: function() {
                var remaining = this.getImagesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            },

            /**
             * sms
             * 
             * @access  public
             * @return  Boolean
             */
            sms: function() {
                var remaining = this.getSmsMessagesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            }
        },

        /**
         * plan
         * 
         * Returns whether or not the account is on the passed in plan. Does not
         * check whether they are active on that plan. Use <paying> for that.
         * 
         * @access  public
         * @param   String plan
         * @return  Boolean
         */
        plan: function(plan) {
            if (this.guest() === true) {
                return false;
            }
            if (this.upgrade() === undefined) {
                if (plan === 'free') {
                    return true;
                }
                return false;
            }
            return this.reference('upgrade').get('plan') === plan;
        },

        /**
         * promo
         * 
         * Returns whether or not the account was upgraded via a promo code.
         * 
         * @access  public
         * @return  Boolean
         */
        promo: function() {
            return this.upgrade() !== undefined
                && this.upgrade().customer() !== undefined
                && this.upgrade().customer().get('type') === 'promo';
        },

        /**
         * reload
         * 
         * @access  public
         * @return  void
         */
        reload: function() {
            this._setupCustomCategories();
            this._setupConnections();
            this._setupFonts();
            this._collections.fonts.loadUploadedNormal();
            this._collections.fonts.each(function(index, font) {
                if (font.get('uploaded').toInt() === 1) {
                    Toolbars.getToolbar('text').getFontsDropdown().addFont(font, false);
                }
            });
            this._setupFrames();
            this._setupColors();
            // this._setupDraft();
            this._setupUpgrade();
            this._setupWatermarks();
        },

        /**
         * setOnboardingValue
         * 
         * @access  public
         * @param   String key
         * @param   mixed value
         * @return  void
         */
        setOnboardingValue: function(key, value) {
            var jitOnboarding = this.setting('jitOnboarding');
            jitOnboarding = JSON.parse(jitOnboarding);
            jitOnboarding[key] = value;
            jitOnboarding = JSON.stringify(jitOnboarding);
            this.set({
                'settings.jitOnboarding': jitOnboarding
            });
            this.save(['settings.jitOnboarding']);
        },

        /**
         * showTermsAgreeInput
         * 
         * Returns a Boolean value as to whether or not a (guest) account should
         * be shown the terms input, which when shown, must be agreed to in
         * order to proceed with signing up.
         * 
         * At the time of documentation, the only time the terms input is not
         * shown is when the country can conclusively be determined as being
         * either:
         * - Australia
         * - Canada
         * - United States
         * 
         * In all other cases (including a false value or empty string value
         * being passed as the country code), the terms input is shown.
         * 
         * @access  public
         * @return  Boolean
         */
        showTermsAgreeInput: function() {
            var countryCode = this.get('geo').country.code;
            if (countryCode === false) {
                return true;
            }
            if (countryCode === '') {
                return true;
            }
            var blacklistCountries = ['au', 'ca', 'us', 'usa'];
            countryCode = countryCode.toLowerCase();
            if (ArrayUtils.contains(countryCode, blacklistCountries) === true) {
                return false;
            }
            return true;
        },

        /**
         * swapCategories
         * 
         * @note    Important to note the soft does-not-equal below. This is to
         *          prevent any issues with 1 !== '1'.
         * @access  public
         * @return  void
         */
        swapCategories: function() {

            /**
             * matches
             * 
             * @access  private
             * @param   CategoryAccessor first
             * @param   array second
             * @return  Boolean
             */
            var matches = function(first, second) {
                var properties = [
                        'photos',
                        'graphics',
                        'templates',
                        'quotes',
                        'uploads',
                        'watermarks',
                        'images',
                        'fonts',
                        'featured',
                        'global',
                        'all',
                        'favorites',
                        'custom'
                    ],
                    index;
                for (index in properties) {
                    if (first.get(properties[index]) != second[properties[index]]) {
                        return false;
                    }
                }
                return true;
            };
            this._collections.categories.each(function(index, accessor) {
                var categories = Stencil.account().get('categories'),
                    index;
                for (index in categories) {
                    if (matches(accessor, categories[index]) === true) {
                        accessor.swap(categories[index]);
                        accessor.set({
                            'count': categories[index].count
                        });
                    }
                }
            });
        },

        /**
         * syncFavorites
         * 
         * @access  public
         * @return  void
         */
        syncFavorites: function() {
            var areas = [
                    'photos',
                    'graphics',
                    'templates',
                    'quotes',
                    'uploads',
                    'images'
                ],
                index,
                collections, area;
            for (index in areas) {
                collections = [];
                area = App.getEditor().getArea(areas[index]);
                jQuery.each(
                    area.getChild('categories').getChildren(),
                    function(index, resultsView) {
                        collections.push(resultsView.getCollection());
                    }
                );
                jQuery.each(collections, function(index, collection) {
                    collection.each(function(index, accessor) {
                        if (accessor.favorited() === true) {
                            accessor.triggerHandler('favorite/ui');
                        }
                    });
                });
                if (area.getChild('queries') !== undefined) {
                    collections = [];
                    jQuery.each(
                        area.getChild('queries').getChildren(),
                        function(index, resultsView) {
                            collections.push(resultsView.getCollection());
                        }
                    );
                    jQuery.each(collections, function(index, collection) {
                        collection.each(function(index, accessor) {
                            if (accessor.favorited() === true) {
                                accessor.triggerHandler('favorite/ui');
                            }
                        });
                    });
                }
            }
        },

        /**
         * syncRefillData
         * 
         * This method exists for cases whereby a user's quotas reset, but they
         * are using the app at the same time. What was happening was a user
         * went from 50 images down to 3, then their quota reset, and the next
         * time they saved an image, a value of 2 was pushed to their account
         * record, overwriting what was just reset.
         * 
         * So this method ensures that before certain quota-setting requests,
         * the data is first retrieved, and if it's been reset, quota's are
         * set to their new values.
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        syncRefillData: function(callback) {
            this.read(function(data) {
                if (this.get('refill').toInt() !== data.refill.toInt()) {
                    this.set({
                        monthlySavedImages: data.monthlySavedImages.toInt(),
                        monthlySentSmsMessages: data.monthlySentSmsMessages.toInt(),
                        bonusImages: data.monthlySavedImages.toInt(),
                        refill: data.refill.toInt()
                    });
                    callback.apply(this, [true]);
                } else {
                    callback.apply(this, [false]);
                }
            });
        },

        /**
         * upgrade
         * 
         * Returns the UpgradeAccessor reference for the account, or else
         * undefined if no reference found.
         * 
         * @access  public
         * @return  UpgradeAccessor|undefined
         */
        upgrade: function() {
            return this._references.upgrade;
        },

        /**
         * upgraded
         * 
         * Returns whether or not the account has been upgraded. This is
         * independent of how they upgraded (eg. conventional, or through for
         * example an AppSumo deal).
         * 
         * @access  public
         * @return  Boolean
         */
        upgraded: function() {
            var upgrade = this.upgrade();
            if (upgrade === undefined) {
                return false;
            }
            return upgrade.get('active').toInt() === 1;
        },

        /**
         * upgradeToPlan
         * 
         * @access  public
         * @param   String plan
         * @return  void
         */
        upgradeToPlan: function(plan) {
            var _this = this,
                path = '/accounts/' + (this._data.key) + '/upgrade';
            RequestUtils.ajax({
                data: {
                    plan: plan
                },
                signature: {"basename":"Account.js","line":1014},
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = '1019-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                },
                type: 'POST',
                url: path
            });
        },

        /**
         * userAccount
         * 
         * @access  public
         * @return  UserAccountAccessor|undefined
         */
        userAccount: function() {
            return this._references.userAccount;
        }
    });
});
window.DependencyLoader.push(['MediaAccessor', 'AssetModel'], function() {

    /**
     * AssetAccessor
     * 
     * @extends MediaAccessor
     */
    window.AssetAccessor = MediaAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Asset'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AssetAccessor')
         */
        _string: 'AssetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
            this._setupResource();
            this._addSelectListener();
        },

        /**
         * _addQuoteTextLayers
         * 
         * @access  protected
         * @return  Boolean
         */
        _addQuoteTextLayers: function() {
            if (JSONUtils.valid(this._data.settings.raw) === false) {
                LogUtils.log.simple('JSON parse error (A:_aQTL)', true);
                return false;
            }
            var raw = JSON.parse(this._data.settings.raw),
                quotation = raw.quotation,
                author = raw.author,
                canvas = Canvases.Preview,
                layers = {
                    author: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: 'Leckerli One',
                        fontSize: 35,
                        text: author,
                        top: 70,
                        width: 90
                    }),
                    quotation: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: Stencil.account().getDefaultFontFamily(),
                        fontSize: 50,
                        text: quotation,
                        top: 45,
                        width: 90
                    })
                },
                drawings = {
                    author: layers.author.getDrawing(),
                    quotation: layers.quotation.getDrawing()
                };
            layers.author.setChangeOperationType('quote:added');
            drawings.author.once({
                'draw': function(event) {
                    this.trim();
                    this.repositionRelativeTo(drawings.quotation);
                    this.animate();
                    drawings.quotation.animate();
                    drawings.quotation.select();
                    // this._cotton.trigger('changed');
                    layers.author.triggerHandler('refresh/dimensions');
                }
            });
            drawings.quotation.once({
                'draw': function(event) {
                    drawings.author.draw();
                }
            });
            drawings.quotation.draw();
            return true;
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, method, locked, options) {
                    this._select(locked, options);
                }
            });
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'feature': function(event, category) {
                    Track.event('Asset featured', {
                        _key: this._data.key
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Asset unfeatured', {
                        _key: this._data.key
                    });
                }
            });
        },

        /**
         * _addVectorLayer
         * 
         * @note    I don't call <sync> against The Noun Project assets since
         *          they're all vectors, and the only thing I want to know about
         *          them is their filesize (which I already collect on the
         *          backend).
         * @access  protected
         * @param   Boolean locked
         * @param   Boolean color
         * @return  void
         */
        _addVectorLayer: function(locked, color) {
            var canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }, color),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
        },

        /**
         * _select
         * 
         * @access  protected
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        _select: function(locked, options) {

            // Graphics
            var vectorPlatforms = [
                    'Iconfinder',
                    'Icons8',
                    'TheNounProject',
                    'VectorSearch'
                ],
                resourceType = this._data.resourceType;
            if (ArrayUtils.contains(resourceType, vectorPlatforms) === true) {
                var color = this._data.color.toInt() === 1;
                this._addVectorLayer(locked, color);
                return true;
            }

            // Quotes
            if (resourceType === 'AlgoliaQuote') {
                this._addQuoteTextLayers();
                return true;
            }

            // Foreground photos
            if (options.destination === 'foreground') {
                Account.onboard('foregroundSelected');
                this.addForegroundBitmapImageLayer(locked);
                return true;
            }

            // Background photos
            Account.onboard('backgroundSelected');
            if (options.autoSelect !== undefined) {
                this.setBackgroundBitmapImageLayer(locked, {
                    autoSelect: options.autoSelect
                });
                return true;
            }
            this.setBackgroundBitmapImageLayer(locked);
            return true;
        },

        /**
         * _setupResource
         * 
         * @note    There was a bug in production whereby if an asset was loaded
         *          into the canvas (eg. ForegroundBitmapImageDrawing), but the
         *          accessor wasn't available in memory, trying to convert it
         *          from a foreground to a background image errored out, because
         *          the resourceType property was (naturally) not available.
         *          This was caused by the conver/background event. So in order
         *          to deal with this temporarily, I simply assume it's a
         *          PhotoResource, and then check the valid value. See here:
         *          https://sentry.io/stencil/javascript/issues/652383493/?query=is:unresolved
         * @note    The 'import' check below is to accommodate legacy assets
         *          that don't have a resourceType corresponding to a gateway.
         *          Rather, they were imported manually, and for them, having a
         *          resource accessor setup and defined isn't relevant, since
         *          they can only be accessed by loading a legacy, imported,
         *          image.
         * @access  protected
         * @return  Boolean
         */
        _setupResource: function() {
            var resourceType = this._data.resourceType;
            if (resourceType === 'import') {
                return false;
            }
            var resoureTypeModelMap = {
                    'AlgoliaQuote': 'QuoteResource',
                    'Iconfinder': 'GraphicResource',
                    'Icons8': 'GraphicResource',
                    'Pexels': 'PhotoResource',
                    'Pixabay': 'PhotoResource',
                    'TheNounProject': 'GraphicResource',
                    'Unsplash': 'PhotoResource',
                    'VectorSearch': 'GraphicResource'
                },
                modelName = 'PhotoResource';
            if (resourceType !== undefined) {
                modelName = resoureTypeModelMap[resourceType];
            }
            var model = Stencil.getModel(modelName);
            this._references.resource = model.setAccessor({
                class: 'resource',
                key: this.getResourceHash(),
                platform: this._data.resourceType,
                id: this._data.resourceId
            });
            return true;
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = CategoryUtils.account.favorites(areaType);
            this.feature(category, performDataRequest);
        },

        /**
         * favorited
         * 
         * @access  public
         * @return  Boolean
         */
        favorited: function() {
            var favorites = Stencil.account().get('favorites'),
                resourceHash = this.getResourceHash(),
                favorited = favorites.indexOf(resourceHash) !== -1;
            return favorited;
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            var area = 'photos';
            if (category.get('graphics').toInt() === 1) {
                area = 'graphics';
            } else if (category.get('quotes').toInt() === 1) {
                area = 'quotes';
            }
            if (ArrayUtils.contains(category, CategoryUtils.global.all()) === true) {
                Stencil.globalFeatures.add(this);
            }
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('key')
                    },
                    (function(data) {
                        this.triggerHandler('feature/complete');
                    }).proxy(this)
                );
            }
            this.triggerHandler('feature', [category]);
            this._references.resource.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * featuredInCategory
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        featuredInCategory: function(category) {
            var features = category.get('features'),
                resourceHash = this.getResourceHash(),
                featuredInCategory = ArrayUtils.contains(resourceHash, features) === true;
            return featuredInCategory;
        },

        /**
         * getPlacementDestination
         * 
         * @access  public
         * @return  String
         */
        getPlacementDestination: function() {
            if (this.get('resourceType') === 'Iconfinder') {
                return 'foreground';
            }
            if (this.get('resourceType') === 'Icons8') {
                return 'foreground';
            }
            if (this.get('resourceType') === 'TheNounProject') {
                return 'foreground';
            }
            if (this.get('resourceType') === 'VectorSearch') {
                return 'foreground';
            }
            return 'background';
        },

        /**
         * getResourceHash
         * 
         * Returns a hash (as a string) of the resource type and id. Useful for
         * comparing resource keys to assets, to see if an asset is actually
         * just a saved version of a resource.
         * 
         * @access  public
         * @return  String
         */
        getResourceHash: function() {
            var resourceType = this._data.resourceType,
                resourceId = this._data.resourceId,
                resourceHash = (resourceType) + ':' + (resourceId);
            return resourceHash;
        },

        /**
         * globalCategoriesFeaturedIn
         * 
         * @access  public
         * @return  Array
         */
        globalCategoriesFeaturedIn: function() {
            var categories = CategoryUtils.global.all(),
                index,
                features,
                matching = [];
            for (index in categories) {
                features = categories[index].get('features');
                if (ArrayUtils.contains(this.getResourceHash(), features) === true) {
                    matching.push(categories[index]);
                }
            }
            return matching;
        },

        /**
         * globallyFeatured
         * 
         * @access  public
         * @return  Boolean
         */
        globallyFeatured: function() {
            var globalFeatures = Stencil.get('globalFeatures'),
                resourceHash = this.getResourceHash();
            return globalFeatures.indexOf(resourceHash) !== -1;
        },

        /**
         * loadCropperDependencies
         * 
         * @access  public
         * @return  Boolean
         */
        loadCropperDependencies: function() {
            var bitmap = this.get('bitmap').toInt();
            if (bitmap === 0) {
                return false;
            }
            this._super();
            return true;
        },

        /**
         * owned
         * 
         * @access  public
         * @return  false
         */
        owned: function() {
            return false;
        },

        /**
         * preload
         * 
         * Contains two different flows for preloading resized resources based
         * on whether the asset is a bitmap (eg. Pixabay) or vector (eg. The
         * Noun Project). When it's a vector, for now, I'm booting in the
         * original asset, because with TNP, it's a relatively small 84x84 pixel
         * bitmap.
         * 
         * @access  public
         * @param   undefined|Function success (default: function(references) {})
         * @param   undefined|Function error (default: function(reference) {})
         * @return  Boolean
         */
        preload: function(success, error) {
            success = DataUtils.getDefaultValue(success, function(references) {});
            error = DataUtils.getDefaultValue(error, function(reference) {});
            if (this._data.resourceType === 'AlgoliaQuote') {
                var references = [];
                success.apply(this, [references]);
                return false;
            }

            // Bitmaps
            var url = this.url('thumb'),
                urls = [url];

            // Vectors
            if (this._data.bitmap.toInt() === 0) {
                url = this.url('original');
                urls = [url]
            }

            // Load
            ImageUtils.load.urls(urls, true, success.proxy(this), error.proxy(this));
            this.loadCropperDependencies();
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = CategoryUtils.account.favorites(areaType);
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @note    Since it's possible that the features collection actually
         *          contains the ResourceAccessor for this AssetAccessor, I
         *          try and remove that as well, incase that's the one that's
         *          being stored in the collection.
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            var area = 'photos';
            if (category.get('graphics').toInt() === 1) {
                area = 'graphics';
            } else if (category.get('quotes').toInt() === 1) {
                area = 'quotes';
            }
            if (ArrayUtils.contains(category, CategoryUtils.global.all()) === true) {
                if (this.globalCategoriesFeaturedIn().length === 1) {
                    Stencil.globalFeatures.remove(this);
                }
            }
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.unfeature(
                    this._data.key,
                    {
                        category: category.get('key')
                    }
                );
            }
            this.triggerHandler('unfeature', [category]);
            this._references.resource.triggerHandler('unfeature', [category]);
            features.remove(this);
            features.remove(this._references.resource);
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with The Noun Project icons for the
         *   preview thumbnail
         * - Thumb image url, at the moment used for Pixabay resources that have
         *   been saved as assets
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options
         * @return  String|false
         */
        url: function(type, options) {
            var key = this._data.key;
            if (type === 'original') {
                var url = ImageUtils.url.thumb(key, {
                    type: 'original'
                });
                return url;
            }
            if (type === 'thumb') {
                var url = ImageUtils.url.thumb(key, {
                    type: 'thumb'
                });
                return url;
            }
            return false;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'CategoryModel'], function() {

    /**
     * CategoryAccessor
     * 
     * @extends Accessor
     */
    window.CategoryAccessor = Accessor.extend({

        /**
         * _paths
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _paths: {},

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Category'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoryAccessor')
         */
        _string: 'CategoryAccessor',

        /**
         * _syncedFeatures
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _syncedFeatures: [],

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._paths = {};
            this._syncedFeatures = [];
            this._super(data);
            this._addTrackListeners();
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  String
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Category deleted');
                }
            });
        },

        /**
         * _getQuoteCategoryPinUrl
         * 
         * @access  protected
         * @return  String
         */
        _getQuoteCategoryPinUrl: function() {
            var role = Config.getRole();
            if (role === 'local' || role === 'dev') {
                // return RequestUtils.url.static('/app/static/images/logos/favicon.152x152.png');
            }
            var assetMap = {
                'Business': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstb956f154',
                'Friendship': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst244496ca',
                'Happiness': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst66eb379a',
                'Hope': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst8e3540fb',
                'Humor': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst5d6b5956',
                'Inspirational': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst3b331092',
                'Leadership': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst9a4d03a0',
                'Love': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asste7917584',
                'Nature': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst0dba3038',
                'Philosophy': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstcb54b664',
                'Relationships': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstae0dfc7b',
                'Religion': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst1879c88a',
                'Spirituality': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstc9881e10',
                'Success': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst0eeda03b',
                'Wisdom': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst7fffad4b',
            }
            if (assetMap[this._data.name] !== undefined) {
                return assetMap[this._data.name];
            }
            return RequestUtils.url.static('/app/static/images/logos/favicon.152x152.png');
        },

        /**
         * belongsToAccount
         * 
         * @access  public
         * @return  Boolean
         */
        belongsToAccount: function() {
            return this._data.accountId.toInt() !== 0;
        },

        /**
         * featureObjects
         * 
         * @access  public
         * @param   Array keys
         * @return  void
         */
        featureObjects: function(keys) {
            this._model.featureObjects(this._data.key, {
                objects: keys
            });
        },

        /**
         * features
         * 
         * @access  public
         * @var     Object
         */
        features: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                var features = this._data.features,
                    key = accessor.get('key');
                if (accessor.is.asset.apply(accessor) === true) {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                features.push(key);
                this.set('count', this._data.count.toInt() + 1);
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var features = this._data.features,
                    key = accessor.get('key'),
                    index;
                if (accessor.is.asset.apply(accessor) === true) {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = features.indexOf(key);
                if (index !== -1) {
                    features.splice(index, 1);
                    this.set('count', this._data.count.toInt() - 1);
                }
            }
        },

        /**
         * getAreaString
         * 
         * @throws Error
         * @access  public
         * @return  String
         */
        getAreaString: function() {
            if (this._data.photos.toInt() === 1) {
                return 'Photos';
            }
            if (this._data.graphics.toInt() === 1) {
                return 'Graphics';
            }
            if (this._data.templates.toInt() === 1) {
                return 'Templates';
            }
            if (this._data.quotes.toInt() === 1) {
                return 'Quotes';
            }
            if (this._data.uploads.toInt() === 1) {
                return 'Uploads';
            }
            if (this._data.watermarks.toInt() === 1) {
                return 'Watermarks';
            }
            if (this._data.images.toInt() === 1) {
                return 'Images';
            }
            var msg = 'Invalid type for getAreaString';
            throw new Error(msg);
        },

        /**
         * getLabelName
         * 
         * Returns the name for the filter label, rather than the name for
         * within the dropdown.
         * 
         * @note    The ss to sss regular expression change is to accommodate for
         *          cases like the term Business being converted to Businesss.
         * @throws  Error
         * @access  public
         * @return  String
         */
        getLabelName: function() {
            if (this._data.all.toInt() === 1) {
                if (this._data.images.toInt() === 1) {
                    return 'All Saved Images';
                }
                if (this._data.templates.toInt() === 1) {
                    return 'My Templates';
                }
                if (this._data.uploads.toInt() === 1) {
                    return 'All Uploads';
                }
                if (this._data.watermarks.toInt() === 1) {
                    return 'Logo / Watermark Uploads';
                }
                var msg = 'Invalid type (all)';
                throw new Error(msg);
            }
            if (this._data.favorites.toInt() === 1) {
                if (this._data.images.toInt() === 1) {
                    return 'Favorite Saved Images';
                }
                if (this._data.graphics.toInt() === 1) {
                    return 'Favorite Icons';
                }
                if (this._data.photos.toInt() === 1) {
                    return 'Favorite Photos';
                }
                if (this._data.quotes.toInt() === 1) {
                    return 'Favorite Quotes';
                }
                if (this._data.templates.toInt() === 1) {
                    return 'Favorite Templates';
                }
                if (this._data.uploads.toInt() === 1) {
                    return 'Favorite Uploads';
                }
                var msg = 'Invalid type (favorites)';
                throw new Error(msg);
            }
            if (this._data.featured.toInt() === 1) {
                if (this._data.graphics.toInt() === 1) {
                    return 'Featured Icons';
                }
                if (this._data.photos.toInt() === 1) {
                    return 'Featured Photos';
                }
                if (this._data.quotes.toInt() === 1) {
                    return 'Featured Quotes';
                }
                if (this._data.templates.toInt() === 1) {
                    return 'Featured Templates';
                }
                var msg = 'Invalid type (featured)';
                throw new Error(msg);
            }
            if (this._data.global.toInt() === 1) {
                if (this._data.graphics.toInt() === 1) {
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Icons');
                }
                if (this._data.photos.toInt() === 1) {
                    if (this._data.name === 'Patterns') {
                        return 'Patterns';
                    }
                    if (this._data.name === 'Textures') {
                        return 'Textures';
                    }
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Photos');
                }
                if (this._data.quotes.toInt() === 1) {
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Quotes');
                }
                if (this._data.templates.toInt() === 1) {
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Templates');
                }
            }
            return this._data.name;
        },

        /**
         * getPath
         * 
         * @note    Reroutes any custom categories that have a slug that
         *          conflicts with a slug from the respective area to the
         *          /collections/$slug path. This is to allow for collections
         *          that have the same name as global categories, while
         *          maintaining a clean URI structure. A bit unconventional, but
         *          allows for users to name their collections anything without
         *          causing an issue, and for us to be able to create new
         *          global categories without worrying about existing custom
         *          categories being overridden.
         * @throws  Error
         * @access  public
         * @param   undefined|Boolean excludeLeadingSlash (default: false)
         * @return  String
         */
        getPath: function(excludeLeadingSlash) {
            excludeLeadingSlash = DataUtils.getDefaultValue(
                excludeLeadingSlash,
                false
            );

            // Formatting
            var _this = this,
                type = _this.getType(),
                __format = function(path) {
                    var __formatOutput = function(path) {
                        if (excludeLeadingSlash === true) {
                            return path.replace(/^\//, '');
                        }
                        return path;
                    };
                    var __formatForUniqueness = function(path) {
                        if (_this._data.custom.toInt() === 1) {
                            var index,
                                categories = CategoryUtils.global.type(type);
                            categories.push(
                                CategoryUtils.account.favorites(type)
                            );
                            if (type === 'templates') {
                                categories.push(
                                    CategoryUtils.account.list(type)
                                );
                            }
                            if (_this._data.slug !== 'featured') {
                                for (index in categories) {
                                    if (categories[index].get('slug') === _this._data.slug) {
                                        return path.replace(/([^/]+)$/, 'collections/$1');
                                    }
                                }
                            }
                        }
                        return path;
                    };
                    return __formatOutput(
                        __formatForUniqueness(
                            path
                        )
                    );
                };

            // Path determination
            var slug = this._data.slug;
            if (this._data.graphics.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app/icons');
                }
                return __format('/app/icons/' + (slug));
            }
            if (this._data.images.toInt() === 1) {
                if (this._data.all.toInt() === 1) {
                    return __format('/app/saved');
                }
                return __format('/app/saved/' + (slug));
            }
            if (this._data.photos.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app');
                }
                return __format('/app/photos/' + (slug));
            }
            if (this._data.quotes.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app/quotes');
                }
                return __format('/app/quotes/' + (slug));
            }
            if (this._data.templates.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app/templates');
                }
                return __format('/app/templates/' + (slug));
            }
            if (this._data.uploads.toInt() === 1) {
                if (this._data.all.toInt() === 1) {
                    return __format('/app/uploads');
                }
                return __format('/app/uploads/' + (slug));
            }
            if (this._data.watermarks.toInt() === 1) {
                if (this._data.all.toInt() === 1) {
                    return __format('/app/logos');
                }
                var msg = 'Invalid slug';
                throw new Error(msg);
            }
            var msg = 'Invalid type';
            throw new Error(msg);
        },

        /**
         * getType
         * 
         * @throws Error
         * @access  public
         * @return  String
         */
        getType: function() {
            if (this._data.graphics.toInt() === 1) {
                return 'graphics';
            }
            if (this._data.images.toInt() === 1) {
                return 'images';
            }
            if (this._data.photos.toInt() === 1) {
                return 'photos';
            }
            if (this._data.quotes.toInt() === 1) {
                return 'quotes';
            }
            if (this._data.templates.toInt() === 1) {
                return 'templates';
            }
            if (this._data.uploads.toInt() === 1) {
                return 'uploads';
            }
            if (this._data.watermarks.toInt() === 1) {
                return 'watermarks';
            }
            var msg = 'Invalid data type';
            throw new Error(msg);
        },

        /**
         * getPinUrl
         * 
         * @note    /w_0.5,c_crop,g_auto/
         * @see     http://cloudinary.com/documentation/image_transformations#automatic_cropping
         * @see     https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/if_ar_gt_1.0,h_212,c_scale/if_else,w_304,c_scale/s3.dev/asstda430352
         * @access  public
         * @return  String
         */
        getPinUrl: function() {
            if (this._data.quotes.toInt() === 1) {
                return this._getQuoteCategoryPinUrl();
            }
            if (this._data.pinKey !== false) {
                if (this._data.graphics.toInt() === 1) {
                    var url = ImageUtils.url.thumb(this._data.pinKey, {
                        type: 'original'
                    });
                    return url;
                }
                var url = ImageUtils.url.thumb(this._data.pinKey, {
                    type: 'thumb'
                });
                return url;
                // return Stencil.getAccessor(this._data.pin).url('thumb');
            }
            return RequestUtils.url.static('/app/static/images/logos/favicon.152x152.png');
        },

        /**
         * pin
         * 
         * @access  public
         * @param   Accessor accessor
         * @return  void
         */
        pin: function(accessor) {
            this._model.pin(this._data.key, {
                objectType: accessor.get('class').toLowerCase(),
                objectKey:  accessor.get('key')
            });
            accessor.triggerHandler('pin');
        },

        /**
         * syncedFeatures
         * 
         * Helper methods to keep track of which objects have successfully had a
         * feature-record created (which is needed for sorting and deleting to
         * ensure no race-conditions).
         * 
         * @access  public
         * @var     Object
         */
        syncedFeatures: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                if (this.syncedFeatures.contains.apply(this, [accessor]) === false) {
                    this._syncedFeatures.push(accessor);
                    this.triggerHandler('syncedFeatures/add');
                }
            },

            /**
             * contains
             * 
             * @access  public
             * @param   Array|String|Accessor obj
             * @return  Boolean
             */
            contains: function(obj) {
                if (jQuery.isArray(obj) === true) {
                    if (obj.length === 0) {
                        return true;
                    }
                    var contains = this.syncedFeatures.contains.apply(
                        this, [obj[0]]
                    );
                    if (contains === false) {
                        return false;
                    }
                    return this.syncedFeatures.contains.apply(
                        this,
                        [obj.slice(1)]
                    );
                }
                if (jQuery.type(obj) === 'string') {
                    var index, accessor;
                    for (index in this._syncedFeatures) {
                        accessor = this._syncedFeatures[index];
                        if (accessor.get('key') === obj) {
                            return true;
                        }
                    }
                    return false;
                }
                return ArrayUtils.contains(obj, this._syncedFeatures) === true;
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var index = this._syncedFeatures.indexOf(accessor);
                if (index !== -1) {
                    this._syncedFeatures.splice(index, 1);
                    this.triggerHandler('syncedFeatures/remove');
                }
            }
        },

        /**
         * unfeatureObjects
         * 
         * @access  public
         * @param   Array keys
         * @return  void
         */
        unfeatureObjects: function(keys) {
            this._model.unfeatureObjects(this._data.key, {
                objects: keys
            });
        }
    });
});
window.DependencyLoader.push(['Accessor', 'ColorModel'], function() {

    /**
     * ColorAccessor
     * 
     * @extends Accessor
     */
    window.ColorAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Color'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorAccessor')
         */
        _string: 'ColorAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Color deleted');
                }
            });
        }
    });
});
window.DependencyLoader.push(['Accessor', 'ConnectionModel'], function() {

    /**
     * ConnectionAccessor
     * 
     * @extends Accessor
     */
    window.ConnectionAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Connection'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionAccessor')
         */
        _string: 'ConnectionAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Connection deleted');
                }
            });
        },

        /**
         * _getFacebookVersion
         * 
         * @access  protected
         * @return  String
         */
        _getFacebookVersion: function() {
            var config = Config.get('facebook'),
                version = config.version;
            version = 'v' + (version);
            return version;
        },

        /**
         * getLabel
         * 
         * @access  public
         * @return  String
         */
        getLabel: function() {
            var type = this._data.type;
            if (type === 'account') {
                return 'Page';
            }
            return 'Profile';
        },

        /**
         * getImageSrc
         * 
         * @access  public
         * @return  String
         */
        getImageSrc: function() {
            if (this._data.network === 'twitter') {
                return this._data.image;
            }
            var facebookVersion = this._getFacebookVersion();
            return this._data.image.replace(
                'graph.facebook.com/',
                'graph.facebook.com/' + (facebookVersion) + '/'
            );
        },

        /**
         * getPath
         * 
         * @throws Error
         * @access  public
         * @return  String
         */
        getPath: function() {
            var id = this._data.networkResourceId,
                label = this._data.label;
            switch (this._data.network) {
                case 'facebook':
                    return 'https://facebook.com/' + (id);
                case 'twitter':
                    return 'https://twitter.com/' + (label);
            }
            var msg = 'Invalid network';
            throw new Error(msg);
        },

        /**
         * getRaw
         * 
         * @access  public
         * @return  Object
         */
        getRaw: function() {
            return JSON.parse(this._data.raw);
        }
    });
});
window.DependencyLoader.push(['Accessor', 'CouponModel'], function() {

    /**
     * CouponAccessor
     * 
     * @extends Accessor
     */
    window.CouponAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Coupon'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CouponAccessor')
         */
        _string: 'CouponAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Coupon deleted');
                }
            });
        },

        /**
         * trial
         * 
         * @access  public
         * @return  Boolean
         */
        trial: function() {
            return this._data.trial.toInt() !== 0;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'CustomerModel'], function() {

    /**
     * CustomerAccessor
     * 
     * @extends Accessor
     */
    window.CustomerAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Customer'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomerAccessor')
         */
        _string: 'CustomerAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * stripe
         * 
         * @access  public
         * @return  String
         */
        stripe: function() {
            var link = 'https://dashboard.stripe.com/';
            if (Config.getRole() !== 'prod') {
                link += 'test/';
            }
            link += 'customers/' + (this._data.gatewayKey);
            return link;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'FeatureModel'], function() {

    /**
     * FeatureAccessor
     * 
     * @extends Accessor
     */
    window.FeatureAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Feature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FeatureAccessor')
         */
        _string: 'FeatureAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
});
window.DependencyLoader.push(['Accessor', 'FontModel'], function() {

    /**
     * FontAccessor
     * 
     * @see     https://speakerdeck.com/bramstein/web-fonts-performance
     * @events  load/full
     * @extends Accessor
     */
    window.FontAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Font'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontAccessor')
         */
        _string: 'FontAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupUpload();
        },

        /**
         * _setupUpload
         * 
         * @access  protected
         * @return  void
         */
        _setupUpload: function() {
            var model = Stencil.getModel('Upload');
            this._references.upload = model.setAccessor(this._data.upload);
        },

        /**
         * delete
         * 
         * I'm overriding the Accessor delete method, because with fonts, they
         * never actually deleted. Rather they get marked as inactive, to ensure
         * the data can still be loaded later on (eg. for deleted fonts in saved
         * images, or featured templates that use uploaded or imported fonts).
         * 
         * @access  public
         * @return  void
         */
        delete: function() {
            this.set({
                'deleted': true
            });
            this.push('active', 0);
            this.triggerHandler('delete');
            this.removeAll();
        },

        /**
         * drawStyleSheet
         * 
         * @access  public
         * @return  void
         */
        drawStyleSheet: function() {
            var type = 'woff';
            if (UserAgentUtils.supports.woff2() === true) {
                type = 'woff2';
            }
            var style = '@font-face {' +
                'font-family:"' + (this.get('familyName')) + '";' +
                'src:url("' + (this.getUrl(type)) + '") ' +
                'format("' + (type) + '");' +
            '}';
            $('head').append('<style type="text/css">' + (style) + '</style>');
        },

        /**
         * getUrl
         * 
         * @access  public
         * @param   String type
         * @return  String
         */
        getUrl: function(type) {
            var key = this._references.upload.get('key');
            if (type === 'woff') {
                key += '.woff';
                var url = RequestUtils.url.cloudFront(key);
                return url;
            }
            if (type === 'woff2') {
                key += '.woff2';
                var url = RequestUtils.url.cloudFront(key);
                return url;
            }
            if (type === 'otf') {
                key += '.otf';
                var url = RequestUtils.url.cloudFront(key);
                return url;
            }
            if (type === 'ttf') {
                key += '.ttf';
                var url = RequestUtils.url.cloudFront(key);
                return url;
            }
            var msg = 'Invalid type for getUrl of font';
            throw new Error(msg);
        },

        /**
         * loadFull
         * 
         * Fully loads specific font (including any available styles such as
         * bold, italic and bold + italic).
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        loadFull: function(callback) {

            // Determine what should be loaded
            var familyName = this.get('familyName'),
                loadableVersions = [];
            loadableVersions.push((familyName) + ':n4');
            if (this.get('bold').toInt() === 1) {
                loadableVersions.push((familyName) + ':n7');
            }
            if (this.get('italic').toInt() === 1) {
                loadableVersions.push((familyName) + ':i4');
            }
            if (this.get('boldItalic').toInt() === 1) {
                loadableVersions.push((familyName) + ':i7');
            }

            // Determine what font versions (if any) should be loaded
            var collection = Stencil.account().collection('fonts'),
                loadedFontFamilies = collection.getLoaded(),
                fontsAlreadyLoaded = _.intersection(
                    loadedFontFamilies,
                    loadableVersions
                ),
                fontVersionToLoad = _.difference(
                    loadableVersions,
                    fontsAlreadyLoaded
                );

            // If there's nothing to load, we're good
            if (fontVersionToLoad.length === 0) {
                callback && callback();
            }
            // If it's a native font
            else if (this.get('native').toInt() === 1) {
                callback && callback();
            }
            // Otherwise let's go ahead with this
            else {

                // If the font is already being loaded
                var loadingFontFamilies = collection.getLoading(),
                    fontBeingLoaded = _.indexOf(
                        loadingFontFamilies,
                        fontVersionToLoad[0]
                    ) !== -1;
                if (callback !== undefined) {
                    this.once({
                        'load/full/success load/full/failed': callback
                    });
                }

                // Font hasn't yet been loaded
                if (fontBeingLoaded === false) {

                    // Track what's being loaded
                    loadingFontFamilies.push.apply(
                        loadingFontFamilies,
                        fontVersionToLoad
                    );

                    /**
                     * There's a strange bug with the WebFont library, in
                     * that when only a custom font is requested, the
                     * library will error out with "No fonts to load!"
                     * 
                     * This is because it does not seem to be accounting
                     * for a single custom font being loaded along with an
                     * empty array of Google fonts.
                     * 
                     * To deal with this, I make the call to the load method
                     * by passing in the webFontConfigObject, which only
                     * adds the google fonts if the array has at least one
                     * entry.
                     */
                    var webFontConfigObject = {
                        classes: false,
                        fontactive: (function(familyName, fvd) {
                            var formattedFamilyName = (familyName) + ':' + (fvd),
                                loadingArrayIndex = _.indexOf(
                                    loadingFontFamilies,
                                    formattedFamilyName
                                );
                            loadedFontFamilies.push(formattedFamilyName);
                            loadingFontFamilies.splice(loadingArrayIndex, 1);
                            if (loadingFontFamilies.length === 0) {
                                this.triggerHandler('load/full/success');
                            }
                        }).proxy(this),
                        /** 
                         * There was an issue with IE11 whereby a font
                         * would fail to load. To accommodate this, for
                         * now, trigger a failed alert, which is the
                         * same as the loaded event.
                         * 
                         * This will ensure the callback gets triggered
                         * (even if it is wrong for now).
                         */
                        fontinactive: (function(familyName, fvd) {
                            var formattedFamilyName = (familyName) + ':' + (fvd),
                                loadingArrayIndex = _.indexOf(
                                    loadingFontFamilies,
                                    formattedFamilyName
                                );
                            loadingFontFamilies.splice(loadingArrayIndex, 1);
                            if (loadingFontFamilies.length === 0) {
                                this.triggerHandler('load/full/failed');
                            }
                        }).proxy(this),
                        timeout: 5000
                    };

                    // Determine which kind of font is being loaded
                    if (this.get('uploaded').toInt() === 0) {
                        webFontConfigObject.google = {
                            families: DataUtils.convertGoogleFontNames(fontVersionToLoad)
                        };
                    } else {
                        webFontConfigObject.custom = {
                            families: DataUtils.convertGoogleFontNames(fontVersionToLoad)
                        };
                    }

                    // Initiate the load
                    WebFont.load(webFontConfigObject);
                }
            }
        }
    });
});
window.DependencyLoader.push(['Accessor', 'FrameModel'], function() {

    /**
     * FrameAccessor
     * 
     * @extends Accessor
     */
    window.FrameAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Frame'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FrameAccessor')
         */
        _string: 'FrameAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Frame deleted');
                }
            });
        },

        /**
         * getIcon
         * 
         * @access  public
         * @return  String
         */
        getIcon: function() {
            switch (this._data.tag) {
                case 'email':
                    return 'fa-envelope-o';
                case 'facebook':
                    return 'fa-facebook';
                case 'googlePlus':
                    return 'fa-google-plus';
                case 'instagram':
                    return 'fa-instagram';
                case 'linkedin':
                    return 'fa-linkedin';
                case 'eBookCover':
                    return 'fa-book';
                case 'pinterest':
                    return 'fa-pinterest-p';
                case 'twitter':
                    return 'fa-twitter';
                case 'youtube':
                    return 'fa-youtube';
                default:
                    return 'fa-circle';
            }
        },

        /**
         * getRatio
         * 
         * @access  public
         * @return  Number
         */
        getRatio: function() {
            var ratio = this._data.width / this._data.height;
            return ratio;
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            window.Frame = this;
            var draft = Stencil.account().draft();
            draft.set({
                frame: Frame.get('key'),
                width: Frame.get('width').toInt(),
                height: Frame.get('height').toInt()
            });
        },

        /**
         * setToPreviewCanvas
         * 
         * @access  public
         * @return  void
         */
        setToPreviewCanvas: function() {
            var canvas = Canvases.Preview;
            this.updateMessaging();
            canvas.once({
                'refresh': function(event) {
                    var layer = canvas.getBackgroundBitmapImageLayer();
                    layer.getCotton().trigger('lock');
                    canvas.render();
                }
            });
            canvas.refreshLayers();
        },

        /**
         * updateMessaging
         * 
         * @access  public
         * @return  void
         */
        updateMessaging: function() {
            var content = App.getStage().getContent(),
                resizer = content.getResizer();
            content.updateResizer();
            resizer.updateSelected();
        }
    });
});
window.DependencyLoader.push(['Accessor', 'GoogleFontModel'], function() {

    /**
     * GoogleFontAccessor
     * 
     * @extends Accessor
     */
    window.GoogleFontAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GoogleFont'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontAccessor')
         */
        _string: 'GoogleFontAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * alreadyImported
         * 
         * @access  public
         * @return  Boolean
         */
        alreadyImported: function() {
            var uploadedFonts = Stencil.account().collection('fonts').getUploaded(),
                index,
                upload;
            for (index in uploadedFonts) {
                upload = uploadedFonts[index].reference('upload');
                if (this._data.file.indexOf(upload.get('name')) !== -1) {
                    return true;
                }
            }
            return false;
        },

        /**
         * drawStyleSheet
         * 
         * @access  public
         * @return  void
         */
        drawStyleSheet: function() {
            var fontFamily = this.get('id'),
                style = '@font-face {' +
                    'font-family:"' + (fontFamily) + '";' +
                    'src:url("' + (this.get('file')) + '")'  +
                '}';
            $('head').append('<style type="text/css">' + (style) + '</style>');
        },

        /**
         * getExtendedSubsets
         * 
         * @access  public
         * @return  Array
         */
        getExtendedSubsets: function() {
            var standardSubsets = ['latin', 'latin-ext'],
                extendedSubsets = [],
                index,
                subset;
            for (index in this._data.subsets) {
                subset = this._data.subsets[index];
                if (ArrayUtils.contains(subset, standardSubsets) === false) {
                    extendedSubsets.push(subset);
                }
            }
            return extendedSubsets;
        },

        /**
         * getExtendedSubsetsTooltip
         * 
         * @access  public
         * @return  String
         */
        getExtendedSubsetsTooltip: function() {
            var extendedSubsets = this.getExtendedSubsets(),
                index;
            for (index in extendedSubsets) {
                extendedSubsets[index] = extendedSubsets[index].ucfirst();
            }
            return 'Supports: <br> - ' + extendedSubsets.join('<br> - ');
        },

        /**
         * getVariant
         * 
         * @note    The following is the breakdown of strength to english
         *          adjective:
         *          - 100: Thin
         *          - 200: Extra-Light
         *          - 300: Light
         *          - 400: Regular
         *          - 500: Medium
         *          - 600: Semi-Bold
         *          - 700: Bold
         *          - 800: Extra-Bold
         *          - 900: Black
         * @access  public
         * @return  String
         */
        getVariant: function() {

            // Map the weights to the english equivalent
            var weightMap = {
                    100: 'Thin',
                    200: 'Extra-Light',
                    300: 'Light',
                    400: 'Regular',
                    500: 'Medium',
                    600: 'Semi-Bold',
                    700: 'Bold',
                    800: 'Extra-Bold',
                    900: 'Black'
                },
                useWeightMap = true;

            // No italics
            if (this._data.variant.match(/italic/) === null) {
                if (useWeightMap === true) {
                    return weightMap[this._data.variant];
                }
                return this._data.variant;
            }

            // Italics
            if (useWeightMap === true) {
                var weight = this._data.variant.match(/^[0-9]+/)[0];
                return (weightMap[weight]) + ' + Italic';
            }

            // Keep weight
            return this._data.variant.replace(/^([0-9]+)italic$/, '$1 + Italic');
        },

        /**
         * hasExtendedSubsetSupport
         * 
         * @access  public
         * @return  Boolean
         */
        hasExtendedSubsetSupport: function() {
            return this.getExtendedSubsets().length > 0;
        },

        /**
         * import
         * 
         * @access  public
         * @return  void
         */
        import: function() {
            this._model.import(this);
        }
    });
});
window.DependencyLoader.push(['AssetAccessor', 'AssetModel'], function() {

    /**
     * GraphicAssetAccessor
     * 
     * @extends AssetAccessor
     */
    window.GraphicAssetAccessor = AssetAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Asset'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicAssetAccessor')
         */
        _string: 'GraphicAssetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * getDesignerIconsQueryPath
         * 
         * @access  public
         * @return  String
         */
        getDesignerIconsQueryPath: function() {
            var uploader = this.setting('uploader'),
                path = '/app/icons/search/',
                query = 'designer:';
            uploader = JSON.parse(uploader);
            query += uploader.username;
            query = encodeURIComponent(query);
            path += query;
            return path;
        },

        /**
         * getIconSetQueryPath
         * 
         * @access  public
         * @return  String
         */
        getIconSetQueryPath: function() {
            var collections = this.setting('collections'),
                path = '/app/icons/search/',
                query = 'set:';
            if (this._data.resourceType === 'VectorSearch') {
                query = '';
            }
            collections = JSON.parse(collections);
            query += collections[0];
            query = encodeURIComponent(query);
            path += query;
            return path;
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @param   View results
         * @param   Boolean locked
         * @return  Array
         */
        getThumbClasses: function(results, locked) {
            var classes = ['thumb', 'lazy', 'icon'];
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            if (results.category() === true) {
                var category = results.getCategory();
                if (this.pinned(category) === true) {
                    classes.push('pin');
                }
            }
            if (locked === true) {
                classes.push('locked');
            }
            if (this.showDesignerIcons(results) === true) {
                classes.push('designerIconsAvailable');
            }
            if (this.showSetIcon(results) === true) {
                classes.push('partOfIconSet');
            }
            return classes;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var src = this.url('original');
            return src;
        },

        /**
         * showDesignerIcons
         * 
         * @access  public
         * @param   View results
         * @return  Boolean
         */
        showDesignerIcons: function(results) {
            if (results.category() === false) {
                var query = results.getQuery();
                if (query.indexOf('designer:') !== -1) {
                    return false;
                }
            }
            var uploader = this.setting('uploader');
            if (JSONUtils.valid(uploader) === false) {
                return false;
            }
            uploader = JSON.parse(uploader);
            if (DataUtils.valid(uploader.username) === true) {
                return true;
            }
            return false;
        },

        /**
         * showSetIcon
         * 
         * @note    I don't think the category() check below is required since
         *          an asset likely can only exist within a category (and not
         *          a search result). Not 100% of this, but I think that the
         *          below check will never evalute to false.
         * @access  public
         * @param   View results
         * @return  Boolean
         */
        showSetIcon: function(results) {
            if (results.category() === false) {
                var query = results.getQuery(),
                    vectorSetNames = Config.get('vectorSetNames');
                if (ArrayUtils.contains(query, vectorSetNames) === true) {
                    return false;
                }
                if (query.indexOf('set:') !== -1) {
                    return false;
                }
            }
            var collections = this.setting('collections');
            if (JSONUtils.valid(collections) === false) {
                return false;
            }
            collections = JSON.parse(collections);
            if (DataUtils.valid(collections) === false) {
                return false;
            }
            if (collections.length > 0) {
                return true;
            }
            return false;
        }
    });
});
window.DependencyLoader.push(['ResourceAccessor'], function() {

    /**
     * GraphicResourceAccessor
     * 
     * @extends ResourceAccessor
     */
    window.GraphicResourceAccessor = ResourceAccessor.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicResourceAccessor')
         */
        _string: 'GraphicResourceAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * getDesignerIconsQueryPath
         * 
         * @access  public
         * @return  String
         */
        getDesignerIconsQueryPath: function() {
            var uploader = this.get('uploader'),
                path = '/app/icons/search/',
                query = 'designer:';
            query += uploader.username;
            query = encodeURIComponent(query);
            path += query;
            return path;
        },

        /**
         * getIconSetQueryPath
         * 
         * @access  public
         * @return  String
         */
        getIconSetQueryPath: function() {
            var collections = this.get('collections'),
                path = '/app/icons/search/',
                query = 'set:';
            if (this._data.key.match(/^VectorSearch\:[0-9]+$/) !== null) {
                query = '';
            }
            query += collections[0];
            query = encodeURIComponent(query);
            path += query;
            return path;
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @param   View results
         * @param   Boolean locked
         * @return  Array
         */
        getThumbClasses: function(results, locked) {
            var classes = ['thumb', 'lazy', 'icon'];
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            if (results.category() === true) {
                var category = results.getCategory();
                if (this.pinned(category) === true) {
                    classes.push('pin');
                }
            }
            if (locked === true) {
                classes.push('locked');
            }
            if (this.showDesignerIcons(results) === true) {
                classes.push('designerIconsAvailable');
            }
            if (this.showSetIcon(results) === true) {
                classes.push('partOfIconSet');
            }
            return classes;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var src = this.url('thumb');
            return src;
        },

        /**
         * showDesignerIcons
         * 
         * @access  public
         * @param   View results
         * @return  Boolean
         */
        showDesignerIcons: function(results) {
            if (results.category() === false) {
                var query = results.getQuery();
                if (query.indexOf('designer:') !== -1) {
                    return false;
                }
            }
            var uploader = this.get('uploader');
            if (DataUtils.valid(uploader) === false) {
                return false;
            }
            if (DataUtils.valid(uploader.username) === true) {
                return true;
            }
            return false;
        },

        /**
         * showSetIcon
         * 
         * @access  public
         * @param   View results
         * @return  Boolean
         */
        showSetIcon: function(results) {
            if (results.category() === false) {
                var query = results.getQuery(),
                    vectorSetNames = Config.get('vectorSetNames');
                if (ArrayUtils.contains(query, vectorSetNames) === true) {
                    return false;
                }
                if (query.indexOf('set:') !== -1) {
                    return false;
                }
            }
            var collections = this.get('collections');
            if (DataUtils.valid(collections) === false) {
                return false;
            }
            if (DataUtils.valid(collections.length) === false) {
                return false;
            }
            if (collections.length > 0) {
                return true;
            }
            return false;
        }
    });
});
window.DependencyLoader.push(['MediaAccessor', 'ImageModel'], function() {

    /**
     * ImageAccessor
     * 
     * @fires   download
     *          normalize
     *          preload
     *          select
     *          favorite
     *          template
     *          unfavorite
     *          upload/abort
     *          upload/error
     *          upload/progress
     *          upload/success
     * @extends MediaAccessor
     */
    window.ImageAccessor = MediaAccessor.extend({

        /**
         * _imageDocument
         * 
         * @access  protected
         * @var     ImageDocument (default: false)
         */
        _imageDocument: false,

        /**
         * _lastSavedConfigurationString
         * 
         * Reference to the last JSON string that was saved for this image. Used
         * to prevent PATCH calls on an image when it's underlying JSON hasn't
         * changed.
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedConfigurationString: '',

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Image'),

        /**
         * _saveConfigurationTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveConfigurationTimeout: null,

        /**
         * _srcs
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _srcs: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageAccessor')
         */
        _string: 'ImageAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.set({
                'resourceGatewaySave': '0'
            });
            this._addTrackListeners();
            this._setupSourceImage();
            this.markConfigurationAsSaved();
            this._addListeners();
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addPreloadListener();
            this._addSettingsChangeListener();
            this._addSelectListener();
            if (this._data.uploaded.toInt() === 1) {
                this.set({
                    'preloaded': 1
                });
            }
        },

        /**
         * _addPreloadListener
         * 
         * @access  protected
         * @return  void
         */
        _addPreloadListener: function() {
            this.on({
                'preload': function(event) {
                    this.set({
                        'preloaded': 1
                    });
                }
            });
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, method, locked, options) {
                    this._select(method, locked, options);
                }
            });
        },

        /**
         * _addSettingsChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addSettingsChangeListener: function() {
            this.on({
                'change/settings.locked': function(event, value) {
                    var $lock = App.getStage().getContent().find('div.sandbox a.lock');
                    $lock.addClass('hidden');
                    if (value.toInt() === 1) {
                        $lock.removeClass('hidden');
                    }
                }
            });
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Image deleted', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'download': function(event) {
                    Track.event('Image downloaded', {
                        _url: this.url('original')
                    });
                },
                'feature': function(event) {
                    Track.event('Image featured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Image unfeatured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                }
            });
        },

        /**
         * _confirmImageChange
         * 
         * @access  protected
         * @return  ConfirmModalView
         */
        _confirmImageChange: function() {
            var h1 = 'This will swap out all your images and text.',
                h2 = 'Are you sure?',
                modal = ModalUtils.showConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * _download
         * 
         * This internal method is as complicated as it is because in Safari,
         * triggering a location change kills any running ajax calls. So I wait
         * for all active remote connections to finish before triggering the
         * location change.
         * 
         * After that, I check for a cookie (set on the server side which
         * communicates to the front end that the image download has begun), to
         * hide the busy modal.
         * 
         * Note that it be worthwhile flow for Safari, since it is the only
         * outlier.
         * 
         * @access  protected
         * @param   false|String contentType
         * @param   false|String filename
         * @param   Boolean scaleForRetina
         * @param   false|Number maxBytes
         * @param   false|String mediaType
         * @return  void
         */
        _download: function(contentType, filename, scaleForRetina, maxBytes, mediaType) {
            var path = this._getDownloadPath(contentType, filename, scaleForRetina, maxBytes, mediaType),
                cookieKey = 'image.download.started',
                _this = this;
            Stencil.once({
                'redirect/complete': function(event) {
                    App.getBusy().hide();
                    _this.triggerHandler('download');
                }
            });
            DownloadUtils.attemptDownload(path, cookieKey);
        },

        /**
         * _getDownloadPath
         * 
         * @access  protected
         * @param   false|String contentType
         * @param   false|String filename
         * @param   Boolean scaleForRetina
         * @param   false|Number maxBytes
         * @param   false|String mediaType
         * @return  String
         */
        _getDownloadPath: function(contentType, filename, scaleForRetina, maxBytes, mediaType) {
            var path = '/images/' + (this._data.key) + '/download',
                params = {};
            if (contentType !== false) {
                if (contentType === 'image/jpeg') {
                    params.contentType = 'image/jpeg';
                } else if (contentType === 'image/png') {
                    params.contentType = 'image/png';
                } else if (contentType === 'application/octet-stream') {
                    params.contentType = 'application/octet-stream';
                }
            }
            if (filename !== false) {
                params.filename = filename;
            }
            if (scaleForRetina === true) {
                params.pushRaw = 1;
            }
            if (maxBytes !== false) {
                params.maxBytes = maxBytes.toInt();
            }
            if (mediaType !== false) {
                params.mediaType = mediaType;
            }
            return (path) + '?' + jQuery.param(params);
        },

        /**
         * _getWatermarkLayers
         * 
         * @access  protected
         * @return  Array
         */
        _getWatermarkLayers: function() {
            var json = this.setting('watermarks');
            if (json === '') {
                return [];
            }
            if (JSONUtils.valid(json) === false) {
                return [];
            }
            var layers = JSON.parse(json).layers;
            if (DataUtils.valid(layers) === false) {
                return [];
            }
            return layers;
        },

        /**
         * _select
         * 
         * @access  protected
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  Boolean
         */
        _select: function(method, locked, options) {

            // Legacy image that needs to be normalized first
            if (
                this._data.legacy.toInt() === 1
                && this._data.legacyNormalized.toInt() === 0
            ) {
                this.normalize();
                return false;
            }

            // Watermark smart toggling for templates
            if (ChangeHistory.persistWatermarksForFeaturedTemplates() === true) {
                Stencil.set('smartToggleWatermarks', true);
                if (this.owned() === false) {
                    Stencil.set('smartToggleWatermarks', false);
                }
            }

            // Draw the image, since nothing is currently being drawn
            var canvas = Canvases.Preview;
            if (canvas.get('drawing') === false) {
                // Footer.disable.save.apply(Footer);
                this._setToPreviewCanvas(method, locked, options);
                return true;
            }

            // Wait for drawing to finish
            var key = 'image.select.pending',
                msg = Config.getMessage(key);
            App.getBusy().show(msg);
            var start = new Date();
            canvas.once({
                'render': function(event, content) {
                    var busy = App.getBusy();
                    busy.hide.minDelay(
                        start,
                        1750,
                        busy
                    );
                }
            });
            return false;
        },

        /**
         * _setSourceImage
         * 
         * @access  protected
         * @param   ImageAccessor sourceImage
         * @return  void
         */
        _setSourceImage: function(sourceImage) {
            this._references.sourceImage = sourceImage;
        },

        /**
         * _setToPreviewCanvas
         * 
         * Method to draw the image represented in the current ImageAccessor to
         * the preview canvas. Does this by deleting any existing layers,
         * setting the account draft to this ImageAccessor (which simply copies
         * over relevant data, such as the frame, width, height, source image
         * id, and json), setting the frame to the new size, and preparing /
         * drawing the canvas.
         * 
         * The check within the render event is intended to check if the image
         * being loaded into the preview canvas is owned by the user (regardless
         * of whether it's a template or image). If it is, I set the image (in
         * the footer, of all places, haha) to ensure that the user can download
         * and P+S, since the image is not yet different.
         * 
         * @access  protected
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        _setToPreviewCanvas: function(method, locked, options) {
            var _this = this,
                account = Stencil.account(),
                draft = account.draft(),
                orphan = account.orphanFrame(),
                frame,
                document,
                imageDocument,
                canvas = Canvases.Preview;
            draft.getImageDocument().deleteAllLayers();
            draft.setToImage(this, method, locked, options);
            App.setSelectedFrame();

            // // Ensure proper draft is set
            // frame = draft.get('frame');
            // frame = Stencil.getAccessor(frame);
            // if (frame === false || frame === orphan) {
            //     frame = orphan;
            //     orphan.set({
            //         width: draft.get('width'),
            //         height: draft.get('height').toInt()
            //     });
            // } else {
            //     if (
            //         frame.get('width').toInt() !== draft.get('width').toInt()
            //         || frame.get('height').toInt() !== draft.get('height').toInt()
            //     ) {
            //         frame = orphan;
            //         orphan.set({
            //             width: draft.get('width'),
            //             height: draft.get('height').toInt()
            //         });
            //     }
            // }
            // frame.select();
            // frame.updateMessaging();

            // Draw
            document = draft.json();
            imageDocument = new ImageDocument(document, draft, canvas);
            draft.setImageDocument(imageDocument);
            canvas.once({
                'render': function(event) {
                    if (_this.owned() === true) {
                        // console.log('owned');

                        /**
                         * The following prevents the same image from being set
                         * in the Footer when it's just a redo or undo operation
                         * being completed.
                         */
                        if (draft !== _this) {
                            Footer.setLastSavedImage(_this);
                        } else {
                            var sourceImage = _this.getSourceImage();
                            if (sourceImage === false) {
                                Footer.setLastSavedImage(false);
                            } else if (sourceImage === undefined) {
                                Footer.setLastSavedImage(false);
                            } else {
                                if (sourceImage.deleted() === false) {
                                    if (sourceImage.owned() === true) {
                                        Footer.setLastSavedImage(sourceImage);
                                    }
                                }
                            }
                        }
                    }

                    /**
                     * Need to call the Footer.reset here because otherwise if
                     * there are layers with filters on them, it's possible that
                     * the Footer will show the wrong button-states.
                     * 
                     * This happens because the filters can take some time to
                     * run (especially the more complicated ones), and because
                     * of a race-condition whereby the fabric renderAll event is
                     * triggered after we need it to (specically, the fabric
                     * after:render event fires after we need it to), this bug
                     * exists.
                     */
                    Footer.reset();
                    _this.triggerHandler('set/previewCanvas/finish');
                }
            });

            /**
             * Same goes here: I'm only showing the busy modal over top of the
             * preview canvas if it's not the draft itself that's being set,
             * which if it is, it's just a redo or undo operation being
             * completed.
             */
            var showBusyModal = true;
            if (draft === this) {
                showBusyModal = false;
            }
            canvas.draw(showBusyModal);
            draft.setConfiguration();
        },

        /**
         * _setupSourceImage
         * 
         * The first check against the property being undefined is because when
         * an image-record's public data is retrieved, no sourceImage property
         * is passed down unless it's a deep-public-data retrieval.
         * 
         * In the case that it is, it's possible that there is no sourceImage
         * (for example, legacy images). For those, false is passed down, thus
         * the second check.
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupSourceImage: function() {
            if (this._data.sourceImage === undefined) {
                return false;
            }
            if (this._data.sourceImage === false) {
                return false;
            }
            var model = Stencil.getModel('Image'),
                sourceImage = this._data.sourceImage;
            this._references.sourceImage = model.setAccessor(sourceImage);
            return true;
        },

        /**
         * _syncedToAnyCategory
         * 
         * @access  protected
         * @return  Boolean
         */
        _syncedToAnyCategory: function() {
            var categories = CategoryUtils.account.all({
                    images: 1
                }),
                index;
            for (index in categories) {
                if (this._syncedToCategory(categories[index]) === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _syncedToCategory
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        _syncedToCategory: function(category) {
            return category.syncedFeatures.contains.apply(category, [this]) === true;
        },

        /**
         * _syncedToListCategory
         * 
         * @access  protected
         * @return  Boolean
         */
        _syncedToListCategory: function() {
            var category = CategoryUtils.account.list('images');
            return this._syncedToCategory(category);
        },

        /**
         * clearSaveConfigurationTimeout
         * 
         * @access  public
         * @return  void
         */
        clearSaveConfigurationTimeout: function() {
            TimeoutPool.clear(this._saveConfigurationTimeout);
        },

        /**
         * containsWatermark
         * 
         * @access  public
         * @param   WatermarkAccessor watermark
         * @return  Boolean
         */
        containsWatermark: function(watermark) {
            var layer = this.getDocumentWatermark(watermark),
                containsWatermark = layer !== null;
            return containsWatermark;
        },

        /**
         * delete
         * 
         * @access  public
         * @param   Boolean autoHideBusyModal (default: true) Used to prevent
         *          busy modal from hiding when called by through multi-delete
         *          flow
         * @return  void
         */
        delete: function(autoHideBusyModal) {
            autoHideBusyModal = DataUtils.getDefaultValue(
                autoHideBusyModal,
                true
            );
            if (this._data.uploaded.toInt() === 1) {
                if (autoHideBusyModal === true) {
                    App.getBusy().hide();
                }
                if (Stencil.account().draft().getSourceImage() === this) {
                    var previousSourceImageId = Stencil.account().draft().get('sourceImageId').toInt();
                    Stencil.account().draft().removeSourceImage();
                    Footer.setLastSavedImage(false);
                    Footer.reset();
                    ChangeHistory.syncSourceImageId(previousSourceImageId, 0);
                }
                this._super();
            } else {
                var msg = Config.getMessage('image.delete.pending');
                App.getBusy().show(msg);
                this.once({
                    'model/feature': this.delete.proxy(this)
                });
            }
        },

        /**
         * download
         * 
         * @todo    Look into whether this may be a problem for popup blockers.
         *          If so, for those browsers, show messaging in the busy modal
         *          that we're saving the image, and once complete, show an
         *          alert prompting them to try downloading again.
         * @access  public
         * @param   false|String contentType
         * @param   false|String filename
         * @param   Boolean scaleForRetina
         * @param   false|Number maxBytes
         * @param   false|String mediaType
         * @param   Boolean showBusyModal
         * @return  void
         */
        download: function(contentType, filename, scaleForRetina, maxBytes, mediaType, showBusyModal) {
            if (Account.delinquent() === true) {
                Stencil.navigate('/app/delinquent?clean=1');
            } else if (User.frozen() === true) {
                Stencil.alert('user.settings.frozen');
                Stencil.kill();
            } else {
                if (this._data.uploaded.toInt() === 1) {
                    if (showBusyModal === true) {
                        var msg = Config.getMessage('image.download.pending.direct');
                        App.getBusy().show(msg);
                    }
                    this._download.apply(this, [
                        contentType,
                        filename,
                        scaleForRetina,
                        maxBytes,
                        mediaType
                    ]);
                } else {
                    if (showBusyModal === true) {
                        var msg = Config.getMessage('image.download.pending');
                        App.getBusy().show(msg);
                    }
                    this.once({
                        'change/uploaded': this._download.proxy(
                            this,
                            [contentType, filename, scaleForRetina, maxBytes, mediaType]
                        )
                    });
                }
            }
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = CategoryUtils.account.favorites('images');
            this.feature(category, performDataRequest);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('images').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelFeatureCall = function() {
                    this._model.feature(
                        this._data.key,
                        {
                            category: category.get('key')
                        },
                        (function(data) {
                            this.triggerHandler('feature/complete');
                        }).proxy(this)
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelFeatureCall.apply(this);
                } else {
                    this.once({
                        'update/uploaded': function(event) {
                            modelFeatureCall.apply(this);
                        }
                    });
                }
            }
            this.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * generateShortUrl
         * 
         * @access  public
         * @return  void
         */
        generateShortUrl: function() {
            if (this._data.uploaded.toInt() === 1) {
                this._model.generateShortUrl(this._data.key);
            } else {
                this.once({
                    'update/uploaded': this.generateShortUrl.proxy(this)
                });
            }
        },

        /**
         * getConfiguration
         * 
         * Returns the unique "recipe" for this image, including the frame (if
         * any, otherwise an empty string), the width and height (traditionally
         * set through a Frame, but now set explictly if the Frame has since
         * been deleted or else does not exist) and the settings, including the
         * json (which defines the layout of all the layers) and watermarks
         * (which helps determine whether the image is unique relative to other
         * watermarks being turned on and off).
         * 
         * @access  public
         * @return  Object
         */
        getConfiguration: function() {
            // var json = this._imageDocument.json(false),
            //     watermarks = this._imageDocument.getWatermarkLayersJson(),
            var configuration = {
                frame: this._data.frame,
                width: this._data.width.toInt(),
                height: this._data.height.toInt(),
                sourceImageId: 0,
                settings: {
                    json: this.setting('json'),
                    watermarks: this.setting('watermarks')
                }
            };
            if (this._imageDocument !== false) {
                var imageDocument = this._imageDocument;
            // if (this === Stencil.account().draft()) {
                configuration.settings = {
                    json: JSON.stringify(imageDocument.json(false)),
                    watermarks: JSON.stringify(
                        imageDocument.getWatermarkLayersJson()
                    )
                };
                if (this._imageDocument.getCanvas() === Canvases.Preview) {
                    configuration.frame = Frame.get('key');
                }
            }
            if (
                this.getSourceImage() !== undefined
                && this.getSourceImage() !== false
            ) {
                configuration.sourceImageId = this.getSourceImage().get('id').toInt();
            }
            return configuration;
        },

        /**
         * getDefaultFilename
         * 
         * @access  public
         * @return  String
         */
        getDefaultFilename: function() {
            var contentType = this.getRecommendedExportContentType(),
                extension = 'png';
            if (contentType === 'image/jpeg') {
                extension = 'jpg';
            }
            if (Frame.get('key') === 'frm-orphan') {
                return 'stencil.' + (extension);
            }
            if (Frame.get('key').match(/frm0/) !== null) {
                var frame = Stencil.getAccessor(Frame.get('key'));
                if (frame === false) {
                    return 'stencil.' + (extension);
                }
                if (frame.get('label').trim() === '') {
                    return 'stencil.' + (extension);
                }
                return 'stencil.' + StringUtils.slugify(frame.get('label'), 48) + '.' + (extension);
            }
            var frames = Frames.all(),
                frame;
            for (var index in frames) {
                frame = frames[index];
                if (Frame.get('key') === frame.key) {
                    return 'stencil.' + StringUtils.slugify(Frame.get('label'), 48) + '.' + (extension);
                }
            }
            return 'stencil.' + (extension);
        },

        /**
         * getDocumentWatermark
         * 
         * @access  public
         * @param   WatermarkAccessor watermark
         * @return  Object|null
         */
        getDocumentWatermark: function(watermark) {
            var layers = this._getWatermarkLayers(),
                index,
                layer,
                key = watermark.get('key');
            for (index in layers) {
                layer = layers[index];
                if (layer.image === key) {
                    return layer;
                }
            }
            return null;
        },

        /**
         * getImageDocument
         * 
         * @access  public
         * @return  ImageDocument
         */
        getImageDocument: function() {
            return this._imageDocument;
        },

        /**
         * getRecommendedExportContentType
         * 
         * @todo    The first check below against the background bitmap image
         *          layer ought to check filters to see if there is an opacity
         *          filter set, and if so, return image/png. The reason it
         *          doesn't matter at the moment is because the opacity filter
         *          doesn't act as it should, since the background rectangle is
         *          set to white, which negates any useful opacity.
         * @access  public
         * @return  String
         */
        getRecommendedExportContentType: function() {

            // Content type already defined (previously uploaded)
            // if (this._data.contentType !== '') {
            //     return this._data.contentType;
            // }

            // Background image set
            var backgroundBitmapImageLayer = Canvases.Preview.getBackgroundBitmapImageLayer();
            if (backgroundBitmapImageLayer.getProperty('image') !== false) {
                return 'image/jpeg';
            }

            // Background rectangle has transparency
            var backgroundRectangleLayer = Canvases.Preview.getBackgroundRectangleLayer();
            if (backgroundRectangleLayer.hasTransparency() === true) {
                return 'image/png';
            }

            // Solid color background + foreground bitmap image layers
            var foregroundBitmapImageLayers = Canvases.Preview.getForegroundBitmapImageLayers();
            if (foregroundBitmapImageLayers.length > 0) {
                return 'image/jpeg';
            }

            // Solid color background + watermark bitmap image layers
            var watermarkBitmapImageLayers = Canvases.Preview.getWatermarkBitmapLayers();
            if (watermarkBitmapImageLayers.length > 0) {
                return 'image/jpeg';
            }

            // Otherwise, basic image (including vectors which are basic)
            return 'image/png';
        },

        /**
         * getSentPath
         * 
         * @access  public
         * @return  String
         */
        getSentPath: function() {
            var path = '/app/images/';
            path += this._data.key;
            path += '/sent?clean=1';
            return path;
        },

        /**
         * getSharePath
         * 
         * @access  public
         * @param   String network
         * @return  String
         */
        getSharePath: function(network) {
            var path = '/app/images/';
            path += this._data.key;
            path += '/share/' + (network);
            return path;
        },

        /**
         * getSnippet
         * 
         * I am checking if it is a legacy image here because I want to prevent
         * looping over the json-setting for them. This is simply because most
         * of the time for legacy images, the json-setting will not have been
         * normalized at the start.
         * 
         * In this case, I still return the placeholder text below, because if
         * I do not, Buffer fails to pull in the image itself.
         * 
         * @access  public
         * @param   Number|false limit
         * @return  Object
         */
        getSnippet: function(limit) {
            if (this._data.legacy.toInt() === 1) {
                return {
                    default: true,
                    snippet: 'Enter your own message here'
                };
            }
            if (JSONUtils.valid(this._data.settings.json) === true) {
                var layers = JSON.parse(this._data.settings.json).layers,
                    text = [];
                jQuery.each(layers, function(index, layer) {
                    if (layer.type === 'text') {
                        text.push(layer.text.trim());
                    }
                });
                if (text.length === 0) {
                    return {
                        default: true,
                        snippet: 'Enter your own message here'
                    };
                }

                // Limit check
                if (limit === false) {
                    return {
                        default: false,
                        snippet: text.join(' / ')
                    };
                }
                text = text.join(' / ');
                if (text.length > limit) {
                    return {
                        default: false,
                        snippet: text.substring(0, limit - 3) + '...'
                    };
                }
                return {
                    default: false,
                    snippet: text
                };
            }
            LogUtils.log.simple('JSON parse error (I:gS)', true);
            return {
                default: true,
                snippet: 'Enter your own message here'
            };
        },

        /**
         * getSourceImage
         * 
         * @access  public
         * @return  ImageAccessor|undefined
         */
        getSourceImage: function() {
            return this._references.sourceImage;
        },

        /**
         * getSrc
         * 
         * Function intended to be used with views to output some image, even if
         * it's not yet fully uploaded to S3.
         * 
         * Returns the raw canvas data if the image hasn't yet finished
         * uploading. If it has, it checks to see if a width is defined. If none
         * is defined (eg. cases with legacy saved images), a url with a scaled
         * width of 800 pixels is returned. Or else, a url with the proper
         * scaled width is returned.
         * 
         * @see     https://stackoverflow.com/questions/23481210/resize-the-canvas-output-image-to-a-specific-size-width-height
         * @note    For these updates to work, have to test retina/non-retina in
         *          multiple browsers to ensure webp support, and detect proper
         *          default type (png/jpeg) for optimization.
         *          Also, ideal to cache the data so that Preview+Share isn't
         *          executing multiple toDataURL calls.
         * @access  public
         * @param   undefined|Object options (default: {})
         * @return  String
         */
        getSrc: function(options) {
            options = DataUtils.getDefaultValue(options, {});
            if (
                this._data.uploaded.toInt() === 0
                || this.preloaded() === false
            ) {
                var srcs = this.get('srcs') || {},
                    key = JSON.stringify(options),
                    contentType = this.getRecommendedExportContentType(),
                    dataURL;
                if (srcs[key] !== undefined) {
                    return srcs[key];
                }
                if (Modernizr.webp !== false) {
                    contentType = 'image/webp';
                }
                var canvas = Canvases.Preview.getElement()[0];
                if (options.clip === true) {
                    dataURL = CanvasElementUtils.centerAndClip(
                        canvas,
                        options.dimensions.width,
                        options.dimensions.height
                    ).toDataURL(contentType);
                } else {
                    dataURL = canvas.toDataURL(contentType);
                }
                srcs[key] = dataURL;
                this.set('srcs', srcs);
                return dataURL;
            }
            var width = this._data.width.toInt();
            if (width === 0) {
                return this.url('scale', {
                    width: 800
                });
            }
            return this.url('scale', {
                width: width
            });
        },

        /**
         * getTheNounProjectIcons
         * 
         * @access  public
         * @return  Array
         */
        getTheNounProjectIcons: function() {
            var layers = this._imageDocument.getTheNounProjectVectorImageLayers(),
                icons = [],
                index;
            for (index in layers) {
                icons.push(layers[index].getProperty('image'));
            }
            return icons;
        },

        /**
         * getThumbBackgroundImageStyle
         * 
         * @access  public
         * @return  String
         */
        getThumbBackgroundImageStyle: function() {
            var backgroundImageStyle = 'none';
            if (this.get('uploaded').toInt() === 0) {
                var dimensions = ImageUtils.getThumbDimensions(),
                    src = this.getSrc({
                        clip: true,
                        dimensions: {
                            height: dimensions.height,
                            width: dimensions.width
                        }
                    });
                backgroundImageStyle = 'url(\'' + (src) + '\')';
            }
            return backgroundImageStyle;
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @return  Array
         */
        getThumbClasses: function() {
            var classes = ['thumb', 'lazy'];
            if (this.get('uploaded').toInt() === 0) {
                classes = ['thumb', 'loaded'];
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            return classes;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var src = this.url('thumb');
            if (this.get('uploaded').toInt() === 0) {
                src = '';
            }
            return src;
        },

        /**
         * isLocked
         * 
         * @access  public
         * @return  Boolean
         */
        isLocked: function() {
            return this._data.settings.locked.toInt() === 1;
        },

        /**
         * isVerifoneFrame
         * 
         * @access  public
         * @return  Boolean
         */
        isVerifoneFrame: function() {
            var frameKey = this._data.frame,
                verifoneFrameKeys = [
                    'frm-partner.verifone-carbon8',
                    'frm-partner.verifone-vx'
                ];
            return ArrayUtils.contains(frameKey, verifoneFrameKeys) === true;
        },

        /**
         * json
         * 
         * Returns a default canvas JSON object (based on guest/user status), or
         * else the JSON object for the image object if it's <json> value is not
         * an empty string.
         * 
         * @access  public
         * @return  Object
         */
        json: function() {
            if (this._data.settings.json === '') {
                if (User.exists() === false) {
                    return Config.default('canvases').guest;
                }
                return Config.default('canvases').user;
            }
            if (JSONUtils.valid(this._data.settings.json) === false) {
                this._data.settings.json = '';
                return this.json();
            }
            var parsed = JSON.parse(this._data.settings.json);
            if (parsed.layers === undefined) {
                this._data.settings.json = '';
                return this.json();
            }
            if (parsed.layers.length === 0) {
                this._data.settings.json = '';
                return this.json();
            }
            return parsed;
        },

        /**
         * loadDependentFonts
         * 
         * Loads any fonts that are dependents of this image. The reason they
         * might not already be loaded is because they might have been deleted
         * by the user, or else they were used in a featured template.
         * 
         * It's important that I set the hasRegularAccess property to 0 so that
         * the rest of the font flow knows that this font is not traditionally
         * accessible by the account.
         * 
         * Also, I set the label to the parsedFamilyName property, incase the
         * user who originally uploaded or imported the font changed it's name
         * at one point. It makes more sense to use whatever was parsed at the
         * time of conversion / upload / importing, rather than whatever they
         * might have changed it to.
         * 
         * @access  public
         * @return  void
         */
        loadDependentFonts: function() {
            var fontObjects = this._data.fonts,
                index, fontObject,
                collection = Stencil.account().collection('fonts'),
                model = Stencil.getModel('Font'),
                accessors;
            for (index in fontObjects) {
                fontObject = fontObjects[index];
                if (collection.find(fontObject.key) !== false) {
                    continue;
                }
                fontObject.hasRegularAccess = 0;
                fontObject.label = fontObject.parsedFamilyName;
                accessors = collection.map([fontObject]);
                Toolbars.getToolbar('text').getFontsDropdown().addFont(accessors[0], true);
            }
        },

        /**
         * markAsUploaded
         * 
         * @access  public
         * @return  void
         */
        // markAsUploaded: function() {
        //     this._model.markAsUploaded(this._data.key);
        // },

        /**
         * markConfigurationAsSaved
         * 
         * Calling this method converts the configuration for the image to json,
         * and stores it locally. The intention of calling this method should be
         * to prevent any future PATCH calls against the record from being
         * triggered by setting the last-saved configuration local varaible to
         * exactly what is set for the image.
         * 
         * @access  public
         * @return  void
         */
        markConfigurationAsSaved: function() {
            var configuration = this.getConfiguration();
            this._lastSavedConfigurationString = JSON.stringify(configuration);
        },

        /**
         * normalize
         * 
         * @access  public
         * @return  void
         */
        normalize: function() {
//             Stencil.alert('import.normalize.disabled');
// return;
            var key = this._data.key,
                path = '/app/images/' + (key) + '/normalize?clean',
                json = this.setting('json'),
                normalized = Normalizer.image(json);
            Stencil.navigate(path);
            this.set('settings.json', normalized);
            this._model.normalize(key);
        },

        /**
         * owned
         * 
         * Checks whether the logged in account owns the image, which is used in
         * determining whether a saved-draft should have the save button enabled
         * upon app-init. This is because it's possible for a user to load a
         * template, but not save or interact with it. In that case, the save
         * button should be available to the user.
         * 
         * @access  public
         * @return  Boolean
         */
        owned: function() {
            return this._data.accountId.toInt() === Stencil.account().get('id').toInt();
        },

        /**
         * preload
         * 
         * Contains preloading logic for images that either don't have their
         * width defined (eg. legacy images), or else do, and should have the
         * exact scaled-width version preloaded.
         * 
         * @access  public
         * @param   undefined|Function success (default: function(references) {})
         * @param   undefined|Function error (default: function(reference) {})
         * @return  void
         */
        preload: function(success, error) {
            success = DataUtils.getDefaultValue(success, function(references) {});
            error = DataUtils.getDefaultValue(error, function(reference) {});
            var url = this.url('thumb'),
                urls = [url];

            // Scaled version
            var width = 800;
            if (this._data.width.toInt() !== 0) {
                width = this._data.width.toInt();
            }
            url = this.url('scale', {
                width: width
            });
            urls.push(url);

            // Function context scoping and calls
            ImageUtils.load.urls(urls, false, success.proxy(this), error.proxy(this));
            this.loadCropperDependencies();
        },

        /**
         * preloaded
         * 
         * @access  public
         * @return  Boolean
         */
        preloaded: function() {
            if (this._data.preloaded === undefined) {
                return false;
            }
            return this._data.preloaded.toInt() === 1;
        },

        /**
         * removeSourceImage
         * 
         * @access  public
         * @return  void
         */
        removeSourceImage: function() {
            this.push('sourceImageId', 0);
            // delete this._data.sourceImageId;
            delete this._references.sourceImage;
        },

        /**
         * saveConfiguration
         * 
         * Note that the deleted check here is because if the image has been
         * deleted in the database, any PATCH calls against it will naturally
         * fail. Not sure at the moment how or when this might happen, but
         * likely can't hurt.
         * 
         * Just (2017-08-03) thought of how this could happen. A user adds a
         * vector resource (not asset) to the canvas, and save action happens.
         * Because it's a vector, we don't need to wait for a high resolution
         * asset to be loaded (eg. for bitmaps), so we can create the image
         * right away. If the user then deletes the image, before the vector
         * resource has been properly imported via the /api/resource:id/save
         * call, and then the request comes back, a this.saveConfiguration call
         * would be made (since the image property for the layer would have been
         * changed). So.. good call, previous-Oliver ;-)
         * 
         * @access  public
         * @return  void
         */
        saveConfiguration: function() {
            if (this.deleted() === false) {
                var configuration = this.getConfiguration(),
                    configurationString = JSON.stringify(configuration);
                if (
                    configurationString !== this._lastSavedConfigurationString
                ) {
                    var columns = [
                        'frame',
                        'resourceGatewaySave',
                        'sourceImageId',
                        'width',
                        'height',
                        'settings.json',
                        'settings.watermarks'
                    ];
                    this.save(columns, {
                        error: function(response) {
                            var error = Stencil.extractError(response);
                            if (error.validator[1] === 'notUploaded') {
                                Stencil.alert('image.uploaded.already');
                                Stencil.kill();
                                return false;
                            }
                            if (error.validator[1] === 'validRecordByKey') {
                                Stencil.alert('image.uploaded.deleted');
                                Stencil.kill();
                                return false;
                            }
                            return true;
                        }
                    });
                    this.set({
                        'resourceGatewaySave': '0'
                    });
                    this.markConfigurationAsSaved();
                }
            }
        },

        /**
         * select
         * 
         * @note    There is an exception whereby if the image (or template)
         *          being selected is a legacy image that has not yet been
         *          normalized, the user first see's the LegacyImageNormalize
         *          modal. After confirming the modal, the image is then
         *          loaded into the canvas. Unfortunately, the four params are
         *          lost in this process (because they're not being sent along
         *          to the LegacyImageNormalize modal, partially because the
         *          flow for this is a bit cumbersome, including a controller
         *          action and Router route). See LegacyImageNormalize.js to see
         *          the default values being passed into this method in that
         *          case.
         * @access  public
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        select: function(method, locked, options) {
            ChangeHistory.setOperationType('image // loaded');
            this.loadDependentFonts();
            this._super(method, locked, options);
        },

        /**
         * setConfiguration
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the configuration associated with the image. A delay is set here to
         * prevent too-many PATCH calls against the record, since this method is
         * called frequently.
         * 
         * This method is also responsible for registering objects within the
         * change history architecture. The delay value for how often objects
         * are registered there is different than the saveDelay used to prevent
         * excessive PATCH calls.
         * 
         * @access  public
         * @return  void
         */
        setConfiguration: function() {
            var configuration = this.getConfiguration(),
                delay = Config.getSaveDelay('image');
            this.set({
                'frame': configuration.frame,
                'sourceImageId': configuration.sourceImageId.toInt(),
                'width': configuration.width.toInt(),
                'height': configuration.height.toInt(),
                'settings.json': configuration.settings.json,
                'settings.watermarks': configuration.settings.watermarks
            });
            this.clearSaveConfigurationTimeout();
            this._saveConfigurationTimeout = this.saveConfiguration.delay(
                delay,
                this
            );
        },

        /**
         * setImageDocument
         * 
         * @access  public
         * @param   ImageDocument imageDocument
         * @return  void
         */
        setImageDocument: function(imageDocument) {
            this._imageDocument = imageDocument;
        },

        /**
         * setToImage
         * 
         * Swaps out the frame and settings.json values, and triggers a sync to
         * ensure that after the delay, a call is made to save the image.
         * 
         * @access  public
         * @param   ImageAccessor image
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        setToImage: function(image, method, locked, options) {

            /**
             * Precaution for redo / undo
             * 
             * Only set the source image if the image being set and the current
             * one are not the same.
             * 
             * @todo!!! Maybe the property should just be exempted, rather than
             *          set to 0? Seems a bit funky to set this to 0...
             */
            var sourceImageId = this.get('id').toInt();
            if (method === 'redo' || method === 'undo') {
                sourceImageId = image.get('sourceImageId').toInt();
            }

            // 
            this.set({
                'frame': image.get('frame'),
                'width': image.get('width').toInt(),
                'height': image.get('height').toInt(),
                'sourceImageId': sourceImageId.toInt(),
                'settings.json': image.setting('json'),
                'settings.watermarks': image.setting('watermarks')
            });

            /**
             * Precaution for redo / undo
             * 
             * Only set the source image if the image that being set is _not_
             * the same one, since redo / undo functionality uses this approach.
             * When the source image is set to itself, it causes issues with
             * the Footer view, since it thinks an image is available to be
             * downloaded (since that's determined by checking the source
             * image).
             */
            if (method === 'redo' || method === 'undo') {
                this._setSourceImage(image.getSourceImage());
            } else {
                this._setSourceImage(image);
            }
            // this.set({
            //     'settings.json': image.setting('json'),
            //     'frame': Frame.get('key')
            // });
            // this.save(['frame', 'settings.json']);
        },

        /**
         * share
         * 
         * Redirects the user to the share page / experience, based on the user
         * account's shareNetwork setting, which tracks the last network they
         * tried sharing to.
         * 
         * The exception here is that if the frame for the image is a Verifone
         * frame _always_ go to that tab. If it's not, but the Verifone tab was
         * the one last selected, default back to Facebook.
         * 
         * @access  public
         * @return  void
         */
        share: function() {
            if (Account.delinquent() === true) {
                Stencil.navigate('/app/delinquent?clean=1');
            } else if (User.frozen() === true) {
                Stencil.alert('user.settings.frozen');
                Stencil.kill();
            } else {
                var network = Stencil.account().userAccount().setting(
                        'shareNetwork'
                    ),
                    path = this.getSharePath(network);
                if (this.isVerifoneFrame() === true) {
                    path = this.getSharePath('verifone');
                }
                Stencil.navigate(path);
                // this.triggerHandler('share');
            }
        },

        /**
         * template
         * 
         * @note    Notice how I'm removing the template and then re-adding right
         *          after the data has been swapped. This is to ensure the
         *          correct key is being stored (since before it's a temporary
         *          key, and after it's the permanent one).
         * @access  public
         * @return  void
         */
        template: function() {
            var category = CategoryUtils.account.list('templates'),
                key = category.get('key'),
                collection = App.getEditor().getArea('templates').getChild('categories').getChild(key).getCollection(),
                templates = collection.map({
                    class: 'template',
                    key: 'ctgX' + DataUtils.getRandomString(8).toLowerCase(),
                    image: this._data
                }, false);
            category.features.add.apply(category, [templates[0]]);
            this._model.template(this._data.key, function(data) {
                category.features.remove.apply(category, [templates[0]]);
                templates[0].swap(data.object);
                category.features.add.apply(category, [templates[0]]);
            });
            this.triggerHandler('template');
            this.once({
                'update/uploaded': function(event) {
                    var category = CategoryUtils.account.list('templates');
                    templates[0].getModel().feature(
                        templates[0].get('key'),
                        {
                            category: category.get('key')
                        }
                    );
                }
            });
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = CategoryUtils.account.favorites('images');
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('images').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelUnfeatureCall = function() {
                    this._model.unfeature(
                        this._data.key,
                        {
                            category: category.get('key')
                        }
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelUnfeatureCall.apply(this);
                } else {
                    this.once({
                        'update/uploaded': function(event) {
                            modelUnfeatureCall.apply(this);
                        }
                    });
                }
            }
            this.triggerHandler('unfeature', [category]);
            features.remove(this);
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with Buffer + Pinterest sharing
         * - Scaled image url, used in Share modal to show a maximum resolution
         *   image (since the full dimension is a waste of bandwidth)
         * - Thumb image url, used in images and templates tab
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options
         * @return  String|false
         */
        url: function(type, options) {
            var key, proxy = 'stencil';
            if (type === 'original') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'shareAsImage';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                var url = ImageUtils.url.thumb(key, {
                    proxy: proxy,
                    type: 'original'
                });
                return url;
            }
            if (type === 'scale') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'shareAsImage';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                var url = ImageUtils.url.thumb(key, {
                    proxy: proxy,
                    type: 'scale',
                    width: options.width
                });
                return url;
            }
            if (type === 'thumb') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'shareAsImage';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                var url = ImageUtils.url.thumb(key, {
                    proxy: proxy,
                    type: 'thumb'
                });
                return url;
            }
            return false;
        }
    });
});
window.DependencyLoader.push(['Accessor'], function() {

    /**
     * MediaAccessor
     * 
     * @events  boundingBox/request/complete
     *          boundingBox/request/error
     *          boundingBox/request/success
     *          boundingBox/request/success/false
     *          boundingBox/request/success/true
     *          select
     * @extends Accessor
     */
    window.MediaAccessor = Accessor.extend({

        /**
         * _boundingBox
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _boundingBox: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'MediaAccessor')
         */
        _string: 'MediaAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @note    Defaults to auto selecting the drawing
         * @note    Defaults to auto animating the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (default: {})
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(locked, options) {
            options = DataUtils.getDefaultValue(options, {});
            var key = options.key || this._data.key,
                canvas = Canvases.Preview,
                layer = canvas.addForegroundBitmapImageLayer({
                    image: key,
                    cropPositionData: options.cropPositionData || {},
                    cropSourceKey: options.cropSourceKey || ''
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    if (options.autoSelect !== false) {
                        this.select();
                    }
                    if (options.animate !== false) {
                        drawing.animate();
                    }
                }
            });
            drawing.draw();
            return layer;
        },

        /**
         * getCropBoxPositionData
         * 
         * @access  public
         * @return  Object
         */
        getCropBoxPositionData: function() {
            var defaultCropBoxPositionData = {
                aspectRatio: 1.5,
                locked: 0,
                shape: 'rectangle',
                styles: {
                    radius: '0'
                }
            };
            if (this._data.settings === undefined) {
                return defaultCropBoxPositionData;
            }
            if (this._data.settings.crop === undefined) {
                return defaultCropBoxPositionData;
            }
            if (this.setting('crop').toInt() === 0) {
                return defaultCropBoxPositionData;
            }
            var cropPositionData = this.setting('cropPositionData');
            cropPositionData = JSON.parse(cropPositionData);
            cropPositionData.aspectRatio = (cropPositionData.width / cropPositionData.height).round(4);
            cropPositionData.locked = (cropPositionData.aspectRatio === 1) ? 1 : 0;
            if (cropPositionData.locked === 0) {
                cropPositionData.locked = (cropPositionData.shape === 'mask' ? 1 : 0);
            }
            return cropPositionData;
        },

        /**
         * getFrameUrl
         * 
         * Returns the frame-specific url. Used in preloading so that when an
         * image is uploaded, it'll be available as soon as it's been processed.
         * Not perfect, since the getFrameUrl method in Images assumes a lot.
         * See that class / function for more documentation.
         * 
         * @access  public
         * @param   CanvasView canvas
         * @return  String
         */
        getFrameUrl: function(canvas) {
            var key = this._data.key,
                url = ImageUtils.getFrameUrl(key, canvas);
            return url;
        },

        /**
         * getResolution
         * 
         * @access  public
         * @return  null|Number
         */
        getResolution: function() {
            var width = this._data.width,
                height = this._data.width;
            if (DataUtils.valid(width) === false) {
                return null;
            }
            if (DataUtils.valid(height) === false) {
                return null;
            }
            if (width.toInt() === 0) {
                return null;
            }
            if (height.toInt() === 0) {
                return null;
            }
            var resolution = width.toInt() * height.toInt();
            return resolution;
        },

        /**
         * loadCropperDependencies
         * 
         * @access  public
         * @return  Boolean
         */
        loadCropperDependencies: function() {
            this.loadCropperImage();
            this.requestBoundingBox();
            return true;
        },

        /**
         * loadCropperImage
         * 
         * @access  public
         * @return  ImageRequest
         */
        loadCropperImage: function() {
            var key = this._data.key,
                url = ImageUtils.getCropperImageUrl(key),
                crossOrigin = true,
                imageRequest = new ImageRequest(url, crossOrigin);
            imageRequest.request();
            return imageRequest;
        },

        /**
         * requestBoundingBox
         * 
         * @access  public
         * @return  Boolean
         */
        requestBoundingBox: function() {
            var allowCropperTrimFunctionality = Config.default('allowCropperTrimFunctionality');
            if (allowCropperTrimFunctionality === false) {
                return false;
            }
            var key = this._data.key,
                url = ImageUtils.getCropperBoundingBoxImageUrl(key),
                data = {
                    url: url
                },
                events = {
                    'success/true': function(event, response) {
                        var eventName = 'boundingBox/request/success/true',
                            boundingBox = response.data.boundingBox,
                            args = [boundingBox];
                        _this.triggerHandler(eventName, args);
                    }
                },
                path = '/utils/images/boundingBox',
                signature = {"basename":"Media.js","line":208},
                reflectionEventSet = {
                    'complete': ['boundingBox/request/complete'],
                    'error': ['boundingBox/request/error'],
                    'success': ['boundingBox/request/success'],
                    'success/false': ['boundingBox/request/success/false']
                },
                request = new ServerRequest(),
                _this = this;
            request.setOptions({
                cacheResponse: true,
                data: data,
                events: events,
                logFailedValidation: true,
                path: path,
                reflectionEventContext: this,
                reflectionEventSet: reflectionEventSet,
                signature: signature
            });
            request.get();
            return true;
        },

        /**
         * select
         * 
         * @access  public
         * @param   String method Possible values:
         *          - click
         *          - drop
         *          - undo
         *          - redo
         * @param   Boolean locked Used to lock certain assets for free users
         * @param   Object options Used to pass along x/y coordinates for a drag
         *          and in some cases the destination for a MediaAccessor object
         *          (eg. foreground or background).
         * @return  void
         */
        select: function(method, locked, options) {
            this.triggerHandler(
                'select',
                [method, locked === true, options]
            );
        },

        /**
         * setBackgroundBitmapImageLayer
         * 
         * @note    Defaults to not auto selecting the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (default: {})
         * @return  BackgroundBitmapImageLayer
         */
        setBackgroundBitmapImageLayer: function(locked, options) {
            options = DataUtils.getDefaultValue(options, {});
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundBitmapImageLayer(),
                drawing = layer.getDrawing(),
                key = options.key || this._data.key,
                cropPositionData = options.cropPositionData || {},
                cropSourceKey = options.cropSourceKey || '';
            layer.setChangeOperationType('image:changed');
            layer.setImage(key);
            layer.setProperty('locked', locked);
            layer.setProperty('cropPositionData', cropPositionData);
            layer.setProperty('cropSourceKey', cropSourceKey);
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access  private
                 * @return  void
                 */
                'refresh': function(event) {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                    if (options.autoSelect === true) {
                        this.select();
                    }
                }
            });
            drawing.reload();
            return layer;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'OverrideModel'], function() {

    /**
     * OverrideAccessor
     * 
     * @extends Accessor
     */
    window.OverrideAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Override'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OverrideAccessor')
         */
        _string: 'OverrideAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
});
window.DependencyLoader.push(['AssetAccessor', 'AssetModel'], function() {

    /**
     * PhotoAssetAccessor
     * 
     * @extends AssetAccessor
     */
    window.PhotoAssetAccessor = AssetAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Asset'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoAssetAccessor')
         */
        _string: 'PhotoAssetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @param   View results
         * @param   Boolean locked
         * @return  Array
         */
        getThumbClasses: function(results, locked) {
            var classes = ['thumb', 'lazy', 'asset'];
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            if (results.category() === true) {
                var category = results.getCategory();
                if (this.pinned(category) === true) {
                    classes.push('pin');
                }
            }
            if (locked === true) {
                classes.push('locked');
            }
            return classes;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var src = this.url('thumb');
            return src;
        },

        /**
         * getThumbTooltipAttribute
         * 
         * @access  public
         * @return  String
         */
        getThumbTooltipAttribute: function() {
            var tooltipAttribute = '';
            return tooltipAttribute;
        }
    });
});
window.DependencyLoader.push(['ResourceAccessor'], function() {

    /**
     * PhotoResourceAccessor
     * 
     * @extends ResourceAccessor
     */
    window.PhotoResourceAccessor = ResourceAccessor.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoResourceAccessor')
         */
        _string: 'PhotoResourceAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @param   View results
         * @param   Boolean locked
         * @return  Array
         */
        getThumbClasses: function(results, locked) {
            var classes = ['thumb', 'lazy', 'asset'];
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            if (results.category() === true) {
                var category = results.getCategory();
                if (this.pinned(category) === true) {
                    classes.push('pin');
                }
            }
            if (locked === true) {
                classes.push('locked');
            }
            return classes;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var src = this.url('thumb');
            return src;
        },

        /**
         * getThumbTooltipAttribute
         * 
         * @access  public
         * @return  String
         */
        getThumbTooltipAttribute: function() {
            var tooltipAttribute = '';
            // if (this.get('platform') === 'Unsplash') {
            //     var tooltip = this.get('credit');
            //     tooltipAttribute = 'tooltip data-title=\'' + (tooltip) + '\' ';
            // }
            return tooltipAttribute;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'PromoModel'], function() {

    /**
     * PromoAccessor
     * 
     * @extends Accessor
     */
    window.PromoAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Promo'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoAccessor')
         */
        _string: 'PromoAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupPromoSet();
        },

        /**
         * _setupPromoSet
         * 
         * @access  protected
         * @return  void
         */
        _setupPromoSet: function() {
            var model = Stencil.getModel('PromoSet');
            this._references.promoSet = model.setAccessor(this._data.promoSet);
        },

        /**
         * promoSet
         * 
         * @access  public
         * @return  PromoSetAccessor
         */
        promoSet: function() {
            return this._references.promoSet;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'PromoSetModel'], function() {

    /**
     * PromoSetAccessor
     * 
     * @extends Accessor
     */
    window.PromoSetAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PromoSet'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoSetAccessor')
         */
        _string: 'PromoSetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
});
window.DependencyLoader.push(['AssetAccessor', 'AssetModel'], function() {

    /**
     * QuoteAssetAccessor
     * 
     * @extends AssetAccessor
     */
    window.QuoteAssetAccessor = AssetAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Asset'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteAssetAccessor')
         */
        _string: 'QuoteAssetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * getDisplayableQuotation
         * 
         * @see     http://stackoverflow.com/questions/784539/how-do-i-replace-all-line-breaks-in-a-string-with-br-tags
         * @access  public
         * @return  String
         */
        getDisplayableQuotation: function() {
            var raw = this.setting('raw');
            if (JSONUtils.valid(raw) === false) {
                LogUtils.log.simple('JSON parse error (qR)', true);
                var quotation = 'Could not retrieve quotation';
                return quotation;
            }
            var quotation = JSON.parse(raw).quotation;
            return quotation.trimToLength(200).replace(
                /(?:\r\n|\r|\n)/g,
                '<br />'
            );
        },

        /**
         * getThumbAuthor
         * 
         * @access  public
         * @return  String
         */
        getThumbAuthor: function() {
            var raw = this.setting('raw');
            if (JSONUtils.valid(raw) === false) {
                LogUtils.log.simple('JSON parse error (qR)', true);
                var author = 'Could not retrieve author';
                return author;
            }
            var author = JSON.parse(raw).author;
            return author;
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @return  Array
         */
        getThumbClasses: function() {
            var classes = ['quote', 'row', 'asset'];
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            return classes;
        },

        /**
         * getThumbQuotation
         * 
         * @access  public
         * @return  String
         */
        getThumbQuotation: function() {
            var quotation = this.getDisplayableQuotation();
            return quotation;
        }
    });
});
window.DependencyLoader.push(['ResourceAccessor'], function() {

    /**
     * QuoteResourceAccessor
     * 
     * @extends ResourceAccessor
     */
    window.QuoteResourceAccessor = ResourceAccessor.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteResourceAccessor')
         */
        _string: 'QuoteResourceAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * _addQuoteTextLayers
         * 
         * @access  protected
         * @return  void
         */
        _addQuoteTextLayers: function() {
            var quotation = this._data.quotation,
                author = this._data.author,
                canvas = Canvases.Preview,
                layers = {
                    author: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: 'Leckerli One',
                        fontSize: 35,
                        text: author,
                        top: 70,
                        width: 90
                    }),
                    quotation: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: Stencil.account().getDefaultFontFamily(),
                        fontSize: 50,
                        text: quotation,
                        top: 45,
                        width: 90
                    })
                },
                drawings = {
                    author: layers.author.getDrawing(),
                    quotation: layers.quotation.getDrawing()
                };
            layers.author.setChangeOperationType('quote:added');
            drawings.author.once({
                'draw': function(event) {
                    this.trim();
                    this.repositionRelativeTo(drawings.quotation);
                    this.animate();
                    drawings.quotation.animate();
                    drawings.quotation.select();
                    // this._cotton.trigger('changed');
                    layers.author.triggerHandler('refresh/dimensions');
                }
            });
            drawings.quotation.once({
                'draw': function(event) {
                    drawings.author.draw();
                }
            });
            drawings.quotation.draw();
        },

        /**
         * getDisplayableQuotation
         * 
         * @see     http://stackoverflow.com/questions/784539/how-do-i-replace-all-line-breaks-in-a-string-with-br-tags
         * @access  public
         * @return  String
         */
        getDisplayableQuotation: function() {
            return this._data.quotation.trimToLength(200).replace(
                /(?:\r\n|\r|\n)/g,
                '<br />'
            );
        },

        /**
         * getThumbAuthor
         * 
         * @access  public
         * @return  String
         */
        getThumbAuthor: function() {
            var author = this.get('author');
            return author;
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @return  Array
         */
        getThumbClasses: function() {
            var classes = ['quote', 'row', 'asset'];
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            return classes;
        },

        /**
         * getThumbQuotation
         * 
         * @access  public
         * @return  String
         */
        getThumbQuotation: function() {
            var quotation = this.getDisplayableQuotation();
            return quotation;
        }
    });
});
window.DependencyLoader.push(['MediaAccessor', 'ResourceModel'], function() {

    /**
     * ResourceAccessor
     * 
     * @extends MediaAccessor
     */
    window.ResourceAccessor = MediaAccessor.extend({

        /**
         * _asset
         * 
         * Possible reference to the asset that the resource was saved to.
         * 
         * @access  protected
         * @var     AssetAccessor (default: false)
         */
        _asset: false,

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Resource'),

        /**
         * _saved
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _saved: false,

        /**
         * _saving
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _saving: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceAccessor')
         */
        _string: 'ResourceAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
            this._addSelectListener();
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, method, locked, options) {
                    this._select(locked, options);
                }
            });
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'feature': function(event, category) {
                    // if (this._asset === false) {
                        Track.event('Resource featured', {
                            _key: this._data.key
                        });
                    // }
                },
                'unfeature': function(event, category) {
                    // if (this._asset === false) {
                        Track.event('Resource unfeatured', {
                            _key: this._data.key
                        });
                    // }
                }
            });
        },

        /**
         * _addVectorLayer
         * 
         * @todo    After saving is complete, preload the asset at the new url
         *          via a crossDomain ajax call to have the preflight request
         *          fire as well
         * @access  protected
         * @param   Boolean locked
         * @param   Boolean color
         * @return  void
         */
        _addVectorLayer: function(locked, color) {
            var canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }, color),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
            Track.event('Vector resource added');
        },

        /**
         * _incrementResourceOperations
         * 
         * Helper method to increment the general and specific
         * operation-counters to ensure that once the maximum is reached, the
         * user is blocked until previous operations finish.
         * 
         * This helper was required because of how the save method works.
         * Namely, it allows multiple calls to it, such that when the resource
         * has already been saved, the save-listener is triggered right away.
         * 
         * While that was the initial intention, it is nice having this in one
         * place regardless.
         * 
         * @access  protected
         * @param   String type
         * @return  void
         */
        _incrementResourceOperations: function(type) {
            var lookup = {
                    feature: 'parallelResourceFeatures',
                    save: 'parallelResourceSaves'
                },
                parallelResourceOperations = Stencil.get('parallelResourceOperations'),
                parallelResourceOperationsByType = Stencil.get(lookup[type]);
            ++parallelResourceOperations;
            Stencil.set('parallelResourceOperations', parallelResourceOperations);
            ++parallelResourceOperationsByType;
            Stencil.set(lookup[type], parallelResourceOperationsByType);
        },

        /**
         * _select
         * 
         * @access  protected
         * @param   Boolean locked
         * @param   Object options
         * @return  Boolean
         */
        _select: function(locked, options) {

            // Graphics
            var vectorPlatforms = [
                    'Iconfinder',
                    'Icons8',
                    'TheNounProject',
                    'VectorSearch'
                ],
                platform = this._data.platform;
            if (ArrayUtils.contains(platform, vectorPlatforms) === true) {
                var color = this._data.color.toInt() === 1;
                this._addVectorLayer(locked, color);
                return true;
            }

            // Quotes
            if (platform === 'AlgoliaQuote') {
                this._addQuoteTextLayers();
                return true;
            }

            // Foreground photos
            if (options.destination === 'foreground') {
                Account.onboard('foregroundSelected');
                this.addForegroundBitmapImageLayer(locked);
                return true;
            }

            // Background photos
            Account.onboard('backgroundSelected');
            if (options.autoSelect !== undefined) {
                this.setBackgroundBitmapImageLayer(locked, {
                    autoSelect: options.autoSelect
                });
                return true;
            }
            this.setBackgroundBitmapImageLayer(locked);
            return true;
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @note    The reason adding a foreground bitmap image layer doesn't
         *          require setting up or listening for a gateway save is because
         *          those calls are initiated in the constructor for the layer.
         *          Since calling this method will *always* result in a new
         *          ForegroundBitmapImageLayer layer being created, nothing needs
         *          to be done right after.
         *          This contrasts the setBackgroundBitmapImageLayer method,
         *          since that method doesn't actually create a new
         *          BackgroundBitmapImageLayer. Rather, it sets the image to it,
         *          since that layer always exists. Because of this, multiple
         *          images should be able to trigger a gateway save, since a user
         *          could hypothetically choose an image, wait 30 seconds, and
         *          then change it. When they do that, because of the how the
         *          events are structured (namely, using the <once> event
         *          listener), a second call needs to be made to ensure the
         *          listeners are ready.
         * @note    Defaults to auto selecting the drawing
         * @note    Defaults to auto animating the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (default: {})
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(locked, options) {
            var layer = this._super(locked, options);
            return layer;
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = CategoryUtils.account.favorites(areaType);
            this.feature(category);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        feature: function(category) {
            var check = this.validate.feature.apply(this, [category]);
            if (check.valid === false) {
                check.callback();
            } else {
                this._incrementResourceOperations('feature');
                var area = 'photos';
                if (category.get('graphics').toInt() === 1) {
                    area = 'graphics';
                } else if (category.get('quotes').toInt() === 1) {
                    area = 'quotes';
                }
                if (ArrayUtils.contains(category, CategoryUtils.global.all()) === true) {
                    Stencil.globalFeatures.add(this);
                }
                category.features.add.apply(category, [this]);
                var key = category.get('key'),
                    features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection(),
                    _this = this;
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('key'),
                        collections: this._data.collections || [],
                        color: this._data.color.toInt() === 1 ? 1 : 0,
                        package: this._data.package,
                        tags: this._data.tags,
                        uploader: this._data.uploader || {},
                        urls: this._data.urls
                    },
                    /**
                     * (anonymous)
                     * 
                     * Passes in a data object representing an asset record.
                     * 
                     * @access  private
                     * @param   Object data
                     * @return  void
                     */
                    function(data) {
                        if (data.object.uploaded.toInt() === 0) {
                            var code = 'r262',
                                reference = 'resource';
                            Stencil.error(code, reference);
                        } else {
                            var model = Stencil.getModel('Asset'),
                                accessor = model.setAccessor(data.object);
                            _this._asset = accessor;
                            _this._saved = true;
                            accessor.preload();
                            // accessor.preload(function() {
                            //     accessor.triggerHandler('preload');
                            // });
                            Stencil.triggerHandler('resource/feature/complete', [accessor]);
                            Stencil.triggerHandler('resource/operation/complete', ['feature', accessor]);
                        }
                    }
                );
                this.triggerHandler('feature', [category]);
                var asset = this.getAsset();
                if (asset !== false) {
                    asset.triggerHandler('feature', [category]);
                }
                features.add(this, false);
            }
        },

        /**
         * getAsset
         * 
         * @access  public
         * @return  false|AssetAccessor
         */
        getAsset: function() {
            var accessors = Stencil.get('accessors'),
                index;
            for (index in accessors) {
                if (accessors[index].reference('resource') === this) {
                    return accessors[index];
                }
            }
            return false;
        },

        /**
         * getPlacementDestination
         * 
         * @access  public
         * @return  String
         */
        getPlacementDestination: function() {
            if (this.get('platform') === 'Iconfinder') {
                return 'foreground';
            }
            if (this.get('platform') === 'Icons8') {
                return 'foreground';
            }
            if (this.get('platform') === 'TheNounProject') {
                return 'foreground';
            }
            if (this.get('platform') === 'VectorSearch') {
                return 'foreground';
            }
            return 'background';
        },

        /**
         * loadCropperDependencies
         * 
         * @access  public
         * @return  Boolean
         */
        loadCropperDependencies: function() {
            return false;
        },

        /**
         * owned
         * 
         * @access  public
         * @return  false
         */
        owned: function() {
            return false;
        },

        /**
         * save
         * 
         * @todo!   Look into removing save-event and having listeners within the
         *          app look to resource/save/complete event.
         * @todo    This is a bad name; can get confused with saving and
         *          accessor's data (but maybe, that's okay, since it's a
         *          resource and it doesn't have any data other than the binary
         *          image itself?)
         * @note    Sometimes in the console it'll seem like there's a lag
         *          between when the /save ajax call returns, and when the
         *          callback is fired. This is because the newly saved resource
         *          is preloaded before the callback is fired.
         * @note    I cannot recall, but I believe I delayed things until after
         *          preload because when a save happens, it is often within the
         *          context of swapping out an image in the canvas. So I wanted
         *          to only swap it out once a preload action has occured (to
         *          prevent any flickering while the resource is requested).
         * @access  public
         * @return  void
         */
        save: function() {
            var check = this.validate.save.apply(this);
            if (check.valid === false) {
                check.callback();
            } else {
                if (this._saving === false) {
                    if (this._saved === true) {
                        this.triggerHandler('save', [this._asset]);
                    } else {
                        this._incrementResourceOperations('save');
                        var _this = this;
                        this._saving = true;
                        this._model.save(
                            this._data.key,
                            {
                                collections: this._data.collections || [],
                                color: this._data.color.toInt() === 1 ? 1 : 0,
                                // tags: this._data.tags || [],
                                tags: this._data.tags,
                                uploader: this._data.uploader || {},
                                urls: this._data.urls
                            },
                            /**
                             * (anonymous)
                             * 
                             * Passes in a data object representing an asset record.
                             * 
                             * @access  private
                             * @param   Object data
                             * @return  void
                             */
                            function(data) {
                                if (data.object.uploaded.toInt() === 0) {
                                    var code = 'r314',
                                        reference = 'resource';
                                    Stencil.error(code, reference);
                                } else {
                                    var model = Stencil.getModel('Asset'),
                                        accessor = model.setAccessor(data.object);
                                    _this._asset = accessor;
                                    accessor.preload(function(references) {
                                        _this._saved = true;
                                        _this._saving = false;
                                        _this.triggerHandler('save', [accessor]);
                                        // _this.triggerHandler('preload');
                                        Stencil.triggerHandler('resource/save/complete', [accessor]);
                                        Stencil.triggerHandler('resource/operation/complete', ['save', accessor]);
                                    });
                                }
                            }
                        );
                    }
                }
            }
        },

        /**
         * saved
         * 
         * @access  public
         * @return  Boolean
         */
        saved: function() {
            return this._saved;
        },

        /**
         * setBackgroundBitmapImageLayer
         * 
         * @note    Defaults to not auto selecting the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (default: {})
         * @return  BackgroundBitmapImageLayer
         */
        setBackgroundBitmapImageLayer: function(locked, options) {
            var layer = this._super(locked, options);
            layer.listenForGatewaySave();
            layer.setupGatewaySave();
            return layer;
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @note    Since it's possible that the features collection actually
         *          contains the AssetAccessor for this ResourceAccessor, I
         *          try and remove that as well, incase that's the one that's
         *          being stored in the collection.
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        unfeature: function(category) {
            var area = 'photos';
            if (category.get('graphics').toInt() === 1) {
                area = 'graphics';
            } else if (category.get('quotes').toInt() === 1) {
                area = 'quotes';
            }
            if (ArrayUtils.contains(category, CategoryUtils.global.all()) === true) {
                if (this.globalCategoriesFeaturedIn().length === 1) {
                    Stencil.globalFeatures.remove(this);
                }
            }
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection();
            this._model.unfeature(
                this._data.key,
                {
                    category: category.get('key')
                },
                /**
                 * (anonymous)
                 * 
                 * Passes in a data object representing an asset record. This is
                 * important because I want to ensure that after an unfeature
                 * response comes back, I can properly remove the associated
                 * AssetAccessor from the associated CategoryAccessor's
                 * syncedFeatures array.
                 * 
                 * So to do that, I set the accessor here (which ought always to
                 * be an asset-record), to ensure it's available by the time
                 * model.unfeature gets around to needing it.
                 * 
                 * The syncedFeatures array needs to be kept in sync to ensure
                 * sorting works properly for categories.
                 * 
                 * @access  private
                 * @param   Object data
                 * @return  void
                 */
                function(data) {
                    var model = Stencil.getModel('Asset'),
                        accessor = model.setAccessor(data.object);
                }
            );
            this.triggerHandler('unfeature', [category]);
            var asset = this.getAsset();
            if (asset !== false) {
                asset.triggerHandler('unfeature', [category]);
            }
            features.remove(this);
            if (asset !== false) {
                features.remove(asset);
            }
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = CategoryUtils.account.favorites(areaType);
            this.unfeature(category);
        },

        /**
         * url
         * 
         * Provides URLs (not through Cloudinary) for resources to match the
         * following cases:
         * - SVG image url (eg. The Noun Project)
         * - Preview image url, used to show both Pixabay and The Noun Project
         *   thumbs
         * - Small image urls, currently only used to draw Pixabay resources
         *   into the canvas so that the resolution is good enough until the
         *   image gets fully downloaded and a higher-resolution is swapped in
         * 
         * @access  public
         * @param   String type
         * @return  String|false
         */
        url: function(type) {
            var url = false;
            if (type === 'small') {
                url = this._data.urls.small;
            }
            if (type === 'svg') {
                url = this._data.urls.svg;
            }
            if (type === 'thumb') {
                url = this._data.urls.preview;
            }
            return url;
        },

        /**
         * validate
         * 
         * @access  public
         * @var     Object
         */
        validate: {

            /**
             * feature
             * 
             * @access  public
             * @param   CategoryAccessor category
             * @return  Object
             */
            feature: function(category) {
                var check = this.validate.operation.apply(this, ['feature', [category]]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceFeatures = Stencil.get('parallelResourceFeatures'),
                    max = Config.default('maxParallelResourceFeatures'),
                    reattemptMinDelay = 2000;
                if (parallelResourceFeatures === undefined) {
                    parallelResourceFeatures = 0;
                    Stencil.set('parallelResourceFeatures', parallelResourceFeatures);
                }
                if (parallelResourceFeatures >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('resource.features.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/feature/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.feature(category);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * operation
             * 
             * @access  public
             * @param   String type This is the type of operation that is being
             *          validated (eg. feature or save). It is important that
             *          this variable is different than the second argument in
             *          the resource/operation/complete-event. It caused a bug
             *          whereby the completed-operation was getting reattempted
             *          because the type-param was named "operation" as well.
             *          Yikes.
             * @param   Array args
             * @return  Object
             */
            operation: function(type, args) {
                var parallelResourceOperations = Stencil.get('parallelResourceOperations'),
                    max = Config.default('maxParallelResourceOperations'),
                    _this = this,
                    reattemptMinDelay = 2000;
                if (parallelResourceOperations === undefined) {
                    parallelResourceOperations = 0;
                    Stencil.set('parallelResourceOperations', parallelResourceOperations);
                }
                if (parallelResourceOperations >= max) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('resource.operations.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/operation/complete': function(event, operation, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this[type].apply(_this, args);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * save
             * 
             * @access  public
             * @return  Object
             */
            save: function() {
                var check = this.validate.operation.apply(this, ['save', []]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceSaves = Stencil.get('parallelResourceSaves'),
                    max = Config.default('maxParallelResourceSaves'),
                    reattemptMinDelay = 2000;
                if (parallelResourceSaves === undefined) {
                    parallelResourceSaves = 0;
                    Stencil.set('parallelResourceSaves', parallelResourceSaves);
                }
                if (parallelResourceSaves >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('resource.saves.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/save/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.save();
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            }
        }
    });
});
window.DependencyLoader.push(['Accessor', 'ShareModel'], function() {

    /**
     * ShareAccessor
     * 
     * @extends Accessor
     */
    window.ShareAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Share'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareAccessor')
         */
        _string: 'ShareAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupConnection();
            this._setupImage();
        },

        /**
         * _setupConnection
         * 
         * @access  protected
         * @return  void
         */
        _setupConnection: function() {
            var model = Stencil.getModel('Connection');
            this._references.connection = model.setAccessor(
                this._data.connection
            );
        },

        /**
         * _setupImage
         * 
         * @access  protected
         * @return  void
         */
        _setupImage: function() {
            var model = Stencil.getModel('Image');
            this._references.image = model.setAccessor(this._data.image);
        },

        /**
         * connection
         * 
         * @access  public
         * @return  ConnectionAccessor
         */
        connection: function() {
            var connection = this._references.connection;
            return connection;
        },

        /**
         * getPath
         * 
         * Returns the path the user should be sent to after a successful share.
         * Note that while the network-parameter being passed is not currently
         * (at the time of documentation) being used within the
         * application-logic, it is being used by Google Analytics for
         * goal-conversion-tracking.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var network = this.connection().get('network'),
                path = '/app/shares/' + (this._data.key) +  '/success' +
                    '?clean=1' +
                    '&network=' + (network);
            return path;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'TemplateModel'], function() {

    /**
     * TemplateAccessor
     * 
     * @extends Accessor
     */
    window.TemplateAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Template'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateAccessor')
         */
        _string: 'TemplateAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addTrackListeners();
            this._setupImage();
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Template deleted', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                },
                'feature': function(event, category) {
                    Track.event('Template featured', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Template unfeatured', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                }
            });
        },

        /**
         * _setupImage
         * 
         * @access  protected
         * @return  void
         */
        _setupImage: function() {
            var model = Stencil.getModel('Image');
            this._references.image = model.setAccessor(this._data.image);
            this._references.image.set({template: true});
        },

        /**
         * _syncedToAnyCategory
         * 
         * @access  protected
         * @return  Boolean
         */
        _syncedToAnyCategory: function() {
            var categories = CategoryUtils.account.all({
                    templates: 1
                }),
                index;
            for (index in categories) {
                if (this._syncedToCategory(categories[index]) === true) {
                    return true;
                }
            }
            categories = CategoryUtils.global.all({
                templates: 1
            });
            for (index in categories) {
                if (this._syncedToCategory(categories[index]) === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _syncedToCategory
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        _syncedToCategory: function(category) {
            return category.syncedFeatures.contains.apply(category, [this]) === true;
        },

        /**
         * _syncedToFavoritesCategory
         * 
         * @todo!!!!This doesn't seem like it's being used. Why?
         * @access  protected
         * @return  Boolean
         */
        _syncedToFavoritesCategory: function() {
            var category = CategoryUtils.account.favorites('templates');
            return this._syncedToCategory(category);
        },

        /**
         * _syncedToGlobalCategory
         * 
         * @todo!!!!This doesn't seem like it's being used. Why?
         * @access  protected
         * @return  Boolean
         */
        _syncedToGlobalCategory: function() {
            var categories = CategoryUtils.global.type('templates'),
                index,
                category;
            for (index in categories) {
                category = categories[index];
                if (this._syncedToCategory(category) === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _syncedToListCategory
         * 
         * @todo!!!!This doesn't seem like it's being used. Why?
         * @access  protected
         * @return  Boolean
         */
        _syncedToListCategory: function() {
            var category = CategoryUtils.account.list('templates');
            return this._syncedToCategory(category);
        },

        /**
         * delete
         * 
         * @access  public
         * @param   Boolean autoHideBusyModal (default: true) Used to prevent
         *          busy modal from hiding when called by through multi-delete
         *          flow
         * @return  void
         */
        delete: function(autoHideBusyModal) {
            autoHideBusyModal = DataUtils.getDefaultValue(
                autoHideBusyModal,
                true
            );
            var image = this._references.image;
            if (image.get('uploaded').toInt() === 1) {
                if (autoHideBusyModal === true) {
                    App.getBusy().hide();
                }
                if (Stencil.account().draft().getSourceImage() === image) {
                    var previousSourceImageId = Stencil.account().draft().get('sourceImageId').toInt();
                    Stencil.account().draft().removeSourceImage();
                    Footer.setLastSavedImage(false);
                    Footer.reset();
                    ChangeHistory.syncSourceImageId(previousSourceImageId, 0);
                }
                this._super();
            } else {
                var msg = Config.getMessage('template.delete.pending');
                App.getBusy().show(msg);
                this.once({
                    'model/feature': this.delete.proxy(this)
                });
            }
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = CategoryUtils.account.favorites('templates');
            this.feature(category, performDataRequest);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            if (ArrayUtils.contains(category, CategoryUtils.global.all()) === true) {
                Stencil.globalFeatures.add(this);
            }
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('templates').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelFeatureCall = function() {
                    this._model.feature(
                        this._data.key,
                        {
                            category: category.get('key')
                        },
                        (function(data) {
                            this.triggerHandler('feature/complete');
                        }).proxy(this)
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelFeatureCall.apply(this);
                } else {
                    var _this = this;
                    this._references.image.once({
                        'update/uploaded': function(event) {
                            modelFeatureCall.apply(_this);
                        }
                    });
                }
            }
            this.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * getPreviewThumbImageUrl
         * 
         * @access  public
         * @return  String
         */
        getPreviewThumbImageUrl: function() {
            var url = this._references.image.url('scale', {
                width: 800
            });
            return url;
        },

        /**
         * getThumbBackgroundImageStyle
         * 
         * @access  public
         * @return  String
         */
        getThumbBackgroundImageStyle: function() {
            var image = this.reference('image'),
                backgroundImageStyle = 'none';
            if (image.get('uploaded').toInt() === 0) {
                var dimensions = ImageUtils.getThumbDimensions(),
                    src = image.getSrc({
                        clip: true,
                        dimensions: {
                            height: dimensions.height,
                            width: dimensions.width
                        }
                    });
                backgroundImageStyle = 'url(\'' + (src) + '\')';
            }
            return backgroundImageStyle
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @param   TemplateCategoryResultsView results
         * @return  Array
         */
        getThumbClasses: function(results) {
            var classes = ['thumb', 'lazy'],
                image = this.reference('image');
            if (image.get('uploaded').toInt() === 0) {
                classes = ['thumb', 'loaded'];
            }
            if (this.globallyFeatured() === true) {
                classes.push('feature');
            }
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            if (this.owned() === true) {
                classes.push('owned');
            }
            var category = results.getCategory();
            if (this.pinned(category) === true) {
                classes.push('pin');
            }
            return classes;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var image = this.reference('image'),
                src = image.url('thumb');
            if (image.get('uploaded').toInt() === 0) {
                src = '';
            }
            return src;
        },

        /**
         * owned
         * 
         * @access  public
         * @return  Boolean
         */
        owned: function() {
            return this._references.image.owned();
        },

        /**
         * pinned
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        pinned: function(category) {
            return category.get('pinKey') === this._references.image.get('key');
        },

        /**
         * select
         * 
         * Triggers a template select unless the user isn't a Pro / admin user.
         * At the moment the below logic to hide the spinner is a big hack. Will
         * probably need to deal with this post-launch.
         * 
         * @todo!   Clean up: spinner removal should not be happening here.
         * @access  public
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        select: function(method, locked, options) {
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                ChangeHistory.setOperationType('template // loaded');
                this._references.image.select(method, locked, options);
            } else {
                // Stencil.navigate('/app/upgrade/pro/templates?clean=1');
                var path = '/app/templates/' +
                    this._data.key +
                    '/preview' +
                    '?clean=1'
                Stencil.navigate(path);
                (function() {
                    App.getElement().find('div.spinning div.spinner').remove();
                    App.getElement().find('div.spinning').removeClass('spinning');
                }).delay(10);
            }
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = CategoryUtils.account.favorites('templates');
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            if (ArrayUtils.contains(category, CategoryUtils.global.all()) === true) {
                Stencil.globalFeatures.remove(this);
            }
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('templates').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelUnfeatureCall = function() {
                    this._model.unfeature(
                        this._data.key,
                        {
                            category: category.get('key')
                        }
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelUnfeatureCall.apply(this);
                } else {
                    var _this = this;
                    this._references.image.once({
                        'update/uploaded': function(event) {
                            modelUnfeatureCall.apply(_this);
                        }
                    });
                }
            }
            this.triggerHandler('unfeature', [category]);
            features.remove(this);
        }
    });
});
window.DependencyLoader.push(['MediaAccessor', 'UploadModel'], function() {

    /**
     * UploadAccessor
     * 
     * @events  upload/success
     *          upload/progress
     *          upload/error
     * @extends MediaAccessor
     */
    window.UploadAccessor = MediaAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Upload'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadAccessor')
         */
        _string: 'UploadAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._addSelectListener();
            this._addTrackListeners();
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, method, locked, options) {
                    this._select(locked, options);
                }
            });
        },

        /**
         * _addTrackListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTrackListeners: function() {
            this.on({
                'delete': function(event) {
                    Track.event('Upload deleted', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'feature': function(event, category) {
                    Track.event('Upload featured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Upload unfeatured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                }
            });
        },

        /**
         * _addVectorLayer
         * 
         * @access  protected
         * @return  void
         */
        _addVectorLayer: function() {
            var color = this._data.color.toInt() === 1,
                canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }, color === true),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', false);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
        },

        /**
         * _download
         * 
         * @access  protected
         * @return  void
         */
        _download: function() {
            var key = this._data.key,
                path = '/uploads/' + (key) + '/download',
                cookieKey = 'upload.download.started',
                alertKey = 'clients.electron.uploads.download.single.complete';
            Stencil.once({
                'redirect/complete': function(event) {
                    App.getBusy().hide();
                }
            });
            DownloadUtils.attemptDownload(path, cookieKey);
        },

        /**
         * _getPreloadUrls
         * 
         * @access  protected
         * @return  Array
         */
        _getPreloadUrls: function() {
            var url = this.url('thumb'),
                urls = [url];
            return urls;
        },

        /**
         * _getResolution
         * 
         * @access  protected
         * @return  false|Number
         */
        _getResolution: function() {
            var width = this.get('width'),
                height = this.get('height');
            if (width.constructor !== Number && width.constructor !== String) {
                return false;
            }
            if (height.constructor !== Number && height.constructor !== String) {
                return false;
            }
            width = width.toInt();
            height = height.toInt();
            return width * height;
        },

        /**
         * _select
         * 
         * @access  protected
         * @param   Boolean locked
         * @param   Object options
         * @return  Boolean
         */
        _select: function(locked, options) {
            this.syncDimensions();

            // Vector
            if (this._data.vector.toInt() === 1) {
                this._addVectorLayer();
                return true;
            }

            // Crop properties
            var cropPositionData = options.cropPositionData || {},
                cropSourceKey = options.cropSourceKey || '',
                key = this._data.key,
                properties = {
                    cropPositionData: cropPositionData,
                    cropSourceKey: cropSourceKey,
                    key: key
                };
            if (this.setting('crop').toInt() === 1) {
                cropPositionData = this.setting('cropPositionData');
                cropPositionData = JSON.parse(cropPositionData);
                properties.cropPositionData = cropPositionData;
                properties.cropSourceKey = this.setting('cropSourceKey');
            }

            // Foreground
            if (options.destination === 'foreground') {
                Account.onboard('foregroundSelected');
                this.addForegroundBitmapImageLayer(locked, properties);
                return true;
            }

            // Background
            Account.onboard('backgroundSelected');
            if (options.autoSelect !== undefined) {
                properties.autoSelect = options.autoSelect;
            }
            this.setBackgroundBitmapImageLayer(locked, properties);
            return true;
        },

        /**
         * download
         * 
         * @access  public
         * @param   Boolean showBusyModal
         * @return  void
         */
        download: function(showBusyModal) {
            if (showBusyModal === true) {
                var msg = Config.getMessage('upload.download.pending');
                App.getBusy().show(msg);
            }
            this._download.apply(this);
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = CategoryUtils.account.favorites('uploads');
            this.feature(category, performDataRequest);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('uploads').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('key')
                    },
                    (function(data) {
                        this.triggerHandler('feature/complete');
                    }).proxy(this)
                );
            }
            this.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * getPlacementDestination
         * 
         * @access  public
         * @return  String
         */
        getPlacementDestination: function() {
            return 'foreground';
        },

        /**
         * getThumbClasses
         * 
         * @access  public
         * @return  Array
         */
        getThumbClasses: function() {
            var classes = ['thumb', 'lazy'];
            if (this.favorited() === true) {
                classes.push('favorite');
            }
            if (this._data.vector.toInt() === 1) {
                classes.push('vector');
            }
            if (this._data.settings.whiteOnTransparent.toInt() === 1) {
                classes.push('whiteOnTransparent');
            }
            return classes;
        },

        /**
         * getThumbKey
         * 
         * @access  public
         * @return  String
         */
        getThumbKey: function() {
            var thumbKey = this._data.key;
            return thumbKey;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var src = this.url('thumb');
            return src;
        },

        /**
         * loadCropperDependencies
         * 
         * @note    The check between the accesor key and the cropSourceKey is
         *          required because it's possible that watermarks have
         *          cropSourceKey values that reference themselves (since they
         *          can overwrite themselves).
         * @access  public
         * @return  Boolean
         */
        loadCropperDependencies: function() {
            var bitmap = this.get('bitmap').toInt();
            if (bitmap === 0) {
                return false;
            }
            if (this.setting('crop').toInt() === 0) {
                this._super();
                return true;
            }
            var cropSourceKey = this.setting('cropSourceKey');
            if (this._data.key === cropSourceKey) {
                this._super();
                return true;
            }
            var key = cropSourceKey;
            DataUtils.requestMediaObject(key, function(accessor) {
                accessor.loadCropperDependencies();
            });
            return false;
        },

        /**
         * overwrite
         * 
         * @access  public
         * @param   String url
         * @param   Function callback
         * @return  void
         */
        overwrite: function(url, callback) {
            var key = this._data.key;
            this._model.overwrite(key, url, callback);
        },

        /**
         * owned
         * 
         * @access  public
         * @return  Boolean
         */
        owned: function() {
            return this._data.accountId.toInt() === Stencil.account().get('id').toInt();
        },

        /**
         * preload
         * 
         * Preloads alternate resource sizes.
         * 
         * @todo    Optimize this so only the sizes used for each upload type
                    (eg. graphic, photo, watermark) is preloaded
         * @todo    Optimize this so for graphic and watermark uploads, the size
         *          that would be added to the canvas is preloaded (eg. at the
         *          moment, that size is 15% of the canvas).
         * @access  public
         * @param   undefined|Function success (default: function(references) {})
         * @param   undefined|Function error (default: function(reference) {})
         * @return  void
         */
        preload: function(success, error) {
            success = DataUtils.getDefaultValue(success, function(references) {});
            error = DataUtils.getDefaultValue(error, function(reference) {});
            var urls = this._getPreloadUrls();
            ImageUtils.load.urls(urls, true, success.proxy(this), error.proxy(this));
            this.loadCropperDependencies();
        },

        /**
         * showCropper
         * 
         * @access  public
         * @return  void
         */
        showCropper: function() {
            var key = this._data.key,
                modal = ModalUtils.showCropper(key),
                _this = this,
                msg = Config.getMessage('app.crop.preparing');
            modal.setSource('thumb');
            modal.setSourceType('upload');
            App.getBusy().show(msg);
            modal.once({
                'cropper/ready': function(event) {
                    var cropPositionData = _this.getCropBoxPositionData();
                    this.setCropBox(cropPositionData);
                    App.getBusy().hide();
                    modal.getElement().removeClass('invisible');
                }
            });
        },

        /**
         * sync
         * 
         * @access  public
         * @return  void
         */
        sync: function() {
            this._model.sync(this._data.key);
            this.triggerHandler('sync/start');
        },

        /**
         * syncDimensions
         * 
         * Syncs the width/height of the upload if it's not yet stored in the
         * object. Will only be used via legacy image uploads being selected,
         * since all new ones are routed through /sync against the upload record
         * to have the server pull the width/height in.
         * 
         * @access  public
         * @return  Boolean
         */
        syncDimensions: function() {
            var width = this._data.width.toInt(),
                height = this._data.height.toInt();
            if (width !== 0 && height !== 0) {
                return false;
            }
            var _this = this,
                url = this.url('original'),
                imageRequest = new ImageRequest(url);
            imageRequest.once({
                'load': function(event, image) {
                    _this.set({
                        'width': image.width.toInt(),
                        'height': image.height.toInt()
                    });
                    _this.save(['width', 'height']);
                }
            });
            imageRequest.request();
            return true;
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = CategoryUtils.account.favorites('uploads');
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('uploads').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.unfeature(
                    this._data.key,
                    {
                        category: category.get('key')
                    }
                );
            }
            this.triggerHandler('unfeature', [category]);
            features.remove(this);
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with legacy upload dimension syncing
         * - Scaled image url, used for thumbnails for watermarks and graphics
         * - Thumb image url, used for within Photos and Graphics for upload
         *   thumbs
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options (default: {})
         * @return  String|false
         */
        url: function(type, options) {
            options = DataUtils.getDefaultValue(options, {});
            var key = this.getThumbKey();
            if (type === 'original') {
                var url = ImageUtils.url.thumb(key, {
                    type: 'original'
                });
                return url;
            }
            if (type === 'scale') {
                var url = ImageUtils.url.thumb(key, {
                    type: 'scale',
                    width: options.width
                });
                return url;
            }
            if (type === 'thumb') {
                var url = ImageUtils.url.thumb(key, {
                    type: 'thumb'
                });
                return url;
            }
            if (type === 'svg') {
                key = (key) + '.svg';
                var url = RequestUtils.url.cloudFront(key);
                return url;
            }
            return false;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'UpgradeModel'], function() {

    /**
     * UpgradeAccessor
     * 
     * @extends Accessor
     */
    window.UpgradeAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Upgrade'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradeAccessor')
         */
        _string: 'UpgradeAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupCoupon();
            this._setupCustomer();
            this._setupPromo();
        },

        /**
         * _setupCoupon
         * 
         * @access  protected
         * @return  void
         */
        _setupCoupon: function() {
            if (this._data.coupon !== false) {
                var model = Stencil.getModel('Coupon');
                this._references.coupon = model.setAccessor(
                    this._data.coupon
                );
            }
        },

        /**
         * _setupCustomer
         * 
         * @access  protected
         * @return  void
         */
        _setupCustomer: function() {
            if (this._data.customer !== false) {
                var model = Stencil.getModel('Customer');
                this._references.customer = model.setAccessor(
                    this._data.customer
                );
            }
        },

        /**
         * _setupPromo
         * 
         * @access  protected
         * @return  void
         */
        _setupPromo: function() {
            if (this._data.promo !== false) {
                var model = Stencil.getModel('Promo');
                this._references.promo = model.setAccessor(this._data.promo);
            }
        },

        /**
         * coupon
         * 
         * Returns the CouponAccessor reference for the upgrade.
         * 
         * @access  public
         * @return  undefined|CouponAccessor
         */
        coupon: function() {
            return this._references.coupon;
        },

        /**
         * customer
         * 
         * Returns the CustomerAccessor reference for the upgrade.
         * 
         * @access  public
         * @return  CustomerAccessor
         */
        customer: function() {
            return this._references.customer;
        },

        /**
         * getCentsPaid
         * 
         * Returns the number of cents that was processed against the Upgrade
         * record, based on the plan and interval.
         * 
         * @access  public
         * @return  Number
         */
        // getCentsPaid: function() {
        //     var interval = this._data.interval,
        //         plan = this._data.plan.ucfirst(),
        //         column = (interval) + (plan) + 'Rate';
        //     return this._data[column];
        // },

        /**
         * getShareASaleCommissionTypeIdentifier
         * 
         * @access  public
         * @return  String
         */
        getShareASaleCommissionTypeIdentifier: function() {
            var plan = this._data.plan,
                interval = this._data.interval;
            return (plan) + '-' + (interval);
        },

        /**
         * getTapfiliateCommissionTypeIdentifier
         * 
         * @access  public
         * @return  String
         */
        getTapfiliateCommissionTypeIdentifier: function() {
            var plan = this._data.plan,
                interval = this._data.interval;
            return (plan) + '-' + (interval);
        },

        /**
         * promo
         * 
         * @access  public
         * @return  PromoAccessor
         */
        promo: function() {
            return this._references.promo;
        }
    });
});
window.DependencyLoader.push(['Accessor', 'UserModel'], function() {

    /**
     * UserAccessor
     * 
     * @extends Accessor
     */
    window.UserAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('User'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserAccessor')
         */
        _string: 'UserAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupActive();
            this._setupCustomers();
            this._setupSentryEmailChangeListener();
        },

        /**
         * _setupActive
         * 
         * @note    The problem with this method is it'll overwrite the
         *          already-loaded account, but with less data (since the
         *          server-side call doesn't go deep into the AccountAccessor
         *          reference).
         * @note    I don't think above is true; the data is merged via the
         *          jQuery extend method, which is non-destructive
         * @access  protected
         * @return  void
         */
        _setupActive: function() {
            var model = Stencil.getModel('Account');
            this._references.active = model.setAccessor(
                this._data.active
            );
        },

        /**
         * _setupCustomers
         * 
         * @access  protected
         * @return  void
         */
        _setupCustomers: function() {
            this._collections.customers = this._collections.customers || new CustomersCollection();
            this._collections.customers.map(this._data.customers, true);
            Account.once({
                'upgrade': this._setupCustomers.proxy(this)
            });
        },

        /**
         * _setupSentryEmailChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _setupSentryEmailChangeListener: function() {
            this.on({
                'change/email': function(event, newValue) {
                    Raven.setUserContext({
                        email: this.get('email'),
                        id: this.get('id')
                    });
                }
            });
        },

        /**
         * active
         * 
         * Returns the active AccountAccessor for the user. Currently only being
         * used in admin area and analytics below.
         * 
         * @access  public
         * @return  AccountAccessor
         */
        active: function() {
            return this._references.active;
            // return Stencil.account();
        },

        /**
         * admin
         * 
         * @access  public
         * @return  Boolean
         */
        admin: function() {
            return this.setting('admin').toInt() === 1;
        },

        /**
         * customer
         * 
         * Returns whether or not the account has a customer record.
         * 
         * @access  public
         * @return  Boolean
         */
        // customer: function() {
        //     return this._collections.customers.all().length !== 0;
        // },

        /**
         * customers
         * 
         * @access  public
         * @param   undefined|Function filter
         * @return  Array
         */
        customers: function(filter) {
            if (filter === undefined) {
                return this._collections.customers;
            }
            return this._collections.customers.filter(filter);
        },

        /**
         * editor
         * 
         * @access  public
         * @return  Boolean
         */
        editor: function() {
            return this.setting('editor').toInt() === 1;
        },

        /**
         * frozen
         * 
         * @access  public
         * @return  Boolean
         */
        frozen: function() {
            return this.setting('frozen').toInt() === 1;
        },

        /**
         * getInterval
         * 
         * @access  public
         * @return  String
         */
        getInterval: function() {
            if (this.active().upgraded() === true) {
                return this.active().upgrade().get('interval');
            }
            return '';
        },

        /**
         * getPartner
         * 
         * @access  public
         * @return  String
         */
        getPartner: function() {
            if (this.active().promo() === true) {
                return this.active().upgrade().customer().get('gateway');
            }
            return '';
        },

        /**
         * getPlan
         * 
         * @access  public
         * @return  String
         */
        getPlan: function() {
            if (this.active().upgraded() === true) {
                return this.active().upgrade().get('plan');
            }
            return 'free';
        },

        /**
         * getTraits
         * 
         * @todo    Ensure all properties below (eg. frames connections, uploads,
         *          favorites) properly sync to Segment when their values change.
         * @note    Properties here need to be set in Segment:
         *          https://i.imgur.com/oonHgPN.png
         *          If they're not set, they own't be received. A way around this
         *          was to have all traits be set as super properties. The
         *          problem with that was properties would be passed along to
         *          events as well.
         * @access  public
         * @return  Object
         */
        getTraits: function() {
            return {

                // Basics
                _akey: this.active().get('key'),
                _secret: this._data.secret,
                _legacy: this._data.legacy,
                _email: this._data.email,
                _name: this._data.name,
                _plan: this.getPlan(),
                _partner: this.getPartner(),
                _interval: this.getInterval(),
                _promotions: this._data.notification.promotions,
                _resources: this._data.notification.resources,
                _blog: this._data.notification.blog,
                _account: this._data.notification.account,
                _product: this._data.notification.product,

                // Connections
                _connections: this.active().collection('connections').all().length,
                _facebookConnections: this.active().collection('connections').facebook().length,
                _twitterConnections: this.active().collection('connections').twitter().length,

                // Frames
                _frames: this.active().collection('frames').custom().length,

                // Extras
                _stars: this.active().get('favorites').length,
                _monthlyMaxImages: this.active().get('monthlyMaxImages'),
                _monthlySavedImages: this.active().get('monthlySavedImages'),
                _totalSavedImages: this.active().get('totalSavedImages'),
                _bonusImages: this.active().get('bonusImages'),
                _tweetBonus: this.active().get('tweetBonus'),
                _shareBonus: this.active().get('shareBonus'),
                _followBonus: this.active().get('followBonus')
            };
        },

        /**
         * showLegacyWelcome
         * 
         * @access  public
         * @return  void
         */
        showLegacyWelcome: function() {
            if (
                this._data.legacy.toInt() === 1
                && this._data.settings.legacyWelcomed.toInt() === 0
                && ModalUtils.getOpen().length === 0
            ) {
                this.set({
                    'settings.legacyWelcomed': 1
                });
                this.save(['settings.legacyWelcomed']);
                Stencil.navigate('/app/legacy?clean=1');
            }
        }
    });
});
window.DependencyLoader.push(['Accessor', 'UserAccountModel'], function() {

    /**
     * UserAccountAccessor
     * 
     * @extends Accessor
     */
    window.UserAccountAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('UserAccount'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserAccountAccessor')
         */
        _string: 'UserAccountAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
});
window.DependencyLoader.push(['Accessor', 'VectorSetModel'], function() {

    /**
     * VectorSetAccessor
     * 
     * @extends Accessor
     */
    window.VectorSetAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('VectorSet'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorSetAccessor')
         */
        _string: 'VectorSetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
});
window.DependencyLoader.push(['UploadAccessor', 'WatermarkModel'], function() {

    /**
     * WatermarkUploadAccessor
     * 
     * @extends UploadAccessor
     */
    window.WatermarkUploadAccessor = UploadAccessor.extend({

        /**
         * _lastSavedCropSettingsString
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedCropSettingsString: '',

        /**
         * _lastSavedFiltersString
         * 
         * Reference to the last filter-based JSON string that was saved for
         * this watermark. Used to prevent PATCH calls on an upload when it's
         * underlying filters have not changed.
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedFiltersString: '',

        /**
         * _lastSavedStylesString
         * 
         * Reference to the last style-based JSON string that was saved for this
         * watermark. Used to prevent PATCH calls on an upload when it's
         * underlying styles have not changed.
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedStylesString: '',

        /**
         * _layer
         * 
         * @access  protected
         * @var     false|Layer (default: false)
         */
        _layer: false,

        /**
         * _model
         * 
         * @access  protected
         * @var     WatermarkModel
         */
        _model: Stencil.getModel('Watermark'),

        /**
         * _saveCropSettingsTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveCropSettingsTimeout: null,

        /**
         * _saveFiltersTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveFiltersTimeout: null,

        /**
         * _saveStylesTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveStylesTimeout: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkUploadAccessor')
         */
        _string: 'WatermarkUploadAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            if (data.settings.filters === '') {
                // var filters = [];
                // data.settings.filters = JSON.stringify(filters);
// window.t = this;
// LogUtils.log.simple(this.toString(), true);
// LogUtils.log.simple(JSON.stringify(filters), true);
//                 this.set({
//                     'settings.filters': JSON.stringify(filters)
//                 });
            }
            this._super(data);
        },

        /**
         * _clearSaveCropSettingsTimeout
         * 
         * @access  protected
         * @return  void
         */
        _clearSaveCropSettingsTimeout: function() {
            TimeoutPool.clear(this._saveCropSettingsTimeout);
        },

        /**
         * _clearSaveFiltersTimeout
         * 
         * @access  protected
         * @return  void
         */
        _clearSaveFiltersTimeout: function() {
            TimeoutPool.clear(this._saveFiltersTimeout);
        },

        /**
         * _clearSaveStylesTimeout
         * 
         * @access  protected
         * @return  void
         */
        _clearSaveStylesTimeout: function() {
            TimeoutPool.clear(this._saveStylesTimeout);
        },

        /**
         * _getDefaultStyles
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaultStyles: function() {
            var defaultStyles = {
                angle: 0,
                flipX: false,
                flipY: false,
                left: 50,
                stretchX: 1,
                stretchY: 1,
                top: 50,
                width: 30
            };
            return defaultStyles;
        },

        /**
         * _getLayerCropSettings
         * 
         * @access  protected
         * @return  Object
         */
        _getLayerCropSettings: function() {
            var crop = 0,
                cropPositionData = this._layer.getProperty('cropPositionData');
            if (JSON.stringify(cropPositionData) !== JSON.stringify({})) {
                crop = 1;
            }
            var layerCropSettings = {
                    crop: crop,
                    cropPositionData: JSON.stringify(cropPositionData),
                    cropSourceKey: this._layer.getProperty('cropSourceKey')
                },
                clone = DataUtils.clone(layerCropSettings);
            return clone;
        },

        /**
         * _getLayerFilters
         * 
         * @access  protected
         * @return  Object
         */
        _getLayerFilters: function() {
            var layerFilters = this._layer.getProperty('filters'),
                clone = ArrayUtils.clone(layerFilters);
            return clone;
        },

        /**
         * _getLayerStyles
         * 
         * @access  protected
         * @return  Object
         */
        _getLayerStyles: function() {
            var styles = this._layer.getStyles(),
                clone = DataUtils.clone(styles);
            delete clone.order;
            return clone;
        },

        /**
         * _getPreloadUrls
         * 
         * @access  protected
         * @return  Array
         */
        _getPreloadUrls: function() {
            var urls = this._super(),
                url = this.getThumbSrc();
            urls.push(url);
            return urls;
        },

        /**
         * _saveCropSettings
         * 
         * @access  protected
         * @return  Boolean
         */
        _saveCropSettings: function() {
            if (this.deleted() === true) {
                return false;
            }
            var cropSettings = this._getLayerCropSettings(),
                cropSettingsString = JSON.stringify(cropSettings);
            if (cropSettingsString === this._lastSavedCropSettingsString) {
                return false;
            }
            var columns = [
                'settings.crop',
                'settings.cropPositionData',
                'settings.cropSourceKey'
            ];
            this.save(columns);
            this.markCropSettingsAsSaved();
            return true;
        },

        /**
         * _saveFilters
         * 
         * Note that the deleted check here is against the accessor and not the
         * layer. This is because if the layer has been deleted in the database,
         * any PATCH calls against it will naturally fail.
         * 
         * @access  protected
         * @return  Boolean
         */
        _saveFilters: function() {
            if (this.deleted() === true) {
                return false;
            }
            var filters = this._getLayerFilters(),
                filtersString = JSON.stringify(filters);
            if (filtersString === this._lastSavedFiltersString) {
                return false;
            }
            this.save(['settings.filters']);
            this.markFiltersAsSaved();
            return true;
        },

        /**
         * _saveStyles
         * 
         * Note that the deleted check here is against the accessor and not the
         * layer. This is because if the layer has been deleted in the database,
         * any PATCH calls against it will naturally fail.
         * 
         * @access  protected
         * @return  Boolean
         */
        _saveStyles: function() {
            if (this.deleted() === true) {
                return false;
            }
            var styles = this._getLayerStyles(),
                stylesString = JSON.stringify(styles);
            if (stylesString === this._lastSavedStylesString) {
                return false;
            }
            this.save(['settings.styles']);
            this.markStylesAsSaved();
            return true;
        },

        /**
         * addToCanvas
         * 
         * At the moment, the only time <focus> is set to false is when this
         * method is called from the User.login routine. The intention is to
         * prevent any watermarks from being focused on when they're simply
         * turned on via logging in.
         * 
         * @access  public
         * @param   Boolean focus
         * @return  Boolean
         */
        addToCanvas: function(focus) {
            if (JSONUtils.valid(this._data.settings.filters) === false) {
                LogUtils.log.simple('JSON parse error (W:aTC)', true);
                return false;
            }
            if (JSONUtils.valid(this._data.settings.styles) === false) {
                LogUtils.log.simple('JSON parse error (W:aTC)', true);
                return false;
            }
            var filters = JSON.parse(this._data.settings.filters),
                styles = JSON.parse(this._data.settings.styles),
                canvas = Canvases.Preview,
                key = this._data.key,
                layer;
            if (this._data.vector.toInt() === 0) {
                var cropPositionData = {},
                    cropSourceKey = '';
                if (this.setting('crop').toInt() === 1) {
                    cropPositionData = this.setting('cropPositionData');
                    cropPositionData = JSON.parse(cropPositionData);
                    cropSourceKey = this.setting('cropSourceKey');
                    // console.log(cropPositionData);
                    // console.log(cropSourceKey);
                }
                layer = canvas.addWatermarkBitmapImageLayer({
                    color: false,
                    cropPositionData: cropPositionData,
                    cropSourceKey: cropSourceKey,
                    filters: filters,
                    image: key,
                    styles: styles,
                    type: 'image',
                    vector: false,
                    watermark: true
                });
            } else {
                layer = canvas.addWatermarkVectorImageLayer({
                    color: this._data.color.toInt() === 1,
                    cropPositionData: {},
                    cropSourceKey: '',
                    filters: filters,
                    image: key,
                    styles: styles,
                    type: 'image',
                    vector: true,
                    watermark: true
                });
            }
            var drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            drawing.once({
                'draw': function(event) {
                    if (focus === true) {
                        this.select();
                    }
                    canvas.render();
                    drawing.animate();
                }
            });
            drawing.draw();
            return true;
        },

        /**
         * delete
         * 
         * @note    Cannot use removeAll method because that would remove the
         *          accessor from those collections (which we don't want to do,
         *          since Watermarks work differently and need to be available
         *          in memory).
         * @access  public
         * @return  void
         */
        delete: function() {
            this.push('usable', 0);
            // Account.favorites.remove(this);
            this.triggerHandler('delete');
            jQuery.each(this._within, function(index, collection) {
                collection.triggerHandler('update');
            });
            // this.removeAll();
        },

        /**
         * getThumbCheckedAttribute
         * 
         * @access  public
         * @return  String
         */
        getThumbCheckedAttribute: function() {
            var checkedAttribute = '';
            if (this.setting('active').toInt() === 1) {
                checkedAttribute = 'checked="checked" ';
            }
            return checkedAttribute;
        },

        /**
         * getThumbKey
         * 
         * @access  public
         * @return  String
         */
        getThumbKey: function() {
            var crop = this.setting('crop').toInt();
            if (crop === 0) {
                var thumbKey = this._super();
                return thumbKey;
            }
            var thumbKey = this.setting('cropSourceKey');
            return thumbKey;
        },

        /**
         * getThumbSrc
         * 
         * @access  public
         * @return  String
         */
        getThumbSrc: function() {
            var crop = this.setting('crop').toInt(),
                src = this._super();
            if (crop === 0) {
                return src;
            }
            var cropPositionData = this.setting('cropPositionData'),
                cropPositionData = JSON.parse(cropPositionData),
                key = this.getThumbKey(),
                src = ImageUtils.url.thumb(key, {
                    type: 'thumb',
                    useCloudinary: true
                });
            src = ImageUtils.applyCropTransformation(src, cropPositionData);
            return src;
        },

        /**
         * markCropSettingsAsSaved
         * 
         * @access  public
         * @return  void
         */
        markCropSettingsAsSaved: function() {
            var cropSettings = this._getLayerCropSettings();
            this._lastSavedCropSettingsString = JSON.stringify(cropSettings);
        },

        /**
         * markFiltersAsSaved
         * 
         * @access  public
         * @return  void
         */
        markFiltersAsSaved: function() {
            var filters = this._getLayerFilters();
            this._lastSavedFiltersString = JSON.stringify(filters);
        },

        /**
         * markStylesAsSaved
         * 
         * @access  public
         * @return  void
         */
        markStylesAsSaved: function() {
            var styles = this._getLayerStyles();
            this._lastSavedStylesString = JSON.stringify(styles);
        },

        /**
         * preloadDrawingImage
         * 
         * @access  public
         * @return  Boolean
         */
        preloadDrawingImage: function() {
            if (JSONUtils.valid(this._data.settings.styles) === false) {
                LogUtils.log.simple('JSON parse error (W:pDI)q', true);
                return false;
            }
            var styles = JSON.parse(this._data.settings.styles),
                dimensions = Canvases.Preview.getRenderedDimensions(),
                percentage = styles.width.toFloat() / 100,
                pixels = (dimensions.width * percentage).round(4);
            pixels = pixels.round(0);
            var ratio = UserAgentUtils.getDevicePixelRatio(),
                key = this._data.key;
            pixels *= ratio;
            var url = ImageUtils.url.thumb(key, {
                    type: 'scale',
                    width: pixels.round(0)
                }),
                urls = [url];
            ImageUtils.load.urls(urls, true);
            return true;
        },

        /**
         * removeFromCanvas
         * 
         * @access  public
         * @return  void
         */
        removeFromCanvas: function() {
            this._layer.triggerHandler('delete');
        },

        /**
         * setCropSettings
         * 
         * @access  public
         * @return  void
         */
        setCropSettings: function() {
            var layerCropSettings = this._getLayerCropSettings(),
                delay = Config.getSaveDelay('watermark');
            this.set({
                'settings.crop': layerCropSettings.crop,
                'settings.cropPositionData': layerCropSettings.cropPositionData,
                'settings.cropSourceKey': layerCropSettings.cropSourceKey
            });
            Stencil.account().draft().setConfiguration();
            this._clearSaveCropSettingsTimeout();
            this._saveCropSettingsTimeout = this._saveCropSettings.delay(delay, this);
        },

        /**
         * setDefaultSettings
         * 
         * @todo!   Handle case where watermark is really tall
         * @access  public
         * @return  void
         */
        setDefaultSettings: function() {
            var styles = this._getDefaultStyles(),
                columns = [
                    // 'settings.crop',
                    // 'settings.cropPositionData',
                    // 'settings.cropSourceKey',
                    'settings.filters',
                    'settings.styles'
                ];
            this.set({
                // 'settings.crop': JSON.stringify(0),
                // 'settings.cropPositionData': JSON.stringify({}),
                // 'settings.cropSourceKey': '',
                'settings.filters': JSON.stringify([]),
                'settings.styles': JSON.stringify(styles)
            });
            this.save(columns);
        },

        /**
         * setFilters
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the styles associated with the watermark (excluding the
         * position-style, which is removed via the helper <_getLayerFilters>
         * method).
         * 
         * Also triggers a setConfiguration call against the draft to ensure
         * that the draft has the most up-to-date watermarks-setting.
         * 
         * @access  public
         * @return  void
         */
        setFilters: function() {
            var filters = this._getLayerFilters(),
                delay = Config.getSaveDelay('watermark');
            this.set({
                'settings.filters': JSON.stringify(filters)
            });
            Stencil.account().draft().setConfiguration();
            this._clearSaveFiltersTimeout();
            this._saveFiltersTimeout = this._saveFilters.delay(delay, this);
        },

        /**
         * setLayer
         * 
         * @access  public
         * @param   WatermarkBitmapLayer layer
         * @return  void
         */
        setLayer: function(layer) {
            this._layer = layer;
        },

        /**
         * setStyles
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the styles associated with the watermark (excluding the
         * position-style, which is removed via the helper <_getLayerStyles>
         * method).
         * 
         * Also triggers a setConfiguration call against the draft to ensure
         * that the draft has the most up-to-date watermarks-setting.
         * 
         * @access  public
         * @return  void
         */
        setStyles: function() {
            var styles = this._getLayerStyles(),
                delay = Config.getSaveDelay('watermark');
            this.set({
                'settings.styles': JSON.stringify(styles)
            });
            Stencil.account().draft().setConfiguration();
            this._clearSaveStylesTimeout();
            this._saveStylesTimeout = this._saveStyles.delay(delay, this);
        }
    });
});
window.DependencyLoader.push(['Collection', 'CategoryModel'], function() {

    /**
     * CategoriesCollection
     * 
     * @extends Collection
     */
    window.CategoriesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Category'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoriesCollection')
         */
        _string: 'CategoriesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @return  void
         */
        sort: function() {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = '/categories/sort';
            RequestUtils.ajax({
                signature: {"basename":"Categories.js","line":53},
                url: path,
                type: 'POST',
                data: {
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = '63-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * Collection
     * 
     * @events  add
     *          remove
     *          update
     *          list
     * @extends Base
     */
    window.Collection = Base.extend({

        /**
         * _accessors
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _accessors: [],

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'collection')
         */
        _classType: 'collection',

        /**
         * _model
         * 
         * @access  protected
         * @var     Model (default: null)
         */
        _model: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Collection')
         */
        _string: 'Collection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            this._accessors = [];
        },

        /**
         * add
         * 
         * @example Collection.add(Accessor)
         *          Collection.add([Accessor])
         * @note    <within> call below ensures Accessor knows which collections
         *          it's part of, so that it can properly remove itself from
         *          them when it's deleted.
         * @note    <add> event triggered passes in the position within the
         *          collection so that the UI drawn is appropriate (eg. at the
         *          beginning or at the end).
         * @access  public
         * @param   Array|Accessor accessors
         * @param   Boolean push Whether the object(s) should be pushed or
         *          unshifted against the array
         * @return  void
         */
        add: function(accessors, push) {
            var _this = this,
                added = 0;
            if (jQuery.isArray(accessors) === false) {
                accessors = [accessors];
            }
            jQuery.each(accessors, function(index, accessor) {
                ++added;
                if (push === true) {
                    _this._accessors.push(accessor);
                } else {
                    _this._accessors.unshift(accessor);
                }
                accessor.within(_this);
                _this.triggerHandler('add',
                    [accessor, _this._accessors.indexOf(accessor)]
                );
            });
            if (added > 0) {
                this.triggerHandler('update');
            }
        },

        /**
         * all
         * 
         * @access  public
         * @return  Array
         */
        all: function() {
            return this._accessors;
        },

        /**
         * each
         * 
         * @access  public
         * @param   Function iterator
         * @return  void
         */
        each: function(iterator) {
            jQuery.each(this._accessors, function(index, accessor) {
                iterator(index, accessor);
            });
        },

        /**
         * empty
         * 
         * @access  public
         * @return  void
         */
        empty: function() {
            this.remove(this._accessors.slice());
            this.triggerHandler('empty');
        },

        /**
         * filter
         * 
         * @access  public
         * @param   Function filter
         * @return  Array
         */
        filter: function(filter) {
            var matching = [];
            jQuery.each(this._accessors, function(index, accessor) {
                if (filter(index, accessor) === true) {
                    matching.push(accessor);
                }
            });
            return matching;
        },

        /**
         * find
         * 
         * @access  public
         * @param   String key
         * @return  false|Accessor
         */
        find: function(key) {
            var matching = this.filter(function(index, accessor) {
                return accessor.get('key') === key;
            });
            if (matching.length === 0) {
                return false;
            }
            return matching[0];
        },

        /**
         * first
         * 
         * @access  public
         * @return  Object
         */
        first: function() {
            return this._accessors[0];
        },

        /**
         * last
         * 
         * @access  public
         * @return  Object
         */
        last: function() {
            var position = this._accessors.length - 1;
            return this._accessors[position];
        },

        /**
         * length
         * 
         * @access  public
         * @return  Number
         */
        length: function() {
            return this._accessors.length;
        },

        /**
         * list
         * 
         * @note    I check for a "timeout" <textStatus> here (as opposed to
         *          other ajax calls) because there is a higher possibility that
         *          a request times out, since some of the list calls against a
         *          collection will be for Pixabay/The Noun Project, which have
         *          been known to timeout. I've checked the backend, and it looks
         *          like Collection.list calls are currently the only ones that
         *          actually attempt to make a connection to these 3rd parties.
         *          /save, and /feature don't, since they depend on passed in
         *          URLs.
         * @todo    Currently, a timeout will result in the same UI as empty
         *          search results. Update it so that it communicates that the
         *          user needs to try again.
         * @access  public
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        list: function(data, callback) {
            var _this = this,
                path = this._model.getBase(),
                signature = {"basename":"Collection.js","line":219};
            RequestUtils.ajax({
                signature: signature,
                url: path,
                type: 'GET',
                data: data,
                error: function(jqXHR, textStatus, errorThrown) {

                    // Console logging
                    App.log('jQuery AJAX error', true);
                    App.log(signature, true);
                    App.log(arguments, true);

                    // Timeouts are more common with resource collections
                    if (textStatus === 'timeout') {
                        _this.map([], true);
                        callback && callback({
                            data: {
                                more: false
                            }
                        });
                        _this.triggerHandler('list');
                    } else {

                        // Segment tracking
                        Track.event('Ajax Error (Collection)', {
                            _code: signature.line,
                            _reference: signature.basename,
                            _data: JSON.stringify(data),
                            _url: path,
                            _textStatus: textStatus
                        });

                        // Connection check
                        RequestUtils.alive(function() {
                            var code = signature.line,
                                reference = signature.basename;
                            Stencil.error(code, reference);
                        });
                    }
                },
                success: function(response) {
                    if (response.success === true) {
                        _this.map(response.data.objects, true);
                        callback && callback(response);
                        _this.triggerHandler('list');
                    } else {
                        var error = Stencil.extractError(response),
                            code = '267-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * map
         * 
         * Maps raw data to it's associated accessors, and then pushes them into
         * the collection.
         * 
         * @example Collection.map(Object, true)
         *          Collection.map([Object], false)
         * @access  public
         * @param   Array|Object objects
         * @param   Boolean push Whether the object(s) should be pushed or
         *          unshifted against the array
         * @return  Array
         */
        map: function(objects, push) {
            var _this = this,
                accessors = [];
            if (jQuery.isArray(objects) === false) {
                objects = [objects];
            }
            jQuery.each(objects, function(index, obj) {
                accessors.push(_this._model.setAccessor(obj));
            });
            this.add(accessors, push);
            return accessors;
        },

        /**
         * move
         * 
         * @see     http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
         * @access  public
         * @param   Accessor accessor
         * @param   Number position
         * @return  void
         */
        move: function(accessor, position) {
            var original = this._accessors.indexOf(accessor);
            this._accessors.splice(
                position,
                0,
                this._accessors.splice(original, 1)[0]
            );
            this.triggerHandler('move', [accessor, position, original]);
        },

        /**
         * remove
         * 
         * @example Collection.remove(Accessor)
         *          Collection.remove([Accessor])
         * @access  public
         * @param   Array|Accessor accessors
         * @return  Number
         */
        remove: function(accessors) {
            var _this = this,
                removed = 0;
            if (jQuery.isArray(accessors) === false) {
                accessors = [accessors];
            }
            jQuery.each(accessors, function(index, accessor) {
                index = _this._accessors.indexOf(accessor);
                if (index !== -1) {
                    ++removed;
                    _this._accessors.splice(index, 1);
                    _this.triggerHandler('remove', [accessor]);
                }
            });
            if (removed > 0) {
                this.triggerHandler('update');
            }
            return removed;
        }
    });
});
window.DependencyLoader.push(['Collection', 'ColorModel'], function() {

    /**
     * ColorsCollection
     * 
     * @extends Collection
     */
    window.ColorsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Color'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorsCollection')
         */
        _string: 'ColorsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * addColor
         * 
         * @access  public
         * @param   String rgbaColorStr
         * @return  ColorAccessor
         */
        addColor: function(rgbaColorStr) {
            var hex = ColorUtils.convert(rgbaColorStr, 'hex'),
                colors = this.map({
                    'class': 'color',
                    'key': 'clrX' + DataUtils.getRandomString(8).toLowerCase(),
                    'label': hex.toLowerCase(),
                    'color': rgbaColorStr
                }, false);
            this._model.create({
                'label': hex.toLowerCase(),
                'color': rgbaColorStr
            }, function(data) {
                colors[0].swap(data.object);
            });
            return colors[0];
        }
    });
});
window.DependencyLoader.push(['Collection', 'ConnectionModel'], function() {

    /**
     * ConnectionsCollection
     * 
     * @extends Collection
     */
    window.ConnectionsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Connection'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionsCollection')
         */
        _string: 'ConnectionsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            // this.on({
            //     'update': function(event) {
            //         Track.user();
            //     }
            // });
        },

        /**
         * facebook
         * 
         * @access  public
         * @return  Array
         */
        facebook: function() {
            return this.network('facebook');
        },

        /**
         * network
         * 
         * @access  public
         * @param   String network
         * @return  Array
         */
        network: function(network) {
            return this.filter(function(index, connection) {
                return connection.get('network') === network;
            });
        },

        /**
         * twitter
         * 
         * @access  public
         * @return  Array
         */
        twitter: function() {
            return this.network('twitter');
        }
    });
});
window.DependencyLoader.push(['Collection', 'CouponModel'], function() {

    /**
     * CouponsCollection
     * 
     * @extends Collection
     */
    window.CouponsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Coupon'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CouponsCollection')
         */
        _string: 'CouponsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'CustomerModel'], function() {

    /**
     * CustomersCollection
     * 
     * @extends Collection
     */
    window.CustomersCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Customer'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomersCollection')
         */
        _string: 'CustomersCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'FeatureModel'], function() {

    /**
     * FeaturesCollection
     * 
     * @extends Collection
     */
    window.FeaturesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Feature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FeaturesCollection')
         */
        _string: 'FeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = '/features/sort';
            RequestUtils.ajax({
                signature: {"basename":"Features.js","line":54},
                url: path,
                type: 'POST',
                data: {
                    category: category.get('key'),
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = '65-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push(['Collection', 'FontModel'], function() {

    /**
     * FontsCollection
     * 
     * @see     https://speakerdeck.com/bramstein/web-fonts-performance
     * @events  load/all/normal
     * @extends Collection
     */
    window.FontsCollection = Collection.extend({

        /**
         * _loaded
         * 
         * Keeps track of fonts that have been loaded using familyName:n4
         * notation. This ensures that there aren't race-conditions between
         * loading the normal versions of fonts, and the full versions (which
         * may include bold, italic and/or bold + italic versions).
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _loaded: [],

        /**
         * _loading
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _loading: [],

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Font'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontsCollection')
         */
        _string: 'FontsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * findByFamilyName
         * 
         * @access  public
         * @param   String familyName
         * @return  false|FontAccessor
         */
        findByFamilyName: function(familyName) {
            var fonts = this.filter(function(index, font) {
                return font.get('familyName') === familyName;
            });
            if (fonts.length === 0) {
                return false;
            }
            return fonts.shift();
        },

        /**
         * getDefaults
         * 
         * @access  public
         * @return  Array
         */
        getDefaults: function() {
            return this.filter(function(index, font) {
                return font.get('uploaded').toInt() === 0;
            });
        },

        /**
         * getLoaded
         * 
         * @access  public
         * @return  Array
         */
        getLoaded: function() {
            return this._loaded;
        },

        /**
         * getLoading
         * 
         * @access  public
         * @return  Array
         */
        getLoading: function() {
            return this._loading;
        },

        /**
         * getUploaded
         * 
         * @access  public
         * @return  Array
         */
        getUploaded: function() {
            return this.filter(function(index, font) {
                return font.get('uploaded').toInt() === 1
                    && font.get('hasRegularAccess').toInt() === 1;
            });
        },

        /**
         * loadAllNormal
         * 
         * @access  public
         * @param   Array fontsToExclude
         * @return  void
         */
        loadAllNormal: function(fontsToExclude) {

            /**
             * Group fonts to load by whether they were uploaded or not
             * (excluding native and intentionally-excluded fonts).
             */
            var googleFontsToLoad = this.filter(function(index, font) {
                    var familyName = font.get('familyName');
                    return fontsToExclude.indexOf(familyName) === -1
                        && font.get('isLegacyFont') === false
                        && font.get('native').toInt() === 0
                        && font.get('uploaded').toInt() === 0;
                }),
                customFontsToLoad = this.filter(function(index, font) {
                    var familyName = font.get('familyName');
                    return fontsToExclude.indexOf(familyName) === -1
                        && font.get('native').toInt() === 0
                        && font.get('uploaded').toInt() === 1;
                });

            // Reformat the arrays for WebFont compatibility, and track them
            var googleFontFamiliesToLoad = (function(googleFontsToLoad) {
                    var familyNames = [], index, familyName;
                    for (index in googleFontsToLoad) {
                        familyName = googleFontsToLoad[index].get('familyName');
                        familyName += ':n4';
                        this._loading.push(familyName);
                        familyNames.push(familyName);
                    }
                    return familyNames;
                }).apply(this, [googleFontsToLoad]),
                customFontFamiliesToLoad = (function(customFontsToLoad) {
                    var familyNames = [], index, familyName;
                    for (index in customFontsToLoad) {
                        familyName = customFontsToLoad[index].get('familyName');
                        familyName += ':n4';
                        this._loading.push(familyName);
                        familyNames.push(familyName);
                    }
                    return familyNames;
                }).apply(this, [customFontsToLoad]);

            /**
             * Boot it in, and use the fontactive event to check whether all
             * the request fonts have been loaded. Using this instead of the
             * active event due to a bug with the library.
             */
            WebFont.load({
                classes: false,
                custom: {
                    families: DataUtils.convertGoogleFontNames(customFontFamiliesToLoad)
                },
                fontactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loaded.push(formattedFamilyName);
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/all/normal');
                    }
                }).proxy(this),
                fontinactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/all/normal');
                    }
                }).proxy(this),
                google: {
                    families: DataUtils.convertGoogleFontNames(googleFontFamiliesToLoad)
                },
                timeout: 5000
            });
        },

        /**
         * loadUploadedNormal
         * 
         * @access  public
         * @return  void
         */
        loadUploadedNormal: function() {

            // Get the uploaded FontAccessor's
            var customFontsToLoad = this.filter(function(index, font) {
                var familyName = font.get('familyName');
                return font.get('native').toInt() === 0
                    && font.get('uploaded').toInt() === 1;
            });

            // Reformat the fonts for WebFont compatibility, and track them
            var customFontFamiliesToLoad = (function(customFontsToLoad) {
                var familyNames = [], index, familyName;
                for (index in customFontsToLoad) {
                    familyName = customFontsToLoad[index].get('familyName');
                    familyName += ':n4';
                    this._loading.push(familyName);
                    familyNames.push(familyName);
                }
                return familyNames;
            }).apply(this, [customFontsToLoad]);

            /**
             * Boot it in, and use the fontactive event to check whether all
             * the request fonts have been loaded. Using this instead of the
             * active event due to a bug with the library.
             */
            WebFont.load({
                classes: false,
                custom: {
                    families: customFontFamiliesToLoad
                },
                fontactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loaded.push(formattedFamilyName);
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/uploaded/normal');
                    }
                }).proxy(this),
                fontinactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/uploaded/normal');
                    }
                }).proxy(this),
                timeout: 5000
            });
        }
    });
});
window.DependencyLoader.push(['Collection', 'FrameModel'], function() {

    /**
     * FramesCollection
     * 
     * @extends Collection
     */
    window.FramesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Frame'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FramesCollection')
         */
        _string: 'FramesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            // this.on({
            //     'update': function(event) {
            //         Track.user();
            //     }
            // });
        },

        /**
         * custom
         * 
         * @access  public
         * @return  Array
         */
        custom: function() {
            return this.filter(function(index, frame) {
                return frame.get('type') === 'custom';
            });
        }
    });
});
window.DependencyLoader.push(['Collection', 'GoogleFontModel'], function() {

    /**
     * GoogleFontsCollection
     * 
     * @extends Collection
     */
    window.GoogleFontsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GoogleFont'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontsCollection')
         */
        _string: 'GoogleFontsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['ResourceFeaturesCollection', 'GraphicFeatureModel'], function() {

    /**
     * GraphicFeaturesCollection
     * 
     * @extends ResourceFeaturesCollection
     */
    window.GraphicFeaturesCollection = ResourceFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GraphicFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicFeaturesCollection')
         */
        _string: 'GraphicFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['ResourcesCollection', 'GraphicResourceModel'], function() {

    /**
     * GraphicResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.GraphicResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GraphicResource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicResourcesCollection')
         */
        _string: 'GraphicResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['FeaturesCollection', 'ImageFeatureModel'], function() {

    /**
     * ImageFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.ImageFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('ImageFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageFeaturesCollection')
         */
        _string: 'ImageFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {
            var accessors = this.all();
            if (category.syncedFeatures.contains.apply(category, [accessors]) === false) {
                category.unbind('syncedFeatures/add');
                category.once({
                    'syncedFeatures/add': this.sort.proxy(this, [category])
                });
            } else {
                this._super(category);
            }
        }
    });
});
window.DependencyLoader.push(['Collection', 'ImageModel'], function() {

    /**
     * ImagesCollection
     * 
     * @extends Collection
     */
    window.ImagesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Image'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImagesCollection')
         */
        _string: 'ImagesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'OverrideModel'], function() {

    /**
     * OverridesCollection
     * 
     * @extends Collection
     */
    window.OverridesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Override'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OverridesCollection')
         */
        _string: 'OverridesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * service
         * 
         * @access  public
         * @param   String serviceKey
         * @return  OverrideAccessor|undefined
         */
        service: function(serviceKey) {
            var overrides = this.services(),
                index,
                override;
            for (index in overrides) {
                override = overrides[index];
                if (override.get('name') === serviceKey) {
                    return override;
                }
            }
            return undefined;
        },

        /**
         * services
         * 
         * @access  public
         * @return  void
         */
        services: function() {
            var overrides = this.filter(function(index, override) {
                return override.get('type') === 'service';
            });
            return overrides;
        }
    });
});
window.DependencyLoader.push(['ResourceFeaturesCollection', 'PhotoFeatureModel'], function() {

    /**
     * PhotoFeaturesCollection
     * 
     * @extends ResourceFeaturesCollection
     */
    window.PhotoFeaturesCollection = ResourceFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PhotoFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoFeaturesCollection')
         */
        _string: 'PhotoFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['ResourcesCollection', 'PhotoResourceModel'], function() {

    /**
     * PhotoResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.PhotoResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PhotoResource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoResourcesCollection')
         */
        _string: 'PhotoResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'PromoSetModel'], function() {

    /**
     * PromoSetsCollection
     * 
     * @extends Collection
     */
    window.PromoSetsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PromoSet'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoSetsCollection')
         */
        _string: 'PromoSetsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['ResourceFeaturesCollection', 'QuoteFeatureModel'], function() {

    /**
     * QuoteFeaturesCollection
     * 
     * @extends ResourceFeaturesCollection
     */
    window.QuoteFeaturesCollection = ResourceFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('QuoteFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteFeaturesCollection')
         */
        _string: 'QuoteFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['ResourcesCollection', 'QuoteResourceModel'], function() {

    /**
     * QuoteResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.QuoteResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('QuoteResource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteResourcesCollection')
         */
        _string: 'QuoteResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['FeaturesCollection'], function() {

    /**
     * ResourceFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.ResourceFeaturesCollection = FeaturesCollection.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceFeaturesCollection')
         */
        _string: 'ResourceFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * This sort method is designed specifically for collections that may
         * include resource accessors (eg. photos, graphics, quotes). It's
         * needed because when a resource is added to a collection (including an
         * area favorites category/collection), the previous sort method would
         * check whether the key of a resource (eg. Pexels:1234) was included in
         * the _syncedFeatures array. This would invariably be false, since it's
         * the asset that would be in there.
         * 
         * Therefore, needed to loop over the accessors, and if it was a
         * ResourceAccessor or QuoteResourceAccessor, lookup the asset, and do
         * the search in the _syncedFeatures array within that.
         * 
         * @see     https://github.com/onassar/Stencil/blob/9cbc58f42361ee2ddbdeb53c54fd5c64ae2fda75/TurtlePHP/application/webroot/app/static/js/collections/QuoteFeatures.js
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {
            var accessors = this.all(),
                categoryContainsSyncedFeatures = function() {
                    if (accessors.length === 0) {
                        return category.syncedFeatures.contains.apply(category, [accessors]) === true;
                    }
                    var featureObjects = [],
                        index,
                        accessor;
                    for (index in accessors) {
                        accessor = accessors[index];
                        if (accessor.is.resource.apply(accessor) === true) {
                            featureObjects.push(accessor.getAsset());
                        } else {
                            featureObjects.push(accessor);
                        }
                    }
                    return category.syncedFeatures.contains.apply(category, [featureObjects]) === true;
                };
            if (categoryContainsSyncedFeatures() === false) {
                category.unbind('syncedFeatures/add');
                category.once({
                    'syncedFeatures/add': this.sort.proxy(this, [category])
                });
            } else {
                this._super(category);
            }
        }
    });
});
window.DependencyLoader.push(['Collection', 'ResourceModel'], function() {

    /**
     * ResourcesCollection
     * 
     * @extends Collection
     */
    window.ResourcesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Resource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourcesCollection')
         */
        _string: 'ResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['FeaturesCollection', 'TemplateFeatureModel'], function() {

    /**
     * TemplateFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.TemplateFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('TemplateFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateFeaturesCollection')
         */
        _string: 'TemplateFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {
            var accessors = this.all();
            if (category.syncedFeatures.contains.apply(category, [accessors]) === false) {
                category.unbind('syncedFeatures/add');
                category.once({
                    'syncedFeatures/add': this.sort.proxy(this, [category])
                });
            } else {
                this._super(category);
            }
        }
    });
});
window.DependencyLoader.push(['FeaturesCollection', 'UploadFeatureModel'], function() {

    /**
     * UploadFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.UploadFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('UploadFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadFeaturesCollection')
         */
        _string: 'UploadFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'UploadModel'], function() {

    /**
     * UploadsCollection
     * 
     * @extends Collection
     */
    window.UploadsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Upload'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadsCollection')
         */
        _string: 'UploadsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'UserModel'], function() {

    /**
     * UsersCollection
     * 
     * @extends Collection
     */
    window.UsersCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('User'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UsersCollection')
         */
        _string: 'UsersCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['Collection', 'VectorSetModel'], function() {

    /**
     * VectorSetsCollection
     * 
     * @extends Collection
     */
    window.VectorSetsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('VectorSet'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorSetsCollection')
         */
        _string: 'VectorSetsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
});
window.DependencyLoader.push(['UploadFeaturesCollection', 'WatermarkFeatureModel'], function() {

    /**
     * WatermarkFeaturesCollection
     * 
     * @extends UploadFeaturesCollection
     */
    window.WatermarkFeaturesCollection = UploadFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('WatermarkFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkFeaturesCollection')
         */
        _string: 'WatermarkFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * usable
         * 
         * @access  public
         * @return  Array
         */
        usable: function() {
            return this.filter(function(index, accessor) {
                return accessor.get('usable').toInt() === 1;
            });
        }
    });
});
window.DependencyLoader.push(['UploadsCollection', 'WatermarkModel'], function() {

    /**
     * WatermarksCollection
     * 
     * @extends UploadsCollection
     */
    window.WatermarksCollection = UploadsCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Watermark'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarksCollection')
         */
        _string: 'WatermarksCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * usable
         * 
         * @access  public
         * @return  Array
         */
        usable: function() {
            return this.filter(function(index, accessor) {
                return accessor.get('usable').toInt() === 1;
            });
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * AccountsController
     * 
     * @extends AppController
     */
    window.AccountsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * checkout
         * 
         * @access  public
         * @param   String plan
         * @param   String interval
         * @param   Object params
         * @return  void
         */
        checkout: function(plan, interval, params) {
            var type = 'direct';
            if (params.curtain) {
                type = 'curtain';
            }
            if (Account.guest() === true) {
                var path = '/app/signup?',
                    redirect = '/app/checkout/' + (plan) + '/' + (interval);
                if (type === 'curtain') {
                    path += 'curtain&';
                    redirect += '?curtain';
                }
                redirect = encodeURIComponent(redirect);
                path += 'redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (
                    Account.upgraded() === true
                    || User.admin() === true
                    || User.editor() === true
                ) {
                    App.getElement().removeClass('curtain');
                    Stencil.navigate('/app/only/free');
                } else {
                    this.track.event({
                        _plan: plan,
                        _interval: interval,
                        _type: type
                    });
                    this.track.page();
                    ModalUtils.closeExcept(['Checkout']);
                    var checkoutModal = ModalUtils.get('Checkout');
                    if (checkoutModal === false) {
                        checkoutModal = ModalUtils.showCheckout(plan, interval, type);
                    }
                    checkoutModal.interval(interval);
                    App.unrestrict();
                }
            }
        },

        /**
         * connections
         * 
         * @access  public
         * @param   String network
         * @param   Object params
         * @return  void
         */
        connections: function(type, params) {
            if (Account.guest() === true) {
                var path = '/app/login',
                    redirect = '/app/settings/' + (type) + '/connected';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                this.track.event({
                    _type: type
                });
                this.track.page();
                ModalUtils.closeExcept(['Settings']);
                var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                modal.getSettings('social').show();
                ModalUtils.showConnections(type);
                App.unrestrict();
            }
        },

        /**
         * countdown
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        countdown: function(params) {
            if (
                (
                    Account.upgraded() === true
                    && Stencil.account().get('monthlyMaxImages').toInt() === 0
                )
                || User.admin() === true
                || User.editor() === true
            ) {
                Stencil.navigate('/app/not/upgraded');
            } else {
                this.track.event();
                this.track.page();
                ModalUtils.close();
                ModalUtils.showCountdown(params.onboard !== undefined);
                App.unrestrict();
            }
        },

        /**
         * plan
         * 
         * @access  public
         * @var     Object
         */
        plan: {

            /**
             * switch
             * 
             * @access  public
             * @param   String plan
             * @param   Object params
             * @return  void
             */
            switch: function(plan, params) {
                this.track.event();
                this.track.page();
                ModalUtils.closeExcept(['Settings']);
                var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                modal.getSettings('plan').show();
                ModalUtils.showPlanSwitch(plan);
                App.unrestrict();
            },

            /**
             * switched
             * 
             * @access  public
             * @param   String plan
             * @param   Object data
             * @param   Object params
             * @return  void
             */
            switched: function(plan, data, params) {
                this.track.event();
                this.track.page();
                ModalUtils.closeExcept(['Settings']);
                var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                modal.getSettings('plan').show();
                ModalUtils.showPlanSwitched(plan, data);
                App.unrestrict();
            }
        },

        /**
         * plans
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        plans: function(params) {
            // if (
            //     (
            //         Account.upgraded() === true
            //         && Account.plan('unlimited') === true
            //     )
            //     || User.admin() === true
            // ) {
            //     Stencil.navigate('/app/not/upgraded');
            // } else
            {
                this.track.event();
                this.track.page();
                ModalUtils.close();
                ModalUtils.showPlans({
                    curtain: params.curtain !== undefined
                });
                App.unrestrict();
            }
        },

        /**
         * upgrade
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String plan
         * @param   String reason
         * @param   Object params
         * @return  void
         */
        upgrade: function(plan, reason, params) {
            // if (
            //     Account.upgraded() === true
            //     || User.admin() === true
            // ) {
            //     Stencil.navigate('/app/not/upgraded');
            // } else
            {
                this.track.event({
                    _plan: plan,
                    _reason: reason
                });
                this.track.page();
                if (params.additive === undefined) {
                    ModalUtils.close();
                }
                ModalUtils.showUpgrade(plan, 'annually', reason);
                App.unrestrict();
            }
        },

        /**
         * upgraded
         * 
         * @access  public
         * @param   String plan
         * @param   Object params
         * @return  void
         */
        upgraded: function(plan, params) {
            if (Account.upgraded() === false) {
            // if (false) {
                Stencil.navigate('/app/only/upgraded');
            } else {
                this.track.event({
                    _plan: plan
                });
                this.track.page();
                ModalUtils.closeExcept(['Upgraded']);
                ModalUtils.get('Upgraded') || ModalUtils.showUpgraded(plan);
                App.unrestrict();
            }
        },

        /**
         * welcomeTour
         * 
         * @access  public
         * @param   String step
         * @param   Object params
         * @return  void
         */
        welcomeTour: function(step, params) {
            if (params === undefined) {
                params = step;
                step = 1;
            }
            this.track.event({
                _step: step
            });
            this.track.page();
            ModalUtils.closeExcept(['WelcomeTour']);
            var modal = ModalUtils.get('WelcomeTour') || ModalUtils.showWelcomeTour();
            modal.step(step);
            App.unrestrict();
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * AdminController
     * 
     * @extends AppController
     */
    window.AdminController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * cacheRefresh
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        cacheRefresh: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/cache/refresh';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    ModalUtils.showCacheRefresh();
                    App.unrestrict();
                }
            }
        },

        /**
         * reimportAssets
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        reimportAssets: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/assets/reimport';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    ModalUtils.showAssetsReimport();
                    App.unrestrict();
                }
            }
        },

        /**
         * section
         * 
         * @access  public
         * @param   String section
         * @param   Object params
         * @return  void
         */
        section: function(section, params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/' + (section);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (
                    User.admin() === false
                    && User.editor() === false
                ) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event({
                        _section: section
                    });
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    modal.getSection(section).show();
                    App.unrestrict();
                }
            }
        },

        /**
         * settings
         * 
         * @access  public
         * @var     Object
         */
        settings: {

            /**
             * services
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            services: function(params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/settings/services';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        ModalUtils.closeExcept(['Admin']);
                        var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                        ModalUtils.showServicesSettings();
                        App.unrestrict();
                    }
                }
            }
        },

        /**
         * images
         * 
         * @access  public
         * @var     Object
         */
        images: {

            /**
             * results
             * 
             * @access  public
             * @param   String query
             * @param   Object params
             * @return  void
             */
            results: function(query, params) {
                if (typeof query === 'object') {
                    params = query;
                    query = '';
                }
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/images';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (
                        User.admin() === false
                        && User.editor() === false
                    ) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event({
                            _query: query
                        });
                        this.track.page();
                        ModalUtils.closeExcept(['Admin']);
                        var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                        modal.getSection('images').show(query);
                        // modal.getSection('users').unload();
                        // modal.getSection('users').load(query);
                        App.unrestrict();
                    }
                }
            }
        },

        /**
         * users
         * 
         * @access  public
         * @var     Object
         */
        users: {

            /**
             * results
             * 
             * @access  public
             * @param   String query
             * @param   Object params
             * @return  void
             */
            results: function(query, params) {
                if (typeof query === 'object') {
                    params = query;
                    query = '';
                }
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users';
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event({
                            _query: query
                        });
                        this.track.page();
                        ModalUtils.closeExcept(['Admin']);
                        var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                        modal.getSection('users').show(query);
                        // modal.getSection('users').unload();
                        // modal.getSection('users').load(query);
                        App.unrestrict();
                    }
                }
            },

            /**
             * search
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            search: function(params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users/search';
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        ModalUtils.closeExcept(['Admin']);
                        var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin(),
                            section = modal.getSection('users'),
                            query = section.getQuery();
                        section.show(query);
                        ModalUtils.showSearchUsers(section);
                        App.unrestrict();
                    }
                }
            },

            /**
             * update
             * 
             * @access  public
             * @param   String key
             * @param   Object params
             * @return  void
             */
            update: function(key, params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users/' + (key);
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        ModalUtils.closeExcept(['Admin']);

                        // 
                        var show = function(user) {
                            var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin(),
                                section = modal.getSection('users'),
                                query = section.getQuery();
                            section.show(query || '');
                            ModalUtils.showUpdateUser(key, section);
                            App.unrestrict();
                        };

                        // 
                        var user = Stencil.getAccessor(key);
                        if (user === false) {
                            App.getBusy().show();
                            var model = Stencil.getModel('User');
                            model.read(key, function(data) {
                                App.getBusy().hide();
                                var user = model.setAccessor(data.object);
                                show(user);
                            });
                        } else {
                            show(user);
                        }
                    }
                }
            }
        }
    });
});
window.DependencyLoader.push('Controller', function() {

    /**
     * AppController
     * 
     * @extends Controller
     */
    window.AppController = Controller.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _getRouter
         * 
         * @access  protected
         * @return  Router
         */
        _getRouter: function() {
            return Stencil.getRouter();
        },

        /**
         * _store
         * 
         * Stores the path currently being experienced.
         * 
         * @access  protected
         * @return  void
         */
        _store: function() {
            var path = '/' + (this._getRouter().current().fragment);
            this._getRouter().setPrevious(path);
        },

        /**
         * alert
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String code
         * @param   Object params
         * @return  void
         */
        alert: function(code, params) {
            if (Stencil.get('alive') === true) {
                this.track.event({
                    _code: code
                });
                this.track.page();
            }
            Alerts.show(code);
            App.unrestrict();
        },

        /**
         * browser
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        browser: function(params) {
            this.track.event();
            this.track.page();
            ModalUtils.close();
            ModalUtils.showBrowser();
            App.unrestrict();
        },

        /**
         * chromeSuccess
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        chromeSuccess: function(params) {
            this.track.event();
            this.track.page();
            ModalUtils.close();
            ModalUtils.showChromeExtensionInstalled();
            App.unrestrict();
        },

        /**
         * cookies
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        cookies: function(params) {
            this.track.event();
            this.track.page();
            ModalUtils.close();
            ModalUtils.showCookies();
            App.unrestrict();
        },

        /**
         * error
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        error: function(params) {
            var code = params.code,
                reference = params.reference;
            this.track.event({
                _code: code,
                _reference: reference
            });
            this.track.page();
            ModalUtils.close();
            ModalUtils.showError(code, reference);
            App.unrestrict();
        },

        /**
         * extras
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        extras: function(params) {
            this.track.event();
            this.track.page();
            ModalUtils.close();
            ModalUtils.showExtras();
            App.unrestrict();
        },

        /**
         * googleFonts
         * 
         * @access  public
         * @return  void
         */
        googleFonts: function() {
            this.track.event();
            this.track.page();
            ModalUtils.close();
            ModalUtils.showGoogleFonts();
            App.unrestrict();
        },

        /**
         * legacy
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        legacy: function(params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event();
                this.track.page();
                ModalUtils.close();
                ModalUtils.showLegacy();
                App.unrestrict();
            }
        },

        /**
         * orientation
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        orientation: function(params) {
            this.track.event();
            this.track.page();
            ModalUtils.showOrientation();
            App.unrestrict();
        },

        /**
         * track
         * 
         * @access  public
         * @var     Object
         */
        track: {

            /**
             * event
             * 
             * Tracks an event relative to the current controller/action.
             * 
             * @access  protected
             * @param   undefined|Object properties
             * @return  void
             */
            event: function(properties) {
                var name = Stencil.getRouter().current().route.toString();
                Track.event(name, properties || {});
            },

            /**
             * page
             * 
             * Tracks an page relative to the current controller/action.
             * 
             * @access  protected
             * @return  void
             */
            page: function() {
                var path = Backbone.history.fragment;
                Track.page('/' + path);
            }
        },

        /**
         * tutorials
         * 
         * @access  public
         * @param   String slug
         * @param   Object params
         * @return  void
         */
        tutorials: function(slug, params) {
            var tutorials = Config.get('tutorials'),
                valid = function(slug) {
                    for (var index in tutorials) {
                        if (slug === tutorials[index].slug) {
                            return true;
                        }
                    }
                    return false;
                };
            if (valid(slug) === false) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this.track.event({
                    _slug: slug
                });
                this.track.page();
                ModalUtils.close();
                ModalUtils.closeExcept(['Tutorials']);
                var modal = ModalUtils.get('Tutorials') || ModalUtils.showTutorials();
                modal.getTutorials(slug).show();
                App.unrestrict();
            }
        },

        /**
         * wildcard
         * 
         * @access  public
         * @param   String fragment
         * @param   Object params
         * @return  void
         */
        wildcard: function(fragment, params) {
            var redirects = Stencil.getRouter().getRedirects(),
                index,
                regEx,
                path = '/app';
            for (index in redirects) {
                regEx = new RegExp(index, 'i');
                if (regEx.test(fragment) === true) {
                    path = '/' + (fragment.replace(regEx, redirects[index]));
                    break;
                }
            }
            Backbone.history.navigate(
                path,
                {
                    trigger: true,
                    replace: true
                }
            );
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * AreasController
     * 
     * @extends AppController
     */
    window.AreasController = AppController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _areaType: false,

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * collection
         * 
         * @access  public
         * @param   String slug
         * @param   Object params
         * @return  void
         */
        collection: function(slug, params) {
            var type = this._areaType,
                lookupProperties = {
                    custom: 1,
                    slug: slug
                };
            lookupProperties[type] = 1;
            var category = CategoryUtils.account.one(lookupProperties);
            if (category === false) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug,
                    _custom: 1
                });
                this.track.page();
                var key = category.get('key');
                App.getEditor().getArea(type).getChild('categories').getChild(key).show();
                ModalUtils.close();
                App.unrestrict();
            }
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * CategoriesController
     * 
     * @extends AppController
     */
    window.CategoriesController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/categories/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (
                    User.admin() === false
                    && User.editor() === false
                ) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    modal.getSection('categories').show();
                    ModalUtils.showAddCategory();
                    App.unrestrict();
                }
            }
        }
    });
});
window.DependencyLoader.push('Class', function() {

    /**
     * Controller
     * 
     * @extends Class
     */
    window.Controller = Class.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * CouponsController
     * 
     * @extends AppController
     */
    window.CouponsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/coupons/add';
                redirect = encodeURIComponent(redirect);
                path += '?redirect' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    modal.getSection('coupons').show();
                    ModalUtils.showAddCoupon();
                    App.unrestrict();
                }
            }
        },

        /**
         * apply
         * 
         * @access  public
         * @param   String plan
         * @param   String interval
         * @param   String code
         * @param   Object params
         * @return  void
         */
        apply: function(plan, interval, code, params) {
            if (typeof code === 'object') {
                params = code;
                code = false;
            }
            if (Account.guest() === true) {
                var path = '/app/signup?',
                    redirect = '/app/checkout/' + (plan) + '/' + (interval) + '/coupon';
                if (code !== false) {
                    redirect += '/' + (code);
                }
                if (location.href.match(/curtain/) !== null) {
                    path += 'curtain&';
                    redirect += '?curtain';
                }
                redirect = encodeURIComponent(redirect);
                path += 'redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (Account.upgraded() === true) {
                    Stencil.navigate('/app/only/free');
                } else {
                    // this._store();
                    if (code === false) {
                        // params = code;
                        // code = false;
                        this.track.event({
                            _plan: plan,
                            _interval: interval
                        });
                    } else {
                        this.track.event({
                            _plan: plan,
                            _interval: interval,
                            _code: code
                        });
                    }
                    this.track.page();
                    ModalUtils.closeExcept(['Checkout']);

                    // Grab checkout modal or open a new one
                    var type = 'direct';
                    if (params.curtain) {
                        type = 'curtain';
                    }
                    var modal = ModalUtils.get('Checkout') || ModalUtils.showCheckout(plan, interval, type);

                    // Throw in the code if it's defined
                    if (code) {
                        ModalUtils.showApplyCoupon(modal, code);
                    } else {
                        ModalUtils.showApplyCoupon(modal);
                    }

                    // Ensure the app is not blocked with the busy modal
                    App.unrestrict();
                }
            }
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * GraphicsController
     * 
     * @extends AreasController
     */
    window.GraphicsController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'graphics')
         */
        _areaType: 'graphics',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = CategoryUtils.universal.all({
                graphics: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/icons';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = CategoryUtils.universal.all({
                        graphics: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app/icons';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('graphics').getChild('categories').getChild(key).show();
                    ModalUtils.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Object params
         * @return  void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('graphics').getChild('queries').getChild(query).show();
            ModalUtils.close();
            App.unrestrict();
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * ImagesController
     * 
     * @extends AreasController
     */
    window.ImagesController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'images')
         */
        _areaType: 'images',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'all';
            }
            var categories = CategoryUtils.universal.all({
                images: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/saved';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'all') {
                            custom = 1;
                        }
                    }
                    categories = CategoryUtils.universal.all({
                        images: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'all' && category.get('custom').toInt() === 0) {
                    var path = '/app/saved';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('images').getChild('categories').getChild(key).show();
                    ModalUtils.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * error
         * 
         * @note    Only accessed via ?clean=1
         * @note    Action logic isn't wrapped in record-lookup since this can
         *          currently only be accessed from within the app and a
         *          conventional flow. If this page needed to be accessed
         *          statically, then I'd need a lookup (for when it's accessed
         *          directly).
         * @access  public
         * @param   String key
         * @param   String connection
         * @param   Object params
         * @return  void
         */
        error: function(key, connection, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key,
                    _connection: connection
                });
                this.track.page();
                ModalUtils.closeExcept(['Share']);
                var image = Stencil.getAccessor(key),
                    connection = Stencil.getAccessor(connection),
                    modal = ModalUtils.get('Share') || ModalUtils.showShare(image);
                modal.getNetwork(connection.get('network')).show();
                ModalUtils.showShareError(modal, image, connection);
                App.unrestrict();
            }
        },

        /**
         * mobile
         * 
         * @access  public
         * @var     Object
         */
        mobile: {

            /**
             * confirm
             * 
             * @access  public
             * @param   String key
             * @param   String mobile
             * @param   Object params
             * @return  void
             */
            confirm: function(key, mobile, params) {
                if (Account.guest() === true) {
                    Stencil.navigate('/app/not/guests');
                } else {
                    this.track.event({
                        _key: key
                    });
                    this.track.page();
                    ModalUtils.closeExcept(['Share']);
                    var image = Stencil.getAccessor(key),
                        modal = ModalUtils.get('Share') || ModalUtils.showShare(image);
                    modal.getNetwork('instagram').show(false);
                    modal = ModalUtils.showConfirmMobile(modal, image);
                    modal.getElement().focusable().focus();
                    App.unrestrict();
                }
            }
        },

        /**
         * normalize
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        normalize: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                ModalUtils.close();
                ModalUtils.showLegacyImageNormalize(key);
                App.unrestrict();
            }
        },

        /**
         * sent
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        sent: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                ModalUtils.closeExcept(['Share']);
                var image = Stencil.getAccessor(key),
                    modal = ModalUtils.get('Share') || ModalUtils.showShare(image);
                modal.getNetwork('instagram').show(false);
                ModalUtils.showSent(modal, image);
                App.unrestrict();
            }
        },

        /**
         * share
         * 
         * @access  public
         * @param   String key
         * @param   String network
         * @param   Object params
         * @return  void
         */
        share: function(key, network, params) {
            if (Account.guest() === true) {
                var path = '/app/login',
                    redirect = '/app/images/' + (key) + '/share/' + (network);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                var show = function(image) {
                    var modal = ModalUtils.get('Share') || ModalUtils.showShare(image);
                    modal.getNetwork(network).show();
                    App.unrestrict();
                };
                this.track.event({
                    _key: key,
                    _network: network
                });
                this.track.page();
                ModalUtils.closeExcept(['Share']);
                var image = Stencil.getAccessor(key);
                if (image === false) {
                    App.getBusy().show();
                    var model = Stencil.getModel('Image');
                    model.read(key, function(data) {
                        App.getBusy().hide();
                        var image = model.setAccessor(data.object);
                        show(image);
                    });
                } else {
                    show(image);
                }
            }
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * PhotosController
     * 
     * @extends AreasController
     */
    window.PhotosController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'photos')
         */
        _areaType: 'photos',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = CategoryUtils.universal.all({
                photos: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = CategoryUtils.universal.all({
                        photos: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('photos').getChild('categories').getChild(key).show();
                    ModalUtils.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Object params
         * @return  void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('photos').getChild('queries').getChild(query).show();
            ModalUtils.close();
            App.unrestrict();
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * PromoSetsController
     * 
     * @extends AppController
     */
    window.PromoSetsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/promoSets/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    modal.getSection('promoSets').show();
                    ModalUtils.showAddPromoSet();
                    App.unrestrict();
                }
            }
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * QuotesController
     * 
     * @extends AreasController
     */
    window.QuotesController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'quotes')
         */
        _areaType: 'quotes',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = CategoryUtils.universal.all({
                quotes: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/quotes';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = CategoryUtils.universal.all({
                        quotes: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app/quotes';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('quotes').getChild('categories').getChild(key).show();
                    ModalUtils.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Object params
         * @return  void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('quotes').getChild('queries').getChild(query).show();
            ModalUtils.close();
            App.unrestrict();
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * SharesController
     * 
     * @extends AppController
     */
    window.SharesController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * success
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        success: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                ModalUtils.closeExcept(['Share']);
                var share = Stencil.getAccessor(key),
                    connection = share.reference('connection'),
                    image = share.reference('image'),
                    modal = ModalUtils.get('Share') || ModalUtils.showShare(image);
                modal.getNetwork(connection.get('network')).show();
                ModalUtils.showShareSuccess(modal, share);
                App.unrestrict();
            }
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * TemplatesController
     * 
     * @extends AreasController
     */
    window.TemplatesController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'templates')
         */
        _areaType: 'templates',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = CategoryUtils.universal.all({
                templates: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/templates';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = CategoryUtils.universal.all({
                        templates: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app/templates';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('templates').getChild('categories').getChild(key).show();
                    ModalUtils.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * preview
         * 
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        preview: function(key, params) {
            var start = new Date(),
                show = function(template) {
                    var url = template.getPreviewThumbImageUrl(),
                        crossOrigin = false;
                    ImageUtils.load.url(url, crossOrigin, function(reference) {
                        (function() {
                            ModalUtils.showTemplatePreview(template);
                            App.unrestrict();
                        }).minDelay(start, 1500);
                    });
                };
            this.track.event({
                _key: key
            });
            this.track.page();
            ModalUtils.closeExcept(['TemplatePreview']);
            App.unrestrict();
            var msg = Config.getMessage('template.preview.loading');
            App.getBusy().show(msg);
            var template = Stencil.getAccessor(key);
            if (template === false) {
                // App.getBusy().show();
                var model = Stencil.getModel('Template');
                model.read(key, function(data) {
                    // App.getBusy().hide();
                    var template = model.setAccessor(data.object);
                    show(template);
                });
            } else {
                show(template);
            }
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * UploadsController
     * 
     * @extends AreasController
     */
    window.UploadsController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'uploads')
         */
        _areaType: 'uploads',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'all';
            }
            var categories = CategoryUtils.universal.all({
                uploads: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/uploads';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'all') {
                            custom = 1;
                        }
                    }
                    categories = CategoryUtils.universal.all({
                        uploads: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'all' && category.get('custom').toInt() === 0) {
                    var path = '/app/uploads';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('uploads').getChild('categories').getChild(key).show();
                    ModalUtils.close();
                    App.unrestrict();
                }
            }
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * UsersController
     * 
     * @extends AppController
     */
    window.UsersController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * delinquent
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        delinquent: function(params) {
            if (User.exists() === false) {
                Stencil.navigate('/app/only/upgraded');
            } else {
                this.track.event();
                this.track.page();
                ModalUtils.close();
                ModalUtils.showDelinquent();
                App.unrestrict();
            }
        },

        /**
         * login
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        login: function(params) {
            if (User.exists() === true) {
                if (params.redirect) {
                    Stencil.navigate(params.redirect);
                } else {
                    App.getElement().removeClass('curtain');
                    Stencil.navigate('/app/only/guests');
                }
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                ModalUtils.close();
                ModalUtils.showLogin(type, params.redirect || false);
                App.unrestrict();
            }
        },

        /**
         * onboard
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        onboard: function(params) {
            if (User.exists() === false) {
                Stencil.navigate('/app/only/users');
            } else {
                this.track.event();
                this.track.page();
                ModalUtils.close();
                ModalUtils.showOnboard();
                App.unrestrict();
            }
        },

        /**
         * password
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        password: function(params) {
            if (User.exists() === true) {
                App.getElement().removeClass('curtain');
                Stencil.navigate('/app/only/guests');
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                ModalUtils.close();
                ModalUtils.showPassword(type, params.redirect || false);
                App.unrestrict();
            }
        },

        /**
         * promo
         * 
         * @access  public
         * @param   String|undefined partner
         * @param   Object params
         * @return  void
         */
        promo: function(partner, params) {
            if (typeof partner === 'object') {
                params = partner;
                partner = false;
            }
            var type = 'direct';
            if (params.curtain) {
                type = 'curtain';
            }
            this.track.event({
                _type: type
            });
            this.track.page();
            ModalUtils.close();
            ModalUtils.showPromo(partner, type, params.redirect || false);
            App.unrestrict();
        },

        /**
         * settings
         * 
         * @access  public
         * @var     Object
         */
        settings: {

            /**
             * notifications
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            notifications: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/notifications';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Settings']);
                    var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                    modal.getSettings('notifications').show();
                    App.unrestrict();
                }
            },

            /**
             * obfuscate
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            obfuscate: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/delete';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Settings']);
                    var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                    modal.getSettings('obfuscate').show();
                    App.unrestrict();
                }
            },

            /**
             * password
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            password: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/password';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Settings']);
                    var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                    modal.getSettings('password').show();
                    App.unrestrict();
                }
            },

            /**
             * payment
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            payment: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/payment';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (Account.upgraded() === false) {
                        Stencil.navigate('/app/settings/profile');
                    } else {
                        if (Account.promo() === true) {
                            Stencil.navigate('/app/settings/profile');
                        } else {
                            this.track.event();
                            this.track.page();
                            ModalUtils.closeExcept(['Settings']);
                            var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                            modal.getSettings('payment').show();
                            App.unrestrict();
                        }
                    }
                }
            },

            /**
             * plan
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            plan: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/plan';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Settings']);
                    var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                    modal.getSettings('plan').show();
                    App.unrestrict();
                }
            },

            /**
             * profile
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            profile: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/profile';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Settings']);
                    var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                    modal.getSettings('profile').show();
                    App.unrestrict();
                }
            },

            /**
             * referral
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            referral: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/referral';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (Account.upgraded() === false) {
                        Stencil.navigate('/app/settings/profile');
                    } else {
                        if (Account.promo() === true) {
                            Stencil.navigate('/app/settings/profile');
                        } else {
                            this.track.event();
                            this.track.page();
                            ModalUtils.closeExcept(['Settings']);
                            var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                            modal.getSettings('referral').show();
                            App.unrestrict();
                        }
                    }
                }
            },

            /**
             * social
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            social: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/social';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Settings']);
                    var modal = ModalUtils.get('Settings') || ModalUtils.showSettings();
                    modal.getSettings('social').show();
                    App.unrestrict();
                }
            }
        },

        /**
         * signup
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        signup: function(params) {
            if (User.exists() === true) {
                App.getElement().removeClass('curtain');
                Stencil.navigate('/app/only/guests');
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                ModalUtils.close();
                ModalUtils.showSignup(type, params.redirect || false);
                App.unrestrict();
            }
        }
    });
});
window.DependencyLoader.push('AppController', function() {

    /**
     * VectorSetsController
     * 
     * @extends AppController
     */
    window.VectorSetsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/vectorSets/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    ModalUtils.closeExcept(['Admin']);
                    var modal = ModalUtils.get('Admin') || ModalUtils.showAdmin();
                    modal.getSection('vectorSets').show();
                    ModalUtils.showAddVectorSet();
                    App.unrestrict();
                }
            }
        }
    });
});
window.DependencyLoader.push('AreasController', function() {

    /**
     * WatermarksController
     * 
     * @extends AreasController
     */
    window.WatermarksController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'watermarks')
         */
        _areaType: 'watermarks',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'all';
            }
            var categories = CategoryUtils.universal.all({
                watermarks: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/logos';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug
                });
                this.track.page();
                var key = categories[0].get('key');
                App.getEditor().getArea('watermarks').getChild('categories').getChild(key).show();
                ModalUtils.close();
                App.unrestrict();
            }
        }
    });
});
window.DependencyLoader.push('AdminRecordsSectionView', function() {

    /**
     * AdminCategoriesView
     * 
     * @extends AdminRecordsSectionView
     */
    window.AdminCategoriesView = AdminRecordsSectionView.extend({

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: 'categories')
         */
        _sectionKey: 'categories',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCategoriesView')
         */
        _string: 'AdminCategoriesView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
});
window.DependencyLoader.push('AdminRecordRowView', function() {

    /**
     * AdminCategoryRowView
     * 
     * @extends AdminRecordRowView
     */
    window.AdminCategoryRowView = AdminRecordRowView.extend({

        /**
         * _category
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCategoryRowView')
         */
        _string: 'AdminCategoryRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, category) {
            this._super(element);
            this._category = category;
            this._addConfirmDeleteListener();
            this._addDeleteListener();
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  CategoryAccessor
         */
        _getAccessor: function() {
            var accessor = this._category;
            return accessor;
        }
    });
});
window.DependencyLoader.push('AdminRecordRowView', function() {

    /**
     * AdminCouponRowView
     * 
     * @extends AdminRecordRowView
     */
    window.AdminCouponRowView = AdminRecordRowView.extend({

        /**
         * _coupon
         * 
         * @access  protected
         * @var     null|CouponAccessor (default: null)
         */
        _coupon: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCouponRowView')
         */
        _string: 'AdminCouponRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CouponAccessor coupon
         * @return  void
         */
        init: function(element, coupon) {
            this._super(element);
            this._coupon = coupon;
            this._addConfirmDeleteListener();
            this._addDeleteListener();
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  CouponAccessor
         */
        _getAccessor: function() {
            var accessor = this._coupon;
            return accessor;
        }
    });
});
window.DependencyLoader.push('AdminRecordsSectionView', function() {

    /**
     * AdminCouponsView
     * 
     * @extends AdminRecordsSectionView
     */
    window.AdminCouponsView = AdminRecordsSectionView.extend({

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: 'coupons')
         */
        _sectionKey: 'coupons',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCouponsView')
         */
        _string: 'AdminCouponsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
});
window.DependencyLoader.push('AdminSectionView', function() {

    /**
     * AdminDashboardView
     * 
     * @extends AdminSectionView
     */
    window.AdminDashboardView = AdminSectionView.extend({

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     String (default: 'dashboard')
         */
        _sectionKey: 'dashboard',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminDashboardView')
         */
        _string: 'AdminDashboardView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AdminImageRowView
     * 
     * @extends View
     */
    window.AdminImageRowView = View.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminImageRowView')
         */
        _string: 'AdminImageRowView',

        /**
         * _image
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _image: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Object image
         * @return  void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this._addOpenListener();
        },

        /**
         * _addOpenListener
         * 
         * @access  protected
         * @return  void
         */
        _addOpenListener: function() {
            this.on({
                'open': function(event) {
                    var key = this._image.get('key'),
                        url = RequestUtils.url.s3(key);
                    window.open(url);
                }
            });
        }
    });
});
window.DependencyLoader.push('AdminRecordsSectionView', function() {

    /**
     * AdminImagesView
     * 
     * @extends AdminRecordsSectionView
     */
    window.AdminImagesView = AdminRecordsSectionView.extend({

        /**
         * _scrollThreshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 500)
         */
        _scrollThreshold: 500,

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: 'images')
         */
        _sectionKey: 'images',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminImagesView')
         */
        _string: 'AdminImagesView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        },

        /**
         * _getListObject
         * 
         * @access  protected
         * @return  void
         */
        _getListObject: function() {
            var listObject = this._super();
            listObject.all = 1;
            return listObject;
        }
    });
});
window.DependencyLoader.push('AdminRecordRowView', function() {

    /**
     * AdminPromoSetRowView
     * 
     * @extends AdminRecordRowView
     */
    window.AdminPromoSetRowView = AdminRecordRowView.extend({

        /**
         * _promoSet
         * 
         * @access  protected
         * @var     null|PromoSetAccessor (default: null)
         */
        _promoSet: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminPromoSetRowView')
         */
        _string: 'AdminPromoSetRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PromoSetAccessor promoSet
         * @return  void
         */
        init: function(element, promoSet) {
            this._super(element);
            this._promoSet = promoSet;
            this._setupTooltips();
            this._addDownloadListener();
            this._addDownloadUnusedListener();
        },

        /**
         * _addDownloadListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadListener: function() {
            this.on({
                'download': function(event) {
                    var key = this._promoSet.get('key'),
                        path = '/promoSets/' + (key) + '/download';
                    window.open(path);
                }
            });
        },

        /**
         * _addDownloadUnusedListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadUnusedListener: function() {
            this.on({
                'download/unused': function(event) {
                    var key = this._promoSet.get('key'),
                        path = '/promoSets/' + (key) + '/download?unused=1';
                    window.open(path);
                }
            });
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  PromoSetAccessor
         */
        _getAccessor: function() {
            var accessor = this._promoSet;
            return accessor;
        }
    });
});
window.DependencyLoader.push('AdminRecordsSectionView', function() {

    /**
     * AdminPromoSetsView
     * 
     * @extends AdminRecordsSectionView
     */
    window.AdminPromoSetsView = AdminRecordsSectionView.extend({

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: 'promoSets')
         */
        _sectionKey: 'promoSets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminPromoSetsView')
         */
        _string: 'AdminPromoSetsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
});
window.DependencyLoader.push('AdminSectionView', function() {

    /**
     * AdminRecordsSectionView
     * 
     * This class serves as the parent for views who have it as their
     * responsibility to iterate over a series of accessors and print out a
     * standard row/thumb for it.
     * 
     * It was abstracted out because most of the unique cases are handled by the
     * individual accessor AdminRecordRowView instances.
     * 
     * @extends AdminSectionView
     */
    window.AdminRecordsSectionView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|Collection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll to prevent loop of requests).
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _more: true,

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._scrollThreshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            if (this._query === undefined) {
                                this.load();
                            } else {
                                this.load(this._query);
                            }
                        }
                    }
                }
            }
        },

        /**
         * _scrollThreshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 100)
         */
        _scrollThreshold: 100,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminRecordsSectionView')
         */
        _string: 'AdminRecordsSectionView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._addInfiniteScrollEvents();
            this._setupCollection();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawRecordRow
         * 
         * @access  protected
         * @param   Accessor accessor
         * @param   Number position
         * @return  void
         */
        _drawRecordRow: function(accessor, position) {
            var className = accessor.get('class'),
                capitalized = StringUtils.ucfirst(className),
                templateName = 'Admin' + (capitalized) + 'Row',
                viewName = 'Admin' + (capitalized) + 'RowView',
                data = {};
            data[className] = accessor;
            var $recordRow = DataUtils.render(templateName, data);
            if (position === 0) {
                this.find('.inner').prepend($recordRow);
            } else {
                this.find('.inner').append($recordRow);
            }
            new window[viewName]($recordRow, accessor);
        },

        /**
         * _getListObject
         * 
         * @access  protected
         * @return  void
         */
        _getListObject: function() {
            var sectionKey = this._sectionKey,
                listObject = {
                    limit: Config.default('objectsPerPage').admin[sectionKey],
                    offset: this._collection.all().length
                };
            return listObject;
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this,
                sectionKey = this._sectionKey,
                collectionName = StringUtils.ucfirst(sectionKey) + 'Collection';
            this._collection = new window[collectionName]();
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._drawRecordRow(accessor, position);
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                listObject = this._getListObject();
            this._collection.list(listObject, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.trackLoad();
                this.load();
            }
        },

        /**
         * unload
         * 
         * @access  public
         * @return  void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AdminSectionView
     * 
     * @extends View
     */
    window.AdminSectionView = View.extend({

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|AdminModalView (default: null)
         */
        _modal: null,

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _sectionKey: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminSectionView')
         */
        _string: 'AdminSectionView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this.ui.show.apply(this);
        },

        /**
         * trackLoad
         * 
         * Tracks that results are being loaded.
         * 
         * @access  public
         * @return  void
         */
        trackLoad: function() {
            this._loaded = true;
            this._loading = true;
        },

        /**
         * ui
         * 
         * @access  public
         * @var     Object
         */
        ui: {

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $element = this._element,
                    $nav = this._modal.find('nav').first(),
                    sectionKey = this._sectionKey,
                    $anchor = $nav.find('[section="' + (sectionKey) + '"]');
                $anchor.siblings('[section]').removeClass('active');
                $anchor.addClass('active');
                $element.siblings('section').addClass('hidden');
                $element.removeClass('hidden');
                ElementUtils.nonTabletAutoFocus($element);
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AdminServiceSettingRowView
     * 
     * @extends View
     */
    window.AdminServiceSettingRowView = View.extend({

        /**
         * _override
         * 
         * @access  protected
         * @var     undefined|OverrideAccessor
         */
        _override: undefined,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="checkbox"].available': function(event, $input) {
                        if ($input[0].checked === true) {
                            this.override.enable.apply(this);
                        } else {
                            this.override.disable.apply(this);
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="checkbox"].override': function(event, $input) {
                        if ($input[0].checked === true) {
                            this.ui.available.enable.apply(this);
                            this.ui.message.show.apply(this);
                            this.override.create.apply(this);
                        } else {
                            this.ui.available.disable.apply(this);
                            this.override.delete.apply(this);
                            this.set.available.apply(this);
                            this.set.override.apply(this);
                        }
                    }
                }
            });
        },

        /**
         * _serviceKey
         * 
         * @access  protected
         * @var     undefined|String
         */
        _serviceKey: undefined,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminServiceSettingRowView')
         */
        _string: 'AdminServiceSettingRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String serviceKey
         * @return  void
         */
        init: function(element, serviceKey) {
            this._super(element);
            this._serviceKey = serviceKey;
            this._override = this._getServiceOverride();
            this.set.available.apply(this);
            this.set.favicon.apply(this);
            this.set.override.apply(this);
        },

        /**
         * _getCollection
         * 
         * @access  protected
         * @return  OverridesCollection
         */
        _getCollection: function() {
            var collection = Stencil.get('overrides');
            return collection;
        },

        /**
         * _getFaviconHost
         * 
         * @access  protected
         * @return  String
         */
        _getFaviconHost: function() {
            var serviceKey = this._serviceKey,
                fallbackHost = 'getstencil.com',
                host = (serviceKey) + '.com';
            if (serviceKey === 'cronhub') {
                host = 'cronhub.io';
            }
            if (serviceKey === 'cropper') {
                host = fallbackHost;
            }
            if (serviceKey === 'checkout') {
                host = fallbackHost;
            }
            if (serviceKey === 'fontUploads') {
                host = fallbackHost;
            }
            if (serviceKey === 'headway') {
                host = 'headwayapp.co';
            }
            if (serviceKey === 'helpScout') {
                host = 'helpscout.net';
            }
            if (serviceKey === 'uppy') {
                host = 'uppy.io';
            }
            if (serviceKey === 'vectorSearch') {
                host = fallbackHost;
            }
            return host;
        },

        /**
         * _getHardcodedServiceValue
         * 
         * @access  protected
         * @return  String
         */
        _getHardcodedServiceValue: function() {
            var serviceKey = this._serviceKey,
                services = Config.get('services'),
                serviceValue = services[serviceKey];
            if (serviceValue === true) {
                return '1';
            }
            return '0';
        },

        /**
         * _getServiceOverride
         * 
         * @access  protected
         * @return  OverrideAccessor|undefined
         */
        _getServiceOverride: function() {
            var serviceKey = this._serviceKey,
                collection = this._getCollection(),
                override = collection.service(serviceKey);
            return override;
        },

        /**
         * override
         * 
         * @access  public
         * @var     Object
         */
        override: {

            /**
             * create
             * 
             * @access  public
             * @return  void
             */
            create: function() {
                var model = Stencil.getModel('Override'),
                    data = {
                        type: 'service',
                        name: this._serviceKey,
                        value: this._getHardcodedServiceValue(),
                    },
                    callback = (function(response) {
                        var object = response.object,
                            collection = this._getCollection(),
                            accessors = collection.map(object),
                            override = accessors[0];
                        this.setOverride(override);
                        this.ui.message.hide.apply(this);
                    }).proxy(this);
                model.create(data, callback);
            },

            /**
             * delete
             * 
             * @access  public
             * @return  void
             */
            delete: function() {
                this._override.delete();
                this.removeOverride();
            },

            /**
             * disable
             * 
             * @access  public
             * @return  void
             */
            disable: function() {
                var override = this._override;
                override.set({
                    'value': '0'
                });
                override.save(['value']);
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                var override = this._override;
                override.set({
                    'value': '1'
                });
                override.save(['value']);
            }
        },

        /**
         * removeOverride
         * 
         * @access  public
         * @return  void
         */
        removeOverride: function() {
            this._override = undefined;
        },

        /**
         * set
         * 
         * @access  public
         * @var     Object
         */
        set: {

            /**
             * available
             * 
             * @access  public
             * @return  Boolean
             */
            available: function() {
                var $available = this.find('input.available');
                $available.disable();
                if (this._override === undefined) {
                    var hardcodedServiceValue = this._getHardcodedServiceValue();
                    $available.prop('checked', hardcodedServiceValue === '1');
                    return false;
                }
                $available.enable();
                var serviceValue = this._override.get('value').toInt();
                $available.prop('checked', serviceValue === 1);
                return true;
            },

            /**
             * favicon
             * 
             * @access  public
             * @return  void
             */
            favicon: function() {
                var $img = this.find('label img'),
                    host = this._getFaviconHost(),
                    domain = 'https://' + (host) + '/',
                    url = RequestUtils.url.favicon(domain);
                $img.attr('src', url);
            },

            /**
             * override
             * 
             * @access  public
             * @return  Boolean
             */
            override: function() {
                var $override = this.find('input.override');
                $override.prop('checked', false);
                if (this._override === undefined) {
                    return false;
                }
                $override.prop('checked', true);
                return true;
            }
        },

        /**
         * setOverride
         * 
         * @access  public
         * @param   OverrideAccessor override
         * @return  void
         */
        setOverride: function(override) {
            this._override = override;
        },

        /**
         * ui
         * 
         * @access  public
         * @var     Object
         */
        ui: {

            /**
             * available
             * 
             * @access  public
             * @var     Object
             */
            available: {

                /**
                 * disable
                 * 
                 * @access  public
                 * @return  void
                 */
                disable: function() {
                    var $input = this.find('input.available');
                    $input.disable();
                },

                /**
                 * enable
                 * 
                 * @access  public
                 * @return  void
                 */
                enable: function() {
                    var $input = this.find('input.available');
                    $input.enable();
                }
            },

            /**
             * message
             * 
             * @access  public
             * @var     Object
             */
            message: {

                /**
                 * hide
                 * 
                 * @access  public
                 * @return  void
                 */
                hide: function() {
                    (function() {
                        App.getBusy().hide();
                    }).delay(1500);
                },

                /**
                 * show
                 * 
                 * @access  public
                 * @return  void
                 */
                show: function() {
                    var msg = Config.getMessage('admin.generic');
                    App.getBusy().show(msg);
                }
            }
        }
    });
});
window.DependencyLoader.push('AdminRecordRowView', function() {

    /**
     * AdminUserRowView
     * 
     * @extends AdminRecordRowView
     */
    window.AdminUserRowView = AdminRecordRowView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input[type="checkbox"]': function(event, $checkbox) {
                        this._user.active().upgradeToPlan('unlimited');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminUserRowView')
         */
        _string: 'AdminUserRowView',

        /**
         * _user
         * 
         * @access  protected
         * @var     null|UserAccessor (default: null)
         */
        _user: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UserAccessor user
         * @return  void
         */
        init: function(element, user) {
            this._super(element);
            this._user = user;
            this._addListeners();
        },

        /**
         * _addCancelListener
         * 
         * @access  protected
         * @return  void
         */
        _addCancelListener: function() {
            this.on({
                'cancel': function(event) {
                    var active = this._user.active();
                    ModalUtils.showCancelAccount(active);
                }
            });
        },

        /**
         * _addImpersonateListener
         * 
         * @access  protected
         * @return  void
         */
        _addImpersonateListener: function() {
            this.on({
                'impersonate': function(event) {
                    var secret = this._user.get('secret'),
                        path = '/app?impersonate=1&secret=' + (secret);
                    User.logout(function() {
                        window.location.assign(path);
                    });
                }
            });
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addCancelListener();
            this._addImpersonateListener();
            this._addShowUpdateListener();
        },

        /**
         * _addShowUpdateListener
         * 
         * @access  protected
         * @return  void
         */
        _addShowUpdateListener: function() {
            this.on({
                'show/update': function(event) {
                    var key = this._user.get('key'),
                        path = '/app/admin/users/' + (key);
                    Stencil.navigate(path);
                }
            });
        }
    });
});
window.DependencyLoader.push('AdminRecordsSectionView', function() {

    /**
     * AdminUsersView
     * 
     * @extends AdminRecordsSectionView
     */
    window.AdminUsersView = AdminRecordsSectionView.extend({

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _more: false,

        /**
         * _query
         * 
         * @access  protected
         * @var     String|false (default: false)
         */
        _query: false,

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: 'users')
         */
        _sectionKey: 'users',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminUsersView')
         */
        _string: 'AdminUsersView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._super();
            this._collection.on({
                'empty': function(event) {
                    _this.find('div.user').remove();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._query === false || this._query === '') {
                var path = '/app/admin/users';
                return path;
            }
            var encoded = encodeURIComponent(this._query),
                path = '/app/admin/users/search/' + (encoded);
            return path;
        },

        /**
         * getQuery
         * 
         * @access  public
         * @return  String
         */
        getQuery: function() {
            var query = this._query;
            return query;
        },

        /**
         * load
         * 
         * @access  public
         * @param   String query
         * @return  void
         */
        load: function(query) {
            var listObject = this._getListObject();
            listObject.query = query;
            var _this = this;
            this._collection.list(listObject, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @param   String query
         * @return  void
         */
        show: function(query) {
            this.ui.show.apply(this);
            if (this._query !== query) {
                this.unload();
                this._query = query;
                this.load(query);
            }
        }
    });
});
window.DependencyLoader.push('AdminRecordRowView', function() {

    /**
     * AdminVectorSetRowView
     * 
     * @extends AdminRecordRowView
     */
    window.AdminVectorSetRowView = AdminRecordRowView.extend({

        /**
         * _vectorSet
         * 
         * @access  protected
         * @var     null|VectorSetAccessor (default: null)
         */
        _vectorSet: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminVectorSetRowView')
         */
        _string: 'AdminVectorSetRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   VectorSetAccessor vectorSet
         * @return  void
         */
        init: function(element, vectorSet) {
            this._super(element);
            this._vectorSet = vectorSet;
            this._addConfirmDeleteListener();
            this._addDeleteListener();
        },

        /**
         * _addDeleteListener
         * 
         * Adds in listeners since deleting a vector set could take some time
         * (since each vector and it's associated tags also need to be deleted).
         * 
         * @access  protected
         * @return  void
         */
        _addDeleteListener: function() {
            this._super();
            var accessor = this._getAccessor();
            accessor.on({
                'delete': function(event) {
                    var role = Config.getRole();
                    if (role !== 'local') {
                        Stencil.alert('cloudflare.timeout')
                        Stencil.kill.delay(1000);
                    }
                },
                'delete/pre': function(event) {
                    var timeout = 20 * 60 * 1000;
                    RequestUtils.set.timeout(timeout);
                },
                'model/delete': function(event) {
                    App.getBusy().hide();
                    var timeout = null;
                    RequestUtils.set.timeout(timeout);
                }
            });
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  VectorSetAccessor
         */
        _getAccessor: function() {
            var accessor = this._vectorSet;
            return accessor;
        }
    });
});
window.DependencyLoader.push('AdminRecordsSectionView', function() {

    /**
     * AdminVectorSetsView
     * 
     * @extends AdminRecordsSectionView
     */
    window.AdminVectorSetsView = AdminRecordsSectionView.extend({

        /**
         * _sectionKey
         * 
         * @access  protected
         * @var     null|String (default: 'vectorSets')
         */
        _sectionKey: 'vectorSets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminVectorSetsView')
         */
        _string: 'AdminVectorSetsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AdminRecordRowView
     * 
     * @extends View
     */
    window.AdminRecordRowView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input[type="checkbox"][name="active"]': function(event, $checkbox) {
                        var accessor = this._getAccessor(),
                            checked = $checkbox.prop('checked'),
                            properties = {
                                'active': 0
                            };
                        if (checked === true) {
                            properties.active = 1;
                        }
                        accessor.set(properties);
                        accessor.save(['active']);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminRecordRowView')
         */
        _string: 'AdminRecordRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupTooltips();
        },

        /**
         * _addConfirmDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addConfirmDeleteListener: function() {
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
        },

        /**
         * _addDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addDeleteListener: function() {
            var $element = this._element,
                accessor = this._getAccessor();
            accessor.on({
                'delete': function(event) {
                    // var collection = ModalUtils.get('Admin').getSection('categories')._collection;
                    $element.remove();
                    // collection.remove(_this._category);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var accessor = this._getAccessor(),
                question = this._getDeleteQuestion(),
                modal = ModalUtils.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    accessor.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _getDeleteQuestion
         * 
         * @access  protected
         * @return  string
         */
        _getDeleteQuestion: function() {
            var accessor = this._getAccessor(),
                className = accessor.get('class'),
                question = 'Are you sure you want to delete this %s?';
            className = StringUtils.insertSpacesIntoCamelCase(className);
            className = className.toLowerCase();
            question = question.replace('%s', className);
            return question;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ColorPickerView
     * 
     * @extends View
     * @fires   change
     *          hide
     *          show
     *          minicolors/change
     *          minicolors/hide
     *          minicolors/show
     */
    window.ColorPickerView = View.extend({

        /**
         * _$input
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$input: null,

        /**
         * _alwaysShowAddColorTooltip
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _alwaysShowAddColorTooltip: true,

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|ColorsCollection (default: null)
         */
        _collection: null,

        /**
         * _colorSwatches
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _colorSwatches: [],

        /**
         * _eventsEnabled
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _eventsEnabled: true,

        /**
         * _eyeDropperEnabled
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _eyeDropperEnabled: false,

        /**
         * _options
         * 
         * @access  protected
         * @var     Object
         */
        _options: {

            /**
             * fallbackColor
             * 
             * @access  protected
             * @var     false|String (default: false)
             */
            fallbackColor: false,

            /**
             * openDirection
             * 
             * @access  protected
             * @var     String (default: 'down')
             */
            openDirection: 'down',

            /**
             * showOpacitySlider
             * 
             * @access  protected
             * @var     Boolean (default: true)
             */
            showOpacitySlider: true
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorPickerView')
         */
        _string: 'ColorPickerView',

        /**
         * _toolbar
         * 
         * @access  protected
         * @var     null|ToolbarView (default: null)
         */
        _toolbar: null,

        /**
         * _visible
         * 
         * Boolean state which tracks whether the color picker (including
         * minicolors itself) is visible to the client.
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _visible: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   jQuery $input
         * @param   ToolbarView toolbar
         * @param   undefined|Object options (default: {})
         * @return  void
         */
        init: function(element, $input, toolbar, options) {
            this._colorSwatches = [];
            options = DataUtils.getDefaultValue(options, {});
            this._toolbar = toolbar;
            this._options = DataUtils.merge(this._options, options);
            this._super(element);
            this._$input = $input;
            this._addEscapeKeyListener();
            this._setupMinicolors();
            this._setupMinicolorsEvents();
            this._setupToolbarEvents();
            this._rearrangeElements();
            this._setupCollection();
            this._drawColorSwatches();
            this._addAddColorListener();
            this._addEyeDropperListener();
            this._refreshButton();
        },

        /**
         * _addAddColorListener
         * 
         * @access  protected
         * @return  void
         */
        _addAddColorListener: function() {
            this.on({
                'addColor': function(event) {
                    if (this._collection.length() < 20) {
                        var rgbaColorStr = this.getColor();
                        if (rgbaColorStr !== false) {
                            this._collection.addColor(rgbaColorStr);
                            var $last = ArrayUtils.last(this._colorSwatches).getElement();
                            $last.addClass('fadeIn');
                            (function() {
                                $last.removeClass('fadeIn');
                            }).delay(950);
                        }
                    }
                }
            });
        },

        /**
         * _addEscapeKeyListener
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeKeyListener: function() {
            var _this = this,
                $app = App.getElement(),
                hide = {
                    'body/keydown/escape': function(event) {
                        if (event.which === 27) {
                            if (_this._visible === true) {
                                if (_this._eyeDropperEnabled === true) {
                                    _this.disableEyeDropper();
                                } else {
                                    _this._$input.minicolors('hide');
                                }
                            }
                        }
                    }
                };
            $app.on({
                'keydown': hide['body/keydown/escape']
            });
        },

        /**
         * _addEyeDropperListener
         * 
         * @access  protected
         * @return  void
         */
        _addEyeDropperListener: function() {
            this.on({
                'toggleEyeDropper': function(event, $element) {
                    this._toggleEyeDropper();
                }
            });
            var eyeDropper = this._getEyeDropper(),
                _this = this;
            eyeDropper.on({
                'disable': function(event) {
                    _this._eyeDropperEnabled = false;
                    var $eyedropper = _this.find('[lookup="eyedropper"]');
                    $eyedropper.removeClass('active');
                },
                'enable': function(event) {
                    _this._eyeDropperEnabled = true;
                    var $eyedropper = _this.find('[lookup="eyedropper"]');
                    $eyedropper.addClass('active');
                }
            });
        },

        /**
         * _destroyTooltips
         * 
         * @access  protected
         * @return  void
         */
        _destroyTooltips: function() {
            var $cta = this.find('.colorSwatch.cta'),
                $anchor = $cta.find('> a');
            $anchor.tooltip('destroy');
            this._element.tooltip('destroy');
        },

        /**
         * _drawColorSwatch
         * 
         * @access  protected
         * @param   ColorAccessor color
         * @param   Number position
         * @return  void
         */
        _drawColorSwatch: function(color, position) {
            var $colorSwatch = DataUtils.render('ColorSwatch', {
                    color: color
                }),
                colorSwatch = new ColorSwatchView($colorSwatch, this, color);
            this._colorSwatches.push(colorSwatch);
            if (position === 0) {
                var $first = this.find('.swatches').find('.colorSwatch').first();
                $colorSwatch.insertAfter($first);
            } else {
                this.find('.swatches').append($colorSwatch);
            }
        },

        /**
         * _drawColorSwatches
         * 
         * @access  protected
         * @return  void
         */
        _drawColorSwatches: function() {
            var _this = this;
            this._collection.each(function(index, color) {
                _this._drawColorSwatch(color, index);
            });
        },

        /**
         * _enableEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _enableEyeDropper: function() {
            if (this._eyeDropperEnabled === false) {
                var eyeDropper = this._getEyeDropper(),
                    _this = this;
                eyeDropper.on({
                    'preview': function(event, rgbaColorStr) {
                        _this.setColor(rgbaColorStr, false);
                        _this.triggerHandler('change', [rgbaColorStr]);
                    }
                });
                eyeDropper.once({
                    'select': function(event, rgbaColorStr) {
                        _this.setColor(rgbaColorStr);
                        _this.disableEyeDropper();
                    }
                });
                eyeDropper.enable();
            }
        },

        /**
         * _getColorKeywords
         * 
         * @access  protected
         * @return  Array
         */
        _getColorKeywords: function() {
            var colors = Config.get('colors'),
                spacedColors = ArrayUtils.insertSpacesIntoCamelCase(colors),
                merged = ArrayUtils.merge(colors, spacedColors);
            return merged;
        },

        /**
         * _getEyeDropper
         * 
         * @access  protected
         * @return  EyeDropperView
         */
        _getEyeDropper: function() {
            var stageContent = this._getStageContent(),
                eyeDropper = stageContent.getEyeDropper();
            return eyeDropper;
        },

        /**
         * _getStageContent
         * 
         * @access  protected
         * @return  StageContentView
         */
        _getStageContent: function() {
            var stageContent = this._toolbar.getToolbars().getStageContent();
            return stageContent;
        },

        /**
         * _rearrangeElements
         * 
         * @access  protected
         * @return  void
         */
        _rearrangeElements: function() {
            this.find('div.content').append(
                this._$input.nextAll('div.minicolors-panel')
            );
            this._element.insertAfter(this._$input);
            this.find('div.content div.grid').append(
                this.find('div.minicolors-grid')
            );
            this.find('div.content div.slider').append(
                this.find('div.minicolors-slider')
            );
            this.find('div.content div.opacity').append(
                this.find('div.minicolors-opacity-slider')
            );
            this.find('.minicolors-panel').append(
                this.find('div.content div.grid'),
                this.find('div.content div.slider'),
                this.find('div.content div.opacity')
            );
            this.find('.minicolors-panel').addClass('clearfix');
            if (this._options.showOpacitySlider === false) {
                this._element.addClass('slim');
            }
            this._element.addClass('opens');
            this._element.addClass('down');
            if (this._options.openDirection === 'up') {
                this._element.removeClass('down');
                this._element.addClass('up');
            }
        },

        /**
         * _refreshButton
         * 
         * @access  protected
         * @return  void
         */
        _refreshButton: function() {
            this._destroyTooltips();
            this._refreshTooltips();
            var $cta = this.find('.colorSwatch.cta'),
                $anchor = $cta.find('> a'),
                colors = this._collection.length();
            $cta.enable();
            if (
                colors === 0
                || colors >= 20
                || this._alwaysShowAddColorTooltip === true
            ) {
                this._setupTooltips();
            }
            if (colors >= 20) {
                $cta.disable();
            }
        },

        /**
         * _refreshGridEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _refreshGridEyeDropper: function() {
            var rgbaColorStr = this.getColor(),
                colorStr = ColorUtils.getWhite('rgba', 0);
            if (rgbaColorStr !== false) {
                colorStr = ColorUtils.convert(rgbaColorStr, 'hex');
            }
            this.find('.minicolors-picker > div').css({
                'background-color': colorStr
            });
        },

        /**
         * _refreshTooltips
         * 
         * @access  protected
         * @return  void
         */
        _refreshTooltips: function() {
            var $cta = this.find('.colorSwatch.cta'),
                $anchor = $cta.find('> a'),
                colors = this._collection.length(),
                title = '';
            if (
                colors === 0
                || colors >= 20
                || this._alwaysShowAddColorTooltip === true
            ) {
                title = 'Save this color<br />to your account';
                if (colors >= 20) {
                    title = 'You have reached your account maximum of 20 ' +
                        'colors. Please delete one to save a new color.'
                }
            }
            $anchor.attr('data-original-title', title);
            $anchor.attr('data-title', title);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._collection = Stencil.account().collection('colors');
            var _this = this;
            this._collection.on({
                'add': function(event, colorAccessor, position) {
                    _this._drawColorSwatch(colorAccessor, position);
                },
                'empty': function(event) {
                    _this.find('.colorSwatch:not(.cta)').remove();
                },
                'remove': function(event, colorAccessor) {
                    var colorSwatches = _this._colorSwatches,
                        colorSwatch,
                        index;
                    for (index in colorSwatches) {
                        colorSwatch = colorSwatches[index];
                        if (colorSwatch.getColor() === colorAccessor) {
                            colorSwatch.remove();
                            colorSwatches.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {
                    _this._refreshButton();
                }
            });
        },

        /**
         * _setupMinicolors
         * 
         * @access  protected
         * @return  void
         */
        _setupMinicolors: function() {
            var _this = this,
                placement = 'bottom right',
                opacity = true,
                colorKeywords = this._getColorKeywords();
            if (this._options.showOpacitySlider === false) {
                opacity = false;
            }
            this._$input.on({
                'focus': function(event) {
                    _this._refreshGridEyeDropper();
                }
            });
            this._$input.minicolors({
                'format': 'hex',
                'keywords': colorKeywords.join(','),
                'hideSpeed': 0,
                'showSpeed': 0,
                'opacity': opacity,
                'position': placement,
                'change': function(value, opacity) {
                    _this.triggerHandler('minicolors/change', [value, opacity]);
                },
                'hide': function(value, opacity) {
                    _this.triggerHandler('minicolors/hide');
                },
                'show': function(value, opacity) {
                    _this.triggerHandler('minicolors/show');
                }
            });
            // this._$input.nextAll('.minicolors-input-swatch').on({
            //     'mousedown': function(event) {
            //         event.preventDefault();
            //         if (_this._visible === true) {
            //             // _this.hide();
            //             // _this._$input.trigger('blur');
            //         }
            //     }
            // });
        },

        /**
         * _setupMinicolorsEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupMinicolorsEvents: function() {
            var colorKeywords = this._getColorKeywords(),
                lowercaseColorKeywords = ArrayUtils.lowercase(colorKeywords);
            this.on({
                'change': function(event, rgbaColorStr) {
                    this._refreshGridEyeDropper();
                },
                'minicolors/change': function(event, value, opacity) {
                    if (value === '') {
                        this._refreshGridEyeDropper();
                    }
                    if (value !== '' && value.match(/^#/) === null) {
                        if (ArrayUtils.contains(value, lowercaseColorKeywords) === true) {
                            value = value.replace(/ /g, '');
                            value = ColorUtils.convert(value, 'hex');
                            var rgbaColorStr = ColorUtils.convert(value, 'rgba');
                            this.setColor(rgbaColorStr, false);
                        }
                    }
                    if (this._eventsEnabled === true) {
                        var fallbackColor = this._options.fallbackColor;
                        if (fallbackColor !== false) {
                            if (value === '') {
                                value = fallbackColor;
                                opacity = ColorUtils.getAlpha(fallbackColor);
                            }
                        }
                        if (value !== '') {
                            var hex = ColorUtils.convert(value, 'hex'),
                                rgbaColorStr = ColorUtils.convert(hex, 'rgba', opacity);
                            this.triggerHandler('change', [rgbaColorStr]);
                        }
                        this.disableEyeDropper();
                    }
                },
                'minicolors/hide': function(event) {
                    this.hide();
                },
                'minicolors/show': function(event) {
                    this.show();
                }
            });
        },

        /**
         * _setupToolbarEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupToolbarEvents: function() {
            var _this = this;
            this._toolbar.on({
                'hide': function(event) {
                    _this._$input.minicolors('hide');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '.colorSwatch.cta > [tooltip]',
                container: App.getElement(),
                placement: 'left'
            });
        },

        /**
         * _toggleEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _toggleEyeDropper: function() {
            if (this._eyeDropperEnabled === false) {
                this._enableEyeDropper();
            } else {
                this.disableEyeDropper();
            }
        },

        /**
         * clearMinicolors
         * 
         * @access  public
         * @return  void
         */
        clearMinicolors: function() {
            this._$input.minicolors('value', '');
            this._$input.minicolors('opacity', '1');
        },

        /**
         * disableEyeDropper
         * 
         * @access  public
         * @return  void
         */
        disableEyeDropper: function() {
            if (this._eyeDropperEnabled === true) {
                var eyeDropper = this._getEyeDropper();
                eyeDropper.disable();
            }
        },

        /**
         * getColor
         * 
         * @access  public
         * @return  false|String
         */
        getColor: function() {
            var colorStr = this._$input.minicolors('value');
            if (colorStr === '') {
                return false;
            }
            var opacity = this._$input.minicolors('opacity'),
                rgbaColorStr = ColorUtils.convert(
                    colorStr,
                    'rgba',
                    opacity
                );
            return rgbaColorStr;
        },

        /**
         * getInput
         * 
         * @access  public
         * @return  jQuery
         */
        getInput: function() {
            return this._$input;
        },

        /**
         * removeLastChange
         * 
         * This resets the internal minicolors object that keeps track of
         * what the last color was. This is to address a bug whereby if the
         * copy + pasted the same color into other fields, the color would
         * not take effect, since minicolors did not think anything has
         * changed (since the input itself is the same one between text
         * layers).
         * 
         * @access  public
         * @return  void
         */
        removeLastChange: function() {
            this._$input.removeData('minicolors-lastChange');
        },

        /**
         * setColor
         * 
         * @note    minicolors always fires the <change> method, even when the
         *          color and/or opacity are set manually. To get around this
         *          (since I only want the event firing when it's manually
         *          changed), I use an internal property called _eventsEnable
         *          which prevents the event from firing.
         * @see     https://github.com/claviska/jquery-minicolors/issues/183
         * @access  public
         * @param   String rgbaColorStr
         * @param   undefined|Boolean triggerEvent (default: true)
         * @return  void
         */
        setColor: function(rgbaColorStr, triggerEvent) {
            triggerEvent = DataUtils.getDefaultValue(triggerEvent, true);
            var color = rgbaColorStr,
                hex = ColorUtils.convert(color, 'hex'),
                opacity = ColorUtils.getAlpha(color);
            if (triggerEvent === false) {
                this._eventsEnabled = false;
                this._$input.minicolors('value', hex);
                this._$input.minicolors('opacity', opacity);
                this._eventsEnabled = true;
            } else {
                this._$input.minicolors('value', hex);
                this._$input.minicolors('opacity', opacity);
            }
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            if (this._visible === true) {
                this._visible = false;
                this._element.addClass('hidden');
                this.disableEyeDropper();
                this.triggerHandler('hide');
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            if (this._visible === false) {
                this._visible = true;
                this._element.removeClass('hidden');
                this.triggerHandler('show');
            }
        },

        /**
         * visible
         * 
         * @access  public
         * @return  Boolean
         */
        visible: function() {
            return this._visible;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ColorSwatchView
     * 
     * @extends View
     */
    window.ColorSwatchView = View.extend({

        /**
         * _color
         * 
         * @access  protected
         * @var     null|ColorAccessor (default: null)
         */
        _color: null,

        /**
         * _colorPicker
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _colorPicker: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorSwatchView')
         */
        _string: 'ColorSwatchView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ColorPicker colorPicker
         * @param   ColorAccessor color
         * @return  void
         */
        init: function(element, colorPicker, color) {
            this._super(element);
            this._colorPicker = colorPicker;
            this._color = color;
            this._addDeleteListener();
            this._addSetListener();
            this._setupTooltips();
        },

        /**
         * _addDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addDeleteListener: function() {
            this.on({
                'delete': function(event) {
                    this._delete();
                }
            });
        },

        /**
         * _addSetListener
         * 
         * @access  protected
         * @return  void
         */
        _addSetListener: function() {
            this.on({
                'set': function(event) {
                    this._colorPicker.setColor(
                        this._color.get('color')
                    );
                }
            });
        },

        /**
         * _delete
         * 
         * @access  protected
         * @return  void
         */
        _delete: function() {
            this._colorPicker.disableEyeDropper();
            var _this = this,
                question = 'Are you sure you want to delete this color?',
                modal = ModalUtils.showConfirmDelete(question),
                $minicolors = this._colorPicker.getElement().parent('.minicolors');
            $minicolors.removeClass('minicolors-focus');
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.getElement().addClass('warning');
            modal.on({
                'leave close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                    $minicolors.addClass('minicolors-focus');
                },
                'yes': function(event) {
                    _this._color.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * getColor
         * 
         * @access  public
         * @return  ColorAccessor
         */
        getColor: function() {
            return this._color;
        },

        /**
         * remove
         * 
         * @access  public
         * @return  void
         */
        remove: function() {
            this._element.remove();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ConnectionRowView
     * 
     * @todo    After all connections have been deleted, close the modal
     * @events  confirm/delete
     * @extends View
     */
    window.ConnectionRowView = View.extend({

        /**
         * _connection
         * 
         * @access  protected
         * @var     null|ConnectionAccessor (default: null)
         */
        _connection: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionRowView')
         */
        _string: 'ConnectionRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ConnectionAccessor connection
         * @return  void
         */
        init: function(element, connection) {
            this._super(element);
            this._connection = connection;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    App.tooltips.hide();
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._connection.on({
                'delete': function(event) {
                    _this._element.remove();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this connection?',
                modal = ModalUtils.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    _this._connection.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        }
    });
});
window.DependencyLoader.push('FrameView', function() {

    /**
     * CustomFrameView
     * 
     * @events  confirm/delete
     * @extends FrameView
     */
    window.CustomFrameView = FrameView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomFrameView')
         */
        _string: 'CustomFrameView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ResizerView resizer
         * @param   FrameAccessor frame
         * @return  void
         */
        init: function(element, resizer, frame) {
            this._super(element, resizer, frame);
            this._addViewListeners();
            this._addFrameListeners();
        },

        /**
         * _addFrameListeners
         * 
         * @access  protected
         * @return  void
         */
        _addFrameListeners: function() {
            var _this = this;
            this._frame.on({
                'delete': function(event) {
                    _this._element.remove();
                }
            });
        },

        /**
         * _addViewListeners
         * 
         * @access  protected
         * @return  void
         */
        _addViewListeners: function() {
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * Confirms that a user wants to delete a frame. If they attempt to
         * delete the frame that their draft is currently using, simply switch
         * them to the orphan frame so that the word "Custom" shows up. To
         * ensure that the orphan has thsame width and height, I set it right
         * before switching to it.
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this custom size?',
                modal = ModalUtils.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    var key = _this._frame.get('key'),
                        account = Stencil.account(),
                        draft = account.draft();
                    if (key === draft.get('frame')) {
                        var orphan = account.orphanFrame();
                        orphan.set({
                            width: _this._frame.get('width').toInt(),
                            height: _this._frame.get('height').toInt()
                        });
                        orphan.select();
                        orphan.setToPreviewCanvas();
                    }
                    _this._frame.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        }
    });
});
window.DependencyLoader.push(['View', 'UploadModel', 'WatermarkModel'], function() {

    /**
     * DropzoneView
     * 
     * @events  abort
     *          cancel
     *          complete/pre
     *          complete
     *          process/next
     *          start
     * @extends View
     */
    window.DropzoneView = View.extend({

        /**
         * _currentUpload
         * 
         * Reference to the current UploadAccessor that is being
         * uploaded/updated.
         * 
         * @access  protected
         * @var     null|UploadAccessor (default: null)
         */
        _currentUpload: null,

        /**
         * _currentUploadItem
         * 
         * Reference to a Blob or File that is currently being uploaded.
         * 
         * @access  protected
         * @var     null|Blob|File (default: null)
         */
        _currentUploadItem: null,

        /**
         * _currentUploadItems
         * 
         * An array of File or Blob references that are currently being
         * uploaded.
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _currentUploadItems: [],

        /**
         * _defaultUploadInterstitialCallback
         * 
         * @access  protected
         * @var     Function
         */
        _defaultUploadInterstitialCallback: (function() {
            return function(upload, callback) {
                callback();
            };
        })(),

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.prompt': function(event, $div) {
                        if (this.availableForUpload() === true) {
                            var $file = this.find('input[type="file"].files');
                            $file.trigger('click');
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[lookup="again"]': function(event, $element) {
                        event.preventDefault();
                        if (this.availableForUpload() === true) {
                            var $file = this.find('input[type="file"].files');
                            $file.trigger('click');
                        }
                    }
                },
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @note    The check for a non-empty files array is to deal
                     *          with an IE bug whereby the change event fires
                     *          twice: one with an empty array, and one with the
                     *          proper files array. More info here:
                     *          https://stackoverflow.com/questions/7419560/solve-ie7-bug-input-type-file-onchange-fire-twice
                     *          https://sentry.io/stencil/javascript/issues/395973564/
                     *          https://i.imgur.com/n05l2LX.png
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="file"].files': function(event, $input) {
                        if (this.availableForUpload() === true) {
                            var files = jQuery.makeArray(
                                $input.prop('files')
                            );
                            if (files.length > 0) {
                                this.uploadItems(files);
                            }
                        }
                    }
                }
            });
        },

        /**
         * _managedUpload
         * 
         * @access  protected
         * @var     null|AWS.S3.ManagedUpload (default: null)
         */
        _managedUpload: null,

        /**
         * _max
         * 
         * Object defining the maximum filesizes and counts for fonts and
         * uploads. It is set when the view is initiated, as it's pulled
         * dynamically from the Stencil config settings.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _max: {},

        /**
         * _models
         * 
         * Defines the models that different types of DropzoneView's ought to
         * use when creating and referencing an UploadAccessor.
         * 
         * @access  protected
         * @var     Object
         */
        _models: {
            font: Stencil.getModel('Upload'),
            image: Stencil.getModel('Upload'),
            watermark: Stencil.getModel('Watermark')
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DropzoneView')
         */
        _string: 'DropzoneView',

        /**
         * _type
         * 
         * A type property for the dropzone, which is used to determine which
         * models to use during uploading, along with other handles like which
         * success/error handlers to use.
         * 
         * @access  protected
         * @var     'image'|'font'|String (default: '')
         */
        _type: '',

        /**
         * _uploading
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _uploading: false,

        /**
         * _uploadInterstitialCallback
         * 
         * @access  protected
         * @var     null|Function (default: null)
         */
        _uploadInterstitialCallback: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @return  void
         */
        init: function(element, type) {
            this._type = type;
            this._currentUploadItems = [];
            this._super(element);
            this._addAbortListener();
            this._addCancelListener();
        },

        /**
         * _addAbortListener
         * 
         * @access  protected
         * @return  void
         */
        _addAbortListener: function() {
            this.on({
                'abort': function(event) {
                    var item = this._currentUploadItem,
                        abortablePartSize = this._managedUpload.partSize;
                    if (item.size > abortablePartSize) {
                        this._managedUpload.abort();
                    } else {
                        var index = this._currentUploadItems.indexOf(item);
                        this._currentUploadItems.splice(index + 1);
                        var total = this._currentUploadItems.length;
                        this.show('status', 'ending');
                        this._ui.updateTotalCount.apply(this, [total]);
                    }
                }
            });
        },

        /**
         * _addCancelListener
         * 
         * @access  protected
         * @return  void
         */
        _addCancelListener: function() {
            this.on({
                'cancel': function(event) {
                    this.show('prompt');
                }
            });
        },

        /**
         * _addUploadAbortListener
         * 
         * @access  protected
         * @return  void
         */
        _addUploadAbortListener: function() {
            var _this = this;
            this._currentUpload.on({
                'upload/abort': function(event, err) {
                    _this.show('prompt');
                    _this._uploading = false;
                    _this.resetReferences();
                }
            });
        },

        /**
         * _addUploadErrorListener
         * 
         * @access  protected
         * @return  void
         */
        _addUploadErrorListener: function() {
            var _this = this;
            this._currentUpload.on({
                'upload/error': function(event, err) {
                    _this._ui.hideContext.apply(_this);
                    _this.show('status', 'failed');
                    _this._uploading = false;
                    _this.resetReferences();
                    _this._trackError(err);
                }
            });
        },

        /**
         * _addUploadProgressListener
         * 
         * @access  protected
         * @return  void
         */
        _addUploadProgressListener: function() {
            var _this = this;
            this._currentUpload.on({

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   Number loaded
                 * @param   Number total
                 * @return  void
                 */
                'upload/progress': function(event, loaded, total) {
                    _this._ui.showHideAbortUpload.apply(_this);
                    var percentage = Math.round(
                        (loaded / total) * 100
                    );
                    _this._ui.updateProgress.apply(_this, [percentage]);
                }
            });
        },

        /**
         * _addUploadSuccessListener
         * 
         * @access  protected
         * @return  void
         */
        _addUploadSuccessListener: function() {
            this._currentUpload.on({
                'upload/success': this._processSuccessfulS3Upload.proxy(this)
            });
        },

        /**
         * _alerts
         * 
         * @access  protected
         * @var     Object
         */
        _alerts: {

            /**
             * zip
             * 
             * @access  protected
             * @return  void
             */
            zip: function() {
                var alertKey = 'upload.font.type',
                    modal = this._showAlert(alertKey);
            }
        },

        /**
         * _completeFailedUpload
         * 
         * @access  protected
         * @param   Array args
         * @return  Boolean
         */
        _completeFailedUpload: function(args) {
            this._uploading = false;
            this.resetReferences();
            this.show('prompt');
            this.triggerHandler('complete', args);
            this.triggerHandler('complete/failed', args);
            return true;
        },

        /**
         * _completeSuccessfulUpload
         * 
         * @access  protected
         * @param   Array args
         * @return  Boolean
         */
        _completeSuccessfulUpload: function(args) {
            this.show('status', 'complete');
            this.triggerHandler('complete', args);
            this.triggerHandler('complete/successful/pre', args);
            this.triggerHandler('complete/successful', args);

            /**
             * Delays here are intended to not jolt the user when the Dropzone
             * prompt UI state is shown again.
             */
            var itemsProcessed = this._getItemsProcessed(),
                totalItems = this._currentUploadItems.length;
            if (itemsProcessed === totalItems) {
                (function() {
                    this._uploading = false;
                    this.resetReferences();
                    this.show('prompt');
                }).delay(2000, this);
                return true;
            }

            // 
            (function() {
                this.show('prompt');
                this.triggerHandler('process/next');
            }).delay(1000, this);
            return true;
        },

        /**
         * _createFontRecord
         * 
         * @access  protected
         * @return  void
         */
        _createFontRecord: function() {
            var model = Stencil.getModel('Font'),
                data = {
                    upload: this._currentUpload.get('key')
                };
            model.create(
                data,
                this._fontRecordCreateSuccess.proxy(this),
                this._fontRecordCreateFail.proxy(this)
            );
        },

        /**
         * _createUploadRecord
         * 
         * @see     http://stackoverflow.com/questions/12570834/how-to-preview-image-get-file-size-image-height-and-width-before-upload
         * @see     http://jsbin.com/oTAtIpA/3/edit?html,css,js,output
         * @access  protected
         * @return  void
         */
        _createUploadRecord: function() {
            var item = this._currentUploadItem,
                model = this._getModel(),
                data = {
                    contentType: item.type,
                    filesize: item.size,
                    name: item.name,
                    type: this._type
                };
            model.create(
                data,
                this._uploadRecordCreateSuccess.proxy(this)
            );
        },

        /**
         * _fakeUploadProcess
         * 
         * @access  protected
         * @return  void
         */
        _fakeUploadProcess: function() {
            this._currentUpload.triggerHandler('upload/progress', [3, 100]);
        },

        /**
         * _fontRecordCreateFail
         * 
         * @access  protected
         * @param   Object response
         * @return  void
         */
        _fontRecordCreateFail: function() {
            var alertKey = 'upload.font.fail',
                modal = this._showAlert(alertKey);
            this.show.delay(0, this, ['prompt']);
            this._uploading = false;
        },

        /**
         * _fontRecordCreateSuccess
         * 
         * @access  protected
         * @param   Object response
         * @return  void
         */
        _fontRecordCreateSuccess: function(response) {
            var data = response.object,
                model = Stencil.getModel('Font'),
                font = model.setAccessor(data),
                upload = this._currentUpload;
            this._completeSuccessfulUpload([upload, font]);
        },

        /**
         * _getItemsProcessed
         * 
         * @access  protected
         * @return  Number
         */
        _getItemsProcessed: function() {
            var index, item;
            for (index in this._currentUploadItems) {
                item = this._currentUploadItems[index];
                if (item === this._currentUploadItem) {
                    break;
                }
            }
            return (index.toInt() + 1);
        },

        /**
         * _getMax
         * 
         * Returns the maximum number of files (images or fonts) that be
         * uploaded at once, as well as the maximum filesize (in bytes) for file
         * uploads.
         * 
         * @access  protected
         * @param   String property
         * @return  mixed
         */
        _getMax: function(property) {
            var properties = {
                filesize: Config.default('imageUploadMaxFilesize').toInt(),
                sequential: Config.default('maxSequentialImageUploads').toInt()
            };
            if (this._type === 'font') {
                properties = {
                    filesize: Config.default('fontUploadMaxFilesize').toInt(),
                    sequential: Config.default('maxSequentialFontUploads').toInt()
                };
            }
            return properties[property];
        },

        /**
         * _getModel
         * 
         * @access  protected
         * @return  Model
         */
        _getModel: function() {
            var type = this._type,
                model = this._models[this._type];
            return model;
        },

        /**
         * _getS3UploadResponse
         * 
         * @access  protected
         * @return  Object
         */
        _getS3UploadResponse: function() {
            var upload = this._currentUpload,
                item = this._currentUploadItem,
                model = Stencil.getModel('S3Upload'),
                object = item,
                objectKey = upload.get('key'),
                response = model.uploadObject(object, objectKey, upload);
            return response;
        },

        /**
         * _getUploadInterstitialCallback
         * 
         * @access  protected
         * @return  Function
         */
        _getUploadInterstitialCallback: function() {
            var uploadInterstitialCallback = this._uploadInterstitialCallback;
            if (uploadInterstitialCallback === null) {
                uploadInterstitialCallback = this._defaultUploadInterstitialCallback;
                return uploadInterstitialCallback;
            }
            return uploadInterstitialCallback;
        },

        /**
         * _getUploadResponseAccessor
         * 
         * @access  protected
         * @param   Object data
         * @return  UploadAccessor
         */
        _getUploadResponseAccessor: function(data) {
            var model = this._getModel(),
                upload = model.setAccessor(data);
            return upload;
        },

        /**
         * _imageUploadPreloadError
         * 
         * @access  protected
         * @param   HTMLImageElement reference
         * @return  void
         */
        _imageUploadPreloadError: function(reference) {
            this._currentUpload.delete();
            this._ui.hideContext.apply(this);
            this.show('status', 'failed');
            this._uploading = false;
            this.resetReferences();
        },

        /**
         * _imageUploadPreloadSuccess
         * 
         * @access  protected
         * @param   Array references
         * @return  void
         */
        _imageUploadPreloadSuccess: function(references) {
            var upload = this._currentUpload;
            this._completeSuccessfulUpload([upload]);
        },

        /**
         * _itemExtensionZip
         * 
         * @access  protected
         * @param   Blob|File item
         * @return  Boolean
         */
        _itemExtensionZip: function(item) {
            var zip = item.name.match(/\.zip$/i) !== null;
            return zip;
        },

        /**
         * _maxItemsUploaded
         * 
         * @access  protected
         * @return  Boolean
         */
        _maxItemsUploaded: function() {
            var maxSequentialUploads = this._getMax('sequential');
            if (this._currentUploadItems.length > maxSequentialUploads) {
                if (this._type === 'font') {
                    this._showAlert('upload.font.max.count');
                    return true;
                }
                this._showAlert('upload.image.max.count');
                return true;
            }
            return false;
        },

        /**
         * minItemsUploaded
         * 
         * @access  protected
         * @return  Boolean
         */
        minItemsUploaded: function() {
            if (this._currentUploadItems.length === 0) {
                return false;
            }
            return true;
        },

        /**
         * _processItems
         * 
         * @access  protected
         * @return  void
         */
        _processItems: function() {
            var items = this._currentUploadItems,
                total = items.length;
            this.triggerHandler('start');
            this._ui.updateContext.apply(this);
            var next = (function(index) {
                var current = index + 1;
                this._ui.updateCurrentCount.apply(this, [current]);
                this.once({
                    'process/next': function(event) {
                        index += 1;
                        if (items[index] !== undefined) {
                            next(index);
                        }
                    }
                });
                this._uploadItem(items[index]);
            }).proxy(this);
            next(0);
        },

        /**
         * _processSuccessfulFontUploadSync
         * 
         * @access  protected
         * @return  void
         */
        _processSuccessfulFontUploadSync: function() {
            this._createFontRecord();
        },

        /**
         * _processSuccessfulImageUploadSync
         * 
         * The point of preloading and have success/error callbacks is so that
         * if there's a problem accessing the image's converted sizes, we can
         * signal an error to the user and allow them to re-upload the file. An
         * example of this would be if the user uploads a .zip file that was
         * accidentally renamed .jpeg. This would get passed the checks (both
         * drag/drop and click of the dropzone pad), but would fail when
         * accessed via Cloudinary.
         * 
         * @todo    Ensure that the <upload.syncDimensions> call
         *          is hooked up to the complete event here
         * @access  protected
         * @return  void
         */
        _processSuccessfulImageUploadSync: function() {
            this._currentUpload.preload(
                this._imageUploadPreloadSuccess.proxy(this),
                this._imageUploadPreloadError.proxy(this)
            );
        },

        /**
         * _processSuccessfulS3Upload
         * 
         * @access  protected
         * @param   jQuery event
         * @param   Object response https://i.imgur.com/8HOGMXx.png
         * @return  void
         */
        _processSuccessfulS3Upload: function(event, response) {
            this.show('status', 'processing');
            // this._uploading = false;
            this._currentUpload.set({
                'uploaded': 1
            });
            this._currentUpload.once({
                'sync/complete': this._processSuccessfulUploadSync.proxy(this)
            });
            var uploadInterstitialCallback = this._getUploadInterstitialCallback(),
                upload = this._currentUpload;
            this._currentUpload.save(
                ['uploaded'],
                {
                    success: function() {
                        uploadInterstitialCallback(upload, function() {
                            upload.sync();
                        });
                    }
                }
            );
        },

        /**
         * _processSuccessfulUploadSync
         * 
         * @access  protected
         * @param   jQuery event
         * @param   false|Object response https://i.imgur.com/59QUuPW.png
         * @return  Boolean
         */
        _processSuccessfulUploadSync: function(event, response) {
            if (response === false) {
                var args = [response.data];
                this._completeFailedUpload(args);
                return false;
            }
            if (this._type === 'font') {
                this._processSuccessfulFontUploadSync();
                return true;
            }
            this._processSuccessfulImageUploadSync();
            return true;
        },

        /**
         * _showAlert
         * 
         * @access  protected
         * @param   String key
         * @return  AlertModalView
         */
        _showAlert: function(key) {
            Stencil.set('ignoreMouseDownLayerBlur', true);
            Stencil.alert(key);
            var modal = ModalUtils.get('Alert');
            modal.once({
                'leave': Stencil.set.proxy(
                    Stencil,
                    ['ignoreMouseDownLayerBlur', false]
                )
            });
            return modal;
        },

        /**
         * _trackError
         * 
         * @access  protected
         * @param   Object err
         * @return  void
         */
        _trackError: function(err) {
            var msg = {
                err: err
            };
            Track.event('Dropzone upload fail', msg);
            RequestUtils.report('upload:upload/error', msg);
        },

        /**
         * _ui
         * 
         * @access  protected
         * @var     Object
         */
        _ui: {

            /**
             * clearInput
             * 
             * @access  protect
             * @return  void
             */
            clearInput: function() {
                var $file = this.find('input[type="file"].files');
                $file.val('');
            },

            /**
             * hideAbortUpload
             * 
             * @access  protected
             * @return  void
             */
            hideAbortUpload: function() {
                var $cta = this.find('div.status div.uploading div.cta');
                $cta.addClass('hidden');
            },

            /**
             * hideContext
             * 
             * @access  protected
             * @return  void
             */
            hideContext: function() {
                var $context = this.find('.context');
                $context.addClass('hidden');
            },

            /**
             * resetProgress
             * 
             * @access  protected
             * @return  void
             */
            resetProgress: function() {
                var $progress = this.find('.progress'),
                    $percentage = this.find('.percentage');
                $progress.addClass('off');
                $progress.css({
                    width: '0%'
                });
                $progress.removeClass('off');
                $percentage.text('0%');
            },

            /**
             * showAbortUpload
             * 
             * Shows the cancel call to action if the file that's being uploaded
             * is at least the minimum amount required for an abort (as defined
             * within the AWS.S3.ManagedUpload instance).
             * 
             * @see     https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3/ManagedUpload.html#minPartSize-property
             * @access  protected
             * @return  void
             */
            showAbortUpload: function() {
                var item = this._currentUploadItem,
                    $cta = this.find('div.status div.uploading div.cta'),
                    abortablePartSize = this._managedUpload.partSize;
                if (item.size > abortablePartSize) {
                    $cta.removeClass('hidden');
                } else {
                    var totalItems = this._currentUploadItems.length;
                    if (totalItems > 1) {
                        var itemsProcessed = this._getItemsProcessed();
                        if (itemsProcessed < totalItems) {
                            $cta.removeClass('hidden');
                        }
                    }
                }
            },

            /**
             * showHideAbortUpload
             * 
             * @access  protected
             * @return  void
             */
            showHideAbortUpload: function() {
                this._ui.hideAbortUpload.apply(this);
                this._ui.showAbortUpload.apply(this);
            },

            /**
             * showUploadStarting
             * 
             * @access  protected
             * @return  void
             */
            showUploadStarting: function() {
                this.show('status', 'uploading');
                this._ui.resetProgress.apply(this);
            },

            /**
             * updateContext
             * 
             * @access  protected
             * @return  void
             */
            updateContext: function() {
                var items = this._currentUploadItems,
                    total = items.length,
                    $context = this.find('.context');
                $context.addClass('hidden');
                if (total > 1) {
                    $context.removeClass('hidden');
                    this._ui.updateTotalCount.apply(this, [total]);
                }
            },

            /**
             * updateCurrentCount
             * 
             * @access  protected
             * @param   Number count
             * @return  void
             */
            updateCurrentCount: function(count) {
                var $current = this.find('[lookup="current"]');
                $current.text(count);
            },

            /**
             * updateProgress
             * 
             * @access  protected
             * @param   Number percentage
             * @return  void
             */
            updateProgress: function(percentage) {
                var $progress = this.find('.progress'),
                    $percentage = this.find('.percentage');
                if (percentage < 3) {
                    percentage = 3;
                }
                percentage += '%';
                $progress.css({
                    width: percentage
                });
                $percentage.text(percentage);
            },

            /**
             * updateTotalCount
             * 
             * @access  protected
             * @param   Number count
             * @return  void
             */
            updateTotalCount: function(count) {
                var $total = this.find('[lookup="total"]');
                $total.text(count);
            }
        },

        /**
         * _uploadItem
         * 
         * @todo    Proper error handling for too large of a file
         * @todo    When upload reaches 100%, switch to Processing state right
         *          away. Do this because sometimes things freeze for a few
         *          seconds here, which is confusing since it says 100%.
         * @access  protected
         * @param   Blob|File item
         * @param   Function callback
         * @return  void
         */
        _uploadItem: function(item, callback) {
            this._uploading = true;
            this._currentUploadItem = item;
            this._ui.hideAbortUpload.apply(this);
            this._ui.showUploadStarting.apply(this);
            this._createUploadRecord();
        },

        /**
         * _uploadRecordCreateSuccess
         * 
         * @access  protected
         * @param   Object response
         * @return  Boolean
         */
        _uploadRecordCreateSuccess: function(response) {
            var upload = this._getUploadResponseAccessor(response.object);
            this._currentUpload = upload;
            var s3UploadResponse = this._getS3UploadResponse();
            if (s3UploadResponse.success === false) {
                this.show('prompt');
                this._uploading = false;
                this.resetReferences();
                this._showAlert(s3UploadResponse.failedRules[0].key);
                return false;
            }

            // Move ahead
            this._managedUpload = s3UploadResponse.response.managedUpload;
            this._addUploadAbortListener();
            this._addUploadErrorListener();
            this._addUploadProgressListener();
            this._addUploadSuccessListener();
            this._fakeUploadProcess();
            return true;
        },

        /**
         * _validItemFilesizes
         * 
         * @access  protect
         * @return  Boolean
         */
        _validItemFilesizes: function() {
            if (this._validItemMaxFilesizes() === false) {
                return false;
            }
            if (this._validItemMinFilesizes() === false) {
                return false;
            }
            return true;
        },

        /**
         * _validItemFontTypes
         * 
         * @access  protected
         * @return  Boolean
         */
        _validItemFontTypes: function() {
            var item,
                items = this._currentUploadItems,
                index;
            for (index in items) {
                item = items[index];
                if (this._itemExtensionZip(item) === true) {
                    this._alerts.zip.apply(this);
                    return false;
                }
            }
            return true;
        },

        /**
         * _validItemImageTypes
         * 
         * @access  protected
         * @return  Boolean
         */
        _validItemImageTypes: function() {
            var imageTypes = Config.default('validImageUploadContentTypes'),
                index,
                item,
                items = this._currentUploadItems,
                type;
            for (index in items) {
                item = items[index];
                type = item.type;
                type = DataUtils.guessItemContentType(item);
                if (ArrayUtils.contains(type, imageTypes) === false) {
                    this._showAlert('upload.image.type');
                    return false;
                }
            }
            return true;
        },

        /**
         * _validItemMaxFilesizes
         * 
         * @access  protect
         * @return  Boolean
         */
        _validItemMaxFilesizes: function() {
            var index,
                item,
                items = this._currentUploadItems,
                maxFilesize = this._getMax('filesize');
            for (index in items) {
                item = items[index];
                if (item.size > maxFilesize) {
                    if (this._type === 'font') {
                        this._showAlert('upload.font.max.filesize');
                        return false;
                    }
                    this._showAlert('upload.image.max.filesize');
                    return false;
                }
            }
            return true;
        },

        /**
         * _validItemMinFilesizes
         * 
         * @access  protect
         * @return  Boolean
         */
        _validItemMinFilesizes: function() {
            var index,
                item,
                items = this._currentUploadItems;
            for (index in items) {
                item = items[index];
                if (item.size < 10) {
                    var key = 'upload.singular.filesize.zero';
                    if (items.length > 1) {
                        key = 'upload.multiple.filesize.zero';
                    }
                    this._showAlert(key);
                    return false;
                }
            }
            return true;
        },

        /**
         * _validItems
         * 
         * @access  protected
         * @return  Boolean
         */
        _validItems: function() {
            if (this._maxItemsUploaded() === true) {
                return false;
            }
            if (this.minItemsUploaded() === false) {
                return false;
            }
            if (this._validItemTypes() === false) {
                return false;
            }
            if (this._validItemFilesizes() === false) {
                return false;
            }
            return true;
        },

        /**
         * _validItemTypes
         * 
         * @access  protected
         * @return  Boolean
         */
        _validItemTypes: function() {
            if (this._type === 'font') {
                if (this._validItemFontTypes() === false) {
                    return false;
                }
                return true;
            }
            if (this._validItemImageTypes() === false) {
                return false;
            }
            return true;
        },

        /**
         * availableForUpload
         * 
         * @access  public
         * @return  Boolean
         */
        availableForUpload: function() {
            if (Config.serviceAvailable('aws') === false) {
                this._showAlert('service.aws');
                return false;
            }
            if (this._uploading === true) {
                return false;
            }
            return true;
        },

        /**
         * getType
         * 
         * @access  public
         * @return  String
         */
        getType: function() {
            var type = this._type;
            return type;
        },

        /**
         * resetReferences
         * 
         * @access  public
         * @return  void
         */
        resetReferences: function() {
            this._currentUpload = null;
            this._currentUploadItem = null;
            this._currentUploadItems = [];
        },

        /**
         * resetUploadInterstitialCallback
         * 
         * @access  public
         * @return  void
         */
        resetUploadInterstitialCallback: function() {
            this._uploadInterstitialCallback = this._defaultUploadInterstitialCallback;
        },

        /**
         * setUploadInterstitialCallback
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        setUploadInterstitialCallback: function(callback) {
            this._uploadInterstitialCallback = callback;
        },

        /**
         * show
         * 
         * @access  public
         * @param   String parent
         * @param   undefined|String child
         * @return  void
         */
        show: function(parent, child) {

            // Parent
            var $prompt = this.find('.prompt'),
                $status = this.find('.status');
                $parent = this.find('.' + (parent));
            $prompt.addClass('invisible');
            $status.addClass('invisible');
            $prompt.removeClass('visible');
            $status.removeClass('visible');
            $parent.removeClass('invisible');
            $parent.addClass('visible');

            // Child 
            if (child !== undefined) {
                $status.removeClass('uploading');
                $status.removeClass('processing');
                $status.removeClass('ending');
                $status.removeClass('complete');
                $status.removeClass('failed');
                $status.addClass(child);
            }
        },

        /**
         * uploadItems
         * 
         * @access  public
         * @param   Array items
         * @return  Boolean
         */
        uploadItems: function(items) {
            this._currentUploadItems = items;
            this._ui.clearInput.apply(this);
            if (this._validItems() === true) {
                this._processItems();
                return true;
            }
            this.resetReferences();
            return false;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * FontsDropdownView
     * 
     * @events  hover
     *          close
     *          open
     *          toggle
     *          select
     * @extends View
     */
    window.FontsDropdownView = View.extend({

        /**
         * _dropzone
         * 
         * @access  protected
         * @var     null|FontsDropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _fontsCollection
         * 
         * @access  protected
         * @var     null|FontsCollection (default: null)
         */
        _fontsCollection: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'nav a[section]': function(event, $anchor) {
                        event.preventDefault();
                        var section = $anchor.attr('section');
                        this.showTab(section);
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'div.selected a': function(event, $anchor) {
                        event.preventDefault();
                        this.toggle();
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'li a.label': function(event, $anchor) {
                        event.preventDefault();
                        var value = $anchor.parent().attr('value'),
                            font = this._fontsCollection.findByFamilyName(value);
                        this.selectFont(font);
                        this.saveFontAsAccountDefault(font);
                        this.triggerHandler('select', font);
                        this.close();
                    }
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'li a': function(event, $anchor) {
                        var $li = $anchor.parent(),
                            value = $li.attr('value'),
                            font = this._fontsCollection.findByFamilyName(value);
                        $li.siblings().removeClass('hover');
                        $li.addClass('hover');
                        this.triggerHandler('hover', font);
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'li a': function(event, $anchor) {
                        var $li = $anchor.parent();
                        $li.removeClass('hover');
                    }
                }
            });
        },

        /**
         * _scrollbars
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _scrollbars: {},

        /**
         * _selectedFont
         * 
         * @access  protected
         * @var     false|FontAccessor
         */
        _selectedFont: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontsDropdownView')
         */
        _string: 'FontsDropdownView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   FontsCollection fontsCollection
         * @return  void
         */
        init: function(element, fontsCollection) {
            this._super(element);
            this._fontsCollection = fontsCollection;
            this._addAuthEvents();
            this._addHoverEvents();
            this._setupAuth();
            this._setupDropzone();
            this._setupImportClickEvent();
            this.on({
                'edit': function(event, $anchor) {
                    var key = $anchor.attr('key'),
                        font = this._fontsCollection.find(key);
                    this._edit(font);
                },
                'confirm/delete': function(event, $anchor) {
                    var key = $anchor.attr('key'),
                        font = this._fontsCollection.find(key);
                    this._confirmDelete(font);
                }
            });
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }
            this.showAppropriateMessagingElements();
        },

        /**
         * _addAuthEvents
         * 
         * @note    Delayed to the end of the stack (via 0 millisecond delay) to
         *          ensure the modal is available before an event is bound to it.
         * @access  protected
         * @return  void
         */
        _addAuthEvents: function() {
            var $anchors = this._element.find(
                'a[href^="/app/login"], ' +
                'a[href^="/app/signup"], ' +
                'a[href^="/app/plans"]'
            );
            $anchors.on({
                'click': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', true);
                    (function() {
                        var modal = ModalUtils.getOpen()[0];
                        modal.once({
                            'close': function() {
                                Stencil.set('ignoreMouseDownLayerBlur', false);
                            }
                        });
                    }).delay(0);
                }
            });
        },

        /**
         * _addEscapeEvent
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeEvent: function() {
            var _this = this,
                callback = function(event) {
                    if (
                        event.which === 27
                        && Stencil.get('ignoreMouseDownLayerBlur') !== true
                        && _this._element.hasClass('open') === true
                    ) {
                        event.preventDefault();
                        _this.close();
                        // $(this).unbind(event);
                    }
                };
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _addHoverEvents
         * 
         * @note    There is a bug where by if the page has a scrollbar and an
         *          element that is being hovered over exists outside of the
         *          scope of the page-scrollbar, the elementFromPoint can't seem
         *          to find it, resulting in the following error:
         *          https://i.imgur.com/SdBdmRf.png
         *          So to deal with this, I simply ensure the length of $el is
         *          greater than 0.
         * @access  protected
         * @return  void
         */
        _addHoverEvents: function() {
            this.find('div.list').scroll(function(event) {
                var el = document.elementFromPoint(App.getX(), App.getY()),
                    $el = $(el);
                if ($el.length > 0) {
                    if ($el.tag() === 'a') {
                        $el.trigger('mouseenter');
                    }
                }
            });
        },

        /**
         * _blur
         * 
         * @access  protected
         * @param   jQuery event
         * @return  void
         */
        _blur: function(event) {
            var $target = $(event.target);
            if (Stencil.get('ignoreMouseDownLayerBlur') !== true) {
                if ($target.closest('.fontsDropdown').length === 0) {
                    this.close();
                }
            }
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @param   FontAccessor font
         * @return  void
         */
        _confirmDelete: function(font) {
            var _this = this,
                question = 'Are you sure you want to delete this font?',
                // h2 = '<strong>WARNING:</strong> This cannot be undone. Any ' +
                //     'images you’ve saved using this font will revert to a ' +
                //     'default font.',
                // modal = ModalUtils.showConfirmDelete(question, h2);
                modal = ModalUtils.showConfirmDelete(question);
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.getElement().addClass('warning');
            modal.on({
                'close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'yes': function(event) {

                    // Revert any fonts being used to the app default
                    _this._revertTextLayersUsingFont(font);

                    /**
                     * Wait until the stack has ended (to ensure mouseup or
                     * keyup events have fired), and then go through the change
                     * history and swap out any text layers that were using that
                     * font with the app default. This is to prevent a bug when
                     * trying to revert to one of those older or future
                     * versions.
                     * 
                     * Without the 0-second delay (which effectively just moves
                     * the call to the end of the stack), no operation gets
                     * recorded, since previous operations would have had their
                     * font families reverted to the app default already, which
                     * means the ChangeHistory.track method wouldn't notice that
                     * anything's changed.
                     */
                    ChangeHistory.syncDeletedFont.delay(0, ChangeHistory, [font]);

                    // Overhead procedures
                    _this.removeFont(font);
                    font.delete();
                    _this.showAppropriateMessagingElements();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _edit
         * 
         * @access  protected
         * @param   FontAccessor font
         * @return  void
         */
        _edit: function(font) {
            var _this = this,
                modal = ModalUtils.showRename(font, 'label');
            modal.find('input').select();
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.on({
                'close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'save': function(event, object) {
                    font.set({
                        label: object.label
                    });
                    var familyName = font.get('familyName'),
                        $li = _this.find('li[value="' + (familyName) + '"]'),
                        $label = $li.find('a.label');
                    $label.text(object.label);
                    this.triggerHandler.delay(500, this, ['close']);
                }
            });
        },

        /**
         * _focusOnSelectedFont
         * 
         * @access  protected
         * @return  void
         */
        _focusOnSelectedFont: function() {
            var uploaded = this._selectedFont.get('uploaded').toInt() === 1
                    && this._selectedFont.get('hasRegularAccess').toInt() === 1,
                sections = {
                    $default: this.find('section[section="default"]'),
                    $uploaded: this.find('section[section="uploaded"]')
                },
                lists = {
                    $default: this.find('[section="default"] div.list'),
                    $uploaded: this.find('[section="uploaded"] div.list')
                },
                $active = this.find('[section] li.active');
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._scrollbars.$default.data('jsp').scrollToY(0, false);
                this._scrollbars.$uploaded.data('jsp').scrollToY(0, false);
                if (uploaded === false) {
                    this._scrollbars.$default.data('jsp').scrollToY(
                        $active.position().top - 4,
                        false
                    );
                } else {
                    this._scrollbars.$uploaded.data('jsp').scrollToY(
                        $active.position().top - 4,
                        false
                    );
                }
            } else {
                sections.$default.removeClass('hidden');
                lists.$default.scrollTop(0);
                sections.$default.addClass('hidden');
                sections.$uploaded.removeClass('hidden');
                lists.$uploaded.scrollTop(0);
                sections.$uploaded.addClass('hidden');
                if (uploaded === false) {
                    sections.$default.removeClass('hidden');
                    lists.$default.scrollTop($active.position().top - 4);
                } else {
                    sections.$uploaded.removeClass('hidden');
                    lists.$uploaded.scrollTop($active.position().top - 4);
                }
            }
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $default
         * @param   jQuery $uploaded
         * @return  void
         */
        _makeScrollable: function($default, $uploaded) {
            this._scrollbars.$default = $default;
            this._scrollbars.$uploaded = $uploaded;
            this._scrollbars.$default.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            this._scrollbars.$uploaded.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _revertTextLayersUsingFont
         * 
         * @access  protected
         * @param   FontAccessor font
         * @return  void
         */
        _revertTextLayersUsingFont: function(font) {
            var account = Stencil.account(),
                fontsCollection = this._fontsCollection,
                appDefaultFontFamily = Stencil.account().getDefaultFontFamily(),
                backupFont = fontsCollection.findByFamilyName(appDefaultFontFamily),
                draftImageDocument = account.draft().getImageDocument(),
                textLayersWithSelectedFont = draftImageDocument.filter(function(index, layer) {
                    return layer.getStyle('fontFamily') === font.get('familyName');
                });
            if (textLayersWithSelectedFont.length > 0) {
                ChangeHistory.setOperationType('fonts // reset');
            }
            jQuery.each(textLayersWithSelectedFont, function(index, textLayer) {
                textLayer.triggerHandler('change/fontFamily', backupFont);
            });

            /**
             * Re-select the font for this selected layer, just incase it was
             * deleted. This ensures either the backup font is showing in the
             * dropdown if it ought to be.
             */
            var activeFontFamily = Canvases.Preview.getSelectedLayer().getStyle('fontFamily'),
                activeFont = fontsCollection.findByFamilyName(activeFontFamily);
            this.selectFont(activeFont);
        },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            var _this = this;
            User.once({
                'login': function(event) {
                    _this.showAppropriateMessagingElements();
                },
                'signup': function(event, user) {
                    _this.showAppropriateMessagingElements();
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this.showAppropriateMessagingElements();
                }
            });
        },

        /**
         * _setupDropzone
         * 
         * @access  protected
         * @return  void
         */
        _setupDropzone: function() {
            var collection = this._fontsCollection,
                $dropzone = this.find('.dropzone');
            this._dropzone = new FontsDropzoneView($dropzone, 'font');
            this._dropzone.on({
                'complete/failed': function(event, response) {
                    LogUtils.log.simple('Failed FontsDropzone upload', true);
                },
                'complete/successful': function(event, upload, font) {
                    Track.event('Font uploaded');
                    collection.add(font);
                    font.loadFull(function() {
                        var fontsDropdown = Toolbars.getToolbar('text').getFontsDropdown();
                        fontsDropdown.addFont(font, false);
                        fontsDropdown.scrollToTop('uploaded');
                    });
                }
            });
        },

        /**
         * _setupImportClickEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupImportClickEvent: function() {
            this.on({
                'import': function(event, $anchor) {
                    // if (Account.upgraded() === true || User.admin() === true) {
                        Stencil.navigate('/app/fonts/import');
                    // } else {
                    //     Stencil.navigate('/app/upgrade/pro/font-imports?clean=1');
                    // }
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            var $default = this.find('section[section="default"] div.list'),
                $uploaded = this.find('section[section="uploaded"] div.list');
            $default.addClass('dark');
            $uploaded.addClass('dark');
            this._makeScrollable($default, $uploaded);
        },

        /**
         * _showTabForSelectedFont
         * 
         * @access  protected
         * @return  void
         */
        _showTabForSelectedFont: function() {
            var font = this._selectedFont,
                section = 'default';
            if (
                font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1
            ) {
                section = 'uploaded';
            }
            this.showTab(section);
        },

        /**
         * addFont
         * 
         * @access  public
         * @param   FontAccessor font
         * @param   Boolean sort
         * @return  void
         */
        addFont: function(font, sort) {
            this.showAppropriateMessagingElements();
            var section = font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1 ? 'uploaded' : 'default';
            var $section = this.find('section[section="' + (section) + '"]'),
                $li = $('<li></li>'),
                $a = $('<a class="label" click="" trigger="null"></a>'),
                $editIcon = $('<a class="icon edit fa fa-pencil" click="" trigger="edit"></a>'),
                $deleteIcon = $('<a class="icon delete fa fa-trash" click="" trigger="confirm/delete"></a>');
            $li.attr('value', font.get('familyName'));
            $li.attr('style', 'font-family: ' + (font.get('familyName')) + ', monospace');
            $a.text(font.get('label'));
            $editIcon.attr('key', font.get('key'));
            $deleteIcon.attr('key', font.get('key'));
            $li.append($a);
            if (
                font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1
            ) {
                $li.append($editIcon, $deleteIcon);
            }
            $section.find('ul').prepend($li);
            if (sort === true) {
                $section.find('ul')[0].orderAlphabeticallyByText();
            }
            this.refreshScrollbars(section);
        },

        /**
         * close
         * 
         * @access  public
         * @return  void
         */
        close: function() {
            this._element.removeClass('open');
            this.triggerHandler('close');
        },

        /**
         * getDropzone
         * 
         * @access  public
         * @return  FontsDropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        },

        /**
         * getFontsCollection
         * 
         * @access  public
         * @return  FontsCollection
         */
        getFontsCollection: function() {
            return this._fontsCollection;
        },

        /**
         * getSelectedFont
         * 
         * @access  public
         * @return  false|FontAccessor
         */
        getSelectedFont: function() {
            return this._selectedFont;
        },

        /**
         * open
         * 
         * @access  public
         * @return  void
         */
        open: function() {
            this._addEscapeEvent();
            var callback = this._blur.proxy(this);
            App.getElement().on({
                'click': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('click', callback);
                }
            });
            this._element.addClass('open');
            this._showTabForSelectedFont();
            this.refreshScrollbars();
            this._focusOnSelectedFont();
            this.triggerHandler('open');

            // 
            var callback = this._blur.proxy(this),
                cotton = Canvases.Preview.getCotton();
            cotton.on({
                'object:selected': callback
            });
            this.once({
                'close': function(event) {
                    cotton.off('object:selected', callback);
                }
            });
        },

        /**
         * refreshScrollbars
         * 
         * @access  public
         * @param   undefined|String section
         * @return  void
         */
        refreshScrollbars: function(section) {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                var sections = {
                        $default: this.find('section[section="default"]'),
                        $uploaded: this.find('section[section="uploaded"]')
                    },
                    lists = {
                        $default: this.find('[section="default"] div.list'),
                        $uploaded: this.find('[section="uploaded"] div.list')
                    };
                sections.$default.removeClass('hidden');
                sections.$uploaded.removeClass('hidden');
                this._scrollbars.$default.data('jsp').reinitialise();
                this._scrollbars.$uploaded.data('jsp').reinitialise();
                sections.$default.addClass('hidden');
                sections.$uploaded.addClass('hidden');
                if (section === undefined) {
                    var font = this._selectedFont;
                    if (
                        font.get('uploaded').toInt() === 1
                        && font.get('hasRegularAccess').toInt() === 1
                    ) {
                        sections.$uploaded.removeClass('hidden');
                    } else {
                        sections.$default.removeClass('hidden');
                    }
                } else {
                    if (section === 'default') {
                        sections.$default.removeClass('hidden');
                    } else {
                        sections.$uploaded.removeClass('hidden');
                    }
                }
            }
        },

        /**
         * removeFont
         * 
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        removeFont: function(font) {
            var familyName = font.get('familyName'),
                $li = this.find('li[value="' + (familyName) + '"]');
            $li.remove();
            this.refreshScrollbars('uploaded');
        },

        /**
         * saveFontAsAccountDefault
         * 
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        saveFontAsAccountDefault: function(font) {
            if (font.get('uploaded').toInt() === 0) {
                var account = Stencil.account();
                account.push('settings.defaultFontFamily', font.get('key'));
            }
        },

        /**
         * scrollToTop
         * 
         * @access  public
         * @param   String section
         * @return  void
         */
        scrollToTop: function(section) {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                if (section === 'uploaded') {
                    this._scrollbars.$uploaded.data('jsp').scrollToY(0, false);
                } else {
                    this._scrollbars.$default.data('jsp').scrollToY(0, false);
                }
            } else {
                this.find('[section="' + (section) + '"] div.list').scrollTop(0);
            }
        },

        /**
         * selectFont
         * 
         * Sets an internal reference to the passed in FontAccessor, and updates
         * the UI so that the .selected element has that corresponding label
         * and font-family set.
         * 
         * @note    I remove any possible "hidden" class from the list item to
         *          ensure that if the font is a legacy one, it can be seen. This
         *          is because legacy fonts are written to the DOM, but simply
         *          hidden (since they're only used when legacy images or
         *          templates are used).
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        selectFont: function(font) {
            this._selectedFont = font;
            var familyName = font.get('familyName'),
                label = font.get('label'),
                $li = this.find('li[value="' + (familyName) + '"]'),
                $copy = this.find('div.selected a span.copy'),
                $items = this.find('section[section] div ul li');
            $li.removeClass('hidden');
            $items.removeClass('active');
            $li.addClass('active');
            $copy.css('font-family', familyName);
            $copy.text(label);
        },

        /**
         * showAppropriateMessagingElements
         * 
         * @access  public
         * @return  void
         */
        showAppropriateMessagingElements: function() {
            var $lists = this.find('section[section="uploaded"] div.list');
            $lists.removeClass('hidden');
            this.find('.messaging,.empty,.guest,.free').addClass('hidden');
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                if (this._fontsCollection.getUploaded().length === 0) {
                    $lists.addClass('hidden');
                    this.find('.messaging,.empty').removeClass('hidden');
                }
            } else {
                $lists.addClass('hidden');
                if (Account.guest() === true) {
                    this.find('.messaging,.guest').removeClass('hidden');
                } else if (Account.free() === true) {
                    this.find('.messaging,.free').removeClass('hidden');
                } else {
                    // Should never get here
                }
            }
        },

        /**
         * showTab
         * 
         * @access  public
         * @param   String section
         * @return  void
         */
        showTab: function(section) {
            this.find('nav a[section]').addClass('noAnimation').removeClass('active');
            this.find('nav a[section="' + (section) + '"]').addClass('active');
            this.find('nav a[section]').removeClass('noAnimation');
            this.find('section[section]').addClass('hidden');
            this.find('section[section="' + (section) + '"]').removeClass('hidden');
        },

        /**
         * toggle
         * 
         * Either closes or opens the dropdown by calling the helper <close> or
         * <open> methods. Also fires the <toggle> event.
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            this.triggerHandler('toggle');
            if (this._element.hasClass('open') === true) {
                this.close();
            } else {
                this.open();
            }
        }
    });
});
window.DependencyLoader.push('DropzoneView', function() {

    /**
     * FontsDropzoneView
     * 
     * @events  complete
     * @extends DropzoneView
     */
    window.FontsDropzoneView = DropzoneView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontsDropzoneView')
         */
        _string: 'FontsDropzoneView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @return  void
         */
        init: function(element, type) {
            this._super(element, type);
        },

        /**
         * _maxFontsUploaded
         * 
         * @access  protected
         * @return  Boolean
         */
        _maxFontsUploaded: function() {
            var fonts = Stencil.account().collection('fonts').getUploaded(),
                max = Config.default('maxFontUploads');
            if (fonts.length < max) {
                return false;
            }
            var alertKey = 'font.import.max';
                modal = this._showAlert(alertKey);
            return true;
        },

        /**
         * _showFontsUpgrade
         * 
         * @access  protected
         * @return  void
         */
        _showFontsUpgrade: function() {
            Stencil.set('ignoreMouseDownLayerBlur', true);
            Stencil.navigate('/app/upgrade/pro/fonts?clean=1');
            var modal = ModalUtils.getOpen()[0];
            modal.once({
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
        },

        /**
         * availableForUpload
         * 
         * @access  public
         * @return  Boolean
         */
        availableForUpload: function() {
            if (this._super() === false) {
                return false;
            }
            if (Config.serviceAvailable('fontUploads') === false) {
                Stencil.alert('services.fontUploads.unavailable');
                return false;
            }
            if (this._maxFontsUploaded() === true) {
                return false;
            }
            if (Account.upgraded() === true) {
                return true;
            }
            if (User.admin() === true) {
                return true;
            }
            if (User.editor() === true) {
                return true;
            }
            this._showFontsUpgrade();
            return false;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * FrameView
     * 
     * @extends View
     */
    window.FrameView = View.extend({

        /**
         * _frame
         * 
         * @access  protected
         * @var     null|FrameAccessor (default: null)
         */
        _frame: null,

        /**
         * _resizer
         * 
         * @access  protected
         * @var     null|ResizerView (default: null)
         */
        _resizer: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FrameView')
         */
        _string: 'FrameView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ResizerView resizer
         * @param   FrameAccessor frame
         * @return  void
         */
        init: function(element, resizer, frame) {
            this._super(element);
            this._resizer = resizer;
            this._frame = frame;
            this._addSelectListener();
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event) {
                    this._handleSelectEvent();
                }
            });
        },

        /**
         * _handleCropperSelectEvent
         * 
         * @access  protected
         * @return  Boolean
         */
        _handleCropperSelectEvent: function() {
            var cropper = this._resizer.getParentView();
            cropper.triggerHandler('resize', [this._frame]);
            this._resizer.hide();
        },

        /**
         * _handleSelectEvent
         * 
         * @access  protected
         * @return  Boolean
         */
        _handleSelectEvent: function() {
            if (this._resizer.getParentView() === App.getStage().getContent()) {
                this._handleStageContentSelectEvent();
                return true;
            }
            this._handleCropperSelectEvent();
            return true;
        },

        /**
         * _handleStageContentSelectEvent
         * 
         * Listens for a frame being selected in the UI, and when it is, first
         * tracks the position of the background image (relative to the
         * background image and frame-key combination) before changing to the
         * new frame. This is because it's possible that the user moves the
         * background position from it's default 50,50 position, and just wants
         * to see what, for example, a Pinterest frame looks like. By storing
         * this background position, it allows us to reposition the background
         * image if the user goes back to the previous frame. It is less
         * jarring.
         * 
         * After the select happens against the FrameAccessor, I then redraw the
         * image (via the setToPreviewCanvas method), and then restore the
         * background image (relative to the background image and the frame
         * being switched to), if any position details were stored (logic is
         * elsewhere for that).
         * 
         * Finally, I hide the Resizer, and make a call to set the configuration
         * of the image to ensure, after the application-wide save-delay, the
         * image configuration details are saved.
         * 
         * @access  protected
         * @return  Boolean
         */
        _handleStageContentSelectEvent: function() {
            ChangeHistory.setOperationType('frame // changed');
            var canvas = Canvases.Preview,
                draft = Stencil.account().draft();
            canvas.trackBackgroundImageLayerPosition();
            this._frame.select();
            this._frame.setToPreviewCanvas();
            canvas.restoreFrameSpecificPosition();
            this._resizer.hide();
            draft.setConfiguration();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * GoogleFontRowView
     * 
     * @extends View
     */
    window.GoogleFontRowView = View.extend({

        /**
         * _googleFont
         * 
         * @access  protected
         * @var     null|GoogleFontAccessor (default: null)
         */
        _googleFont: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontRowView')
         */
        _string: 'GoogleFontRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GoogleFontAccessor googleFont
         * @return  void
         */
        init: function(element, googleFont) {
            this._super(element);
            this._googleFont = googleFont;
            this._addImportListener();
        },

        /**
         * _accountHasReachedMaximumFonts
         * 
         * @access  protected
         * @return  Boolean
         */
        _accountHasReachedMaximumFonts: function() {
            var fonts = Stencil.account().collection('fonts').getUploaded(),
                max = Config.default('maxFontUploads');
            if (fonts.length < max) {
                return false;
            }
            return true;
        },

        /**
         * _addImportListener
         * 
         * @access  protected
         * @return  void
         */
        _addImportListener: function() {
            this.on({
                'import': function(event, $button) {
                    this._attemptImport();
                }
            });
        },

        /**
         * _attemptImport
         * 
         * @access  protected
         * @return  Boolean
         */
        _attemptImport: function() {
            if (Config.serviceAvailable('fontUploads') === false) {
                Stencil.alert('services.fontUploads.unavailable');
                return false;
            }
            if (this._authorizedToImportGoogleFont() === false) {
                ModalUtils.showUpgrade('pro', 'annually', 'font-imports');
                return false;
            }
            if (this._accountHasReachedMaximumFonts() === true) {
                Stencil.alert('font.import.max');
                return false;
            }
            this._import();
            return true;
        },

        /**
         * _authorizedToImportGoogleFont
         * 
         * @access  protected
         * @return  Boolean
         */
        _authorizedToImportGoogleFont: function() {
            if (User.admin() === true) {
                return true;
            }
            if (User.editor() === true) {
                return true;
            }
            if (Account.upgraded() === true) {
                return true;
            }
            return false;
        },

        /**
         * _import
         * 
         * @access  protected
         * @return  Boolean
         */
        _import: function() {
            var modal = ModalUtils.getOpen()[0],
                $button = this.lookup('importButton');
            modal.pause();
            $button.addClass('busy');
            $button.disable();
            // modal.find('a.button.tiny').disable();
            this._googleFont.once({
                'import': function(event, data) {

                    // Button updates
                    $button.removeClass('busy');
                    $button.addClass('done');
                    // modal.find('a.button.tiny:not(.done)').enable();
                    // $button.enable();
                    modal.unpause();

                    // Collection updates
                    var model = Stencil.getModel('Font'),
                        font = model.setAccessor(data.object),
                        fontsDropdown = Toolbars.getToolbar('text').getFontsDropdown(),
                        collection = fontsDropdown.getFontsCollection();
                    Track.event('Font imported');
                    collection.add(font);
                    font.loadFull(function() {
                        fontsDropdown.addFont(font, false);
                        fontsDropdown.scrollToTop('uploaded');
                    });

                    // Focus on the tab in the dropdown
                    fontsDropdown.showTab('uploaded');
                }
            });
            this._googleFont.import();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ResizerView
     * 
     * @events  hide
     *          show
     *          toggle
     * @extends View
     */
    window.ResizerView = View.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|FramesCollection (default: null)
         */
        _collection: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'nav a': function(event, $anchor) {
                        var type = $anchor.attr('type');
                        event.preventDefault();
                        this.section(type);
                    }
                }
            });
        },

        /**
         * _parentView
         * 
         * @access  protected
         * @var     null|View (default: null)
         */
        _parentView: null,

        /**
         * _scrollbars
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _scrollbars: {},

        /**
         * _selectedFrame
         * 
         * @access  protected
         * @var     null|FrameAccessor (default: null)
         */
        _selectedFrame: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResizerView')
         */
        _string: 'ResizerView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   StageContentView|CropperView parentView
         * @return  void
         */
        init: function(element, parentView) {
            this._scrollbars = {};
            this._super(element);
            this._parentView = parentView;
            this._addListeners();
            this._setupCollection();
            this._drawFrames();
            this._setupForm();
            this._setupScrollbars();
            this.section('posts');
            this.showHideCustomEmptyState();
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this.on({
                'hide': this.hide,
                'show': this.show,
                'toggle': this.toggle,
            });
        },

        /**
         * _drawCustomFrame
         * 
         * @access  protected
         * @param   FrameAccessor frame
         * @param   Number position
         * @return  void
         */
        _drawCustomFrame: function(frame, position) {
            var $frames = this.find('section[type="custom"] div.frames'),
                $frame = DataUtils.render('CustomFrame', {
                    frame: frame
                });
            if (position === 0) {
                $frames.prepend($frame);
            } else {
                $frames.append($frame);
            }
            new CustomFrameView($frame, this, frame);
        },

        /**
         * _drawDefaultFrame
         * 
         * @access  protected
         * @param   FrameAccessor frame
         * @param   Number position
         * @return  void
         */
        _drawDefaultFrame: function(frame, position) {
            var type = frame.get('type').plural(),
                $frames = this.find('section[type="' + (type) + '"] div.frames'),
                $frame = DataUtils.render('Frame', {
                    frame: frame
                });
            if (position === 0) {
                $frames.prepend($frame);
            } else {
                $frames.append($frame);
            }
            new FrameView($frame, this, frame);
        },

        /**
         * _drawFrame
         * 
         * @access  protected
         * @param   FrameAccessor frame
         * @param   Number position
         * @return  void
         */
        _drawFrame: function(frame, position) {
            if (frame.get('type') === 'custom') {
                this._drawCustomFrame(frame, position);
            } else {
                this._drawDefaultFrame(frame, position);
            }
        },

        /**
         * _drawFrames
         * 
         * @access  protected
         * @return  void
         */
        _drawFrames: function() {
            var _this = this;
            this._collection.each(function(index, frame) {
                _this._drawFrame(frame, index);
            });
        },

        /**
         * _getSelectedFrame
         * 
         * @access  protected
         * @return  FrameAccessor
         */
        _getSelectedFrame: function() {
            if (this._parentView === App.getStage().getContent()) {
                return Frame;
            }
            return this._selectedFrame;
        },

        /**
         * _makeScrollable
         * 
         * @see     http://jquery-custom-scrollbar.rocketmind.pl/
         * @access  protected
         * @param   jQuery $element
         * @param   String section
         * @return  void
         */
        _makeScrollable: function($element, section) {
            this._scrollbars[section] = $element;
            this._scrollbars[section].jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._collection = Stencil.account().collection('frames');
            var accessors = this._collection.all(),
                _this = this;
            this._collection.on({
                'add': function(event, frame, position) {
                    _this._drawFrame(frame, position);
                },
                'empty': function(event) {
                    _this.find('.frame').remove();
                },
                'update': function(event) {
                    _this.showHideCustomEmptyState();
                    _this.refreshScrollbars();
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Custom frame created');
                    this.find('input[type="text"]').val('');
                    var collection = _this._collection;
                    collection.map(response.data.object, false);
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupScrollbars: function() {
            if (UserAgentUtils.supports.css.scrollbars() === true) {
                return false;
            }
            var $posts = this.find('section.posts');
            this._makeScrollable($posts.find('.content'), 'posts');
            var $ads = this.find('section.ads');
            this._makeScrollable($ads.find('.content'), 'ads');
            var $headers = this.find('section.headers');
            this._makeScrollable($headers.find('.content'), 'headers');
            var $custom = this.find('section.custom');
            this._makeScrollable($custom.find('.content'), 'custom');
            return true;
        },

        /**
         * getParentView
         * 
         * @access  public
         * @return  StageContentView|CropperView
         */
        getParentView: function() {
            var parentView = this._parentView;
            return parentView;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._element.addClass('hidden');
            this.refreshScrollbars();
        },

        /**
         * refreshScrollbars
         * 
         * @access  public
         * @return  void
         */
        refreshScrollbars: function() {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._scrollbars.posts.data('jsp').reinitialise();
                this._scrollbars.ads.data('jsp').reinitialise();
                this._scrollbars.headers.data('jsp').reinitialise();
                this._scrollbars.custom.data('jsp').reinitialise();
            }
        },

        /**
         * section
         * 
         * @access  public
         * @param   String section
         * @return  void
         */
        section: function(section) {
            var $nav = this.find('nav'),
                $content = this.find('> div.content > div.content');
            $nav.find('a').removeClass('active');
            $nav.find('a[type=' + (section) + ']').addClass('active');
            $content.find('> section').addClass('hidden');
            $content.find('> section.' + (section)).removeClass('hidden');
            this.refreshScrollbars();
            if (section === 'custom') {
                if (
                    UserAgentUtils.is.tablet() === false
                    && UserAgentUtils.is.ie() === false
                ) {
                    $content.find('> section.' + (section)).focusable().focus();
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.refreshScrollbars();
        },

        /**
         * showHideCustomEmptyState
         * 
         * Shows or hides the appropriate section depending on whether the
         * collection is empty.
         * 
         * @access  public
         * @return  void
         */
        showHideCustomEmptyState: function() {
            var $section = this.find('section.custom'),
                $frames = $section.find('.frames'),
                $messaging = $section.find('.messaging,.empty');
            $frames.removeClass('hidden');
            $messaging.addClass('hidden');
            if (this._collection.custom().length === 0) {
                $frames.addClass('hidden');
                $messaging.removeClass('hidden');
            }
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            this._element.toggleClass('hidden');
            if (this._element.hasClass('hidden') === false) {
                var _this = this,
                    $app = App.getElement(),
                    hide = {
                        'body/mousedown': function(event) {
                            var $target = $(event.target),
                                outsideResizer = $target.parents('div.resizer').length === 0;
                            if (outsideResizer === true) {
                                var outsideConfirmModal = $target.parents('div.modal.confirm').length === 0;
                                if (outsideConfirmModal === true) {
                                    _this.hide();
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        },
                        'body/keydown/escape': function(event) {
                            if (event.which === 27) {
                                var confirmModalShowing = App.find('div.modal.confirm').length !== 0;
                                if (confirmModalShowing === false) {
                                    _this.hide();
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        }
                    };
                $app.on({
                    'mousedown': hide['body/mousedown'],
                    'keydown': hide['body/keydown/escape']
                });
            }
            this.refreshScrollbars();
        },

        /**
         * setSelectedFrame
         * 
         * @access  public
         * @param   FrameAccessor frame
         * @return  void
         */
        setSelectedFrame: function(frame) {
            this._selectedFrame = frame;
        },

        /**
         * updateSelected
         * 
         * @access  public
         * @return  void
         */
        updateSelected: function() {

            // Reset
            var frame = this._getSelectedFrame();
            this.find('div.active').removeClass('active');
            this.find('a.button.tiny').removeClass('done');
            this.find('a.button.tiny').enable();

            // Current
            var $frame = this.find('[lookup="' + (frame.get('key')) + '"]');
            $frame.addClass('active');
            $frame.find('a.button').addClass('done');
            $frame.find('a.button').disable();

            // Section
            var type = frame.get('type'),
                sections = {
                    custom: 'custom',
                    post: 'posts',
                    ad: 'ads',
                    header: 'headers'
                },
                section = sections[type];
            if (section !== undefined) {
                this.section(section);
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ResourcesSearchView
     * 
     * @events  clear
     *          submit
     * @extends View
     */
    window.ResourcesSearchView = View.extend({

        /**
         * _area
         * 
         * @access  protected
         * @var     null|AreaView (default: null)
         */
        _area: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        if (event.which === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            }
                        } else if (event.which === 27) {
                            // var val = $input.val();
                            // if (val !== '') {
                            //     $input.val('');
                            // } else {
                                $input.blur();
                            // }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="clear"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('clear');
                    }
                },
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        $input.parent().removeClass('queried');
                        $input.parent().removeClass('active');
                        if ($input.val().length > 0) {
                            $input.parent().addClass('active');
                        }

                        // Mark UI as queried if user types their way back
                        var activeResults = this._area.getChild('queries').getActiveResults();
                        if (activeResults !== null) {
                            if ($input.val() === activeResults.getQuery()) {
                                $input.parent().removeClass('active');
                                $input.parent().addClass('queried');
                            }
                        }
                    }
                }
            });
        },

        /**
         * _maxOpenQueries
         * 
         * The maximum number of queries that can be open at once before
         * garbage collection kicks in.
         * 
         * @access  protected
         * @var     Number (default: 10)
         */
        _maxOpenQueries: 10,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourcesSearchView')
         */
        _string: 'ResourcesSearchView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element);
            this._area = area;
            this.on({
                'clear': function(event) {
                    var categoryPath = this._area.getChild('categories').getPath();
                    Stencil.navigate(categoryPath);
                },
                'submit': function(event) {
                    var $input = this.find('input.search'),
                        val = $input.val(),
                        children = this._area.getChild('queries').getChildren();
                    if (children[val] !== undefined) {
                        this._area.getChild('queries').getChild(val).triggerHandler('destroy');
                    }
                    this._destroyIdleQueries(val);
                    if (UserAgentUtils.is.tablet() === true) {
                        document.activeElement.blur();
                        $input.blur();
                    }
                    this._area.search(val, true);
                }
            });
        },

        /**
         * _destroyIdleQueries
         * 
         * Destroys QueryResultsView's once the limit has been reached (for
         * memory purposes).
         * 
         * @note    Was named oscar, after Oscar the Grouch ;)
         * @note    Second length check needs to be made since the destroy
         *          handler changes the response from getChildren
         * @access  protected
         * @param   String currentQuery the query currently being searched for
         * @return  void
         */
        _destroyIdleQueries: function(currentQuery) {
            var children = this._area.getChild('queries').getChildren(),
                maxOpenQueries = this._maxOpenQueries;
            if (Object.keys(children).length >= maxOpenQueries) {
                var query;
                for (query in children) {
                    if (query !== currentQuery) {
                        if (Object.keys(children).length >= maxOpenQueries) {
                            children[query].triggerHandler('destroy');
                        }
                    }
                }
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ToolbarsView
     * 
     * @extends View
     */
    window.ToolbarsView = View.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _drawProperties: {
            'backgroundBitmapImage': {
                'template': 'BackgroundBitmapImageToolbar',
                'view': 'BackgroundBitmapImageToolbarView'
            },
            'backgroundRectangle': {
                'template': 'BackgroundRectangleToolbar',
                'view': 'BackgroundRectangleToolbarView'
            },
            'colorVectorImage': {
                'template': 'ColorVectorImageToolbar',
                'view': 'ColorVectorImageToolbarView'
            },
            'foregroundBitmapImage': {
                'template': 'ForegroundBitmapImageToolbar',
                'view': 'ForegroundBitmapImageToolbarView'
            },
            'text': {
                'template': 'TextToolbar',
                'view': 'TextToolbarView'
            },
            'vectorImage': {
                'template': 'VectorImageToolbar',
                'view': 'VectorImageToolbarView'
            },
            'watermarkBitmapImage': {
                'template': 'WatermarkBitmapImageToolbar',
                'view': 'WatermarkBitmapImageToolbarView'
            },
            'watermarkColorVectorImage': {
                'template': 'WatermarkColorVectorImageToolbar',
                'view': 'WatermarkColorVectorImageToolbarView'
            },
            'watermarkVectorImage': {
                'template': 'WatermarkVectorImageToolbar',
                'view': 'WatermarkVectorImageToolbarView'
            }
        },

        /**
         * _stageContent
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _stageContent: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ToolbarsView')
         */
        _string: 'ToolbarsView',

        /**
         * _toolbars
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _toolbars: {},

        /**
         * _visibleToolbar
         * 
         * @access  protected
         * @var     false|ToolbarView (default: false)
         */
        _visibleToolbar: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   StageContentView stageContent
         * @return  void
         */
        init: function(element, stageContent) {
            this._toolbars = {};
            this._stageContent = stageContent;
            this._super(element);
            this._drawToolbars();
        },

        /**
         * _drawToolbar
         * 
         * @access  protected
         * @param   String type
         * @return  void
         */
        _drawToolbar: function(type) {
            var template = this._drawProperties[type].template,
                viewName = this._drawProperties[type].view,
                $element = DataUtils.render(template),
                view = new window[viewName]($element, this);
            this._toolbars[type] = view;
            this._element.append($element);
        },

        /**
         * _drawToolbars
         * 
         * @access  protected
         * @return  void
         */
        _drawToolbars: function() {
            for (var index in this._drawProperties) {
                this._drawToolbar(index);
            }
        },

        /**
         * getStageContent
         * 
         * @access  public
         * @return  null|StageContentView
         */
        getStageContent: function() {
            return this._stageContent;
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @param   String type
         * @return  ToolbarView
         */
        getToolbar: function(type) {
            return this._toolbars[type];
        },

        /**
         * getVisibleToolbar
         * 
         * @access  public
         * @return  false|ToolbarView
         */
        getVisibleToolbar: function() {
            return this._visibleToolbar;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            for (var index in this._toolbars) {
                this._toolbars[index].hide();
            }
            var content = App.getStage().getContent();
            content.handles.hide.apply(content);
        },

        /**
         * setVisibleToolbar
         * 
         * @access  public
         * @param   false|ToolbarView toolbar
         * @return  void
         */
        setVisibleToolbar: function(toolbar) {
            this._visibleToolbar = toolbar;
        },

        /**
         * show
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options (default: {})
         * @return  void
         */
        show: function(type, options) {
            options = DataUtils.getDefaultValue(options, {});
            this.hide();
            this._toolbars[type].show(options);
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * TutorialsView
     * 
     * @extends View
     */
    window.TutorialsView = View.extend({

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|TutorialsModalView (default: null)
         */
        _modal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TutorialsView')
         */
        _string: 'TutorialsView',

        /**
         * _slug
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _slug: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String slug
         * @param   TutorialsModalView modal
         * @return  void
         */
        init: function(element, slug, modal) {
            this._super(element);
            this._slug = slug;
            this._modal = modal;
            this.on({
                'overlay': function(event, $div) {
                    var youTubeSlug = $div.attr('youTubeSlug'),
                        modal = ModalUtils.showYouTubeVideo(youTubeSlug, {});
                    // modal.setFallback(this.getPath());
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  void
         */
        getPath: function() {
            return '/app/help/' + (this._slug);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[tutorials="' + (this._slug) + '"]');
            $anchor.siblings('[tutorials]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AreaView
     * 
     * @extends View
     */
    window.AreaView = View.extend({

        /**
         * _activeGroup
         * 
         * @access  protected
         * @var     null|GroupView (default: null)
         */
        _activeGroup: null,

        /**
         * _canHaveCollections
         * 
         * @access  protected
         * @var     true (default: true)
         */
        _canHaveCollections: true,

        /**
         * _children
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _children: {},

        /**
         * _contextMenu
         * 
         * @access  protected
         * @var     null|ContextMenuView (default: null)
         */
        _contextMenu: null,

        /**
         * _nav
         * 
         * @access  protected
         * @var     null|AreaNavView (default: null)
         */
        _nav: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AreaView')
         */
        _string: 'AreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @note    Below <_children> is needed because of how inheritance works
         *          with the extend.js library
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._children = {};
            this._super(element);
        },

        /**
         * canHaveCollections
         * 
         * @access  public
         * @return  Boolean
         */
        canHaveCollections: function() {
            return this._canHaveCollections;
        },

        /**
         * getActiveGroup
         * 
         * @access  public
         * @return  GroupView
         */
        getActiveGroup: function() {
            return this._activeGroup;
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String type
         * @return  GroupView
         */
        getChild: function(type) {
            return this._children[type];
        },

        /**
         * getContextMenu
         * 
         * @access  public
         * @return  ContextMenuView
         */
        getContextMenu: function() {
            return this._contextMenu;
        },

        /**
         * getHomePath
         * 
         * @access  public
         * @return  String
         */
        getHomePath: function() {
            return this.find('div.sticky a').first().attr('href');
        },

        /**
         * getNav
         * 
         * @access  public
         * @return  jQuery
         */
        getNav: function() {
            return this._nav;
        },

        /**
         * getType
         * 
         * @access  public
         * @return  String
         */
        getType: function() {
            return this._type;
        },

        /**
         * setActiveGroup
         * 
         * @access  protected
         * @param   GroupView group
         * @return  void
         */
        setActiveGroup: function(group) {
            this._activeGroup = group;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            App.getEditor().setActiveArea(this);
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            var $nav = App.getSidebar().getNav(),
                $anchor = $nav.find('[area="' + (this._type) + '"]');
            $anchor.siblings('[area]').removeClass('active');
            $anchor.addClass('active');
        }
    });
});
window.DependencyLoader.push('SearchableAreaView', function() {

    /**
     * GraphicsAreaView
     * 
     * @extends SearchableAreaView
     */
    window.GraphicsAreaView = SearchableAreaView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicsAreaView')
         */
        _string: 'GraphicsAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'graphics')
         */
        _type: 'graphics',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * _getResourceSearchPlaceholderCopy
         * 
         * @access  protected
         * @return  String
         */
        _getResourceSearchPlaceholderCopy: function() {
            var total = StatUtils.getGraphicSearchGatewaysCount();
            if (total.toInt() === 0) {
                return 'Search royalty-free icons';
            }
            var placeholder = 'Search ' + (total) + '+ royalty-free icons';
            return placeholder;
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new GraphicCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new GraphicContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('GraphicAreaNav', {
                categories: CategoryUtils.global.type('graphics', false)
            });
            this._nav = new GraphicAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('graphics', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupQueries
         * 
         * @access  protected
         * @return  void
         */
        _setupQueries: function() {
            var $queries = this.find('section[group="queries"]');
            this._children.queries = new GraphicQueriesGroupView(
                $queries,
                this
            );
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Boolean refresh
         * @return  void
         */
        search: function(query, refresh) {
            query = query.trim();
            query = encodeURIComponent(query);
            var path = '/app/icons/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
});
window.DependencyLoader.push('AreaView', function() {

    /**
     * ImagesAreaView
     * 
     * @extends AreaView
     */
    window.ImagesAreaView = AreaView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImagesAreaView')
         */
        _string: 'ImagesAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'images')
         */
        _type: 'images',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new ImageCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new ImageContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('ImageAreaNav', {
                categories: CategoryUtils.global.type('images', false)
            });
            this._nav = new ImageAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('images', false)
            );
            this.find('> header').append($nav);
        }
    });
});
window.DependencyLoader.push('SearchableAreaView', function() {

    /**
     * PhotosAreaView
     * 
     * @extends SearchableAreaView
     */
    window.PhotosAreaView = SearchableAreaView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotosAreaView')
         */
        _string: 'PhotosAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'photos')
         */
        _type: 'photos',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * _getResourceSearchPlaceholderCopy
         * 
         * @access  protected
         * @return  String
         */
        _getResourceSearchPlaceholderCopy: function() {
            var total = StatUtils.getPhotoSearchGatewaysCount();
            if (total.toInt() === 0) {
                return 'Search royalty-free photos';
            }
            var placeholder = 'Search ' + (total) + '+ royalty-free photos';
            return placeholder;
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new PhotoCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new PhotoContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('PhotoAreaNav', {
                categories: CategoryUtils.global.type('photos', false)
            });
            this._nav = new PhotoAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('photos', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupQueries
         * 
         * @access  protected
         * @return  void
         */
        _setupQueries: function() {
            var $queries = this.find('section[group="queries"]');
            this._children.queries = new PhotoQueriesGroupView(
                $queries,
                this
            );
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Boolean refresh
         * @return  void
         */
        search: function(query, refresh) {
            query = query.trim();
            query = encodeURIComponent(query);
            var path = '/app/photos/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
});
window.DependencyLoader.push('SearchableAreaView', function() {

    /**
     * QuotesAreaView
     * 
     * @extends SearchableAreaView
     */
    window.QuotesAreaView = SearchableAreaView.extend({

        /**
         * _dragImage
         * 
         * @access  protected
         * @var     null|Image (default: null)
         */
        _dragImage: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuotesAreaView')
         */
        _string: 'QuotesAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'quotes')
         */
        _type: 'quotes',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._preloadDragImage();
        },

        /**
         * _getResourceSearchPlaceholderCopy
         * 
         * @access  protected
         * @return  String
         */
        _getResourceSearchPlaceholderCopy: function() {
            var total = StatUtils.getQuoteSearchGatewaysCount();
            if (total.toInt() === 0) {
                return 'Search quotes';
            }
            var placeholder = 'Search ' + (total) + '+ quotes';
            return placeholder;
        },

        /**
         * _preloadDragImage
         * 
         * @note    The load event callback seems weird, in that it's just
         *          setting the width and height to themselves, but this is
         *          required to ensure the HTMLImageElement has the proper HTML
         *          attributes available.
         * @access  protected
         * @return  void
         */
        _preloadDragImage: function() {
            var path = Config.default('quoteDragImagePath'),
                url = RequestUtils.url.static(path),
                imageRequest = new ImageRequest(url),
                image = imageRequest.getImage();
            imageRequest.once({
                'load': function(event, image) {
                    image.width = image.width;
                    image.height = image.height;
                }
            });
            imageRequest.request();
            this._dragImage = image;
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new QuoteCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new QuoteContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('QuoteAreaNav', {
                categories: CategoryUtils.global.type('quotes', false)
            });
            this._nav = new QuoteAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('quotes', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupQueries
         * 
         * @access  protected
         * @return  void
         */
        _setupQueries: function() {
            var $queries = this.find('section[group="queries"]');
            this._children.queries = new QuoteQueriesGroupView(
                $queries,
                this
            );
        },

        /**
         * getDragImage
         * 
         * @access  public
         * @return  Image
         */
        getDragImage: function() {
            return this._dragImage;
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Boolean refresh
         * @return  void
         */
        search: function(query, refresh) {
            query = query.trim();
            query = encodeURIComponent(query);
            var path = '/app/quotes/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
});
window.DependencyLoader.push('AreaView', function() {

    /**
     * TemplatesAreaView
     * 
     * @extends AreaView
     */
    window.TemplatesAreaView = AreaView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplatesAreaView')
         */
        _string: 'TemplatesAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'templates')
         */
        _type: 'templates',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new TemplateCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new TemplateContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('TemplateAreaNav', {
                categories: CategoryUtils.global.type('templates', false)
            });
            this._nav = new TemplateAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('templates', false)
            );
            this.find('> header').append($nav);
        }
    });
});
window.DependencyLoader.push('AreaView', function() {

    /**
     * UploadsAreaView
     * 
     * @extends AreaView
     */
    window.UploadsAreaView = AreaView.extend({

        /**
         * _dropzone
         * 
         * @access  protected
         * @var     null|DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadsAreaView')
         */
        _string: 'UploadsAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'uploads')
         */
        _type: 'uploads',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupDropzone();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new UploadCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new UploadContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('UploadAreaNav', {
                categories: CategoryUtils.global.type('uploads', false)
            });
            this._nav = new UploadAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('uploads', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupDropzone
         * 
         * @access  protected
         * @return  void
         */
        _setupDropzone: function() {
            var $dropzone = this.find('.dropzone'),
                children = this._children;
            this._dropzone = new DropzoneView($dropzone, 'image');
            this._dropzone.on({
                'complete/failed': function(event, response) {
                    Stencil.alert('services.cloudinary.maxResolution');
                },
                'complete/successful': function(event, uploadAccessor) {
                    var category = CategoryUtils.account.list('uploads'),
                        key = category.get('key'),
                        results = children.categories.getChild(key),
                        collection = results.getCollection();
                    results.scrollToTop();
                    Track.event('Image uploaded');
                    collection.map(uploadAccessor.data(), false);
                    Stencil.navigate('/app/uploads');
                    category.features.add.apply(category, [uploadAccessor]);
                    uploadAccessor.getModel().feature(
                        uploadAccessor.get('key'),
                        {
                            category: category.get('key')
                        }
                    );
                }
            });
        },

        /**
         * getDropzone
         * 
         * @access  public
         * @return  DropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        }
    });
});
window.DependencyLoader.push('AreaView', function() {

    /**
     * WatermarksAreaView
     * 
     * @extends AreaView
     */
    window.WatermarksAreaView = AreaView.extend({

        /**
         * _canHaveCollections
         * 
         * @access  protected
         * @var     false (default: false)
         */
        _canHaveCollections: false,

        /**
         * _dropzone
         * 
         * @access  protected
         * @var     null|DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarksAreaView')
         */
        _string: 'WatermarksAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'watermarks')
         */
        _type: 'watermarks',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupDropzone();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new WatermarkCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new WatermarkContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('WatermarkAreaNav', {
                categories: CategoryUtils.global.type('watermarks', false)
            });
            this._nav = new WatermarkAreaNavView(
                $nav,
                this,
                CategoryUtils.global.type('watermarks', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupDropzone
         * 
         * @note    Because the complete event does not get fired within the flow
         *          of a mouseup or keyup event, it's important to trigger the
         *          ChangeHistory.track method here, to ensure it's tracked at
         *          the right moment.
         * @access  protected
         * @return  void
         */
        _setupDropzone: function() {
            var $dropzone = this.find('.dropzone'),
                children = this._children;
            this._dropzone = new WatermarksDropzoneView($dropzone, 'watermark');
            this._dropzone.on({
                'complete/failed': function(event, response) {
                    Stencil.alert('services.cloudinary.maxResolution');
                },
                'complete/successful': function(event, watermarkUploadAccessor) {
                    var category = CategoryUtils.account.list('watermarks'),
                        key = category.get('key'),
                        collections = {
                            account: Stencil.account().collection('watermarks'),
                            category: children.categories.getChild(key).getCollection()
                        };
                    watermarkUploadAccessor.setDefaultSettings();
                    watermarkUploadAccessor.addToCanvas(true);
                    App.triggerHandler('changeHistory/track');
                    Track.event('Watermark uploaded');
                    collections.account.map(watermarkUploadAccessor.data(), false);
                    collections.category.map(watermarkUploadAccessor.data(), false);
                    Stencil.navigate('/app/logos');
                    category.features.add.apply(category, [watermarkUploadAccessor]);
                    watermarkUploadAccessor.getModel().feature(
                        watermarkUploadAccessor.get('key'),
                        {
                            category: category.get('key')
                        }
                    );
                }
            });
        },

        /**
         * getDropzone
         * 
         * @access  public
         * @return  DropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AreaNavView
     * 
     * @extends View
     */
    window.AreaNavView = View.extend({

        /**
         * _area
         * 
         * @access  protected
         * @var     false|AreaView (default: false)
         */
        _area: false,

        /**
         * _categories
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _categories: [],

        /**
         * _closable
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _closable: true,

        /**
         * _collectionResults
         * 
         * @access  protected
         * @var     false|CollectionResultsView (default: false)
         */
        _collectionResults: false,

        /**
         * _previousCategory
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _previousCategory: null,

        /**
         * _pulse
         * 
         * This is a reference to the timeout of the current (if any) pulse
         * going on. This is needed to cancel any pulses before starting a new
         * one.
         * 
         * @access  protected
         * @var     false|Number (default: false)
         */
        _pulse: false,

        /**
         * _radiate
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _radiate: false,

        /**
         * _secondaryBlurDelay
         * 
         * The number of milliseconds to wait before blurring the secondary
         * nav, to allow for slight errors in a mouse movement whereby the mouse
         * temporarily moves out of the relevant area while moving towards the
         * secondary nav.
         * 
         * @access  protected
         * @var     Number (default: 200)
         */
        _secondaryBlurDelay: 200,

        /**
         * _selectedCategory
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _selectedCategory: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AreaNavView')
         */
        _string: 'AreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @param   Array categories
         * @return  void
         */
        init: function(element, area, categories) {
            this._super(element);
            this._area = area;
            this._categories = categories;
            if (this._area.canHaveCollections() === true) {
                this._setupCollectionSubnav();
                this._setupCollectionsListeners();
            }
            this._addSelectListener();
            this._setupCountListeners();
            this._setupPinKeyListeners();
            this._setupPopover();
            this._setupRadiateUI();
            this._setupTooltips();
            this.secondary.delayReferences = [];
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, category) {
                    if (this._previousCategory !== null) {
                        this._previousCategory.unbind('change/name', this.updateName.proxy(this));
                    }
                    this._selectedCategory.on({
                        'change/name': this.updateName.proxy(this)
                    });
                    this.updateName();
                }
            });
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            var _this = this,
                index;
            for (index in this._categories) {
                this.addCategoryCountChangeListener(this._categories[index]);
            }
        },

        /**
         * _setupPinKeyListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupPinKeyListeners: function() {
            var _this = this,
                index;
            for (index in this._categories) {
                this.addPinKeyChangeListener(this._categories[index]);
            }

            // 
            // (function() {
            //     var selectors = [
            //         'div.sticky a > div.icon[style*="/if_els"]',
            //         'div.curated a > div.icon[style*="/if_els"]'
            //     ];
            //     var $icons = this.find(selectors.join(','));
            //     $icons.each(function(index, icon) {
            //         var $icon = $(icon),
            //             backgroundImage = $icon.css('background-image'),
            //             key = backgroundImage.match(/([^\/]+)$/)[0].replace(')', '').replace('"', '');
            //         console.log(
            //             ImageUtils.url.thumb(key, {
            //                 type: 'thumb'
            //             })
            //         );
            //     });
            // }).delay(1000, this);
        },

        /**
         * _setupPopover
         * 
         * @access  protected
         * @return  void
         */
        _setupPopover: function() {
            this.on({
                'menu/close': function(event) {
                    this.find('> div.filter').removeClass('expanded');
                    this.secondary.hide.apply(this);
                },
                'menu/open': function(event) {
                    var _this = this;
                    this.find('> div.filter').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                if (_this.closable() === true) {
                                    var $target = $(event.target);
                                    if ($target.parents('div.popover').length === 0) {
                                        _this.triggerHandler('menu/close');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (_this.closable() === true) {
                                    if (event.which === 27) {
                                        _this.triggerHandler('menu/close');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                }
            });
        },

        /**
         * _setupCollectionsListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionsListeners: function() {
            var selectors = [
                    'div.sticky a:not([lookup="viewCollections"])',
                    'div.curated a:not([lookup="viewCollections"])'
                ],
                _this = this,
                secondaryBlurDelay = this._secondaryBlurDelay;
            this.find(selectors.join(',')).on({
                'mouseenter': function(event) {
                    _this.secondary.delayReferences.push(
                        _this.secondary.hide.delay(secondaryBlurDelay, _this)
                    );
                }
            });
            this.find('a[lookup="viewCollections"]').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                    _this.secondary.show.apply(_this);
                }
            });
            this.find('div.collections').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                }
            });
        },

        /**
         * _setupCollectionSubnav
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionSubnav: function() {
            var $collection = this.find('div.collections'),
                areaType = this._area.getType(),
                customCategories = CategoryUtils.account.custom(areaType).slice().reverse();
            this._collectionResults = new CollectionResultsView(
                $collection,
                this._area
            );
            this._collectionResults.getCollection().add(customCategories);
            this._collectionResults.showHideEmptyState();
        },

        /**
         * _setupRadiateUI
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupRadiateUI: function() {
            if (this._radiate === false) {
                return false;
            }
            var $chevron = this._element.find('.fa.fa-angle-down');
            $chevron.addClass('radiate');
            this.once({
                'menu/open': function(event) {
                    App.find('.fa.fa-angle-down').removeClass('radiate');
                }
            });
            return true;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * addCategoryCountChangeListener
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        addCategoryCountChangeListener: function(category) {
            var _this = this;
            category.on({
                'change/count': function(event, newValue, oldValue) {
                    var path, selector, $count;
                    path = this.getPath();
                    selector = 'a[href="' + (path) + '"] div[lookup="count"]';
                    $count = _this.find(selector);
                    $count.text(newValue.commas());
                }
            });
        },

        /**
         * addPinKeyChangeListener
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        addPinKeyChangeListener: function(category) {
            var _this = this;
            category.on({
                'change/pinKey': function(event, newValue) {
                    var path, selector, $pin;
                    path = this.getPath();
                    selector = 'a[href="' + (path) + '"] > div.icon';
                    $pin = _this.find(selector),
                    pinUrl = category.getPinUrl();
                    $pin.css({
                        'background-image': 'url(\'' + (pinUrl) + '\')'
                    });
                }
            });
        },

        /**
         * closable
         * 
         * @note    Works as a getter/setter
         * @access  public
         * @param   undefined|Boolean closable
         * @return  Boolean|void
         */
        closable: function(closable) {
            if (closable === undefined) {
                return this._closable === true;
            }
            this._closable = closable === true;
        },

        /**
         * getCollectionResults
         * 
         * @access  public
         * @return  CollectionResultsView
         */
        getCollectionResults: function() {
            return this._collectionResults;
        },

        /**
         * hideResultsLabel
         * 
         * @access  public
         * @return  void
         */
        hideResultsLabel: function() {
            this.find('label.category').removeClass('hidden');
            this.find('label.results').addClass('hidden');
        },

        /**
         * pulse
         * 
         * @access  protected
         * @return  void
         */
        pulse: function() {
            var _this = this,
                $anchor = this.find('div.favorites a'),
                trigger = function() {
                    $anchor.addClass('pulse');
                },
                cleanup = function() {
                    this._pulse = false;
                    $anchor.removeClass('pulse');
                };
            if (this._pulse !== false) {
                TimeoutPool.clear(this._pulse);
                $anchor.removeClass('pulse');
                trigger.delay(0);
                this._pulse = cleanup.delay(1200, this);
            } else {
                trigger.apply();
                this._pulse = cleanup.delay(1200, this);
            }
        },

        /**
         * secondary
         * 
         * @access  public
         * @var     Object
         */
        secondary: {

            /**
             * clearDelays
             * 
             * @access  public
             * @return  void
             */
            clearDelays: function() {
                var delayReferences = this.secondary.delayReferences,
                    index;
                for (index in delayReferences) {
                    TimeoutPool.clear(delayReferences[index]);
                }
            },

            /**
             * delayReferences
             * 
             * @access  public
             * @return  Array (default: [])
             */
            delayReferences: [],

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                this.find('.popover').removeClass('expanded');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                this.find('.popover').addClass('expanded');
                var $activeAnchor = this.find('.secondary a.active');
                if ($activeAnchor.length > 0) {
                    $activeAnchor.parent().data('view').scrollTo(0);
                }
            }
        },

        /**
         * select
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        select: function(category) {
            var path = category.getPath(),
                $anchor = this.find('a[href="' + (path) + '"]');
            this.triggerHandler('menu/close');
            this.find('a.active').removeClass('active');
            $anchor.addClass('active');
            this.hideResultsLabel();
            if (category !== this._selectedCategory) {
                this._previousCategory = this._selectedCategory;
                this._selectedCategory = category;
                this.triggerHandler('select', [this._selectedCategory]);
            }
        },

        /**
         * showResultsLabel
         * 
         * @access  public
         * @return  void
         */
        showResultsLabel: function() {
            this.find('label.category').addClass('hidden');
            this.find('label.results').removeClass('hidden');
            this.find('a.active').removeClass('active');
        },

        /**
         * updateName
         * 
         * @access  public
         * @return  void
         */
        updateName: function() {
            var name = this._selectedCategory.getLabelName(),
                $categoryLabel = this.find('label.category');
            $categoryLabel.find('span.copy').text(name);
        }
    });
});
window.DependencyLoader.push('GroupView', function() {

    /**
     * CategoriesGroupView
     * 
     * @extends GroupView
     */
    window.CategoriesGroupView = GroupView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoriesGroupView')
         */
        _string: 'CategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   String key
         * @return  void
         */
        _drawChild: function(key) {
            var category = Stencil.getAccessor(key),
                key = category.get('key'),
                $results = DataUtils.render(this._drawProperties.template, {
                    category: category
                });
            this._element.append($results);
            this._children[key] = new window[this._drawProperties.view](
                $results,
                this,
                category
            );
            var _this = this;
            this._children[key].on({
                'destroy': function(event) {
                    delete _this._children[key];
                }
            });
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String key
         * @return  PhotoCategoryResultsView
         */
        getChild: function(key) {
            if (this._super(key) === undefined) {
                this._drawChild(key);
            }
            return this._super(key);
        }
    });
});
window.DependencyLoader.push('ResultsView', function() {

    /**
     * CategoryResultsView
     * 
     * @extends ResultsView
     */
    window.CategoryResultsView = ResultsView.extend({

        /**
         * _category
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoryResultsView')
         */
        _string: 'CategoryResultsView',

        /**
         * init
         * 
         * @note    Important for the category to be set before the parent
         *          constructor is called.
         * @access  public
         * @param   jQuery element
         * @param   CategoriesGroupView categoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, categoriesGroup, category) {
            this._category = category;
            this._super(element, categoriesGroup);
            this._addDestroyListener();
            // this._collection.on({
            //     'add': function(event) {
            //         category.set('count', this.length());
            //     }
            // });
            this._setupAuthCollectionEmpty();
            this._setupAuthSort();
        },

        /**
         * _addDestroyListener
         * 
         * @access  protected
         * @return  void
         */
        _addDestroyListener: function() {
            this.on({
                'destroy': function(event) {
                    this._collection.empty();
                    this._element.remove();
                }
            });
        },

        /**
         * _load
         * 
         * @access  protected
         * @param   Number numberOfResults
         * @param   Number limit
         * @return  void
         */
        _load: function(numberOfResults, limit) {
            var _this = this;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        },

        /**
         * _setupAuthCollectionEmpty
         * 
         * Ensures that after a User/login event, if these results are for a
         * category that is owned by an account, empty it out (since the
         * after the user logs in, the content needs to be reloaded to ensure it
         * properly represents the recently logged in user).
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthCollectionEmpty: function() {
            var _this,
                accountId = this._category.get('accountId').toInt();
            if (accountId !== 0) {
                var _this = this;
                User.once({
                    'login': function(event, user) {
                        _this.triggerHandler('destroy');
                    }
                });
            }
        },

        /**
         * _setupAuthSort
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthSort: function() {
            if (this._category.get('accountId').toInt() === 0) {
                if (
                    User.admin() === true
                    || User.editor() === true
                ) {
                    this._setupSort();
                }
                var _this = this;
                User.once({
                    'login': function(event, user) {
                        if (
                            User.admin() === true
                            || User.editor() === true
                        ) {
                            _this._setupSort();
                        }
                    }
                });
            } else {
                this._setupSort();
            }
        },

        /**
         * _setupSort
         * 
         * @see     https://github.com/RubaXa/Sortable
         * @access  protected
         * @return  void
         */
        _setupSort: function() {
            var _this = this,
                list = this.find('.inner')[0];
            this._element.addClass('sortable');
            Sortable.create(list, {
                scroll: true,
                handle: '.move',
                ghostClass: 'ghost',
                onEnd: function(event) {
                    /**
                     * For some reason, after a sort has been performed, the
                     * Sortable class seems to set the draggable attribute
                     * of the a.overlay (and all child-elements of the along
                     * with the parent element itself) to false. So I simply
                     * reinstate this.
                     */
                    App.getEditor().getJoystick().find('a.overlay').attr(
                        'draggable',
                        'true'
                    );
                },
                onUpdate: function(event) {
                    var accessor = $(event.item).data('accessor');
                    _this._collection.move(accessor, event.newIndex);
                }
            });

            // Trigger server side sync after debounced delay
            var delay = Config.getSaveDelay('sort');
            this._collection.on({
                'move': _.debounce(
                    this._collection.sort.proxy(this._collection, [this._category]),
                    delay
                )
            });
        },

        /**
         * getCategory
         * 
         * @access  public
         * @return  CategoryAccessor
         */
        getCategory: function() {
            return this._category;
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            return this._category.getPath();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                nav = area.getNav(),
                path = this._category.getPath();
            App.getSidebar().updatePath(area, path);
            nav.select(this._category);
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * CollectionResultsView
     * 
     * @extends View
     */
    window.CollectionResultsView = View.extend({

        /**
         * _area
         * 
         * @access  protected
         * @var     false|AreaView (default: false)
         */
        _area: false,

        /**
         * _childrenCanBeSorted
         * 
         * @access  protected
         * @var     true|Boolean (default: true)
         */
        _childrenCanBeSorted: true,

        /**
         * _children
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _children: [],

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|CategoriesCollection (default: null)
         */
        _collection: null,

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'CollectionRow',
            view: 'CollectionRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CollectionResultsView')
         */
        _string: 'CollectionResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._children = [];
            this._area = area;
            this._super(element);
            this._addCreateCollectionListener();
            this._addHelpListener();
            if (this._area.canHaveCollections() === true) {
                this._setupCollection();
            }
            if (this._childrenCanBeSorted === true) {
                this._setupSort();
            }
        },

        /**
         * _addCreateCollectionListener
         * 
         * @access  protected
         * @return  void
         */
        _addCreateCollectionListener: function() {
            this.on({
                'createCollection': function(event, $anchor) {
                    if (User.exists() === false) {
                        var nav = this._area.getNav(),
                            contextMenu = this._area.getContextMenu();
                        nav.triggerHandler('menu/close');
                        contextMenu.triggerHandler('close');
                        Stencil.navigate('/app/signup');
                    } else {
                        var showAutoFeaturingMessaging = true;
                        if (this === this._area.getNav().getCollectionResults()) {
                            showAutoFeaturingMessaging = false;
                        }
                        var areaType = this._area.getType(),
                            modal = ModalUtils.showCreateCollection(
                                areaType,
                                showAutoFeaturingMessaging
                            ),
                            _this = this;
                        this._area.getNav().closable(false);
                        this._area.getContextMenu().closable(false);
                        modal.find('input').select();
                        modal.on({
                            'close': function(event) {
                                _this._area.getNav().closable(true);
                                _this._area.getContextMenu().closable(true);
                            },
                            'save': function(event, object) {
                                var collectionResults = {
                                        contextMenu: _this._area.getContextMenu().getCollectionResults(),
                                        nav: _this._area.getNav().getCollectionResults()
                                    },
                                    collections = {
                                        contextMenu: collectionResults.contextMenu.getCollection(),
                                        nav: collectionResults.nav.getCollection()
                                    },
                                    accessors = {
                                        contextMenu: collections.contextMenu.map(object),
                                        nav: collections.nav.map(object)
                                    },
                                    categories = Stencil.get('account').collection('categories');
                                this.triggerHandler.delay(750, this, ['close']);
                                collections.contextMenu.triggerHandler('update');
                                collections.nav.triggerHandler('update');
                                collectionResults.contextMenu.sort();
                                collectionResults.nav.sort();
                                categories.add(accessors.contextMenu[0]);
                                _this._area.getContextMenu().updateCollectionResultRowStates();

                                // Scrolling
                                var relevantCollectionResults = collectionResults.contextMenu;
                                if (_this === collectionResults.nav) {
                                    relevantCollectionResults = _this;
                                }
                                var length = relevantCollectionResults.getChildren().length,
                                    child = relevantCollectionResults.getChildren()[length - 1];
                                if (_this !== collectionResults.nav) {
                                    child.toggle();
                                }
                                (function() {
                                    if (child.visible() === false) {
                                        child.scrollTo(undefined, function() {
                                            child.highlight();
                                        });
                                    } else {
                                        child.highlight();
                                    }
                                }).delay(750);
                            }
                        });
                    }
                }
            });
        },

        /**
         * _addHelpListener
         * 
         * @access  protected
         * @return  void
         */
        _addHelpListener: function() {
            var $question = this.find('div.question');
            this.on({
                'showCollectionsIntro': function(event, $anchor) {
                    ClientWrappers.get('helpScout').showCollectionsIntroArticle();
                }
            });
            Scripts.load('helpScout', function() {
                $question.removeClass('hidden');
            });
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @param   Number position
         * @return  CollectionRowView
         */
        _drawChild: function(category, position) {
            var $element = DataUtils.render(this._drawProperties.template, {
                category: category
            });
            if (position === 0) {
                this._element.find('div.inner').prepend($element);
            } else {
                this._element.find('div.inner').append($element);
            }
            var child = new window[this._drawProperties.view](
                $element,
                category,
                this
            );
            this._children.push(child);
            $element.data('category', category);
            $element.data('view', child);
            return child;
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new CategoriesCollection();
            this._collection.on({
                'add': function(event, categoryAccessor, position) {
                    _this._drawChild(categoryAccessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                },
                'remove': function(event, categoryAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getCategory() === categoryAccessor) {
                            children[index].getElement().remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                }
            });
        },

        /**
         * _setupSort
         * 
         * @see     https://github.com/RubaXa/Sortable
         * @access  protected
         * @return  void
         */
        _setupSort: function() {
            var _this = this,
                list = this._element.find('div.results div.inner')[0];
            Sortable.create(list, {
                scroll: true,
                handle: '.move',
                ghostClass: 'ghost',
                chosenClass: 'chosen',
                setData: function(dataTransfer) {
                    // dragGhost = dragEl.cloneNode(true);
                    // dragGhost.classList.add('custom-drag-ghost');
                    // document.body.appendChild(dragGhost);
                    // dataTransfer.setDragImage(dragGhost, 0, 0);
                },
                onEnd: function() {
                    $(list).removeClass('active');
                },
                onStart: function() {
                    $(list).addClass('active');
                },
                onUpdate: function(event) {
                    var accessor = $(event.item).data('category');
                    _this._collection.move(accessor, event.newIndex);
                    _this._area.getContextMenu().getCollectionResults().getCollection().move(accessor, event.newIndex);
                }
            });

            // Trigger server side sync after debounced delay
            var delay = Config.getSaveDelay('category.sort');
            this._collection.on({
                'move': _.debounce(
                    this._collection.sort.proxy(this._collection),
                    delay
                )
            });
        },

        /**
         * getArea
         * 
         * @access  public
         * @return  AreaView
         */
        getArea: function() {
            return this._area;
        },

        /**
         * getChildren
         * 
         * @access  public
         * @return  Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getCollection
         * 
         * @access  public
         * @return  Collection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * showHideEmptyState
         * 
         * Shows or hides the appropriate section depending on whether there are
         * any custom categories.
         * 
         * @access  public
         * @return  void
         */
        showHideEmptyState: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty').addClass('hidden');
            if (this._collection.all().length === 0) {
                this.find('.results').addClass('hidden');
                this.find('.messaging,.empty').removeClass('hidden');
            }
        },

        /**
         * sort
         * 
         * @access  public
         * @return  void
         */
        sort: function() {
            if (Config.default('collectionSortOrder') === 'alphabetical') {
                var $inner = this.find('div.inner'),
                    selector = '> div.collectionRow';
                $inner.get(0).orderAlphabeticallyByText(selector);
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * CollectionRowView
     * 
     * @extends View
     */
    window.CollectionRowView = View.extend({

        /**
         * _category
         * 
         * @access  protected
         * @var     false|CategoryAccessor (default: false)
         */
        _category: false,

        /**
         * _collectionResults
         * 
         * @access  protected
         * @var     false|CollectionResultsView (default: false)
         */
        _collectionResults: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CollectionRowView')
         */
        _string: 'CollectionRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CategoryAccessor category
         * @param   CollectionResultsView collectionResults
         * @return  void
         */
        init: function(element, category, collectionResults) {
            this._category = category;
            this._collectionResults = collectionResults;
            this._super(element, category);
            this._addCategoryCountChangeListener();
            this._addRowListeners();
        },

        /**
         * _addCategoryCountChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addCategoryCountChangeListener: function() {
            var _this = this;
            this._category.on({
                'change/count': function(event, newValue, oldValue) {
                    var commaValue = newValue.toInt().commas();
                    _this.find('div.count').html(commaValue);
                }
            });
        },

        /**
         * _addConfirmDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addConfirmDeleteListener: function() {
            this.on({
                'confirm/delete': function(event, $anchor) {
                    this._confirmDelete();
                }
            });
        },

        /**
         * _addEditListener
         * 
         * @access  protected
         * @return  void
         */
        _addEditListener: function() {
            this.on({
                'edit': function(event, $anchor) {
                    this._edit();
                }
            });
        },

        /**
         * _addNameChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addNameChangeListener: function() {
            var _this = this;
            this._category.on({
                'change/name': function(event, newValue, oldValue) {
                    _this.find('div.copy').text(newValue);
                    var key = _this._category.get('key'),
                        selector = 'div.filter label.category[category="' + (key) + '"] span.copy';
                    App.find(selector).html(newValue);
                    _this._collectionResults.sort();
                }
            });
        },

        /**
         * _addRowListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRowListeners: function() {
            this._addConfirmDeleteListener();
            this._addEditListener();
            this._addNameChangeListener();
            this._addSlugChangeListener();
        },

        /**
         * _addSlugChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addSlugChangeListener: function() {
            var _this = this;
            this._category.on({
                'change/slug': function(event, newValue, oldValue) {
                    var path = this.getPath();
                    _this.getElement().find('> a').attr('href', path);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this collection?',
                modal = ModalUtils.showConfirmDelete(question);
            this._getArea().getNav().closable(false);
            modal.getElement().addClass('warning');
            modal.on({
                'close': function(event) {
                    _this._getArea().getNav().closable(true);
                },
                'yes': function(event) {
                    _this._category.delete();
                    this.triggerHandler('leave');

                    // Navigate home if focused on the category
                    var activeResults = _this._getActiveResults();
                    if (activeResults.category() === true) {
                        if (activeResults.getCategory() === _this._category) {
                            var path = _this._getArea().getHomePath(),
                                nav = _this._getArea().getNav();
                            Stencil.navigate(path);
                            nav.triggerHandler('menu/open');
                            nav.secondary.show.apply(nav);
                        }
                    }
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _edit
         * 
         * @access  protected
         * @return  void
         */
        _edit: function() {
            var _this = this,
                category = this._category,
                modal = ModalUtils.showRename(category, 'name');
            modal.find('input').select();
            this._getArea().getNav().closable(false);
            modal.on({
                'close': function(event) {
                    _this._getArea().getNav().closable(true);
                },
                'save': function(event, object) {
                    category.set({
                        name: object.name,
                        slug: object.slug
                    });
                    this.triggerHandler.delay(500, this, ['close']);
                    _this._collectionResults.getCollection().triggerHandler('update');

                    // Scrolling
                    (function() {
                        if (_this.visible() === false) {
                            _this.scrollTo(undefined, function() {
                                _this.highlight();
                            });
                        } else {
                            _this.highlight();
                        }
                    }).delay(500);

                    // Navigate home if focused on the category
                    var activeResults = _this._getActiveResults();
                    if (activeResults.category() === true) {
                        if (activeResults.getCategory() === _this._category) {
                            var path = category.getPath();
                            Stencil.navigate(path, false);
                        }
                    }
                }
            });
        },

        /**
         * _getArea
         * 
         * @access  protected
         * @return  AreaView
         */
        _getArea: function() {
            return this._collectionResults.getArea();
        },

        /**
         * _getActiveResults
         * 
         * @access  protected
         * @return  ResultsView
         */
        _getActiveResults: function() {
            return this._getArea().getActiveGroup().getActiveResults();
        },

        /**
         * _parentHasScrollbar
         * 
         * @access  protected
         * @return  Boolean
         */
        _parentHasScrollbar: function() {
            var $parent = this._element.parent();
            return $parent.get(0).scrollHeight > $parent.height();
        },

        /**
         * getCategory
         * 
         * @access  public
         * @return  CategoryAccessor
         */
        getCategory: function() {
            return this._category;
        },

        /**
         * highlight
         * 
         * @access  public
         * @return  void
         */
        highlight: function() {
            // var animationClassName = 'shake';
            var animationClassName = 'flicker';
            this._element.addClass(animationClassName);
            this._element.removeClass.delay(750, this._element, [
                animationClassName
            ]);
        },

        /**
         * scrollTo
         * 
         * @access  public
         * @param   undefined|Number duration (optional)
         * @param   undefined|Function callback (optional)
         * @return  void
         */
        scrollTo: function(duration, callback) {
            if (this._parentHasScrollbar() === true) {
                var $element = this.getElement(),
                    $parent = $element.parent();
                $parent.scrollTo($element, duration, callback);
            }
        },

        /**
         * visible
         * 
         * @access  public
         * @return  Boolean
         */
        visible: function() {
            var $parent = this._element.parent(),
                percentageVisible = this._element.percentageVisible($parent);
            if (percentageVisible < 25) {
                return false;
            }
            return true;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ContextMenuView
     * 
     * @extends View
     */
    window.ContextMenuView = View.extend({

        /**
         * _$relative
         * 
         * @access  protected
         * @var     jQuery (default: null)
         */
        _$relative: null,

        /**
         * _area
         * 
         * @access  protected
         * @var     AreaView (default: null)
         */
        _area: null,

        /**
         * _closable
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _closable: true,

        /**
         * _collectionResults
         * 
         * @access  protected
         * @var     false|CollectionResultsView (default: false)
         */
        _collectionResults: false,

        /**
         * _cropperModalMinDelay
         * 
         * Number of milliseconds to wait, at a minimum, before show the cropper
         * modal.
         * 
         * @access  protected
         * @var     Number (default: 850)
         */
        _cropperModalMinDelay: 850,

        /**
         * _delays
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            multiple: {
                delete: 650,
                // favorite: 650,
                trailing: 750,
                // unfavorite: 650
            }
        },

        /**
         * _secondaryBlurDelay
         * 
         * The number of milliseconds to wait before blurring the secondary
         * nav, to allow for slight errors in a mouse movement whereby the mouse
         * temporarily moves out of the relevant area while moving towards the
         * secondary nav.
         * 
         * @access  protected
         * @var     Number (default: 200)
         */
        _secondaryBlurDelay: 200,

        /**
         * _showing
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _showing: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ContextMenuView')
         */
        _string: 'ContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._area = area;
            this._super(element);
            this.secondary.delayReferences = [];
            if (this._area.canHaveCollections() === true) {
                this._setupCollectionSubContextMenu();
                this._setupCollectionsListeners();
            }
            // this._addCloseListeners();
            this._addCropListener();
        },

        /**
         * _accessorIsResource
         * 
         * @access  protected
         * @return  Boolean
         */
        _accessorIsResource: function() {
            var accessor = this._getAccessor(),
                key = accessor.get('key');
            if (key.indexOf(':') === -1) {
                return false;
            }
            return true;
        },

        /**
         * _addCloseListeners
         * 
         * @access  protected
         * @return  void
         */
        _addCloseListeners: function() {
            var _this = this,
                $app = App.getElement(),
                view = this._getView(),
                callback = function() {
                    if (this.closable() === true) {
                        this.hide();
                        this.secondary.hide.apply(this);
                        $app.unbind('mousedown', handlers['body/mousedown']);
                        $app.unbind('keydown', handlers['body/keydown/escape']);
                        Stencil.getRouter().unbind('route', handlers['route']);
                        this.unbind('close', handlers['close']);
                        view.getResults().removeScrollEvent(
                            handlers['results/scroll']
                        );
                    }
                },
                handlers = {
                    'body/mousedown': function(event) {
                        var $target = $(event.target);
                        if ($target.parents('div.contextMenu').length === 0) {
                            callback.apply(_this);
                        }
                    },
                    'body/keydown/escape': function(event) {
                        if (event.which === 27) {
                            callback.apply(_this);
                        }
                    },
                    'close': function(event) {
                        callback.apply(_this);
                    },
                    'results/scroll': function(event) {
                        var $results = _this._$relative.closest('.results'),
                            percentageVisible = _this._$relative.percentageVisible($results);
                        if (percentageVisible < 30) {
                            callback.apply(_this);
                            // var results = _this._area.getActiveGroup().getActiveResults();
                            // results.deselectAll();
                        } else {
                            _this.position();
                        }
                    },
                    'route': function(route, params) {
                        callback.apply(_this);
                    }
                };
            $app.on({
                'mousedown': handlers['body/mousedown'],
                'keydown': handlers['body/keydown/escape']
            });
            Stencil.getRouter().on({
                'route': handlers['route']
            });
            this.on({
                'close': handlers['close']
            });
            this._$relative.data('view').getResults().addScrollEvent(
                handlers['results/scroll']
            );
        },

        /**
         * _addCropListener
         * 
         * @access  protected
         * @return  void
         */
        _addCropListener: function() {
            this.on({
                'crop': function(event) {
                    this._showCropperModal();
                }
            });
        },

        /**
         * _destroyTooltips
         * 
         * @access  protected
         * @return  void
         */
        _destroyTooltips: function() {
            this._element.tooltip('destroy');
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  Accessor
         */
        _getAccessor: function() {
            var accessor = this._getSelected()[0].getAccessor();
            return accessor;
        },

        /**
         * _getBusyMessage
         * 
         * @access  protected
         * @param   String type
         * @return  String
         */
        _getBusyMessage: function(type) {
            var areaType = this._area.getType(),
                key = 'multiple.' + (areaType) + '.' + (type);
            return Config.getMessage(key);
        },

        /**
         * _getConfirmDeleteQuestion
         * 
         * @access  protected
         * @param   Array selected
         * @return  String
         */
        _getConfirmDeleteQuestion: function(selected) {
            if (selected.length === 1) {
                return this._messages.delete.one;
            }
            var count = selected.length;
            return this._messages.delete.multiple.replace('###', count);
        },

        /**
         * _getMultipleDelay
         * 
         * @access  protected
         * @param   String action
         * @return  Number
         */
        _getMultipleDelay: function(action) {
            return this._delays.multiple[action];
        },

        /**
         * _getSelected
         * 
         * @access  protected
         * @return  Array
         */
        _getSelected: function() {
            var results = this._area.getActiveGroup().getActiveResults();
            return results.childrenSelected.all.apply(results);
        },

        /**
         * _getView
         * 
         * @access  protected
         * @return  View
         */
        _getView: function() {
            return this._$relative.data('view');
        },

        /**
         * _hideActiveThumb
         * 
         * @access  protected
         * @return  void
         */
        _hideActiveThumb: function() {
            var results = this._area.getActiveGroup().getActiveResults();
            results.deselectAll();
        },

        /**
         * _loadCropperDependencies
         * 
         * @access  protected
         * @return  Boolean
         */
        _loadCropperDependencies: function() {
            if (this._multipleSelected() === true) {
                return false;
            }
            var accessor = this._getAccessor();
            return accessor.loadCropperDependencies();
        },

        /**
         * _multipleSelected
         * 
         * @access  protected
         * @return  Boolean
         */
        _multipleSelected: function() {
            return this._getSelected().length > 1;
        },

        /**
         * _positionCaret
         * 
         * Positions the caret perfectly in the middle of the part of the thumb
         * that is currently visible.
         * 
         * @note    The check for the relative offset being less than 200 is to
         *          ensure that the percentageVisible conditional only applies
         *          when the relative is partially obstructed at the top of the
         *          scrollable area, rather than the bottom. It's a crude way of
         *          doing this, but it's effective and saves me from having to
         *          write a helper method that determines if the bleed is
         *          occuring at the top or bottom of the scrollable area.
         * @access  protected
         * @return  void
         */
        _positionCaret: function() {
            var $relative = this._$relative,
                $container = $relative.closest('.results'),
                $caret = this.find('.stencil-caret'),
                percentageVisible = $relative.percentageVisible($container),
                relativeHeight = $relative.outerHeight().toInt(),
                heightShowing = ((relativeHeight * percentageVisible) / 100).round(0),
                middlePoint = (heightShowing / 2).round(0),
                middlePointGlobalReference = middlePoint + $relative.offset().top;
            if (percentageVisible < 100 && $relative.offset().top < 200) {
                middlePointGlobalReference = middlePoint + $container.offset().top;
            }
            var middlePointRelativeValue = middlePointGlobalReference - this._element.offset().top;
            if ($caret.css('top').toInt() !== middlePointRelativeValue) {
                $caret.css({
                    'top': (middlePointRelativeValue).round(0) + 'px'
                }); 
            }
        },

        /**
         * _positionSecondary
         * 
         * Toggles a class on and off depending on whether the secondary menu
         * would bleed past the app's viewport.
         * 
         * @access  protected
         * @return  void
         */
        _positionSecondary: function() {
            var $secondary = this.find('.secondary'),
                wouldBleedBeyondBottomOfViewport = function() {
                    var top = this._element.offset().top - App.getElement().css('padding-top').toInt(),
                        height = $secondary.outerHeight(),
                        viewportHeight = App.getElement().find('> div.content').outerHeight(),
                        bottomPadding = 9;
                    return (top + height + bottomPadding) > viewportHeight;
                };
            if (wouldBleedBeyondBottomOfViewport.apply(this) === true) {
                if (this._element.hasClass('bottomToTop') === false) {
                    this._element.addClass('bottomToTop');
                }
            } else {
                if (this._element.hasClass('bottomToTop') === true) {
                    this._element.removeClass('bottomToTop');
                }
            }
        },

        /**
         * _positionWrapper
         * 
         * @access  protected
         * @return  void
         */
        _positionWrapper: function() {

            /**
             * Left
             * 
             */
            var rightPadding = 4,
                left = this._$relative.offset().left + this._$relative.outerWidth().toInt() - this._element.parent().offset().left + rightPadding;

            /**
             * Top
             * 
             */

            // Calculated top value
            var relativeMiddlePoint = this._$relative.offset().top + (this._$relative.outerHeight() / 2).round(0),
                top = relativeMiddlePoint - this._element.css('margin-top').toInt() - (this._element.outerHeight().toInt() / 2).round(0);
            top -= App.getElement().css('padding-top').toInt();
            top = Math.max(0, top);


            // Max top
            var maxTop,
                elementMarginTop = this._element.css('margin-top').toInt(),
                elementMarginBottom = this._element.css('margin-bottom').toInt();
            maxTop = App.getElement().find('> div.content').height().toInt() - this._element.outerHeight().toInt() - elementMarginBottom - elementMarginBottom;
            // maxTop -= App.getElement()[0].scrollHeight - $(window).height();
            // maxTop += $(window).scrollTop();

            // Validate max top
            top = Math.min(top, maxTop);

            // Done
            if (
                this._element.css('left').toInt() !== left
                || this._element.css('top').toInt() !== top
            ) {
                this._element.css({
                    left: (left) + 'px',
                    top: (top) + 'px'
                });
            }
        },

        /**
         * _pulseFavoriteIcon
         * 
         * @access  protected
         * @return  void
         */
        _pulseFavoriteIcon: function() {
            var $unfavorite = this.find('[lookup="unfavorite"]'),
                $icon = $unfavorite.find('.icon');
            $icon.addClass('pulse');
            (function() {
                $icon.removeClass('pulse');
            }).delay(1200);
        },

        /**
         * _selectedHaveBeenFavorited
         * 
         * @access  protected
         * @return  Boolean
         */
        _selectedHaveBeenFavorited: function() {
            var selected = this._getSelected(),
                index = 0;
            for (index; index < selected.length; ++index) {
                if (selected[index].getAccessor().favorited() === false) {
                    return false;
                }
            }
            return true;
        },

        /**
         * _setupCollectionsListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionsListeners: function() {
            var selector = 'div.primary a:not([lookup="viewCollections"])',
                _this = this,
                secondaryBlurDelay = this._secondaryBlurDelay;
            this.find(selector).on({
                'mouseenter': function(event) {
                    _this.secondary.delayReferences.push(
                        _this.secondary.hide.delay(secondaryBlurDelay, _this)
                    );
                }
            });
            this.find('a[lookup="viewCollections"]').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                    if ($(this).attr('disabled') === undefined) {
                        _this.secondary.show.apply(_this);
                    }
                }
            });
            this.find('div.secondary').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                }
            });
        },

        /**
         * _setupCollectionSubContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionSubContextMenu: function() {
            var $collection = this.find('div.collections'),
                areaType = this._area.getType(),
                customCategories = CategoryUtils.account.custom(areaType).slice().reverse();
            this._collectionResults = new ContextMenuCollectionResultsView(
                $collection,
                this._area
            );
            this._collectionResults.getCollection().add(customCategories);
            this._collectionResults.showHideEmptyState();
        },

        /**
         * _setupConfirmDeleteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupConfirmDeleteEvent: function() {
            this.on({
                'confirm/delete': function(event, $anchor) {
                    var _this = this,
                        selected = this._getSelected(),
                        question = this._getConfirmDeleteQuestion(selected),
                        modal = ModalUtils.showConfirmDelete(question);
                    this.triggerHandler('close');
                    modal.on({
                        'yes': function(event) {
                            if (selected.length === 1) {
                                selected[0].getAccessor().delete();
                                this.triggerHandler('leave');
                                var results = _this._area.getActiveGroup().getActiveResults();
                                results.deselectAll();
                            } else {
                                var callback = function(index) {
                                    if (index < selected.length) {
                                        this.showBusyModalProgressMessaging(
                                            index,
                                            selected
                                        );
                                        var accessor = selected[index].getAccessor(),
                                            delay = this._getMultipleDelay('delete'),
                                            areaType = this._area.getType();
                                            eventType = 'model/delete';
                                        if (areaType === 'watermarks') {
                                            eventType = 'update/usable';
                                        }
                                        accessor.once(eventType, function(event) {
                                            if ((index + 1) >= selected.length) {
                                                delay = _this._getMultipleDelay('trailing');
                                            }
                                            callback.delay(delay, _this, [index + 1]);
                                        });

                                        // Prevent image/template busy hiding
                                        if (
                                            areaType === 'images'
                                            || areaType === 'templates'
                                        ) {
                                            accessor.delete(false);
                                        } else {
                                            accessor.delete();
                                        }
                                    } else {
                                        App.getBusy().hide();
                                        this.closable(true);
                                        var results = this._area.getActiveGroup().getActiveResults();
                                        results.deselectAll();
                                    }
                                };

                                // UI
                                this.triggerHandler('leave');
                                var msg = _this._getBusyMessage('delete');
                                App.getBusy().show(msg);
                                _this.closable(false);
                                callback.apply(_this, [0]);
                            }
                        },
                        'no': function(event) {
                            this.triggerHandler('leave');
                        }
                    });
                }
            });
            // this.on({
            //     'confirm/delete': function(event, $anchor) {
            //         var _this = this,
            //             selected = this._getSelected(),
            //             question = this._getConfirmDeleteQuestion(selected),
            //             modal = ModalUtils.showConfirmDelete(question);
            //         this.triggerHandler('close');
            //         modal.on({
            //             'yes': function(event) {
            //                 if (selected.length === 1) {
            //                     selected[0].getAccessor().delete();
            //                     this.triggerHandler('leave');
            //                     var results = _this._area.getActiveGroup().getActiveResults();
            //                     results.deselectAll();
            //                 } else {
            //                     var callback = function(index) {
            //                         if (index < selected.length) {
            //                             this.showBusyModalProgressMessaging(
            //                                 index,
            //                                 selected
            //                             );
            //                             var accessor = selected[index].getAccessor(),
            //                                 delay = this._getMultipleDelay('delete');
            //                             accessor.once({
            //                                 'model/delete': function(event) {
            //                                     if ((index + 1) >= selected.length) {
            //                                         delay = _this._getMultipleDelay('trailing');
            //                                     }
            //                                     callback.delay(delay, _this, [index + 1]);
            //                                 }
            //                             });

            //                             // Prevent image/template busy hiding
            //                             var areaType = this._area.getType();
            //                             if (
            //                                 areaType === 'images'
            //                                 || areaType === 'templates'
            //                             ) {
            //                                 accessor.delete(false);
            //                             } else {
            //                                 accessor.delete();
            //                             }
            //                         } else {
            //                             App.getBusy().hide();
            //                             this.closable(true);
            //                             var results = this._area.getActiveGroup().getActiveResults();
            //                             results.deselectAll();
            //                         }
            //                     };

            //                     // UI
            //                     this.triggerHandler('leave');
            //                     var msg = _this._getBusyMessage('delete');
            //                     App.getBusy().show(msg);
            //                     _this.closable(false);
            //                     callback.apply(_this, [0]);
            //                 }
            //             },
            //             'no': function(event) {
            //                 this.triggerHandler('leave');
            //             }
            //         });
            //     }
            // });
        },

        /**
         * _setupFavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupFavoriteEvent: function() {
            this.on({
                'favorite': function(event, $anchor) {
                    var areaType = this._area.getType();
                    if (this._multipleSelected() === false) {
                        if (
                            Account.max.favorites() === true
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {
                            this._getAccessor().favorite(areaType, true);
                            this._area.getNav().pulse();
                            this._toggleFavoriteState();
                            this._pulseFavoriteIcon();
                        }
                    } else {

                        // Get ones that can be favorited
                        var selected = this._getSelected(),
                            unfavoritedSelected = [],
                            index;
                        for (index in selected) {
                            if (selected[index].getAccessor().favorited() === false) {
                                unfavoritedSelected.push(selected[index]);
                            }
                        }

                        // Limit check
                        var account = Stencil.account();
                        if (
                            account.getFavoritesRemaining() < unfavoritedSelected.length
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {

                            // Logic
                            var accessor,
                                unfavoritedSelectedKeys = [],
                                category = CategoryUtils.account.favorites(areaType);
                            for (index in selected) {
                                if (selected[index].getAccessor().favorited() === false) {
                                    accessor = selected[index].getAccessor();
                                    accessor.favorite(areaType, false);
                                    unfavoritedSelectedKeys.push(accessor.get('key'));
                                }
                            }
                            category.featureObjects(unfavoritedSelectedKeys);

                            // UI
                            this._area.getNav().pulse();
                            this._toggleFavoriteState();
                            this._pulseFavoriteIcon();
                        }
                    }
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'right'
            });
        },

        /**
         * _setupUnfavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupUnfavoriteEvent: function() {
            this.on({
                'unfavorite': function(event, $anchor) {
                    var results = this._area.getActiveGroup().getActiveResults(),
                        currentCategory = results.getCategory(),
                        areaType = this._area.getType(),
                        favoritesCategory = CategoryUtils.account.favorites(areaType);
                    if (this._multipleSelected() === false) {
                        this._getAccessor().unfavorite(areaType, true);
                        this._toggleFavoriteState();
                        if (currentCategory === favoritesCategory) {
                            results.deselectAll();
                            this.triggerHandler('close');
                        }
                    } else {
                        var selected = this._getSelected(),
                            category = favoritesCategory,
                            featuredSelectedKeys = [],
                            index,
                            accessor;
                        for (index in selected) {
                            accessor = selected[index].getAccessor();
                            accessor.unfavorite(areaType, false);
                            featuredSelectedKeys.push(accessor.get('key'));
                        }
                        category.unfeatureObjects(featuredSelectedKeys);

                        // UI
                        this._toggleFavoriteState();
                        if (currentCategory === favoritesCategory) {
                            results.deselectAll();
                            this.triggerHandler('close');
                        }
                    }
                }
            });
        },

        /**
         * _showCropperModal
         * 
         * @access  protected
         * @return  AlertModalView|CropperModalView
         */
        _showCropperModal: function() {
            if (Config.serviceAvailable('cropper') === false) {
                var alertModal = Stencil.alert('services.cropper.unavailable');
                return alertModal;
            }
            var start = new Date(),
                key = this._getCropKey(),
                accessor = this._getAccessor(),
                delay = this._cropperModalMinDelay,
                $relative = this._$relative,
                modal = ModalUtils.showCropper(key),
                msg = Config.getMessage('app.crop.preparing');
            this.hide();
            this._hideActiveThumb();
            modal.setSource('thumb');
            modal.setSourceType(this._contextMenuType);
            modal.setThumbRelative($relative);
            App.getBusy().show(msg);
            modal.once({
                'cropper/ready': function(event) {
                    (function() {
                        var cropPositionData = accessor.getCropBoxPositionData();
                        this.setCropBox(cropPositionData);
                        if (cropPositionData.x !== undefined) {
                            var x = cropPositionData.x,
                                y = cropPositionData.y,
                                width = cropPositionData.width,
                                height = cropPositionData.height;
                            this.resizeCropBox(width, height);
                            this.moveCropBox(x, y);
                        }
                        App.getBusy().hide();
                        modal.getElement().removeClass('invisible');
                    }).minDelay(start, delay, this);
                }
            });
            return modal;
        },

        /**
         * _toggleFavoriteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleFavoriteState: function() {
            var $favorite = this.find('[lookup="favorite"]'),
                $unfavorite = this.find('[lookup="unfavorite"]');
            $favorite.addClass('hidden');
            $unfavorite.addClass('hidden');
            if (this._selectedHaveBeenFavorited() === false) {
                $favorite.removeClass('hidden');
            } else {
                $unfavorite.removeClass('hidden');
            }
        },

        /**
         * _toggleMultipleCountTooltip
         * 
         * @access  protected
         * @return  void
         */
        _toggleMultipleCountTooltip: function() {
            var $h3 = this.find('h3');
            $h3.tooltip('destroy');
            if (this._multipleSelected() === true) {
                var count = this._getSelected().length,
                    areaType = this._area.getType(),
                    type = areaType,
                    tooltip = '';
                if (areaType === 'graphics') {
                    type = 'icons';
                }
                tooltip = (count) + ' ' + (type) + ' selected';
                $h3.attr('data-title', tooltip);
                $h3.attr('data-original-title', tooltip);
                this._element.tooltip({
                    html: true,
                    selector: 'h3[tooltip]',
                    container: App.getElement(),
                    placement: 'right'
                });
            }
        },

        /**
         * _updateSelectedCount
         * 
         * @access  protected
         * @return  void
         */
        _updateSelectedCount: function() {
            var count = this._getSelected().length;
            // this.find('h3').find('span').text(this._getSelected().length);
            this.find('h3').html(count);
        },

        /**
         * closable
         * 
         * @note    Works as a getter/setter
         * @access  public
         * @param   undefined|Boolean closable
         * @return  Boolean|void
         */
        closable: function(closable) {
            if (closable === undefined) {
                return this._closable === true;
            }
            this._closable = closable === true;
        },

        /**
         * getCollectionResults
         * 
         * @access  public
         * @return  CollectionResultsView
         */
        getCollectionResults: function() {
            return this._collectionResults;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._showing = false;
            this._element.addClass('hidden');
            if (this._$relative) {
                if (this._multipleSelected() === false) {
                    // this._getSelected()[0].deselect();
                    // this._$relative.removeClass('active');
                }
            }
        },

        /**
         * isShowing
         * 
         * @access  public
         * @return  Boolean
         */
        isShowing: function() {
            return this._showing === true;
        },

        /**
         * position
         * 
         * @access  public
         * @return  void
         */
        position: function() {
            this._positionWrapper();
            this._positionSecondary();
            this._positionCaret();
        },

        /**
         * secondary
         * 
         * @access  public
         * @var     Object
         */
        secondary: {

            /**
             * clearDelays
             * 
             * @access  public
             * @return  void
             */
            clearDelays: function() {
                var delayReferences = this.secondary.delayReferences,
                    index;
                for (index in delayReferences) {
                    TimeoutPool.clear(delayReferences[index]);
                }
            },

            /**
             * delayReferences
             * 
             * @access  public
             * @return  Array (default: [])
             */
            delayReferences: [],

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                this._element.removeClass('expanded');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                this._element.addClass('expanded');
            }
        },

        /**
         * setRelative
         * 
         * @access  public
         * @param   jQuery $relative
         * @return  void
         */
        setRelative: function($relative) {
            this._$relative = $relative;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._showing = true;
            this._toggleFavoriteState();
            this._element.removeClass('hidden');
            this._addCloseListeners();
            this._$relative.addClass('active');
            this._element.removeClass('multiple');
            this._toggleMultipleCountTooltip();
            this._updateSelectedCount();
            this._loadCropperDependencies();
            if (this._area.canHaveCollections() === true) {
                this.updateCollectionResultRowStates();
            }
            if (this._multipleSelected() === true) {
                this._element.addClass('multiple');
            }
        },

        /**
         * showBusyModalProgressMessaging
         * 
         * @access  public
         * @param   Number index
         * @param   Array arr
         * @return  void
         */
        showBusyModalProgressMessaging: function(index, arr) {
            var copy = App.getBusy().find('.copy').text(),
                replacement = '(' + (index + 1) + ' of ' + (arr.length) + ')';
            copy = copy.replace(/\([^\)]+\)/, replacement);
            App.getBusy().find('.copy').text(copy);
        },

        /**
         * updateCollectionResultRowStates
         * 
         * @access  public
         * @return  void
         */
        updateCollectionResultRowStates: function() {
            this._collectionResults.updateRowStates();
        }
    });
});
window.DependencyLoader.push('CollectionResultsView', function() {

    /**
     * ContextMenuCollectionResultsView
     * 
     * @extends CollectionResultsView
     */
    window.ContextMenuCollectionResultsView = CollectionResultsView.extend({

        /**
         * _childrenCanBeSorted
         * 
         * @access  protected
         * @var     false|Boolean (default: false)
         */
        _childrenCanBeSorted: false,

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'ContextMenuCollectionRow',
            view: 'ContextMenuCollectionRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ContextMenuCollectionResultsView')
         */
        _string: 'ContextMenuCollectionResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _setupCollection
         * 
         * Listeners for the move event against the collection, and when it
         * occurs, re-orders the rows to match the appropriate order.
         * 
         * This is more complicated than it seems it ought to be, because when
         * a sort happens, the <_children> array is not actually re-ordered.
         * So I need to loop through it to find the appropriate element that
         * has been moved, and use that as a starting point.
         * 
         * After that, I then need to iterate over next / prev calls to move
         * the element to where it should be.
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this;
            this._collection.on({
                'move': function(event, categoryAccessor, newPosition, oldPosition) {
                    var findChild = function(accessor) {
                        var index,
                            child;
                        for (index in this._children) {
                            child = this._children[index];
                            if (child.getCategory() === accessor) {
                                return this._children[index];
                            }
                        }
                        var msg = 'Could not find child';
                        throw new Error(msg);
                    };
                    var child = findChild.apply(_this, [
                            this._accessors[newPosition]
                        ]),
                        index = 0;
                    if (newPosition > oldPosition) {
                        for (index; index < (newPosition - oldPosition); index++) {
                            child.getElement().insertAfter(
                                child.getElement().next()
                            );
                        }
                    } else {
                        for (index; index < (oldPosition - newPosition); index++) {
                            child.getElement().insertBefore(
                                child.getElement().prev()
                            );
                        }
                    }
                }
            });
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            var index;
            for (index in this._children) {
                this._children[index].disable();
            }
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            var index;
            for (index in this._children) {
                this._children[index].enable();
            }
        },

        /**
         * sort
         * 
         * @access  public
         * @return  void
         */
        sort: function() {
            if (Config.default('collectionSortOrder') === 'alphabetical') {
                var $inner = this.find('div.inner'),
                    selector = '> div.contextMenuCollectionRow';
                $inner.get(0).orderAlphabeticallyByText(selector);
            }
        },

        /**
         * updateRowStates
         * 
         * @access  public
         * @return  void
         */
        updateRowStates: function() {
            var index;
            for (index in this._children) {
                this._children[index].adjustState();
            }
        }
    });
});
window.DependencyLoader.push('CollectionRowView', function() {

    /**
     * ContextMenuCollectionRowView
     * 
     * @extends CollectionRowView
     */
    window.ContextMenuCollectionRowView = CollectionRowView.extend({

        /**
         * _delays
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            sequential: {
                feature: 1750,
                unfeature: 650
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ContextMenuCollectionRowView')
         */
        _string: 'ContextMenuCollectionRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CategoryAccessor category
         * @param   ContextMenuCollectionResultsView contextMenuCollectionResults
         * @return  void
         */
        init: function(element, category, contextMenuCollectionResults) {
            this._super(element, category, contextMenuCollectionResults);
        },

        /**
         * _addRowListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRowListeners: function() {
            this._addNameChangeListener();
            this._addToggleListener();
        },

        /**
         * _addToggleListener
         * 
         * @access  protected
         * @return  void
         */
        _addToggleListener: function() {
            this.on({
                'toggle': function(event, $anchor) {
                    this.toggle();
                }
            });
        },

        /**
         * _getContextMenu
         * 
         * @access  protected
         * @return  ContextMenuView
         */
        _getContextMenu: function() {
            return this._getArea().getContextMenu();
        },

        /**
         * _getSelected
         * 
         * @access  protected
         * @return  Array
         */
        _getSelected: function() {
            var activeResults = this._getActiveResults();
            return activeResults.childrenSelected.all.apply(activeResults);
        },

        /**
         * _getStateClass
         * 
         * @access  protected
         * @return  String
         */
        _getStateClass: function() {
            var selected = this._getSelected(),
                $anchor = this.find('> a');
            if (selected.length === 1) {
                var accessor = selected[0].getAccessor();
                if (accessor.featuredInCategory(this._category) === true) {
                    return 'checked';
                }
                return 'idle';
            }
            var index,
                accessor,
                count = 0;
            for (index in selected) {
                accessor = selected[index].getAccessor();
                if (accessor.featuredInCategory(this._category) === true) {
                    count++;
                }
            }
            if (count === 0) {
                return 'idle';
            }
            if (count === selected.length) {
                return 'checked';
            }
            return 'partial';
        },

        /**
         * actions
         * 
         * @access  public
         * @var     Object
         */
        actions: {

            /**
             * batch
             * 
             * @access  public
             * @var     Object
             */
            batch: {

                /**
                 * feature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                feature: function(callback) {
                    var selected = this._getSelected(),
                        category = this._category,
                        unfeaturedSelectedKeys = [],
                        index,
                        accessor;
                    for (index in selected) {
                        if (selected[index].getAccessor().featuredInCategory(category) === false) {
                            accessor = selected[index].getAccessor();
                            accessor.feature(category, false);
                            unfeaturedSelectedKeys.push(accessor.get('key'));
                        }
                    }
                    this._category.featureObjects(unfeaturedSelectedKeys);
                    callback.apply(this);
                },

                /**
                 * unfeature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                unfeature: function(callback) {
                    var selected = this._getSelected(),
                        category = this._category,
                        featuredSelectedKeys = [],
                        index,
                        accessor;
                    for (index in selected) {
                        accessor = selected[index].getAccessor();
                        accessor.unfeature(category, false);
                        featuredSelectedKeys.push(accessor.get('key'));
                    }
                    this._category.unfeatureObjects(featuredSelectedKeys);
                    callback.apply(this);
                }
            },

            /**
             * proxy
             * 
             * @access  public
             * @var     Object
             */
            proxy: {

                /**
                 * feature
                 * 
                 * Manages whether a batch request or series of single requests
                 * are made for a feature action. This is determined by checking
                 * whether any of the selected objects are a resource, in which
                 * case the feature requests must be done independently (since
                 * the Categories server-side controller can't accommodate
                 * resources).
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                feature: function(callback) {
                    var selected = this._getSelected(),
                        method = this.actions.batch.feature,
                        index,
                        accessor;
                    for (index in selected) {
                        accessor = selected[index].getAccessor();
                        if (accessor.is.resource.apply(accessor) === true) {
                            method = this.actions.sequential.feature;
                            break;
                        }
                    }
                    method.apply(this, [callback]);
                },

                /**
                 * unfeature
                 * 
                 * Manages whether a batch request or series of single requests
                 * are made for a unfeature action. This is determined by
                 * checking whether any of the selected objects are a resource,
                 * in which case the unfeature requests must be done
                 * independently (since the Categories server-side controller
                 * can't accommodate resources).
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                unfeature: function(callback) {
                    var selected = this._getSelected(),
                        method = this.actions.batch.unfeature,
                        index,
                        accessor;
                    for (index in selected) {
                        accessor = selected[index].getAccessor();
                        if (accessor.is.resource.apply(accessor) === true) {
                            method = this.actions.sequential.unfeature;
                            break;
                        }
                    }
                    method.apply(this, [callback]);
                }
            },

            /**
             * sequential
             * 
             * @access  public
             * @var     Object
             */
            sequential: {

                /**
                 * feature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                feature: function(callback) {

                    // Retrieve accessors that can be featured
                    this._collectionResults.disable();
                    var selected = this._getSelected(),
                        category = this._category,
                        unfeaturedSelected = [],
                        index;
                    for (index in selected) {
                        if (selected[index].getAccessor().featuredInCategory(category) === false) {
                            unfeaturedSelected.push(selected[index]);
                        }
                    }

                    // 
                    var delay = this._delays.sequential.feature,
                        featureFunction = function(index) {
                            if (index < unfeaturedSelected.length) {
                                var accessor = unfeaturedSelected[index].getAccessor(),
                                    _this = this;
                                accessor.once({
                                    'model/feature': function(event) {
                                        featureFunction.delay(delay, _this, [index + 1]);
                                    }
                                });
                                accessor.feature(category);
                            } else {
                                callback.apply(this);
                                this._collectionResults.enable();
                            }
                        };
                    featureFunction.apply(this, [0]);
                },

                /**
                 * unfeature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                unfeature: function(callback) {
                    var selected = this._getSelected(),
                        category = this._category,
                        delay = this._delays.sequential.unfeature,
                        unfeatureFunction = function(index) {
                            if (index < selected.length) {
                                var accessor = selected[index].getAccessor(),
                                    _this = this;
                                accessor.once({
                                    'model/unfeature': function(event) {
                                        unfeatureFunction.delay(delay, _this, [index + 1]);
                                    }
                                });
                                accessor.unfeature(category);
                            } else {
                                callback.apply(this);
                            }
                        };
                    unfeatureFunction.apply(this, [0]);
                }
            }
        },

        /**
         * adjustState
         * 
         * @access  public
         * @return  void
         */
        adjustState: function() {
            var $anchor = this.find('> a'),
                stateClass = this._getStateClass();
            $anchor.removeClass('idle');
            $anchor.removeClass('partial');
            $anchor.removeClass('processing');
            $anchor.removeClass('checked');
            $anchor.addClass(stateClass);
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this._element.disable();
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this._element.enable();
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            var $anchor = this.find('> a').first();
            if ($anchor.hasClass('idle') === true) {
                $anchor.removeClass('idle');
                $anchor.addClass('processing');
                this.disable();
                this.actions.proxy.feature.apply(this, [function() {
                    $anchor.removeClass('processing');
                    $anchor.addClass('checked');
                    $anchor.find('.checked').addClass('pulse');
                    (function() {
                        $anchor.find('.checked').removeClass('pulse');
                    }).delay(1200);
                    this.enable();
                }]);
            } else if ($anchor.hasClass('partial') === true) {
                $anchor.removeClass('partial');
                $anchor.addClass('processing');
                this.disable();
                this.actions.proxy.feature.apply(this, [function() {
                    $anchor.removeClass('processing');
                    $anchor.addClass('checked');
                    $anchor.find('.checked').addClass('pulse');
                    (function() {
                        $anchor.find('.checked').removeClass('pulse');
                    }).delay(1200);
                    this.enable();
                }]);
            } else if ($anchor.hasClass('checked') === true) {
                $anchor.removeClass('checked');
                $anchor.addClass('processing');
                this.disable();
                var closeContextMenu = function() {
                    var activeResults = this._getActiveResults();
                    if (activeResults.category() === true) {
                        if (this._category === activeResults.getCategory()) {
                            return true;
                        }
                    }
                    return false;
                };
                if (closeContextMenu.apply(this) === true) {
                    this._getContextMenu().triggerHandler('close');
                }
                this.actions.proxy.unfeature.apply(this, [function() {
                    $anchor.removeClass('processing');
                    $anchor.addClass('idle');
                    this.enable();
                    if (closeContextMenu.apply(this) === true) {
                        this._getActiveResults().deselectAll();
                    }
                }]);
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * GroupView
     * 
     * @extends View
     */
    window.GroupView = View.extend({

        /**
         * _activeResults
         * 
         * @access  protected
         * @var     null|ResultsView (default: null)
         */
        _activeResults: null,

        /**
         * _area
         * 
         * @access  protected
         * @var     null|AreaView (default: null)
         */
        _area: null,

        /**
         * _children
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _children: {},

        /**
         * _drawProperties
         * 
         * Defines variables, like the template and View, that ought to be used
         * when drawing results.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _drawProperties: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GroupView')
         */
        _string: 'GroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._children = {};
            this._super(element, parent);
            this._area = area;
        },

        /**
         * getActiveResults
         * 
         * @access  public
         * @return  null|ResultsView
         */
        getActiveResults: function() {
            return this._activeResults;
        },

        /**
         * getArea
         * 
         * @access  public
         * @return  AreaView
         */
        getArea: function() {
            return this._area;
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String key
         * @return  ResultsView
         */
        getChild: function(key) {
            return this._children[key];
        },

        /**
         * getChildren
         * 
         * @access  public
         * @return  Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            return this._activeResults.getPath();
        },

        /**
         * setActiveResults
         * 
         * @access  protected
         * @param   ResultsView results
         * @return  void
         */
        setActiveResults: function(results) {
            this._activeResults = results;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._area.setActiveGroup(this);
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._area.show();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * HourglassView
     * 
     * @extends View
     */
    window.HourglassView = View.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'HourglassView')
         */
        _string: 'HourglassView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * JoystickView
     * 
     * @events  feature
     *          select
     *          favorite
     * @extends View
     */
    window.JoystickView = View.extend({

        /**
         * _listeners
         * 
         * @see     https://jsfiddle.net/Lg5QH/1/
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                dragend: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': function(event, $anchor) {
                        $anchor.css({
                            backgroundImage: 'none'
                        });
                        App.getStage().getContent().find('section.messages').addClass('mirage');
                        App.getStage().getContent().getMessages().addClass('hidden');
                    }
                },
                dragstart: {

                    /**
                     * (anonymous)
                     * 
                     * @note    The defining below of the bypass string in the
                     *          encoded data is because Safari (at least) seemed
                     *          to pass along more information, perhaps for
                     *          security reasons. So I needed a way to tell which
                     *          types[] array position was indeed what I wanted.
                     * @see     http://bit.ly/1O8GfCS
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': function(event, $anchor) {
                        var dataTransfer = event.originalEvent.dataTransfer,
                            $element = $anchor.closest('.thumb, .quote.row'),
                            accessor = $element.data('accessor'),
                            type = this._getType(),
                            key = accessor.get('key'),
                            exchangeToken = ExchangeTokenUtils.store(key),
                            encoded = JSON.stringify({
                                token: exchangeToken,
                                locked: $element.hasClass('locked'),
                                type: type
                            });

                        // Preload of SVG
                        if (type === 'graphic') {
                            this._preloadVector(accessor);
                        }

                        // Preload of upload SVG and proper
                        if (type === 'upload') {
                            if (accessor.get('vector').toInt() === 1) {
                                this._preloadVector(accessor);
                            }
                        }

                        // Encoded the data and set it for the transfer
                        encoded = 'bypass' + (encoded);
                        dataTransfer.setData(encoded, '');
                        // $anchor.addClass('dragging');
                        if (type === 'quote') {
                            if (event.originalEvent.dataTransfer.setDragImage) {
                                var image = App.getEditor().getArea('quotes').getDragImage();
                                event.originalEvent.dataTransfer.setDragImage(
                                    image,
                                    (image.width / 2).round(0),
                                    (image.height / 2).round(0)
                                );
                            }
                        } else {
                            $anchor.css({
                                backgroundImage: $element.css('background-image')
                            });
                            $anchor.css({
                                backgroundSize: $element.css('background-size')
                            });
                        }

                        // Update the canvas message
                        App.getStage().getContent().find('section.messages').removeClass('mirage');
                        App.getStage().getContent().getMessages().addClass('hidden');
                        App.getStage().getContent().getMessage(type).removeClass('vector');
                        App.getStage().getContent().getMessage(type).removeClass('hidden');
                        if (type === 'upload') {
                            if (accessor.get('vector').toInt() === 1) {
                                App.getStage().getContent().getMessage(type).addClass('vector');
                            }
                        }
                    }
                },
                mousedown: {

                    /**
                     * (anonymous)
                     * 
                     * This is useful for clearing out any highlighted text for
                     * when a drag is started. Otherwise, weird cases like this
                     * can happen if the user (likely accidentally) highlighted
                     * parts of the page when they start the drag:
                     * https://i.imgur.com/pLzGLrz.jpg
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': ElementUtils.clearSelectedText
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * The logic below was intented to combat a bug that was
                     * randomly appearing. It was that every now and then,
                     * dragging an image resulted in the thumb not being visible
                     * in the "dragged" node. See screenshot:
                     * https://i.imgur.com/lIxw6DB.jpg
                     * 
                     * I believe this was happening because for whatever reason,
                     * the cache entry for the thumb was somehow getting
                     * invalidated (could be because I had the console open so
                     * much). So to deal with this, I devised the following
                     * logic that would simply preload the thumb (again) when
                     * the mouse entered the overlay. It worked, but I don't
                     * think it's neccessary, because with the console closed,
                     * I have not been able to reproduce it on dev.
                     * 
                     * UPDATE
                     * So I ran into this with the setDragImage logic above for
                     * quotes. In the case above, I was creating a new Image
                     * object and setting the src to the drag image I wanted to
                     * use. But what was happening was even if the image was in
                     * the browsers cache, it was possible a lookup would be
                     * done, which although it may only take 4ms, would result
                     * in the drag image not being set because the image needs
                     * to be available *immediately*.
                     * 
                     * So to get around this, I preload the drag image in the
                     * QuotesAreaView, and set a reference to it. Then I created
                     * a getter / lookup for that reference, and when setting
                     * the drag image above, I use that reference (since that's
                     * guarenteed not to perform any http request).
                     * 
                     * So if this bug does come up again, one way to deal with 
                     * it could be to create a reference to the image in each
                     * ThumbView, and use that reference as the drag image
                     * (instead of setting the background-image for the
                     * a.overlay node).
                     * 
                     * @see     http://stackoverflow.com/questions/8809876/can-i-get-divs-background-image-url
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': function(event, $anchor) {
                        // var $element = $anchor.closest('.thumb, .quote.row'),
                        //     url = $element.css('background-image');
                        // url = url.replace('url(','').replace(')','').replace(/\"/gi, "");
                        // new Image().src = url;
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'JoystickView')
         */
        _string: 'JoystickView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addFavoriteListener();
            this._addFeatureListener();
            this._addPinListener();
            this._addSelectListener();
            this._addShowContextMenuListener();
        },

        /**
         * _addFavoriteListener
         * 
         * @access  protected
         * @return  void
         */
        _addFavoriteListener: function() {
            this.on({
                'favorite': function(event, $anchor) {
                    var accessor = this._getAccessor();
                    this._favorite(accessor);
                }
            });
        },

        /**
         * _addFeatureListener
         * 
         * @access  protected
         * @return  void
         */
        _addFeatureListener: function() {
            this.on({
                'feature': function(event, $anchor) {
                    var type = App.getEditor().getActiveArea().getType(),
                        accessor = this._getAccessor();
                    ModalUtils.showApplyCategories(type, accessor);
                }
            });
        },

        /**
         * _addPinListener
         * 
         * @access  protected
         * @return  void
         */
        _addPinListener: function() {
            this.on({
                'pin': function(event, $anchor) {
                    var accessor = this._getAccessor(),
                        category = this._getResults().getCategory();
                    accessor.pin(category);
                    // category.pin(accessor);
                }
            });
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, $anchor, nativeEvent) {
                    this._select($anchor, nativeEvent);
                }
            });
        },

        /**
         * _addShowContextMenuListener
         * 
         * @access  protected
         * @return  void
         */
        _addShowContextMenuListener: function() {
            this.on({
                'showContextMenu': function(event, $anchor) {
                    var view = this._getView(),
                        results = this._getResults();
                    results.deselectAll();
                    view.select();
                    view.showContextMenu();
                }
            });
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @param   Accessor accessor
         * @return  Boolean
         */
        _favorite: function(accessor) {
            var activeArea = App.getEditor().getActiveArea(),
                nav = activeArea.getNav(),
                areaType = activeArea.getType();
            if (User.admin() === true) {
                nav.pulse();
                accessor.favorite.apply(accessor, [areaType, true]);
                return true;
            }
            if (User.editor() === true) {
                nav.pulse();
                accessor.favorite.apply(accessor, [areaType, true]);
                return true;
            }
            if (Account.max.favorites() === false) {
                nav.pulse();
                accessor.favorite.apply(accessor, [areaType, true]);
                return true;
            }
            var path = '/app/upgrade/pro/favorites?clean=1';
            if (Account.plan('pro') === true) {
                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
            }
            Stencil.navigate(path);
            return false;
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  Accessor
         */
        _getAccessor: function() {
            var $element = this._element.closest('.thumb, .quote.row'),
                accessor =  $element.data('accessor');
            return accessor;
        },

        /**
         * _getResults
         * 
         * @access  protected
         * @return  ResultsView
         */
        _getResults: function() {
            var view = this._getView(),
                results = view.getResults();
            return results;
        },

        /**
         * _getType
         * 
         * @note    Used by event handles to send type details to <favorite> and
         *          <feature> methods in some accessors.
         * @note    Not elegant, but works for now.
         * @access  protected
         * @return  String
         */
        _getType: function() {
            var type = App.getEditor().getActiveArea().getType();
            if (type === 'graphics') {
                return 'graphic';
            }
            if (type === 'templates') {
                return 'template';
            }
            if (type === 'images') {
                return 'image';
            }
            if (type === 'quotes') {
                return 'quote';
            }
            if (type === 'uploads') {
                return 'upload';
            }
            return 'photo';
        },

        /**
         * _getView
         * 
         * @access  protected
         * @return  View
         */
        _getView: function() {
            var $element = this._element.closest('.thumb, .quote.row'),
                view = $element.data('view');
            return view;
        },

        /**
         * _preloadVector
         * 
         * @access  protected
         * @param   Accessor accessor
         * @return  void
         */
        _preloadVector: function(accessor) {
            var preloadedVectors = Stencil.get('preloadedVectors'),
                vectorUrl = accessor.url('svg');
            if (accessor.is.asset.apply(accessor) === true) {
                var key = (accessor.get('key')) + '.svg';
                vectorUrl = RequestUtils.url.cloudFront(key);
            }
            if (preloadedVectors === undefined) {
                preloadedVectors = [];
                Stencil.set('preloadedVectors', preloadedVectors);
            }
            if (ArrayUtils.contains(vectorUrl, preloadedVectors) === false) {
                preloadedVectors.push(vectorUrl);
                Stencil.set('preloadedVectors', preloadedVectors);
                var signature = {"basename":"Joystick.js","line":415};
                RequestUtils.ajax({
                    excludeDefaultData: true,
                    signature: signature,
                    cache: true,
                    crossDomain: true,
                    url: vectorUrl,
                    type: 'GET',
                    dataType: 'text'
                });
            }
        },

        /**
         * _select
         * 
         * @access  protected
         * @param   jQuery $anchor
         * @param   jQuery nativeEvent
         * @return  Boolean
         */
        _select: function($anchor, nativeEvent) {

            // Preparation
            var $element = $anchor.closest('.thumb, .quote.row'),
                view = this._getView(),
                accessor = this._getAccessor();

            /**
             * Shift + Click
             * 
             */
            if (nativeEvent.shiftKey === true) {

                // 
                var results = this._getResults(),
                    childrenSelected = results.childrenSelected.all.apply(results);
                if (childrenSelected.length === 0) {
                    var $range = $element.prevAll().addBack().reverse();
                    $range.each(function(index, element) {
                        $(element).data('view').select();
                        $(element).addClass('active-shift');
                    });
                    return true;
                }

                // 
                var $lastSelected = $element.parent().find('.active-last'),
                    $shiftSelected = $element.parent().find('.active-shift');
                $shiftSelected.each(function(index, element) {
                    $(element).data('view').deselect();
                });
                if ($element[0] === $lastSelected[0]) {
                    $lastSelected.data('view').select();
                    results.reClassifyChildren();
                    return true;
                }

                // 
                $lastSelected.data('view').deselect();
                var $range = $lastSelected.getRangeElements($element).reverse();
                $range.each(function(index, element) {
                    $(element).data('view').select();
                    $(element).addClass('active-shift');
                });
                results.reClassifyChildren();
                return true;
            }

            /**
             * Command + Click
             * 
             */
            if (
                (UserAgentUtils.is.mac() === true && nativeEvent.metaKey === true)
                || (UserAgentUtils.is.mac() === false && nativeEvent.ctrlKey === true)
            ) {
                var results = this._getResults();
                $element.siblings().removeClass('active-shift');
                view.toggle();
                results.reClassifyChildren();
                return true;
            }

            /**
             * Click
             * 
             */
            if ($element.hasClass('active') === false) {
                var locked = $element.hasClass('locked'),
                    options = {};
                if (accessor.getPlacementDestination !== undefined) {
                    options.destination = accessor.getPlacementDestination();
                }
                var accountDraftStillBeingCreated = function() {
                    if (Stencil.account().draft().data().settings.locked === undefined) {
                        return true;
                    }
                    return false;
                };

                // 
                if (accountDraftStillBeingCreated() === false) {
                    accessor.select.apply(
                        accessor,
                        ['click', locked, options]
                    );
                    if ($element.data('view').showPreloadingSpinner) {
                        $element.data('view').showPreloadingSpinner();
                    }
                    return true;
                }

                // 
                var msg = Config.getMessage('account.draft.processing');
                App.getBusy().show(msg);
                Stencil.account().once({
                    'draft/create': function(event, draft) {
                        App.getBusy().hide();
                    }
                });
                return false;
            }

            // 
            return false;
        }
    });
});
window.DependencyLoader.push('GroupView', function() {

    /**
     * QueriesGroupView
     * 
     * @extends GroupView
     */
    window.QueriesGroupView = GroupView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QueriesGroupView')
         */
        _string: 'QueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   String query
         * @return  void
         */
        _drawChild: function(query) {
            var $results = DataUtils.render(this._drawProperties.template, {
                    fallback: this._drawProperties.fallback(),
                    query: query
                });
            $results.attr('query', query);
            $results.find('div.finished div.copy strong').text(query);
            this._element.append($results);
            this._children[query] = new window[this._drawProperties.view](
                $results,
                this,
                query
            );
            var _this = this;
            this._children[query].on({
                'destroy': function(event) {
                    delete _this._children[query];
                }
            });
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String query
         * @return  QueryResultsView
         */
        getChild: function(query) {
            if (this._super(query) === undefined) {
                this._drawChild(query);
            }
            return this._super(query);
        }
    });
});
window.DependencyLoader.push('ResultsView', function() {

    /**
     * QueryResultsView
     * 
     * @extends ResultsView
     */
    window.QueryResultsView = ResultsView.extend({

        /**
         * _query
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _query: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QueryResultsView')
         */
        _string: 'QueryResultsView',

        /**
         * _typedGatewayStats
         * 
         * This will become an object which keeps track of the following:
         * - Whether there are more resources to load, via the _more_ property
         * - The offset for each gateway
         * 
         * @access  protected
         * @var     false|Object (default: false)
         */
        _typedGatewayStats: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QueriesGroupView queriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, queriesGroup, query) {
            this._query = query;
            this._super(element, queriesGroup);
            this._addDestroyListener();
        },

        /**
         * _addDestroyListener
         * 
         * @access  protected
         * @return  void
         */
        _addDestroyListener: function() {
            this.on({
                'destroy': function(event) {
                    this._collection.empty();
                    this._element.remove();
                }
            });
        },

        /**
         * _getAvailabilityWarningCopy
         * 
         * @access  protected
         * @param   Array unavailableGateways
         * @return  String
         */
        _getAvailabilityWarningCopy: function(unavailableGateways) {
            var unavailableGatewayCopy = Config.default('unavailableGatewayCopy'),
                queryResultsType = this._getQueryResultsType();
            if (unavailableGateways.length === 1) {
                var gatewayName = unavailableGateways[0];
                return unavailableGatewayCopy[queryResultsType].gateways[gatewayName];
            }
            return unavailableGatewayCopy[queryResultsType].multiple;
        },

        /**
         * _hideAvailabilityWarning
         * 
         * @access  protected
         * @return  void
         */
        _hideAvailabilityWarning: function() {
            var $icons = this._group.getArea().find('div.icons');
            $icons.removeClass('warning');
        },

        /**
         * _showAvailabilityWarning
         * 
         * @access  protected
         * @param   Array unavailableGateways
         * @return  void
         */
        _showAvailabilityWarning: function(unavailableGateways) {
            var $icons = this._group.getArea().find('div.icons'),
                $span = $icons.find('div.icon.warning span'),
                warningCopy = this._getAvailabilityWarningCopy(
                    unavailableGateways
                );
            $icons.addClass('warning');
            $span.attr('data-title', warningCopy);
        },

        /**
         * _showHideAvailabilityWarning
         * 
         * @access  protected
         * @param   Array searchGatewayAvailability
         * @return  void
         */
        _showHideAvailabilityWarning: function(searchGatewayAvailability) {
            this._hideAvailabilityWarning();
            var unavailableGateways = [];
            for (var index in searchGatewayAvailability) {
                if (searchGatewayAvailability[index] === false) {
                    unavailableGateways.push(index);
                }
            }
            if (unavailableGateways.length > 0) {
                this._showAvailabilityWarning(unavailableGateways);
            }
        },

        /**
         * _validSearchGateways
         * 
         * @access  protected
         * @return  Boolean
         */
        _validSearchGateways: function() {
            var searchGateways = this._getSearchGateways(),
                index,
                serviceName,
                serviceAvailable;
            for (index in searchGateways) {
                serviceName = StringUtils.lcfirst(searchGateways[index]);
                serviceAvailable = Config.serviceAvailable(serviceName);
                if (serviceAvailable === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * getQuery
         * 
         * @access  public
         * @return  String
         */
        getQuery: function() {
            return this._query;
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {

            // Refresh the scrollbar if it's needed
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                queryResultsType = this._getQueryResultsType(),
                limit = Config.default('objectsPerPage')[queryResultsType].results;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }

            // Service check
            this._hideAvailabilityWarning();
            if (this._validSearchGateways() === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    typedGatewayStats: this._typedGatewayStats,
                    limit: limit,
                    query: this._query,
                    type: queryResultsType
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    _this._typedGatewayStats = response.data.typedGatewayStats;
                    _this._showHideFinishedState(limit);
                    var searchGatewayAvailability = response.data.searchGatewayAvailability;
                    _this._showHideAvailabilityWarning(searchGatewayAvailability);
                });
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                nav = area.getNav(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                path = this.getPath();
            App.getSidebar().updatePath(area, path);
            nav.showResultsLabel();
            $search.val(this._query);
            if (
                UserAgentUtils.is.tablet() === false
                && UserAgentUtils.is.ie() === false
            ) {
                $search.focus();
            }
        }
    });
});
window.DependencyLoader.push('SelectableElementView', function() {

    /**
     * QuoteRowView
     * 
     * @extends SelectableElementView
     */
    window.QuoteRowView = SelectableElementView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteRowView')
         */
        _string: 'QuoteRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AssetAccessor|ResourceAccessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._addRowListeners();
        },

        /**
         * _addRowListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRowListeners: function() {
            var areaType = this._getAreaType();
            this.on({
                'unfavorite': function(event) {
                    this._accessor.unfavorite(areaType, true);
                },
                'unfeature': function(event, category) {
                    ModalUtils.showApplyCategories(areaType, this._accessor);
                }
            });
        },

        /**
         * _getAreaType
         * 
         * @access  protected
         * @return  String
         */
        _getAreaType: function() {
            return this._results.getGroup().getArea().getType();
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            var $active = this.find('div.active');
            $active.css({
                'lineHeight': this._element.outerHeight() + 'px'
            });
            this._super();
        }
    });
});
window.DependencyLoader.push('QuoteRowView', function() {

    /**
     * ChildQuoteRowView
     * 
     * @extends QuoteRowView
     */
    window.ChildQuoteRowView = QuoteRowView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChildQuoteRowView')
         */
        _string: 'ChildQuoteRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === CategoryUtils.account.favorites('quotes')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === CategoryUtils.account.favorites('quotes')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
});
window.DependencyLoader.push('ContextMenuView', function() {

    /**
     * ResourceContextMenuView
     * 
     * @extends ContextMenuView
     */
    window.ResourceContextMenuView = ContextMenuView.extend({

        /**
         * _delays
         * 
         * Overwriting parent delays for multiple to ensure partners don't get
         * spammed by requests that are too close together.
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            multiple: {
                delete: 650,
                favorite: {
                    category: 650,
                    results: 1750
                },
                trailing: 750,
                unfavorite: 650
            }
        },

        /**
         * _maxSequentialResourceActions
         * 
         * @access  protected
         * @var     Number (default: 5)
         */
        _maxSequentialResourceActions: 5,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceContextMenuView')
         */
        _string: 'ResourceContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView|PhotosAreaView|QuotesAreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _atLeastOneSelectedIsLocked
         * 
         * @access  protected
         * @return  Boolean
         */
        _atLeastOneSelectedIsLocked: function() {
            var selected = this._getSelected(),
                index;
            for (index in selected) {
                if (selected[index].getElement().hasClass('locked') === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _getFavoritesCategory
         * 
         * @access  protected
         * @return  CategoryAccessor
         */
        _getFavoritesCategory: function() {
            var areaType = this._area.getType();
            return CategoryUtils.account.favorites(areaType);
        },

        /**
         * _getMultipleDelay
         * 
         * @access  protected
         * @param   String action
         * @return  Number
         */
        _getMultipleDelay: function(action) {
            if (action === 'favorite') {
                var results = this._area.getActiveGroup().getActiveResults();
                if (results.category() === true) {
                    return this._delays.multiple[action].category;
                }
                return this._delays.multiple[action].results;
            }
            return this._super(action);
        },

        /**
         * _setupFavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupFavoriteEvent: function() {
            this.on({
                'favorite': function(event, $anchor) {
                    if (this._multipleSelected() === false) {
                        if (
                            Account.max.favorites() === true
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {
                            var areaType = this._area.getType();
                            this._area.getNav().pulse();
                            this._getAccessor().favorite(areaType, true);
                            this._toggleFavoriteState();
                            this._toggleMultipleCountTooltip();
                            this._pulseFavoriteIcon();
                        }
                    } else {

                        // Get ones that can be favorited
                        var selected = this._getSelected(),
                            unfavoritedSelected = [],
                            index;
                        for (index in selected) {
                            if (selected[index].getAccessor().favorited() === false) {
                                unfavoritedSelected.push(selected[index]);
                            }
                        }

                        // Limit check
                        var account = Stencil.account();
                        if (
                            account.getFavoritesRemaining() < unfavoritedSelected.length
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {

                            // Let's do this!
                            var callback = function(index) {
                                if (index < unfavoritedSelected.length) {
                                    this.showBusyModalProgressMessaging(
                                        index,
                                        unfavoritedSelected
                                    );
                                    var accessor = unfavoritedSelected[index].getAccessor(),
                                        delay = this._getMultipleDelay('favorite'),
                                        areaType = this._area.getType(),
                                        _this = this;
                                    accessor.once({
                                        'model/feature': function(event) {
                                            if ((index + 1) >= unfavoritedSelected.length) {
                                                delay = _this._getMultipleDelay('trailing');
                                            }
                                            callback.delay(delay, _this, [index + 1]);
                                            // // if ((index + 1) < unfavoritedSelected.length) {
                                            //     callback.delay(delay, callback, [index + 1]);
                                            // // } else {
                                            // //     callback(index + 1);
                                            // // }
                                        }
                                    });
                                    accessor.favorite(areaType, true);
                                } else {
                                    this._toggleFavoriteState();
                                    this._toggleMultipleCountTooltip();
                                    this._pulseFavoriteIcon();
                                    App.getBusy().hide();
                                    this.closable(true);
                                    // var results = this._area.getActiveGroup().getActiveResults();
                                    // results.deselectAll();
                                }
                            };

                            // UI
                            this._area.getNav().pulse();
                            var msg = this._getBusyMessage('favorite');
                            App.getBusy().show(msg);
                            this.closable(false);
                            callback.apply(this, [0]);
                        }
                    }
                }
            });
        },

        /**
         * _setupUnfavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupUnfavoriteEvent: function() {
            this.on({
                'unfavorite': function(event, $anchor) {
                    var results = this._getView().getResults(),
                        areaType = this._area.getType();
                    if (this._multipleSelected() === false) {
                        this._getAccessor().unfavorite(areaType, true);
                        this._toggleFavoriteState();
                        this._toggleMultipleCountTooltip();
                        if (results.category() === true) {
                            var currentCategory = results.getCategory(),
                                favoritesCategory = this._getFavoritesCategory();
                            if (currentCategory === favoritesCategory) {
                                results.deselectAll();
                                this.triggerHandler('close');
                            }
                        }
                    } else {
                        var selected = this._getSelected(),
                            delay = this._getMultipleDelay('unfavorite'),
                            callback = function(index) {
                                if (index < selected.length) {
                                    this.showBusyModalProgressMessaging(
                                        index,
                                        selected
                                    );
                                    var accessor = selected[index].getAccessor(),
                                        _this = this;
                                    accessor.once({
                                        'model/unfeature': function(event) {
                                            if ((index + 1) >= selected.length) {
                                                delay = _this._getMultipleDelay('trailing');
                                            }
                                            callback.delay(delay, _this, [index + 1]);
                                            // // if ((index + 1) < selected.length) {
                                            //     callback.delay(delay, callback, [index + 1]);
                                            // // } else {
                                            // //     callback(index + 1);
                                            // // }
                                        }
                                    });
                                    accessor.unfavorite(areaType, true);
                                } else {
                                    this._toggleFavoriteState();
                                    this._toggleMultipleCountTooltip();
                                    App.getBusy().hide();
                                    this.closable(true);
                                    if (results.category() === true) {
                                        var currentCategory = results.getCategory(),
                                            favoritesCategory = this._getFavoritesCategory();
                                        if (currentCategory === favoritesCategory) {
                                            results.deselectAll();
                                            this.triggerHandler('close');
                                        }
                                    }
                                }
                            };

                        // UI
                        if (results.category() === true) {
                            var currentCategory = results.getCategory(),
                                favoritesCategory = this._getFavoritesCategory();
                            if (currentCategory === favoritesCategory) {
                                this.triggerHandler('close');
                            }
                        }
                        var msg = this._getBusyMessage('unfavorite');
                        App.getBusy().show(msg);
                        this.closable(false);
                        callback.apply(this, [0]);
                    }
                }
            });
        },

        /**
         * _toggleCollectionTooltips
         * 
         * @access  protected
         * @return  void
         */
        _toggleCollectionTooltips: function() {
            this._destroyTooltips();
            var $viewCollections = this.find('[lookup="viewCollections"]');
            $viewCollections.enable();
            if (this._atLeastOneSelectedIsLocked() === true) {
                var tooltip = this._tooltips.collections.single;
                if (this._multipleSelected() === true) {
                    tooltip = this._tooltips.collections.multiple;
                }
                $viewCollections.attr('data-title', tooltip);
                $viewCollections.attr('data-original-title', tooltip);
                this._setupTooltips();
                $viewCollections.disable();
            } else {
                if (this._multipleSelected() === true) {
                    var results = this._area.getActiveGroup().getActiveResults();
                    if (results.category() === false) {
                        var maxSequentialResourceActions = this._maxSequentialResourceActions;
                        if (this._getSelected().length > maxSequentialResourceActions) {
                            var tooltip = this._tooltips.collections.limit;
                            tooltip = tooltip.replace('###', maxSequentialResourceActions);
                            $viewCollections.attr('data-title', tooltip);
                            $viewCollections.attr('data-original-title', tooltip);
                            this._setupTooltips();
                            $viewCollections.disable();
                        }
                    }
                }
            }
        },

        /**
         * _toggleFavoriteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleFavoriteState: function() {
            this._super();
            this._destroyTooltips();
            var $unfavorite = this.find('[lookup="unfavorite"]'),
                $favorite = this.find('[lookup="favorite"]');
            $unfavorite.enable();
            $favorite.enable();
            if (this._atLeastOneSelectedIsLocked() === true) {
                var tooltips = {
                    favorite: this._tooltips.favorite.single,
                    unfavorite: this._tooltips.unfavorite.single
                };
                if (this._multipleSelected() === true) {
                    tooltips = {
                        favorite: this._tooltips.favorite.multiple,
                        unfavorite: this._tooltips.unfavorite.multiple
                    };
                }
                $unfavorite.attr('data-title', tooltips.unfavorite);
                $unfavorite.attr('data-original-title', tooltips.unfavorite);
                $favorite.attr('data-title', tooltips.favorite);
                $favorite.attr('data-original-title', tooltips.favorite);
                this._setupTooltips();
                $unfavorite.disable();
                $favorite.disable();
            } else {
                if (this._multipleSelected() === true) {
                    var results = this._area.getActiveGroup().getActiveResults();
                    if (results.category() === false) {
                        var maxSequentialResourceActions = this._maxSequentialResourceActions;
                        if (this._getSelected().length > maxSequentialResourceActions) {
                            var tooltip = this._tooltips.favorite.limit;
                            tooltip = tooltip.replace('###', maxSequentialResourceActions);
                            $favorite.attr('data-title', tooltip);
                            $favorite.attr('data-original-title', tooltip);
                            this._setupTooltips();
                            $favorite.disable();
                        }
                    }
                }
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ResultsView
     * 
     * @extends View
     */
    window.ResultsView = View.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _children
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _children: [],

        /**
         * _childrenSelected
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _childrenSelected: [],

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|FeaturesCollection (default: null)
         */
        _collection: null,

        /**
         * _drawProperties
         * 
         * Defines the template and View that ought to be used when drawing a
         * a child (right now, either a thumb or quote row).
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _drawProperties: {},

        /**
         * _infiniteScrollThreshold
         * 
         * Number of pixels below the bottom of the scrollable area at which
         * point another load is triggered
         * 
         * @access  protected
         * @var     Number (default: 350)
         */
        _infiniteScrollThreshold: 350,

        /**
         * _loaded
         * 
         * Whether an initial load has been triggered.
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll).
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * Tracks whether or not there is more data to be loaded.
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _more: true,

        /**
         * _scrollEvents
         * 
         * @access  protected
         * @var     Object
         */
        _scrollEvents: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._infiniteScrollThreshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            },

            /**
             * plugin
             * 
             * @access  private
             * @param   jQuery event
             * @param   Number y
             * @param   Boolean top
             * @param   Boolean bottom
             * @return  void
             */
            plugin: function(event, y, top, bottom) {
                var $inner = this._element.find('div.inner'),
                    bottom = y > ($inner.outerHeight() - this._element.outerHeight() - this._infiniteScrollThreshold);
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResultsView')
         */
        _string: 'ResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GroupView group
         * @return  void
         */
        init: function(element, group) {
            this._children = [];
            this._childrenSelected = [];
            this._group = group;
            this._super(element);
            this._addInfiniteScrollEvents();
            this._setupAuthLocking();
            this._setupResults();
            this._setupTooltips();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scrollEvents.native.proxy(this);
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                check = this._scrollEvents.plugin.proxy(this);
            }
            this.addScrollEvent(check);
        },

        /**
         * _addLoadedListener
         * 
         * The logic for this is as follows:
         * If you're navigating to your favorite-photos, we should only block
         * the whole div.results area if there are no results already loaded
         * into that area. The case where there are already results loaded is if
         * for example you do a search and favorite one of the results before
         * having navigated to /app/photos/favorites.
         * 
         * This shouldn't cause an issue with QueryResultsView views since
         * they'll always be empty.
         * 
         * @access  protected
         * @return  void
         */
        _addLoadedListener: function() {
            if (this._loaded === false) {
                if (this.getNumberOfResults() === 0) {
                    this.once({
                        'loaded': function(event) {
                            var length = this._collection.length();
                            if (length === 0) {
                                this.hourglass();
                            } else {
                                this._onResultsReady(function() {
                                    this.hourglass();
                                });
                            }
                        }
                    });
                    this.hourglass();
                }
                this.trackLoad();
                this.load();
            }
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   Accessor accessor
         * @param   Number position
         * @return  View
         */
        _drawChild: function(accessor, position) {
            var $element = DataUtils.render(this._drawProperties.template, {
                accessor: accessor,
                locked: this._locked(position),
                results: this
            });
            if (position === 0) {
                this._element.find('div.inner').prepend($element);
            } else {
                this._element.find('div.inner').append($element);
            }
            var child = new window[this._drawProperties.view](
                $element,
                accessor,
                this
            );
            this._children.push(child);
            $element.data('accessor', accessor);
            $element.data('view', child);
            return child;
        },

        /**
         * _hasScrollBar
         * 
         * @access  protected
         * @return  Boolean
         */
        _hasScrollBar: function() {
            var $results = this.find('div.results').first();
            if (UserAgentUtils.supports.css.scrollbars() === true) {
                return $results.get(0).scrollHeight > $results.height();
            }
            return this._$scrollbar.data('jsp').getIsScrollableV() === true;
        },

        /**
         * _locked
         * 
         * Returns whether or not a specific result should be locked, based on
         * the config settings for this section, and how many previous results
         * have been written.
         * 
         * @access  protected
         * @param   Number position
         * @return  Boolean
         */
        _locked: function(position) {
            if (User.admin() === true) {
                return false;
            }
            if (User.editor() === true) {
                return false;
            }
            if (Account.upgraded() === true) {
                return false;
            }
            var applicableResultsHash = [
                    'GraphicCategoryResultsView',
                    'GraphicQueryResultsView',
                    'PhotoCategoryResultsView',
                    'PhotoQueryResultsView'
                ];
            if (ArrayUtils.contains(this._string, applicableResultsHash) === true) {
                var maxFree = Config.default('maxFree'),
                    lookup = {
                        GraphicCategoryResultsView: maxFree.graphicFeatures,
                        GraphicQueryResultsView: maxFree.graphicResources,
                        PhotoCategoryResultsView: maxFree.photoFeatures,
                        PhotoQueryResultsView: maxFree.photoResources
                    };
                if ((position + 1) > lookup[this._string]) {
                    return true;
                }
                return false;
            }
            return false;
        },

        /**
         * _makeScrollable
         * 
         * @note    It's important to set the _$scrollbar value to null, since
         *          it should no longer be available after a destroy event has
         *          been triggered.
         * @see     http://jquery-custom-scrollbar.rocketmind.pl/
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            this._$scrollbar.bind({
                'jsp-scroll-y': function(event, y, top, bottom) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                }
            });

            // Resizing
            var resize = function() {
                $element.data('jsp').reinitialise();
            };
            $(window).resize(resize);
            this.on({
                'destroy': function(event) {
                    this._$scrollbar = null;
                    $(window).unbind('resize', resize);
                }
            });
        },

        /**
         * _onResultsReady
         * 
         * This method triggers the callback once we're sure that at least one
         * thumb has been loaded (and is therefore visible to the user).
         * 
         * The intention with this is to lower the perceived time that it takes
         * for results to load. Before doing this, the hourglass spinner would
         * be hidden as soon as the server responded back with the data, but the
         * div.results area would remain empty, since images (naturally) take
         * longer to load than raw data. This was especially noticable on slower
         * connections (eg. while travelling, and thus, in places where internet
         * isn't as reliable).
         * 
         * Check out the other _onResultsReady methods in other ResultsView
         * child-classes to see how those are handled.
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            var interval = (function() {
                var selectors = [
                        '.lazy.loaded',
                        '.lazy.error'
                    ],
                    selector = selectors.join(',');
                if (this.find(selector).length > 0) {
                    IntervalPool.clear(interval);
                    callback.apply(this);
                }
            }).interval(50, this);
        },

        /**
         * _setupAuthLocking
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthLocking: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    if (
                        User.admin() === true
                        || User.editor() === true
                        || Account.upgraded() === true
                    ) {
                        _this.find('.locked').removeClass('locked');
                    }
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this.find('.locked').removeClass('locked');
                }
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection.on({
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _setupResults
         * 
         * @access  protected
         * @return  void
         */
        _setupResults: function() {
            var $results = this.find('.results');
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._makeScrollable($results);
            } else {
                $results.scroll(function(event) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                });
            }
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                delay: {
                    show: 300,
                    hide: 0
                },
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * _showHideFinishedState
         * 
         * Shows the finished state if no more results have been found, and
         * there's a scrollbar visible to the user.
         * 
         * @access  protected
         * @param   Number limit
         * @return  void
         */
        _showHideFinishedState: function(limit) {
            if (this._more === false) {
                if (this._hasScrollBar() === true) {
                    this.find('div.status.finished').removeClass('hidden');
                    this.refreshScrollbar();
                }
            }
        },

        /**
         * addScrollEvent
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        addScrollEvent: function(callback) {
            var $results = this.find('div.results').first(),
                listener = 'scroll';
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                listener = 'jsp-scroll-y';
            }
            $results.bind(listener, callback);
        },

        /**
         * category
         * 
         * Returns whether or not this ResultView represents a category.
         * 
         * @access  public
         * @return  Boolean
         */
        category: function() {
            return this.getCategory !== undefined;
        },

        /**
         * childrenSelected
         * 
         * @access  public
         * @var     Object
         */
        childrenSelected: {

            /**
             * add
             * 
             * @access  public
             * @param   View child
             * @return  void
             */
            add: function(child) {
                this._childrenSelected.push(child);
            },

            /**
             * all
             * 
             * @access  public
             * @return  Array
             */
            all: function() {
                return this._childrenSelected;
            },

            /**
             * contains
             * 
             * @access  public
             * @param   View child
             * @return  Boolean
             */
            contains: function(child) {
                return this._childrenSelected.indexOf(child) !== -1;
            },

            /**
             * remove
             * 
             * @access  public
             * @param   View child
             * @return  void
             */
            remove: function(child) {
                var childrenSelected = this._childrenSelected,
                    index = childrenSelected.indexOf(child);
                if (index !== -1) {
                    childrenSelected.splice(index, 1);
                }
            }
        },

        /**
         * deselectAll
         * 
         * @access  public
         * @return  void
         */
        deselectAll: function() {
            var index = 0,
                length = this._children.length;
            while (index < length) {
                this._children[index].deselect();
                index++;
            }
            index = this._childrenSelected.length;
            while (index--) {
                this._childrenSelected[index].deselect();
            }
        },

        /**
         * getChildren
         * 
         * @access  public
         * @return  Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getCollection
         * 
         * @access  public
         * @return  Collection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * getGroup
         * 
         * @access  public
         * @return  GroupView
         */
        getGroup: function() {
            return this._group;
        },

        /**
         * getNumberOfResults
         * 
         * @access  public
         * @return  Number
         */
        getNumberOfResults: function() {
            return this._collection.all().length;
        },

        /**
         * lazyLoadChildren
         * 
         * @note    <loading> class used below to ensure no duplicate calls made
         *          to lazy load assets incase a collection <update> event fires
         *          twice.
         * @note    <waiting> class is used below in cases where there are
         *          hundreds of assets. In those cases, 50 will be drawn upon
         *          load, but the last X won't be loaded, because they're so far
         *          below the threshold value for preloading. Without the
         *          <waiting> class, an infinite-scroll could trigger an
         *          additional collection:update event, which could result in
         *          multiple lazy events beyond attached to the element. When
         *          that happens, things bust :(
         * @access  public
         * @return  void
         */
        lazyLoadChildren: function() {
            var _this = this,
                $elements = this.find(
                    '.lazy:not(.loading):not(.loaded):not(.waiting)'
                );
            $elements.addClass('waiting');
            $elements.lazyload({
                threshold: 500,
                container: this._element.find('.results').first(),
                effect: 'fadeIn',
                effect_speed: 400,
                appear: function(remaining, settings) {
                    $(this).addClass('loading');
                },
                error: function(remaining, settings, img) {
                    var src = img.src;
                    $elements.filter('[data-original="' + (src) + '"]').addClass('error');
                },
                load: function(remaining, settings, img) {
                    $(this).addClass('loaded');
                    $(this).removeClass('loading');
                    $(this).removeClass('waiting');
                    $(this).removeAttr('data-original');
                    var drawCallback = _this._drawProperties.drawCallback;
                    if (drawCallback !== undefined) {
                        var scope = $(this).data('view');
                        drawCallback.apply(scope);
                    }
                }
            });
        },

        /**
         * reClassifyChildren
         * 
         * @see     https://api.jquery.com/removeclass/#removeClass-function
         * @access  public
         * @return  void
         */
        reClassifyChildren: function() {
            var $elements = this.find('[class*="active-n-"]'),
                toSort = [];
            if ($elements.length > 0) {
                $elements.each(function(index, element) {
                    var $element = $(element),
                        count = $element.attr('class').match(/active-n-([0-9]+)/)[1];
                    toSort.push([
                        $element,
                        count.toInt()
                    ]);
                });
                toSort.sort(function(a, b) {
                    return a[1] - b[1];
                });
                $(toSort).each(function(index, entry) {
                    var $element = $(entry[0]);
                    $element.removeClass(function(index, className) {
                        return className.match(/(active-n-[0-9]+)/).shift();
                    });
                    $element.addClass('active-n-' + (index));
                });
                $(toSort[toSort.length - 1][0]).addClass('active-last');
            }
        },

        /**
         * refreshScrollbar
         * 
         * Refreshes the DOM created scrollbar if the browser doesn't natively
         * support scrollbar styling, if the scrollbar is defined, and a
         * reference to the DOM created scrollbar could be found.
         * 
         * There was a massive edge-case bug whereby if a ResultsView was
         * destroyed (via the destroy event trigger), this method was still
         * being called if the maximum number of seconds for a ResultView was
         * reached.
         * 
         * Specifically, if the user searched for more than 10 terms, the
         * destroy event would get triggered in the ResourcesSearchView
         * instance. However the timer was still going to refresh the results
         * (to ensure that any photo/vector paths were still usable), and the
         * below logic would get triggered, but wasn't checking whether the DOM
         * created scrollbar was still available (it wasn't, because it was
         * removed as can be seen here: https://i.imgur.com/Vz1qGma.png).
         * 
         * So now I'm doing two things to be sure:
         * 1) in the destroy listener defined in this class, I re-set the
         * _$scrollbar to null once this ResultsView is destroyed
         * 2) I check to make sure the _$scrollbar and it's associated DOM
         * created scrollbar, are valid references.
         * 
         * @access  public
         * @return  Boolean
         */
        refreshScrollbar: function() {
            if (UserAgentUtils.supports.css.scrollbars() === true) {
                return false;
            }
            if (this._$scrollbar === null) {
                return false
            }
            if (this._$scrollbar.data('jsp') === undefined) {
                return false
            }
            this._$scrollbar.data('jsp').reinitialise();
            return true;
        },

        /**
         * removeScrollEvent
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        removeScrollEvent: function(callback) {
            var $results = this.find('div.results').first(),
                listener = 'scroll';
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                listener = 'jsp-scroll-y';
            }
            $results.unbind(listener, callback);
        },

        // /**
        //  * removeChild
        //  * 
        //  * @access  public
        //  * @param   Accessor accessor
        //  * @return  void
        //  */
        // removeChild: function(accessor) {
        //     var index;
        //     for (index in this._children) {
        //         if (this._children[index].getAccessor() === accessor) {
        //             this._children[index].remove();
        //             this._children.splice(index, 1);
        //             break;
        //         }
        //     }
        // },

        /**
         * scrollToTop
         * 
         * @access  public
         * @return  void
         */
        scrollToTop: function() {
            var $results = this.find('.results');
            if ($results.scrollTop() !== 0) {
                $results.animate({scrollTop: 0}, 'fast');
            }
        },

        /**
         * selectAll
         * 
         * @access  public
         * @return  void
         */
        selectAll: function() {
            var index = 0,
                length = this._children.length;
            for (index; index < length; ++index) {
                this._children[index].deselect();
            }
            index = length;
            while (index--) {
                this._children[index].select();
                this._children[index].getElement().addClass('active-shift');
            }
            this.reClassifyChildren();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._group.setActiveResults(this);
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._group.show();
            this.triggerHandler('menu/close');
            this.refreshScrollbar();
            this._addLoadedListener();
        },

        /**
         * showHideEmptyState
         * 
         * Shows or hides the appropriate section depending on whether the
         * collection is empty.
         * 
         * @access  public
         * @return  void
         */
        showHideEmptyState: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty').addClass('hidden');
            if (this._collection.all().length === 0) {
                this.find('.results').addClass('hidden');
                this.find('.messaging,.empty').removeClass('hidden');
            }
        },

        /**
         * trackLoad
         * 
         * Tracks that results are being loaded. Centralized here because it's
         * being used in multiple places, and due to a jScrollPane bug (which
         * happens when via this ResultsView.refreshScrollbar method), it needs
         * to occur before any jScrollPane logic gets executed.
         * 
         * @access  public
         * @return  void
         */
        trackLoad: function() {
            this._loaded = true;
            this._loading = true;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * SelectableElementView
     * 
     * @extends View
     */
    window.SelectableElementView = View.extend({

        /**
         * _accessor
         * 
         * @access  protected
         * @var     null|Accessor (default: null)
         */
        _accessor: null,

        /**
         * _results
         * 
         * @access  protected
         * @var     null|ResultsView (default: null)
         */
        _results: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SelectableElementView')
         */
        _string: 'SelectableElementView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._accessor = accessor;
            this._results = results;
            this._super(element);
            this._addContextMenuListener();
        },

        /**
         * _addContextMenuListener
         * 
         * @access  protected
         * @return  void
         */
        _addContextMenuListener: function() {
            var _this = this;
            this._element.on({
                contextmenu: function(event) {
                    event.preventDefault();
                    if ($(this).hasClass('active') === false) {
                        _this.getResults().deselectAll();
                    }
                    _this.select();
                    _this.showContextMenu();
                }
            });
        },

        /**
         * _getRightMostSelectedChild
         * 
         * @access  protected
         * @return  jQuery
         */
        _getRightMostSelectedChild: function() {
            var $element = this._element,
                leftOffset = $element.offset().left,
                topOffset = $element.offset().top,
                results = this._results,
                childrenSelected = results.childrenSelected.all.apply(results),
                index,
                child,
                childLeftOffset,
                childTopOffset;
            for (index in childrenSelected) {
                child = childrenSelected[index];
                childLeftOffset = child.getElement().offset().left;
                childTopOffset = child.getElement().offset().top;
                if (
                    childLeftOffset > leftOffset
                    && childTopOffset === topOffset
                ) {
                    leftOffset = childLeftOffset;
                    $element = child.getElement();
                }
            }
            return $element;
        },

        /**
         * deselect
         * 
         * @see     https://api.jquery.com/removeclass/#removeClass-function
         * @access  public
         * @return  void
         */
        deselect: function() {
            var results = this._results,
                selected = results.childrenSelected.contains.apply(
                    results,
                    [this]
                );
// console.log('a. deselecting');
            if (selected === true) {
// console.log('deselecting');
                results.childrenSelected.remove.apply(results, [this]);
                this._element.removeClass('active-shift');
                this._element.removeClass('active-last');
                this._element.removeClass('active');
                this._element.removeClass(function(index, className) {
                    return className.match(/(active-n-[0-9]+)/).shift();
                });
            }
        },

        /**
         * getAccessor
         * 
         * @access  public
         * @return  Accessor
         */
        getAccessor: function() {
            return this._accessor;
        },

        /**
         * getContextMenu
         * 
         * @access  public
         * @return  ContextMenuView
         */
        getContextMenu: function() {
            return this._results.getGroup().getArea().getContextMenu();
        },

        /**
         * getResults
         * 
         * @access  public
         * @return  ResultsView
         */
        getResults: function() {
            return this._results;
        },

        /**
         * hideContextMenu
         * 
         * @access  public
         * @return  void
         */
        hideContextMenu: function() {
            this.getContextMenu().triggerHandler('close');
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            var results = this._results,
                selected = results.childrenSelected.contains.apply(
                    results,
                    [this]
                );
            if (selected === false) {
                this._element.siblings().removeClass('active-last');
                this._element.addClass('active-last');
                this._element.addClass('active');
                var selected = this._element.siblings('.active');
                this._element.addClass('active-n-' + (selected.length));
                results.childrenSelected.add.apply(results, [this]);
            }
        },

        /**
         * showContextMenu
         * 
         * @access  public
         * @return  void
         */
        showContextMenu: function() {
            var contextMenu = this.getContextMenu(),
                $relative = this._getRightMostSelectedChild();
            contextMenu.setRelative($relative);
            contextMenu.show();
            contextMenu.position();
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  Boolean Whether the thumb was selected or not
         */
        toggle: function() {
            var results = this._results,
                selected = results.childrenSelected.contains.apply(
                    results,
                    [this]
                );
            if (selected === false) {
                this.select();
                return true;
            }
            this.deselect();
            return false;
        }
    });
});
window.DependencyLoader.push('SelectableElementView', function() {

    /**
     * ThumbView
     * 
     * @extends SelectableElementView
     */
    window.ThumbView = SelectableElementView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ThumbView')
         */
        _string: 'ThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._addThumbListeners();
        },

        /**
         * _addImageUploadProgressListeners
         * 
         * @access  protected
         * @return  void
         */
        _addImageUploadProgressListeners: function() {
            var imageAccessor = this._getImageAccessor(),
                uploaded = imageAccessor.get('uploaded').toInt() === 1,
                $element = this._element;
            if (uploaded === false) {
                var $progress = this.find('div[lookup="progress"]');
                $element.attr('disabled', 'disabled');
                $progress.removeClass('hidden');
                $progress.removeClass('complete');
                $progress.addClass('uploading');
                $progress.addClass('pending');
                imageAccessor.on({

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @return  void
                     */
                    'upload/success': function(event, response) {
                        $progress.removeClass('uploading');
                        $progress.addClass('complete');
                        (function() {
                            $element.removeAttr('disabled');
                            $progress.removeClass('complete');
                            $progress.addClass('hidden');
                        }).delay(2500);
                    },

                    /**
                     * (anonymous)
                     * 
                     * @see     https://medium.com/@pppped/how-to-code-a-responsive-circular-percentage-chart-with-svg-and-css-3632f8cd7705
                     * @see     https://codepen.io/sergiopedercini/pen/aWawra
                     * @access  private
                     * @param   Object event
                     * @param   Number loaded
                     * @param   Number total
                     * @return  void
                     */
                    'upload/progress': function(event, loaded, total) {
                        var $copy = $progress.find('div.copy.uploading'),
                            $path = $progress.find('svg path'),
                            percentage = Math.round(
                                (loaded / total) * 100
                            );
                        if (percentage !== 0) {
                            $progress.removeClass('pending')
                        }
                        $copy.text((percentage) + '%');
                        $path.attr('stroke-dasharray', (percentage) + ' 100');
                    }
                });
            }
        },

        /**
         * _addThumbListeners
         * 
         * @access  protected
         * @return  void
         */
        _addThumbListeners: function() {
            var areaType = this._getAreaType();
            this.on({
                'unfavorite': function(event) {
                    this._accessor.unfavorite(areaType, true);
                },
                'unfeature': function(event, category) {
                    ModalUtils.showApplyCategories(areaType, this._accessor);
                },
                'unpin': function(event) {
                    var category = this._results.getCategory();
                    this._accessor.unpin(category);
                }
            });
        },

        /**
         * _drawImageUploadProgress
         * 
         * @access  protected
         * @return  void
         */
        _drawImageUploadProgress: function() {
            var imageAccessor = this._getImageAccessor(),
                uploaded = imageAccessor.get('uploaded').toInt() === 1;
            if (uploaded === false) {
                var $markup = DataUtils.render('ImageUploadProgress');
                this._element.append($markup);
            }
        },

        /**
         * _getAreaType
         * 
         * @access  protected
         * @return  String
         */
        _getAreaType: function() {
            return this._results.getGroup().getArea().getType();
        },

        /**
         * showPreloadingSpinner
         * 
         * @todo    Include logic that the spinner only shows up if it takes at
         *          least 25ms. If that's the case, show the spinner for at least
         *          125ms (to prevent that flicker-experience).
         * @todo    Fix below note, and test by throttling
         * @note    There is a possible bug here for people with slow internet
         *          connections. Specifically, if they click on a thumbnail, and
         *          wait, but it takes too long, they may click on another. When
         *          that happens, they'll notice two different spinners visible.
         *          When the first one that was clicked finally comes back and
         *          triggers the <refresh> event on the background image drawing,
         *          it'll remove the the spinning class, and spinner element,
         *          from both thumbs. A way around this would be to remove the
         *          previous spinner UI (the class and element), if any, whenever
         *          a thumb is clicked. Don't think it's needed at the moment,
         *          though.
         * @note    This method isn't triggered by clicking on a logo, since
         *          logos don't make use of the Joystick view
         * @access  public
         * @param   undefined|Object options
         * @return  void
         */
        showPreloadingSpinner: function(options) {

            /**
             * Draw the spinner inside the thumb, and add the class to the thumb
             * so that it can hide children that shouldn't be shown while the
             * associated image-url is being loaded into the canvas.
             */
            var _this = this,
                canvas = Canvases.Preview,
                areaType = this._getAreaType(),
                $spinner = $('<div class="spinner">' +
                    '<div class="icon fa fa-refresh fa-spin"></div>' +
                    '</div>'
                );
            this._element.append($spinner);
            this._element.addClass('spinning');

            /**
             * If the graphics tab is focused, grab the last layer in the array,
             * and wait for it to be drawn before removing the spinner. This is
             * to detect a successful draw, at which point the spinner is
             * removed.
             * 
             * @todo    Add in support for watermarks
             */
            if (areaType === 'graphics') {
                var layer = canvas.getImage().getImageDocument().getLayers(false).slice(
                    -1
                ).pop();
                layer.getDrawing().once({
                    'draw': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
            /**
             * If the photos tab is focused, grab the photo image layer, and
             * wait for it to be refreshed before removing the spinner. I wait
             * for a refresh rather than a draw here, since the background image
             * layer is always already drawn.
             */
            else if (areaType === 'photos') {
                if (options !== undefined && options.destination === 'foreground') {
                    var layer = canvas.getImage().getImageDocument().getLayers(false).slice(
                        -1
                    ).pop();
                    layer.getDrawing().once({
                        'draw': function(event) {
                            _this._element.removeClass('spinning');
                            $spinner.remove();
                        }
                    });
                } else {
                    canvas.getBackgroundBitmapImageLayer().getDrawing().once({
                        'refresh': function(event) {
                            _this._element.removeClass('spinning');
                            $spinner.remove();
                        }
                    });
                }
            }
            /**
             * Otherwise likely images / templates tab
             */
            else {
                canvas.once({
                    'render': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
        }
    });
});
window.DependencyLoader.push('ThumbView', function() {

    /**
     * GraphicThumbView
     * 
     * @extends ThumbView
     */
    window.GraphicThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicThumbView')
         */
        _string: 'GraphicThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === CategoryUtils.account.favorites('graphics')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _pin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _pin: function(category) {
            this._element.siblings().removeClass('pin');
            this._element.addClass('pin');
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'pin': function(event, category) {
                    _this._pin.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                },
                'unpin': function(event, category) {
                    _this._unpin.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === CategoryUtils.account.favorites('graphics')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * _unpin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unpin: function(category) {
            this._element.removeClass('pin');
            this._results.getChildren()[0].getElement().addClass('pin');
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
});
window.DependencyLoader.push('ThumbView', function() {

    /**
     * ImageThumbView
     * 
     * @extends ThumbView
     */
    window.ImageThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageThumbView')
         */
        _string: 'ImageThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor imageAccessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, imageAccessor, results) {
            this._super(element, imageAccessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
            this._drawImageUploadProgress();
            this._addImageUploadProgressListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === CategoryUtils.account.favorites('images')) {
                this._element.addClass('favorite');
            }
        },

        /**
         * _getImageAccessor
         * 
         * @access  protected
         * @return  ImageAccessor
         */
        _getImageAccessor: function() {
            var imageAccessor = this._accessor;
            return imageAccessor;
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'preload': function(event) {
                    var url = this.url('thumb');
                    _this._element.css({
                        'background-image': 'url(\'' + (url) + '\')'
                    });
                    _this._results._drawProperties.drawCallback.apply(_this);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === CategoryUtils.account.favorites('images')) {
                this._element.removeClass('favorite');
            }
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
});
window.DependencyLoader.push('ThumbView', function() {

    /**
     * PhotoThumbView
     * 
     * @extends ThumbView
     */
    window.PhotoThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoThumbView')
         */
        _string: 'PhotoThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === CategoryUtils.account.favorites('photos')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _pin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _pin: function(category) {
            this._element.siblings().removeClass('pin');
            this._element.addClass('pin');
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'pin': function(event, category) {
                    _this._pin.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                },
                'unpin': function(event, category) {
                    _this._unpin.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === CategoryUtils.account.favorites('photos')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * _unpin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unpin: function(category) {
            this._element.removeClass('pin');
            this._results.getChildren()[0].getElement().addClass('pin');
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
});
window.DependencyLoader.push('ThumbView', function() {

    /**
     * TemplateThumbView
     * 
     * @extends ThumbView
     */
    window.TemplateThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _imageHandlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _imageHandlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateThumbView')
         */
        _string: 'TemplateThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplateAccessor templateAccessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, templateAccessor, results) {
            this._super(element, templateAccessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
            this._drawImageUploadProgress();
            this._addImageUploadProgressListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
            this._accessor.reference('image').on(this._imageHandlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === CategoryUtils.account.favorites('templates')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _getImageAccessor
         * 
         * @access  protected
         * @return  ImageAccessor
         */
        _getImageAccessor: function() {
            var templateAccessor = this._accessor,
                imageAccessor = templateAccessor.reference('image');
            return imageAccessor;
        },

        /**
         * _pin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _pin: function(category) {
            this._element.siblings().removeClass('pin');
            this._element.addClass('pin');
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
            this._accessor.reference('image').off(this._imageHandlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'pin': function(event, category) {
                    _this._pin.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                },
                'unpin': function(event, category) {
                    _this._unpin.apply(_this, [category]);
                }
            };
            this._imageHandlers = {
                'preload': function(event) {
                    var url = this.url('thumb');
                    _this._element.css({
                        'background-image': 'url(\'' + (url) + '\')'
                    });
                    _this._results._drawProperties.drawCallback.apply(_this);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === CategoryUtils.account.favorites('templates')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * _unpin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unpin: function(category) {
            this._element.removeClass('pin');
            this._results.getChildren()[0].getElement().addClass('pin');
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
});
window.DependencyLoader.push('ThumbView', function() {

    /**
     * UploadThumbView
     * 
     * @extends ThumbView
     */
    window.UploadThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadThumbView')
         */
        _string: 'UploadThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadAccessor uploadAccessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, uploadAccessor, results) {
            this._super(element, uploadAccessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === CategoryUtils.account.favorites('uploads')) {
                this._element.addClass('favorite');
            }
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === CategoryUtils.account.favorites('uploads')) {
                this._element.removeClass('favorite');
            }
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
});
window.DependencyLoader.push('SelectableElementView', function() {

    /**
     * WatermarkView
     * 
     * @extends SelectableElementView
     */
    window.WatermarkView = SelectableElementView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * Fired when a watermark is turned on.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="checkbox"]:checked': function(event, $input) {
                        this._accessor.set({
                            'settings.active': 1
                        });
                        this._accessor.save(['settings.active']);
                        this._accessor.addToCanvas(true);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Fired when a watermark is turned off.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="checkbox"]:not(:checked)': function(event, $input) {
                        this._accessor.set({
                            'settings.active': 0
                        });
                        this._accessor.save(['settings.active']);
                        this._accessor.removeFromCanvas();
                    }
                },
                mouseover: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $label
                     * @return  void
                     */
                    'label': function(event, $label) {
                        this._accessor.preloadDrawingImage();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkView')
         */
        _string: 'WatermarkView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarkUploadAccessor watermark
         * @param   WatermarkCategoryResultsView watermarkCategoryResults
         * @return  void
         */
        init: function(element, watermark, watermarkCategoryResults) {
            this._super(element, watermark, watermarkCategoryResults);
            this._addDeleteListener();
            this._addSelectListener();
            this._addSettingsChangeListeners();
        },

        /**
         * _addContextMenuListener
         * 
         * @access  protected
         * @return  void
         */
        _addContextMenuListener: function() {
            this._super();
            this.on({
                'showContextMenu': function(event, $anchor) {
                    this.getResults().deselectAll();
                    this.select();
                    this.showContextMenu();
                }
            });
        },

        /**
         * _addDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addDeleteListener: function() {
            var _this = this;
            this._accessor.on({
                'delete': function(event) {
                    _this._element.remove();
                }
            });
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            var _this = this;
            this._element.on({
                'click': function(event) {
                    _this._select(event);
                }
            });
        },

        /**
         * _addSettingsChangeListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSettingsChangeListeners: function() {
            var _this = this;
            this._accessor.on({
                'change/settings.active': function(event, active) {
                    _this.find('[type="checkbox"]').prop(
                        'checked',
                        active.toInt() === 1
                    );
                },
                'change/settings.cropSourceKey': function(event, cropSourceKey) {
                    if (cropSourceKey !== '') {
                        _this.refresh();
                    }
                }
            });
        },

        /**
         * _select
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Booean
         */
        _select: function(event) {

            // Preparation
            var $element = this.getElement(),
                view = this;

            /**
             * Shift + Click
             * 
             */
            if (event.shiftKey === true) {
                event.preventDefault();

                // 
                var results = view.getResults(),
                    childrenSelected = results.childrenSelected.all.apply(results);
                if (childrenSelected.length === 0) {
                    var $range = $element.prevAll().addBack().reverse();
                    $range.each(function(index, element) {
                        $(element).data('view').select();
                        $(element).addClass('active-shift');
                    });
                    return true;
                }

                // 
                var $lastSelected = $element.parent().find('.active-last'),
                    $shiftSelected = $element.parent().find('.active-shift');
                $shiftSelected.each(function(index, element) {
                    $(element).data('view').deselect();
                });
                if ($element[0] === $lastSelected[0]) {
                    $lastSelected.data('view').select();
                    results.reClassifyChildren();
                    return true;
                }

                // 
                $lastSelected.data('view').deselect();
                var $range = $lastSelected.getRangeElements($element).reverse();
                $range.each(function(index, element) {
                    $(element).data('view').select();
                    $(element).addClass('active-shift');
                });
                results.reClassifyChildren();
                return true;
            }

            /**
             * Command + Click
             * 
             */
            if (
                (UserAgentUtils.is.mac() === true && event.metaKey === true)
                || (UserAgentUtils.is.mac() === false && event.ctrlKey === true)
            ) {
                event.preventDefault();
                var results = view.getResults();
                $element.siblings().removeClass('active-shift');
                view.toggle();
                results.reClassifyChildren();
                return true;
            }

            // 
            return false;
        },

        /**
         * refresh
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        refresh: function(callback) {
            var $label = this.find('label.image'),
                url = this._accessor.getThumbSrc();
// console.log(src);
            ImageUtils.load.url(url, false, function(reference) {
                $label.css({
                    'background-image': 'url(\'' + (url) + '\')'
                });
                // callback();
            });
        }
    });
});
window.DependencyLoader.push('QueryResultsView', function() {

    /**
     * TimedQueryResultsView
     * 
     * Helper class (but never directly instantiated) to provide certain types
     * of query searches (eg. photos and graphics) with the properties and
     * methods they need to properly reload queries once they need to be
     * reloaded.
     * 
     * This only needs to exist because some gateways (at the time of
     * documentation, The Noun Project and Pixabay) have resource links expire
     * after a certain amount of time (eg. one hour, or one day).
     * 
     * @extends QueryResultsView
     */
    window.TimedQueryResultsView = QueryResultsView.extend({

        /**
         * _expires
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _expires: null,

        /**
         * _maxNumberOfReloads
         * 
         * The maximum number of times a query can be reloaded (to prevent a bug
         * whereby requests were coming in thousands-of-times from one machine).
         * I believe this may have been happening due to a machine-clock issue,
         * since the interval below runs every 250ms, and that may have been
         * causing an unreasonable number of requests to get triggered.
         * 
         * @access  protected
         * @var     Number (default: 10)
         */
        _maxNumberOfReloads: 10,

        /**
         * _numberOfTimesReloaded
         * 
         * Tracks the number of times the query has been reloaded (which
         * happens based on the expiry dates of the returned resources).
         * 
         * @access  protected
         * @var     Number (default: 0)
         */
        _numberOfTimesReloaded: 0,

        /**
         * _secondsUntilReload
         * 
         * Currently set to a default value of one hour, but child classes
         * override this value due to the differences in how the gateways work.
         * 
         * @access  protected
         * @var     Number
         */
        _secondsUntilReload: (1 * 60 * 60),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TimedQueryResultsView')
         */
        _string: 'TimedQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicQueriesGroupView|PhotoQueriesGroupView queriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, queriesGroup, query) {
            this._super(element, queriesGroup, query);
            this._expires = Math.floor(Date.now() / 1000) + this._secondsUntilReload;
            this._setupExpireCheckInterval();
        },

        /**
         * _setupExpireCheckInterval
         * 
         * @note    Currently only being used by GraphicQueryResultsView and
         *          PhotoQueryResultsView. QuoteQueryResultsView not using it
         *          since those results don't "time out".
         * @access  protected
         * @return  void
         */
        _setupExpireCheckInterval: function() {
            (function() {
                var now = Math.floor(Date.now() / 1000);
                if (this._expires < now) {
                    this._numberOfTimesReloaded++;
                    if (
                        this._numberOfTimesReloaded > this._maxNumberOfReloads
                    ) {
                        Stencil.alert('search.bug');
                        Stencil.kill();
                    } else {
                        this._typedGatewayStats = false;
                        this._expires = now + this._secondsUntilReload;
                        this._collection.empty();
                        this.trackLoad();
                        this.load();
                    }
                }
            }).interval(250, this);
        }
    });
});
window.DependencyLoader.push('ContextMenuView', function() {

    /**
     * UGCContextMenuView
     * 
     * @extends ContextMenuView
     */
    window.UGCContextMenuView = ContextMenuView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UGCContextMenuView')
         */
        _string: 'UGCContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView|WatermarksAreaView|UploadsAreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
            this._addDownloadMulitpleListener();
            this._addDownloadSingleListener();
        },

        /**
         * _addDownloadMulitpleListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadMulitpleListener: function() {
            this.on({
                'download/multiple': function(event, $anchor) {
                    this.triggerHandler('close');
                    var selected = this._getSelected(),
                        accessor,
                        accessors = [],
                        index,
                        multipleDownloadSettings = this._multipleDownloadSettings;
                    for (index in selected) {
                        accessor = selected[index].getAccessor();
                        accessors.push(accessor);
                    }
                    var msgKey = 'downloads.multiple.pending',
                        msg = Config.getMessage(msgKey);
                    App.getBusy().show(msg);
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                    var onceUploaded = function(callback) {
                        var index,
                            accessor,
                            wait = false;
                        for (index in accessors) {
                            accessor = accessors[index];
                            if (accessor.get('uploaded').toInt() === 0) {
                                wait = true;
                                break;
                            }
                        }
                        if (wait === true) {
                            onceUploaded.delay(150, window, [callback]);
                        } else {
                            callback(accessors);
                        }
                    };
                    onceUploaded(function(accessors) {
                        var path = multipleDownloadSettings.path,
                            cookieKey = multipleDownloadSettings.cookieKey,
                            alertKeys = multipleDownloadSettings.alertKeys,
                            alertKey = alertKeys.multiple,
                            index,
                            keys = [];
                        for (index in accessors) {
                            keys.push(accessors[index].get('key'));
                        }
                        path = path + '?' + jQuery.param({
                            data: {
                                keys: keys
                            }
                        });
                        Stencil.once({
                            'redirect/complete': function(event) {
                                App.getBusy().hide();
                                if (UserAgentUtils.is.electron() === true) {
                                    Stencil.alert(alertKey);
                                }
                            }
                        });
                        DownloadUtils.attemptDownload(path, cookieKey);
                    });
                }
            });
        },

        /**
         * _addDownloadSingleListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadSingleListener: function() {
            this.on({
                'download/single': function(event, $anchor) {
                    var multipleDownloadSettings = this._multipleDownloadSettings,
                        alertKeys = multipleDownloadSettings.alertKeys,
                        alertKey = alertKeys.single;
                    this.triggerHandler('close');
                    this._getAccessor().download(true);
                    Stencil.once({
                        'redirect/complete': function(event) {
                            if (UserAgentUtils.is.electron() === true) {
                                Stencil.alert(alertKey);
                            }
                        }
                    });
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _maxParallelDownloads
         * 
         * @access  protected
         * @return  Number
         */
        _maxParallelDownloads: function() {
            var maxParallelDownloads = Config.get('defaults').maxParallelDownloads.toInt();
            return maxParallelDownloads;
        },

        /**
         * _toggleDownloadTooltips
         * 
         * @access  protected
         * @return  void
         */
        _toggleDownloadTooltips: function() {
            this._destroyTooltips();
            var $download = this.find('[lookup="download/multiple"]');
            $download.enable();
            if (this._multipleSelected() === true) {
                var results = this._area.getActiveGroup().getActiveResults(),
                    maxParallelDownloads = this._maxParallelDownloads();
                if (this._getSelected().length > maxParallelDownloads) {
                    var tooltip = this._tooltips.download.limit;
                    tooltip = tooltip.replace('###', maxParallelDownloads);
                    $download.attr('data-title', tooltip);
                    $download.attr('data-original-title', tooltip);
                    this._setupTooltips();
                    $download.disable();
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleDownloadTooltips();
            this._super();
        }
    });
});
window.DependencyLoader.push('DropzoneView', function() {

    /**
     * WatermarksDropzoneView
     * 
     * @events  complete
     * @extends DropzoneView
     */
    window.WatermarksDropzoneView = DropzoneView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarksDropzoneView')
         */
        _string: 'WatermarksDropzoneView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @return  void
         */
        init: function(element, type) {
            this._super(element, type);
        },

        /**
         * availableForUpload
         * 
         * @access  public
         * @return  Boolean
         */
        availableForUpload: function() {
            if (this._super() === false) {
                return false;
            }
            if (Account.upgraded() === true) {
                return true;
            }
            if (User.admin() === true) {
                return true;
            }
            if (User.editor() === true) {
                return true;
            }
            Stencil.navigate('/app/upgrade/pro/logos?clean=1');
            return false;
        }
    });
});
window.DependencyLoader.push('ResourceContextMenuView', function() {

    /**
     * GraphicContextMenuView
     * 
     * @extends ResourceContextMenuView
     */
    window.GraphicContextMenuView = ResourceContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'graphic')
         */
        _contextMenuType: 'graphic',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicContextMenuView')
         */
        _string: 'GraphicContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            collections: {
                single: 'Please upgrade<br />to add this icon<br />to a collection',
                limit: 'You can only add up to ### icons<br />from a search to a collection at once',
                multiple: 'Please upgrade<br />to add these icons<br />to a collection'
            },
            favorite: {
                single: 'Please upgrade<br />to favorite this icon',
                limit: 'You can only favorite up to ###<br />icons from a search at once',
                multiple: 'Please upgrade<br />to favorite these icons'
            },
            unfavorite: {
                single: 'Please upgrade<br />to unfavorite this icon',
                multiple: 'Please upgrade<br />to unfavorite these icons'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @return  void
         */
        init: function(element, graphicsArea) {
            this._super(element, graphicsArea);
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
            this._setupViewDesignerIcons();
            this._setupViewIconSet();
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    var locked = this._$relative.hasClass('locked');
                    this._getAccessor().select('click', locked, {});
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _setupViewDesignerIcons
         * 
         * @access  protected
         * @return  void
         */
        _setupViewDesignerIcons: function() {
            this.on({
                'viewDesignerIcons': function(event, $anchor) {
                    this.triggerHandler('close');
                    var accessor = this._getAccessor(),
                        path = accessor.getDesignerIconsQueryPath();
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupViewIconSet
         * 
         * @access  protected
         * @return  void
         */
        _setupViewIconSet: function() {
            this.on({
                'viewIconSet': function(event, $anchor) {
                    this.triggerHandler('close');
                    var $anchor = this._$relative.find('a.set'),
                        href = $anchor.attr('href');
                    Stencil.navigate(href);
                }
            });
        },

        /**
         * _toggleDesignerIconsState
         * 
         * @access  protected
         * @return  void
         */
        _toggleDesignerIconsState: function() {
            var $viewDesignerIcons = this.find('[lookup="viewDesignerIcons"]');
            $viewDesignerIcons.addClass('hidden');
            if (this._multipleSelected() === false) {
                if (this._$relative.hasClass('designerIconsAvailable') === true) {
                    $viewDesignerIcons.removeClass('hidden');
                }
            }
        },

        /**
         * _toggleIconSetState
         * 
         * @access  protected
         * @return  void
         */
        _toggleIconSetState: function() {
            var $viewIconSet = this.find('[lookup="viewIconSet"]');
            $viewIconSet.addClass('hidden');
            if (this._multipleSelected() === false) {
                if (this._$relative.hasClass('partOfIconSet') === true) {
                    $viewIconSet.removeClass('hidden');
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleIconSetState();
            this._toggleDesignerIconsState();
            this._toggleCollectionTooltips();
            this._super();
        }
    });
});
window.DependencyLoader.push('UGCContextMenuView', function() {

    /**
     * ImageContextMenuView
     * 
     * @extends UGCContextMenuView
     */
    window.ImageContextMenuView = UGCContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'image')
         */
        _contextMenuType: 'image',

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### images?',
                one: 'Are you sure you want to delete this image?'
            }
        },

        /**
         * _multipleDownloadSettings
         * 
         * @access  protected
         * @var     Object
         */
        _multipleDownloadSettings: {
            alertKeys: {
                multiple: 'clients.electron.images.download.multiple.complete',
                single: 'clients.electron.images.download.single.complete'
            },
            cookieKey: 'images.downloads.multiple.started',
            path: '/images/download'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageContextMenuView')
         */
        _string: 'ImageContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            download: {
                limit: 'You can only download up to ### images at once'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView imagesArea
         * @return  void
         */
        init: function(element, imagesArea) {
            this._super(element, imagesArea);
            this._setupConfirmDeleteEvent();
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupShareEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _addDownloadSingleListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadSingleListener: function() {
            this.on({
                'download/single': function(event, $anchor) {
                    var multipleDownloadSettings = this._multipleDownloadSettings,
                        alertKeys = multipleDownloadSettings.alertKeys,
                        alertKey = alertKeys.single;
                    this.triggerHandler('close');
                    var contentType = this._getAccessor().get('contentType');
                    this._getAccessor().download(contentType, false, false, false, false, true);
                    Stencil.once({
                        'redirect/complete': function(event) {
                            if (UserAgentUtils.is.electron() === true) {
                                Stencil.alert(alertKey);
                            }
                        }
                    });
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _getCropKey
         * 
         * @access  protected
         * @return  String
         */
        _getCropKey: function() {
            var accessor = this._getAccessor(),
                key = accessor.get('key');
            return key;
        },

        /**
         * _preloadShareImage
         * 
         * @access  protected
         * @return  void
         */
        _preloadShareImage: function() {
            var image = this._getAccessor(),
                url = image.getSrc();
            ImageUtils.load.url(url);
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {});
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _setupShareEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupShareEvent: function() {
            this.on({
                'share': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().share();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _showCropperModal
         * 
         * @access  protected
         * @return  void
         */
        _showCropperModal: function() {
            var image = this._getAccessor();
            if (image.get('uploaded').toInt() === 1) {
                this._super();
            } else {
                var msg = Config.getMessage('app.crop.image.saving');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function(event) {
                        App.getBusy().hide();
                    }
                });
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._multipleSelected() === false) {
                App.preloadShareModalStaticAssets();
                this._preloadShareImage();
            }
        }
    });
});
window.DependencyLoader.push('ResourceContextMenuView', function() {

    /**
     * PhotoContextMenuView
     * 
     * @extends ResourceContextMenuView
     */
    window.PhotoContextMenuView = ResourceContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'photo')
         */
        _contextMenuType: 'photo',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoContextMenuView')
         */
        _string: 'PhotoContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            collections: {
                single: 'Please upgrade<br />to add this photo<br />to a collection',
                limit: 'You can only add up to ### photos<br />from a search to a collection at once',
                multiple: 'Please upgrade<br />to add these photos<br />to a collection'
            },
            favorite: {
                single: 'Please upgrade<br />to favorite this photo',
                limit: 'You can only favorite up to ###<br />photos from a search at once',
                multiple: 'Please upgrade<br />to favorite these photos'
            },
            unfavorite: {
                single: 'Please upgrade<br />to unfavorite this photo',
                multiple: 'Please upgrade<br />to unfavorite these photos'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @return  void
         */
        init: function(element, photosArea) {
            this._super(element, photosArea);
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _getCropKey
         * 
         * @access  protected
         * @return  String
         */
        _getCropKey: function() {
            if (this._accessorIsResource() === true) {
                var resource = this._getAccessor(),
                    asset = resource.getAsset(),
                    key = asset.get('key');
                return key;
            }
            var asset = this._getAccessor(),
                key = asset.get('key');
            return key;
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    var locked = this._$relative.hasClass('locked'),
                        options = {
                            autoSelect: true,
                            destination: $anchor.attr('destination')
                        };
                    this._getAccessor().select('click', locked, options);
                    this._getView().showPreloadingSpinner(options);
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _showCropperModal
         * 
         * @access  protected
         * @return  void
         */
        _showCropperModal: function() {
            if (this._accessorIsResource() === false) {
                this._super();
            } else {
                var _this = this,
                    superMethod = this._super,
                    accessor = this._getAccessor(),
                    msg = Config.getMessage('app.crop.resource.saving');
                App.getBusy().show(msg);
                accessor.once({
                    'save': function(event) {
                        App.getBusy().hide();
                        superMethod.apply(_this);
                    }
                });
                accessor.save();
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleCollectionTooltips();
            this._super();
        }
    });
});
window.DependencyLoader.push('ResourceContextMenuView', function() {

    /**
     * QuoteContextMenuView
     * 
     * @extends ResourceContextMenuView
     */
    window.QuoteContextMenuView = ResourceContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'quote')
         */
        _contextMenuType: 'quote',

        /**
         * _delays
         * 
         * Overwriting parent delays for multiple to ensure partners don't get
         * spammed by requests that are too close together.
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            multiple: {
                delete: 650,
                favorite: {
                    category: 650,
                    results: 650
                },
                trailing: 750,
                unfavorite: 650
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteContextMenuView')
         */
        _string: 'QuoteContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @return  void
         */
        init: function(element, quotesArea) {
            this._super(element, quotesArea);
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {});
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _toggleFavoriteState
         * 
         * @note    This is the same method as ContextMenuView because the logic
         *          in ResourceContextMenuView isn't appliacable to
         *          QuoteContextMenuView's
         * @access  protected
         * @return  void
         */
        _toggleFavoriteState: function() {
            var $favorite = this.find('[lookup="favorite"]'),
                $unfavorite = this.find('[lookup="unfavorite"]');
            $favorite.addClass('hidden');
            $unfavorite.addClass('hidden');
            if (this._selectedHaveBeenFavorited() === false) {
                $favorite.removeClass('hidden');
            } else {
                $unfavorite.removeClass('hidden');
            }
        }
    });
});
window.DependencyLoader.push('ContextMenuView', function() {

    /**
     * TemplateContextMenuView
     * 
     * @extends ContextMenuView
     */
    window.TemplateContextMenuView = ContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'template')
         */
        _contextMenuType: 'template',

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### templates?',
                one: 'Are you sure you want to delete this template?'
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateContextMenuView')
         */
        _string: 'TemplateContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplatesAreaView templatesArea
         * @return  void
         */
        init: function(element, templatesArea) {
            this._super(element, templatesArea);
            this._setupConfirmDeleteEvent();
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _selectedAreOwned
         * 
         * @access  protected
         * @return  Boolean
         */
        _selectedAreOwned: function() {
            var selected = this._getSelected(),
                index = 0;
            for (index; index < selected.length; ++index) {
                if (selected[index].getAccessor().owned() === false) {
                    return false;
                }
            }
            return true;
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {});
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _toggleDeleteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleDeleteState: function() {
            var $delete = this.find('[lookup="delete"]'),
                $divider = $delete.prev();
            $delete.addClass('hidden');
            $divider.addClass('hidden');
            if (this._selectedAreOwned() === true) {
                $delete.removeClass('hidden');
                $divider.removeClass('hidden');
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleDeleteState();
            this._super();
        }
    });
});
window.DependencyLoader.push('UGCContextMenuView', function() {

    /**
     * UploadContextMenuView
     * 
     * @extends UGCContextMenuView
     */
    window.UploadContextMenuView = UGCContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'upload')
         */
        _contextMenuType: 'upload',

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### uploads?',
                one: 'Are you sure you want to delete this upload?'
            }
        },

        /**
         * _multipleDownloadSettings
         * 
         * @access  protected
         * @var     Object
         */
        _multipleDownloadSettings: {
            alertKeys: {
                multiple: 'clients.electron.uploads.download.multiple.complete',
                single: 'clients.electron.uploads.download.single.complete'
            },
            cookieKey: 'uploads.downloads.multiple.started',
            path: '/uploads/download'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadContextMenuView')
         */
        _string: 'UploadContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            download: {
                limit: 'You can only download up to ### uploads at once'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadsAreaView uploadsArea
         * @return  void
         */
        init: function(element, uploadsArea) {
            this._super(element, uploadsArea);
            this._addSelectListener();
            this._setupConfirmDeleteEvent();
            this._setupFavoriteEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {
                        autoSelect: true,
                        destination: $anchor.attr('destination')
                    });
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _getCropKey
         * 
         * @access  protected
         * @return  String
         */
        _getCropKey: function() {
            var accessor = this._getAccessor();
            if (accessor.setting('crop').toInt() === 0) {
                var key = accessor.get('key');
                return key;
            }
            var key = accessor.setting('cropSourceKey');
            return key;
        },

        /**
         * _showHideCrop
         * 
         * @access  protected
         * @return  void
         */
        _showHideCrop: function() {
            var $crop = this.find('[lookup="crop"]');
            $crop.removeClass('hidden');
            if (this._multipleSelected() === false) {
                var selected = this._getAccessor();
                if (selected.get('vector').toInt() === 1) {
                    $crop.addClass('hidden');
                }
            }
        },

        /**
         * _showHideReCrop
         * 
         * @access  protected
         * @return  Boolean
         */
        _showHideReCrop: function() {
            var $crop = this.find('[lookup="crop"]'),
                $reCrop = this.find('[lookup="re-crop"]');
            $reCrop.addClass('hidden');
            if (this._multipleSelected() === true) {
                return false;
            }
            var selected = this._getAccessor();
            if (selected.setting('crop').toInt() === 1) {
                $reCrop.removeClass('hidden');
                $crop.addClass('hidden');
                return true;
            }
            return false;
        },

        /**
         * _showHideSetAsBackground
         * 
         * @access  protected
         * @return  void
         */
        _showHideSetAsBackground: function() {
            var $setAsBackground = this.find('[lookup="setAsBackground"]');
            $setAsBackground.removeClass('hidden');
            if (this._multipleSelected() === false) {
                var selected = this._getAccessor();
                if (selected.get('vector').toInt() === 1) {
                    $setAsBackground.addClass('hidden');
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._showHideCrop();
            this._showHideReCrop();
            this._showHideSetAsBackground();
            this._super();
        }
    });
});
window.DependencyLoader.push('UGCContextMenuView', function() {

    /**
     * WatermarkContextMenuView
     * 
     * @extends UGCContextMenuView
     */
    window.WatermarkContextMenuView = UGCContextMenuView.extend({

        /**
         * _contextMenuType
         * 
         * @access  protected
         * @var     String (default: 'watermark')
         */
        _contextMenuType: 'watermark',

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### logos / ' +
                    'watermarks?',
                one: 'Are you sure you want to delete this logo / watermark?'
            }
        },

        /**
         * _multipleDownloadSettings
         * 
         * @access  protected
         * @var     Object
         */
        _multipleDownloadSettings: {
            alertKeys: {
                multiple: 'clients.electron.watermarks.download.multiple.complete',
                single: 'clients.electron.watermarks.download.single.complete'
            },
            cookieKey: 'uploads.downloads.multiple.started',
            path: '/uploads/download'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkContextMenuView')
         */
        _string: 'WatermarkContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            download: {
                limit: 'You can only download up to ### logos / watermarks ' +
                    'at once'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarksAreaView watermarksArea
         * @return  void
         */
        init: function(element, watermarksArea) {
            this._super(element, watermarksArea);
            this._setupConfirmDeleteEvent();
            this._setupToggleEvents();
        },

        /**
         * _getCropKey
         * 
         * @access  protected
         * @return  String
         */
        _getCropKey: function() {
            var accessor = this._getAccessor();
            if (accessor.setting('crop').toInt() === 0) {
                var key = accessor.get('key');
                return key;
            }
            var key = accessor.setting('cropSourceKey');
            return key;
        },

        /**
         * _setupToggleEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupToggleEvents: function() {
            this.on({
                'toggle/on toggle/off': function(event, $anchor) {
                    var $checkbox = this._$relative.find('input[type="checkbox"]');
                    $checkbox.prop('checked', !$checkbox.prop('checked'));
                    $checkbox.trigger('change');
                    this._toggleActiveState();
                },
                'toggle/on': function(event, $anchor) {
                    this.triggerHandler('close');
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _showHideCrop
         * 
         * @access  protected
         * @return  void
         */
        _showHideCrop: function() {
            var $crop = this.find('[lookup="crop"]');
            $crop.removeClass('hidden');
            if (this._multipleSelected() === false) {
                var selected = this._getAccessor();
                if (selected.get('vector').toInt() === 1) {
                    $crop.addClass('hidden');
                }
            }
        },

        /**
         * _showHideReCrop
         * 
         * @access  protected
         * @return  Boolean
         */
        _showHideReCrop: function() {
            var $crop = this.find('[lookup="crop"]'),
                $reCrop = this.find('[lookup="re-crop"]');
            $reCrop.addClass('hidden');
            if (this._multipleSelected() === true) {
                return false;
            }
            var selected = this._getAccessor();
            if (selected.setting('crop').toInt() === 1) {
                $reCrop.removeClass('hidden');
                $crop.addClass('hidden');
                return true;
            }
            return false;
        },

        /**
         * _toggleActiveState
         * 
         * @access  protected
         * @return  void
         */
        _toggleActiveState: function() {
            var accessor = this._getAccessor();
            this.find('[lookup="toggle/on"]').addClass('hidden');
            this.find('[lookup="toggle/off"]').addClass('hidden');
            if (accessor.setting('active').toInt() === 1) {
                this.find('[lookup="toggle/off"]').removeClass('hidden');
            } else {
                this.find('[lookup="toggle/on"]').removeClass('hidden');
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            if (this._multipleSelected() === false) {
                this._toggleActiveState();
            }
            this._showHideCrop();
            this._showHideReCrop();
            this._super();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * EditorView
     * 
     * @extends View
     */
    window.EditorView = View.extend({

        /**
         * _activeArea
         * 
         * @access  protected
         * @var     undefined|AreaView (default: undefined)
         */
        _activeArea: undefined,

        /**
         * _areas
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _areas: {},

        /**
         * _joystick
         * 
         * @access  protected
         * @var     null|JoystickView (default: null)
         */
        _joystick: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $target
                     * @return  void
                     */
                    'div.thumb, div.quote.row': function(event, $target) {
                        this.showParticle($target);
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $target
                     * @return  void
                     */
                    'div.thumb, div.quote.row': function(event, $target) {
                        this.hideParticle($target);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'EditorView')
         */
        _string: 'EditorView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawGraphics();
            this._drawImages();
            this._drawJoystick();
            this._drawPhotos();
            this._drawQuotes();
            this._drawTemplates();
            this._drawUploads();
            this._drawWatermarks();
        },

        /**
         * _drawGraphics
         * 
         * @access  protected
         * @return  void
         */
        _drawGraphics: function() {
            var $graphics = DataUtils.render('GraphicsArea');
            this.find('> div.inner > div.wrapper').append($graphics);
            this._areas.graphics = new GraphicsAreaView($graphics);
        },

        /**
         * _drawImages
         * 
         * @access  protected
         * @return  void
         */
        _drawImages: function() {
            var $images = DataUtils.render('ImagesArea');
            this.find('> div.inner > div.wrapper').append($images);
            this._areas.images = new ImagesAreaView($images);
        },

        /**
         * _drawJoystick
         * 
         * @access  protected
         * @return  void
         */
        _drawJoystick: function() {
            var $joystick = DataUtils.render('Joystick');
            this.find('> div.inner > div.wrapper').append($joystick);
            this._joystick = new JoystickView($joystick);
        },

        /**
         * _drawPhotos
         * 
         * @access  protected
         * @return  void
         */
        _drawPhotos: function() {
            var $photos = DataUtils.render('PhotosArea');
            this.find('> div.inner > div.wrapper').append($photos);
            this._areas.photos = new PhotosAreaView($photos);
        },

        /**
         * _drawQuotes
         * 
         * @access  protected
         * @return  void
         */
        _drawQuotes: function() {
            var $quotes = DataUtils.render('QuotesArea');
            this.find('> div.inner > div.wrapper').append($quotes);
            this._areas.quotes = new QuotesAreaView($quotes);
        },

        /**
         * _drawTemplates
         * 
         * @access  protected
         * @return  void
         */
        _drawTemplates: function() {
            var $templates = DataUtils.render('TemplatesArea');
            this.find('> div.inner > div.wrapper').append($templates);
            this._areas.templates = new TemplatesAreaView($templates);
        },

        /**
         * _drawUploads
         * 
         * @access  protected
         * @return  void
         */
        _drawUploads: function() {
            var $uploads = DataUtils.render('UploadsArea', {
                accept: Config.default('validImageUploadContentTypes')
            });
            this.find('> div.inner > div.wrapper').append($uploads);
            this._areas.uploads = new UploadsAreaView($uploads);
        },

        /**
         * _drawWatermarks
         * 
         * @access  protected
         * @return  void
         */
        _drawWatermarks: function() {
            var $watermarks = DataUtils.render('WatermarksArea', {
                accept: Config.default('validImageUploadContentTypes')
            });
            this.find('> div.inner > div.wrapper').append($watermarks);
            this._areas.watermarks = new WatermarksAreaView($watermarks);
        },

        /**
         * getActiveArea
         * 
         * @note    It's possible that this method is called before an active
         *          area has been set. For example, if the user lands here
         *          somewhow, no area will have been set as active:
         *          https://i.imgur.com/0p6z2xu.png
         * @access  public
         * @return  AreaView|undefined
         */
        getActiveArea: function() {
            return this._activeArea;
        },

        /**
         * getArea
         * 
         * @access  public
         * @param   String type
         * @return  AreaView
         */
        getArea: function(type) {
            return this._areas[type];
        },

        /**
         * getAreas
         * 
         * @access  public
         * @return  Object
         */
        getAreas: function() {
            return this._areas;
        },

        /**
         * getJoystick
         * 
         * @access  public
         * @return  JoystickView
         */
        getJoystick: function() {
            return this._joystick;
        },

        /**
         * hideParticle
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        hideParticle: function($element) {
            $element.removeClass('hover');
        },

        /**
         * setActiveArea
         * 
         * @access  protected
         * @param   AreaView area
         * @return  void
         */
        setActiveArea: function(area) {
            this._activeArea = area;
        },

        /**
         * showParticle
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        showParticle: function($element) {
            $element.siblings().removeClass('hover');
            $element.addClass('hover');
            $element.append(this._joystick.getElement());
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * GraphicCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.GraphicCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'GraphicCategoryResults',
            view: 'GraphicCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicCategoriesGroupView')
         */
        _string: 'GraphicCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @return  void
         */
        init: function(element, graphicsArea) {
            this._super(element, graphicsArea);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/icons/search/shape
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._activeResults === null) {
                return CategoryUtils.global.featured('graphics').getPath();
            }
            return this._super();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.removeClass('queried');
        }
    });
});
window.DependencyLoader.push('QueriesGroupView', function() {

    /**
     * GraphicQueriesGroupView
     * 
     * @extends QueriesGroupView
     */
    window.GraphicQueriesGroupView = QueriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            fallback: function() {
                var searchTerms = ['Fruit', 'People', 'Share', 'Arrow'],
                    searchTerm = ArrayUtils.random(searchTerms);
                return {
                    copy: searchTerm,
                    link: '/app/icons/search/' + searchTerm.toLowerCase()
                };
            },
            template: 'GraphicQueryResults',
            view: 'GraphicQueryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicQueriesGroupView')
         */
        _string: 'GraphicQueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @return  void
         */
        init: function(element, graphicsArea) {
            this._super(element, graphicsArea);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.addClass('queried');
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * ImageCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.ImageCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'ImageCategoryResults',
            view: 'ImageCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageCategoriesGroupView')
         */
        _string: 'ImageCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView imagesArea
         * @return  void
         */
        init: function(element, imagesArea) {
            this._super(element, imagesArea);
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * PhotoCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.PhotoCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'PhotoCategoryResults',
            view: 'PhotoCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoCategoriesGroupView')
         */
        _string: 'PhotoCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @return  void
         */
        init: function(element, photosArea) {
            this._super(element, photosArea);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/photos/search/people
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._activeResults === null) {
                return CategoryUtils.global.featured('photos').getPath();
            }
            return this._super();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.removeClass('queried');
        }
    });
});
window.DependencyLoader.push('QueriesGroupView', function() {

    /**
     * PhotoQueriesGroupView
     * 
     * @extends QueriesGroupView
     */
    window.PhotoQueriesGroupView = QueriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            fallback: function() {
                var searchTerms = ['Skiing', 'Nature', 'Beach', 'Puppies'],
                    searchTerm = ArrayUtils.random(searchTerms);
                return {
                    copy: searchTerm,
                    link: '/app/photos/search/' + searchTerm.toLowerCase()
                };
            },
            template: 'PhotoQueryResults',
            view: 'PhotoQueryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoQueriesGroupView')
         */
        _string: 'PhotoQueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @return  void
         */
        init: function(element, photosArea) {
            this._super(element, photosArea);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.addClass('queried');
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * QuoteCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.QuoteCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'QuoteCategoryResults',
            view: 'QuoteCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteCategoriesGroupView')
         */
        _string: 'QuoteCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @return  void
         */
        init: function(element, quotesArea) {
            this._super(element, quotesArea);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/quotes/search/people
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._activeResults === null) {
                return CategoryUtils.global.featured('quotes').getPath();
            }
            return this._super();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.removeClass('queried');
        }
    });
});
window.DependencyLoader.push('QueriesGroupView', function() {

    /**
     * QuoteQueriesGroupView
     * 
     * @extends QueriesGroupView
     */
    window.QuoteQueriesGroupView = QueriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            fallback: function() {
                var searchTerms = ['Love', 'Success', 'Freedom', 'Friendship'],
                    searchTerm = ArrayUtils.random(searchTerms);
                return {
                    copy: searchTerm,
                    link: '/app/quotes/search/' + searchTerm.toLowerCase()
                };
            },
            template: 'QuoteQueryResults',
            view: 'QuoteQueryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteQueriesGroupView')
         */
        _string: 'QuoteQueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @return  void
         */
        init: function(element, quotesArea) {
            this._super(element, quotesArea);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.addClass('queried');
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * TemplateCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.TemplateCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'TemplateCategoryResults',
            view: 'TemplateCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateCategoriesGroupView')
         */
        _string: 'TemplateCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplatesAreaView templatesArea
         * @return  void
         */
        init: function(element, templatesArea) {
            this._super(element, templatesArea);
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * UploadCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.UploadCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'UploadCategoryResults',
            view: 'UploadCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadCategoriesGroupView')
         */
        _string: 'UploadCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadsAreaView uploadsArea
         * @return  void
         */
        init: function(element, uploadsArea) {
            this._super(element, uploadsArea);
        }
    });
});
window.DependencyLoader.push('CategoriesGroupView', function() {

    /**
     * WatermarkCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.WatermarkCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'WatermarkCategoryResults',
            view: 'WatermarkCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkCategoriesGroupView')
         */
        _string: 'WatermarkCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarksAreaView watermarksArea
         * @return  void
         */
        init: function(element, watermarksArea) {
            this._super(element, watermarksArea);
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * GraphicAreaNavView
     * 
     * @extends AreaNavView
     */
    window.GraphicAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicAreaNavView')
         */
        _string: 'GraphicAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, graphicsArea, categories) {
            this._super(element, graphicsArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.favorites('graphics')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.global.featured('graphics')
            );
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * ImageAreaNavView
     * 
     * @extends AreaNavView
     */
    window.ImageAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageAreaNavView')
         */
        _string: 'ImageAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView imagesArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, imagesArea, categories) {
            this._super(element, imagesArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.favorites('images')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.account.list('images')
            );
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * PhotoAreaNavView
     * 
     * @extends AreaNavView
     */
    window.PhotoAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoAreaNavView')
         */
        _string: 'PhotoAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, photosArea, categories) {
            this._super(element, photosArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.favorites('photos')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.global.featured('photos')
            );
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * QuoteAreaNavView
     * 
     * @extends AreaNavView
     */
    window.QuoteAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteAreaNavView')
         */
        _string: 'QuoteAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, quotesArea, categories) {
            this._super(element, quotesArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.favorites('quotes')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.global.featured('quotes')
            );
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * TemplateAreaNavView
     * 
     * @extends AreaNavView
     */
    window.TemplateAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateAreaNavView')
         */
        _string: 'TemplateAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplatesAreaView templatesArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, templatesArea, categories) {
            this._super(element, templatesArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.favorites('templates')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.global.featured('templates')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.account.list('templates')
            );
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * UploadAreaNavView
     * 
     * @extends AreaNavView
     */
    window.UploadAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadAreaNavView')
         */
        _string: 'UploadAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadsAreaView uploadsArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, uploadsArea, categories) {
            this._super(element, uploadsArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.favorites('uploads')
            );
            this.addCategoryCountChangeListener(
                CategoryUtils.account.list('uploads')
            );
        }
    });
});
window.DependencyLoader.push('AreaNavView', function() {

    /**
     * WatermarkAreaNavView
     * 
     * @extends AreaNavView
     */
    window.WatermarkAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkAreaNavView')
         */
        _string: 'WatermarkAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarksAreaView watermarksArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, watermarksArea, categories) {
            this._super(element, watermarksArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                CategoryUtils.account.list('watermarks')
            );
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * GraphicCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.GraphicCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'GraphicThumb',
            view: 'GraphicThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicCategoryResultsView')
         */
        _string: 'GraphicCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   GraphicCategoriesGroupView graphicCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, graphicCategoriesGroup, category) {
            this._collection = new GraphicFeaturesCollection();
            this._super(element, graphicCategoriesGroup, category);
            this._setupCollection();
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.toString() === 'GraphicResourceAccessor') {
                        if (accessor.saved() === true) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        if (accessor.get('uploaded').toInt() === 1) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    }
                    _this._drawChild(accessor, position);
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').graphics.categories;
            this._load(numberOfResults, limit);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search');
            $search.blur();
            if (this._category.get('featured').toInt() === 1) {
                if (
                    UserAgentUtils.is.tablet() === false
                    && UserAgentUtils.is.ie() === false
                ) {
                    $search.focus();
                }
            }
        }
    });
});
window.DependencyLoader.push('TimedQueryResultsView', function() {

    /**
     * GraphicQueryResultsView
     * 
     * @noto    In the past, I've noticed TNP sometimes caching search requests.
     *          For example, I (Oliver) do a search for "love" at 7:30pm EST and
     *          get a collection of icons that are set to expire at 8:30pm EST.
     *          Then Adam does a search at 8:20pm EST, and because the search
     *          may come back as a part of a cached result set, his icons are
     *          set to expire 10 minutes later.
     *          
     *          As of 18 July 2017, this is still the case. 
     *          
     *          To deal with this, when this QueryResultsView is instantiated, I
     *          set the _expires property to the appropriate timestamp taking
     *          into consideration the _secondsUntilReload value.
     *          
     *          However, after that, each time I add a resource to the
     *          collection, I set the _expires variable to the lowest possible
     *          expiry timestamp, to ensure that at the earliest required point
     *          in time, the result set is reloaded.
     *          
     *          Here's a sample SVG link:
     *          https://d30y9cdsu7xlg0.cloudfront.net/noun-svg/215288.svg?Expires=1452645199&Signature=cGU10SmwvHMJc4drNz-eavJO2RQwqXPuursIR74nzdtTAo~LHmdsBgbq49dJfQbWzfn-0ee93gqvK8ZT9L7uwiL38jkDEEmuWIOGOFUIlu95EyhY1l-BnXcCB0TTKVFUGd8jfF9kYDo6iC27PoANo43-RuVWtIOoBtjwvYu9R3E_&Key-Pair-Id=APKAI5ZVHAXN65CHVU2Q
     * @extends TimedQueryResultsView
     */
    window.GraphicQueryResultsView = TimedQueryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'GraphicThumb',
            view: 'GraphicThumbView'
        },

        /**
         * _secondsUntilReload
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, The Noun
         * Project expires links after 1 hour, though their documentation states
         * 24 hours :/
         * 
         * There is the possible case whereby a user searches for something that
         * only results in non-expiring results (eg. EmojiOne emojis). In that
         * case, it seems the reload will happen regardless after one hour. Not
         * ideal, but oh well.
         * 
         * @see     http://api.thenounproject.com/documentation.html
         * @see     https://i.imgur.com/mOrzOwT.png
         * @access  protected
         * @var     Number
         */
        _secondsUntilReload: (1 * 60 * 60) - 60,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicQueryResultsView')
         */
        _string: 'GraphicQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicQueriesGroupView graphicQueriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, graphicQueriesGroup, query) {
            this._collection = new GraphicResourcesCollection();
            this._super(element, graphicQueriesGroup, query);
            this._setupCollection();
        },

        /**
         * _getQueryResultsType
         * 
         * @access  protected
         * @return  String
         */
        _getQueryResultsType: function() {
            return 'graphics';
        },

        /**
         * _getSearchGateways
         * 
         * @access  protected
         * @return  Array
         */
        _getSearchGateways: function() {
            var searchGateways = Config.default('graphicSearchGateways');
            return searchGateways;
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    var svg = accessor.get('urls').svg,
                        expires;
                    if (svg.match(/Expires\=([0-9]+)/) !== null) {
                        expires = svg.match(/Expires\=([0-9]+)/).pop().toInt();
                        _this._expires = Math.min(_this._expires, expires);
                    }
                    _this._drawChild(accessor, position);
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var path = '/app/icons/search/' + encodeURIComponent(this._query);
            return path;
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * ImageCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.ImageCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            drawCallback: function() {
                var $element = this.getElement();
                if ($element.hasClass('loaded') === true) {
                    $element.addClass('backgroundTransparentFallback');
                    var currentBackgroundImageValue = $element.css('background-image'),
                        path = '/app/static/images/backgrounds/checkered.png',
                        url = RequestUtils.url.static(path),
                        transparentBackgroundImageValue = 'url(\'' + (url) + '\')';
                    // transparentBackgroundImageValue = transparentBackgroundImageValue.replace(/^([^,]*)(,)([^,]*)(,)(.*)$/, '$1$2$3');
                    $element.css({
                        backgroundImage: (currentBackgroundImageValue) + ', ' +
                            transparentBackgroundImageValue
                    });
                }
            },
            template: 'ImageThumb',
            view: 'ImageThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageCategoryResultsView')
         */
        _string: 'ImageCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   ImageCategoriesGroupView imageCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, imageCategoriesGroup, category) {
            this._collection = new ImageFeaturesCollection();
            this._super(element, imageCategoriesGroup, category);
            this._setupCollection();
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, imageAccessor, position) {
                    if (imageAccessor.get('uploaded').toInt() === 1) {
                        category.syncedFeatures.add.apply(category, [imageAccessor]);
                    }
                    var child = _this._drawChild(imageAccessor, position);
                    _this._drawProperties.drawCallback.apply(child);
                },
                'remove': function(event, imageAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === imageAccessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [imageAccessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').images.categories;

            // Start at the beginning if first accessor is being uploaded atm
            if (numberOfResults === 1) {
                var first = this._collection.first();
                if (first.get('uploaded').toInt() === 0) {
                    numberOfResults = 0;
                }
            }
            this._load(numberOfResults, limit);
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * PhotoCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.PhotoCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'PhotoThumb',
            view: 'PhotoThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoCategoryResultsView')
         */
        _string: 'PhotoCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   PhotoCategoriesGroupView photoCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, photoCategoriesGroup, category) {
            this._collection = new PhotoFeaturesCollection();
            this._super(element, photoCategoriesGroup, category);
            this._setupCollection();
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.toString() === 'PhotoResourceAccessor') {
                        if (accessor.saved() === true) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        if (accessor.get('uploaded').toInt() === 1) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    }
                    _this._drawChild(accessor, position);
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').photos.categories;
            this._load(numberOfResults, limit);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search');
            $search.blur();
            if (this._category.get('featured').toInt() === 1) {
                if (
                    UserAgentUtils.is.tablet() === false
                    && UserAgentUtils.is.ie() === false
                ) {
                    $search.focus();
                }
            }
        }
    });
});
window.DependencyLoader.push('TimedQueryResultsView', function() {

    /**
     * PhotoQueryResultsView
     * 
     * @extends TimedQueryResultsView
     */
    window.PhotoQueryResultsView = TimedQueryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'PhotoThumb',
            view: 'PhotoThumbView'
        },

        /**
         * _secondsUntilReload
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, Pixabay links
         * expire after 24 hours.
         * 
         * @see     https://pixabay.com/api/docs/
         * @see     https://i.imgur.com/484aa4c.png
         * @access  protected
         * @var     Number
         */
        _secondsUntilReload: (24 * 60 * 60) - 60,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoQueryResultsView')
         */
        _string: 'PhotoQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotoQueriesGroupView photoQueriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, photoQueriesGroup, query) {
            this._collection = new PhotoResourcesCollection();
            this._super(element, photoQueriesGroup, query);
            this._setupCollection();
        },

        /**
         * _getQueryResultsType
         * 
         * @access  protected
         * @return  String
         */
        _getQueryResultsType: function() {
            return 'photos';
        },

        /**
         * _getSearchGateways
         * 
         * @access  protected
         * @return  Array
         */
        _getSearchGateways: function() {
            var searchGateways = Config.default('photoSearchGateways');
            return searchGateways;
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._drawChild(accessor, position);
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var path = '/app/photos/search/' + encodeURIComponent(this._query);
            return path;
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * QuoteCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.QuoteCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'QuoteRow',
            view: 'ChildQuoteRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteCategoryResultsView')
         */
        _string: 'QuoteCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   QuoteCategoriesGroupView quoteCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, quoteCategoriesGroup, category) {
            this._collection = new QuoteFeaturesCollection();
            this._super(element, quoteCategoriesGroup, category);
            this._setupCollection();
        },

        /**
         * _onResultsReady
         * 
         * @note    This executes right away because there's no images to lazy
         *          load.
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            callback.apply(this);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.toString() === 'QuoteResourceAccessor') {
                        if (accessor.saved() === true) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        if (accessor.get('uploaded').toInt() === 1) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    }
                    _this._drawChild(accessor, position);
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').quotes.categories;
            this._load(numberOfResults, limit);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search');
            $search.blur();
            if (this._category.get('featured').toInt() === 1) {
                if (
                    UserAgentUtils.is.tablet() === false
                    && UserAgentUtils.is.ie() === false
                ) {
                    $search.focus();
                }
            }
        }
    });
});
window.DependencyLoader.push('QueryResultsView', function() {

    /**
     * QuoteQueryResultsView
     * 
     * @extends QueryResultsView
     */
    window.QuoteQueryResultsView = QueryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'QuoteRow',
            view: 'ChildQuoteRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteQueryResultsView')
         */
        _string: 'QuoteQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuoteQueriesGroupView quoteQueriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, quoteQueriesGroup, query) {
            this._collection = new QuoteResourcesCollection();
            this._super(element, quoteQueriesGroup, query);
            this._setupCollection();
        },

        /**
         * _getQueryResultsType
         * 
         * @access  protected
         * @return  String
         */
        _getQueryResultsType: function() {
            return 'quotes';
        },

        /**
         * _getSearchGateways
         * 
         * @access  protected
         * @return  Array
         */
        _getSearchGateways: function() {
            var searchGateways = Config.default('quoteSearchGateways');
            return searchGateways;
        },

        /**
         * _onResultsReady
         * 
         * @note    This executes right away because there's no images to lazy
         *          load.
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            callback.apply(this);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._drawChild(accessor, position);
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var path = '/app/quotes/search/' + encodeURIComponent(this._query);
            return path;
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * TemplateCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.TemplateCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            drawCallback: function() {
                var $element = this.getElement();
                if ($element.hasClass('loaded') === true) {
                    $element.addClass('backgroundTransparentFallback');
                    var currentBackgroundImageValue = $element.css('background-image'),
                        path = '/app/static/images/backgrounds/checkered.png',
                        url = RequestUtils.url.static(path),
                        transparentBackgroundImageValue = 'url(\'' + (url) + '\')';
                    // transparentBackgroundImageValue = transparentBackgroundImageValue.replace(/^([^,]*)(,)([^,]*)(,)(.*)$/, '$1$2$3');
                    $element.css({
                        backgroundImage: (currentBackgroundImageValue) + ', ' +
                            transparentBackgroundImageValue
                    });
                }
            },
            template: 'TemplateThumb',
            view: 'TemplateThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateCategoryResultsView')
         */
        _string: 'TemplateCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   TemplateCategoriesGroupView templateCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, templateCategoriesGroup, category) {
            this._collection = new TemplateFeaturesCollection();
            this._super(element, templateCategoriesGroup, category);
            this._setupCollection();
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, templateAccessor, position) {
                    if (templateAccessor.reference('image').get('uploaded').toInt() === 1) {
                        category.syncedFeatures.add.apply(category, [templateAccessor]);
                    }
                    var child = _this._drawChild(templateAccessor, position);
                    _this._drawProperties.drawCallback.apply(child);
                },
                'remove': function(event, templateAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === templateAccessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [templateAccessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').templates.categories;

            // Start at the beginning if first accessor is being uploaded atm
            if (numberOfResults === 1) {
                var first = this._collection.first().reference('image');
                if (first.get('uploaded').toInt() === 0) {
                    numberOfResults = 0;
                }
            }
            this._load(numberOfResults, limit);
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * UploadCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.UploadCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'UploadThumb',
            view: 'UploadThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadCategoryResultsView')
         */
        _string: 'UploadCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   UploadCategoriesGroupView uploadCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, uploadCategoriesGroup, category) {
            this._collection = new UploadFeaturesCollection();
            this._super(element, uploadCategoriesGroup, category);
            this._setupCollection();
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, uploadAccessor, position) {
                    _this._drawChild(uploadAccessor, position);
                },
                'remove': function(event, uploadAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === uploadAccessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [uploadAccessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').uploads.categories;
            this._load(numberOfResults, limit);
        }
    });
});
window.DependencyLoader.push('CategoryResultsView', function() {

    /**
     * WatermarkCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.WatermarkCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'WatermarkThumb',
            view: 'WatermarkView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkCategoryResultsView')
         */
        _string: 'WatermarkCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   WatermarkCategoriesGroupView watermarkCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, watermarkCategoriesGroup, category) {
            this._collection = new WatermarkFeaturesCollection();
            this._super(element, watermarkCategoriesGroup, category);
            this._setupAuthReloading();
            this._setupCollection();
        },

        /**
         * _onResultsReady
         * 
         * This method is a bit funky, in that it makes a call to the collection
         * usable method to see if any watermarks are actually available to be
         * used. This is because we respond from the server with watermarks even
         * if they can't be used (and aren't visible). This may be an artifact
         * of a bug related to ensuring WatermarkAccessor's are available when
         * loading old images and/or templates.
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            if (this._collection.usable().length === 0) {
                callback.apply(this);
            } else {
                var interval = (function() {
                    var selectors = [
                            '.watermark.loaded label.lazy'
                        ],
                        selector = selectors.join(',');
                    if (this.find(selector).length > 0) {
                        IntervalPool.clear(interval);
                        callback.apply(this);
                    }
                }).interval(50, this);
            }
        },

        /**
         * _setupAuthReloading
         * 
         * Adds additional signup/upgrade events since watermarks are behind a
         * pay-wall. No other section has different UI states based on being a
         * guest, free user and upgaded user in the way that AllWatermarks does.
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthReloading: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
            User.once({
                'signup': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this,
                category = this._category;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.get('usable').toInt() === 1) {
                        _this._drawChild(accessor, position);
                    }
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [accessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * lazyLoadChildren
         * 
         * @note    <loading> class used below to ensure no duplicate calls made
         *          to lazy load assets incase a collection <update> event fires
         *          twice. To reproduce this, comment out the <loading> class
         *          lines below, reload browser from Background filters tab,
         *          upload an image, and switch to the uploads tab.
         * @note    <waiting> class is used below in cases where there are
         *          hundreds of assets. In those cases, 50 will be drawn upon
         *          load, but the last X won't be loaded, because they're so far
         *          below the threshold value for preloading. Without the
         *          <waiting> class, an infinite-scroll could trigger an
         *          additional collection:update event, which could result in
         *          multiple lazy events beyond attached to the element. When
         *          that happens, things bust :(
         * @access  public
         * @return  void
         */
        lazyLoadChildren: function() {
            var $elements = this.find(
                '.watermark:not(.loading):not(.loaded):not(.waiting) .lazy'
            );
            $elements.parent().addClass('waiting');
            $elements.lazyload({
                threshold: 500,
                container: this._element.find('.results').first(),
                effect: 'fadeIn',
                appear: function(remaining, settings) {
                    $(this).parent().addClass('loading');
                },
                load: function(remaining, settings) {
                    $(this).parent().addClass('loaded');
                    $(this).parent().removeClass('loading');
                    $(this).parent().removeClass('waiting');
                    $(this).removeAttr('data-original');
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').watermarks.categories;
            this._load(numberOfResults, limit);
        },

        /**
         * selectAll
         * 
         * @note    Needed to override the parent method because Watermarks
         *          work differently: since they're not actually deleted (rather
         *          marked as unusable), they don't get removed from their
         *          associated collections (which in turn means they don't get
         *          removed from the this._children array).
         *          So to deal with this, I check whether the WatermarkView
         *          is available in the DOM, and if not, it means it was removed
         *          and should be included in the selectAll flow.
         * @see     https://i.imgur.com/Pl17mmh.png
         * @see     https://i.imgur.com/TUN1DVk.png
         * @access  public
         * @return  void
         */
        selectAll: function() {
            var index = 0,
                length = this._children.length,
                $element;
            for (index; index < length; ++index) {
                this._children[index].deselect();
            }
            index = length;
            while (index--) {
                $element = this._children[index].getElement();
                if (jQuery.contains(document, $element[0]) === false) {
                    continue;
                }
                this._children[index].select();
                this._children[index].getElement().addClass('active-shift');
            }
            this.reClassifyChildren();
        },

        /**
         * showHideEmptyState
         * 
         * Could not think of a good name for this method. It show/hides the
         * appropriate elements based on whether the collection contains any
         * objects or not.
         * 
         * @access  public
         * @return  void
         */
        showHideEmptyState: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty,.guest,.free').addClass('hidden');
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                if (this._collection.usable().length === 0) {
                    this.find('.results').addClass('hidden');
                    this.find('.messaging,.empty').removeClass('hidden');
                }
            } else {
                this.find('.results').addClass('hidden');
                if (Account.guest() === true) {
                    this.find('.messaging,.guest').removeClass('hidden');
                } else if (Account.free() === true) {
                    this.find('.messaging,.free').removeClass('hidden');
                } else {
                    // Should never get here
                }
            }
        }
    });
});
window.DependencyLoader.push('AreaView', function() {

    /**
     * SearchableAreaView
     * 
     * Child of AreaView meant to serve only areas whereby there is an input
     * that allows the area to be searched.
     * 
     * @extends AreaView
     */
    window.SearchableAreaView = AreaView.extend({

        /**
         * _resourcesSearch
         * 
         * @access  protected
         * @var     null|ResourcesSearchView (default: null)
         */
        _resourcesSearch: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SearchableAreaView')
         */
        _string: 'SearchableAreaView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
            this._setupResourceSearch();
            this._setupQueries();
        },

        /**
         * _setupResourceSearch
         * 
         * @access  protected
         * @return  void
         */
        _setupResourceSearch: function() {
            var placeholder = this._getResourceSearchPlaceholderCopy(),
                $resourcesSearch = DataUtils.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').prepend($resourcesSearch);
        },

        /**
         * getResourceSearch
         * 
         * @access  public
         * @return  ResourcesSearchView
         */
        getResourceSearch: function() {
            return this._resourcesSearch;
        }
    });
});
window.DependencyLoader.push('FormView', function() {

    /**
     * AppFormView
     * 
     * @extends FormView
     */
    window.AppFormView = FormView.extend({

        /**
         * _fallback
         * 
         * @access  protected
         * @var     String (default: 'Something went wrong. Please try again.')
         */
        _fallback: 'Something went wrong. Please try again',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * This detects the client being focused on a submission
                     * element, and pressing either the enter key or space key
                     * to trigger submission.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        if (event.which === 13 || event.which === 32) {
                            event.preventDefault();
                            this.triggerHandler('submit');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AppFormView')
         */
        _string: 'AppFormView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'submitted': function(event) {
                    this.clearErrors();
                    this.find('a.button').addClass('busy');
                    this.find('a.button').disable();
                },
                'returned': function(event) {
                    this.find('a.button').removeClass('busy');
                },
                'returned/failed': function(event, response) {
                    this.find('a.button').enable();
                    var error = this.getError(response);
                    this.showError(error);
                },
                'returned/shit': function(event, response) {
                    this.find('a.button').enable();
                    var error = this.getError(response);
                    this.showError(error);
                },
                'returned/succeeded': function(event, response) {
                    this.find('a.button').addClass('done');
                    (function() {
                        this.find('a.button').removeClass('done');
                        this.find('a.button').enable();
                    }).delay(2000, this);
                    // }, this._timeout);
                }
            });
        },

        /**
         * setErrorMessage
         * 
         * @access  protected
         * @param   String msg
         * @return  void
         */
        setErrorMessage: function(msg) {
            var $callout = this.find('.callout.errors');
            $callout.find('p').html(msg);
        },

        /**
         * showError
         * 
         * @access  protected
         * @param   Object error
         * @return  void
         */
        showError: function(error) {
            if (error.code) {
                Track.event('Form Error', {
                    _code: error.code
                });
            }
            this.setErrorMessage(error.message);
            var $callout = this.find('.callout.errors');
            $callout.removeClass('hidden');
            error.input && error.input.focus();
        },

        /**
         * clearErrors
         * 
         * @access  public
         * @return  void
         */
        clearErrors: function() {
            this.find('div.callout.errors').addClass('hidden');
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this._super();
            this.find('select').disable();
            this.find('select').selectpicker('refresh');
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this._super();
            this.find('select').enable();
            this.find('select').selectpicker('refresh');
        },

        /**
         * getError
         * 
         * @access  public
         * @param   Object response
         * @return  Object
         */
        getError: function(response) {
            var error = response && response.failedRules && response.failedRules[0]
                    && response.failedRules[0].error,
                message = this._fallback,
                input = this._element.focusable(),
                code = false;
            if (error) {
                message = error.message || message;
                code = error.code || false;
                if (error.input) {
                    input = this.find('[name="' + (error.input) + '"]');
                }
            }
            return {
                code: code,
                message: message,
                input: input
            };
        },

        /**
         * setFallback
         * 
         * @access  public
         * @param   String message
         * @return  void
         */
        setFallback: function(message) {
            this._fallback = message;
        }
    });
});
window.DependencyLoader.push('AppFormView', function() {

    /**
     * CreditCardAppFormView
     * 
     * @see     https://stripe.com/docs/testing
     *          https://stripe.com/docs/stripe.js
     *          https://dashboard.stripe.com/fraud/rules
     * @events  card/submit
     *          card/submitted
     *          card/returned
     *          card/returned/failed
     *          card/returned/succeeded
     * @testing Visa 4242424242424242
     *          Visa 4012888888881881
     *          MasterCard 5555555555554444
     *          MasterCard 5105105105105100
     *          American Express 378282246310005
     *          American Express 371449635398431
     *          Discover 6011111111111117
     *          Discover 6011000990139424
     *          Diners Club 30569309025904
     *          Diners Club 38520000023237
     *          JCB 3530111333300000
     *          JCB 3566002020360505
     * @testing Fails 4000000000000341 (passes checks, but can't be charged)
     *          Fails 4000000000000002
     *          Fails 4000000000000119
     *          Fails 4000000000000101 (cvc)
     *          Fails 4000000000000127 (cvc)
     *          Fails 4000000000000036 (zip code)
     * @extends AppFormView
     */
    window.CreditCardAppFormView = AppFormView.extend({

        /**
         * _acceptedCreditCardTypes
         * 
         * An array of credit card types that are accepted by Stencil. This is
         * primarily determined by what Stripe allows us to accept (which is
         * different than US based companies, which can accept cards like JCB,
         * Diners Club and American Express).
         * 
         * @access  protected
         * @var     Array
         */
        _acceptedCreditCardTypes: [
            'Visa',
            'MasterCard',
            'American Express'
        ],

        /**
         * _listeners
         * 
         * Overrides the FormView parent listeners to trigger the card handlers
         * before the 'native' ones
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * Handles the case whereby a user tabs to the submit button
                     * and hits the enter or space key.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="card/submit"]': function(event, $element) {
                        if (event.which === 13 || event.which === 32) {
                            event.preventDefault();
                            this.triggerHandler('card/submit');
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('card/submit');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                        this.triggerHandler('card/submit');
                    }
                }
            });
        },

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            emptyName: 'Please enter the name as it appears on the card',
            emptyZip: 'Please enter the zip or postal code associated with ' +
                'this card'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CreditCardAppFormView')
         */
        _string: 'CreditCardAppFormView',

        /**
         * _timeout
         * 
         * This is used for both the token posting and form posting.
         * 
         * @access  protected
         * @var     Number (default: 1250)
         */
        _timeout: 1250,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            Scripts.load('stripe');
            this._setInputRestrictions();
            this._addCardControllerListeners();
            this._addCardUIListeners();
        },

        /**
         * _addCardControllerListeners
         * 
         * @access  protected
         * @return  void
         */
        _addCardControllerListeners: function() {
            this.on({
                'card/submit': function(event) {
                    var _this = this;
                    App.getBusy().show();
                    Scripts.load('stripe', function() {
                        App.getBusy().hide();
                        _this._requestStripeToken();
                    });
                },
                'card/returned': this.enable
            });
        },

        /**
         * _addCardUIListeners
         * 
         * @access  protected
         * @return  void
         */
        _addCardUIListeners: function() {
            this.on({
                'card/submitted': function(event) {
                    this.clearErrors();
                    this.find('a.button').addClass('busy');
                    this.find('a.button').disable();
                },
                'card/returned/failed': function(event, error) {
                    this.find('a.button').removeClass('busy');
                    this.find('a.button').enable();
                    this.showError(error);
                },
                'card/returned/succeeded': function(event, response) {
                    var stripeToken = response.id;
                    this.find('input[name="data[token]"]').val(stripeToken);
                    this.triggerHandler('submit');
                },
                'returned/succeeded': function(event, response) {
                    this.find('[data-stripe]').val('');
                }
            });
        },

        /**
         * _getCreditCardNumber
         * 
         * @access  protected
         * @return  String
         */
        _getCreditCardNumber: function() {
            var $number = this.find('[data-stripe="number"]'),
                number = $number.val();
            return number;
        },

        /**
         * _getCreditCardZip
         * 
         * @access  protected
         * @return  String
         */
        _getCreditCardZip: function() {
            var $zip = this.find('[data-stripe="zip"]'),
                zip = $zip.val();
            if (zip === '') {
                return '000000';
            }
            return zip;
        },

        /**
         * _getCreditCardName
         * 
         * @access  protected
         * @return  String
         */
        _getCreditCardName: function() {
            var $name = this.find('[data-stripe="name"]'),
                name = $name.val();
            return name;
        },

        /**
         * _getCreditCardCvc
         * 
         * @access  protected
         * @return  String
         */
        _getCreditCardCvc: function() {
            var $cvc = this.find('[data-stripe="cvc"]'),
                cvc = $cvc.val();
            return cvc;
        },

        /**
         * _getStripeError
         * 
         * @access  protected
         * @param   Object response
         * @return  Object
         */
        _getStripeError: function(response) {
            var $number = this.find('[data-stripe="number"]'),
                $cvc = this.find('[data-stripe="cvc"]'),
                $zip = this.find('[data-stripe="zip"]'),
                $expiry = this.find('[data-stripe="expiry"]'),
                $input = $number;
            if (response.error.param === 'cvc') {
                $input = $cvc;
            } else if (response.error.param === 'address_zip') {
                $input = $zip;
            } else if (response.error.param === 'exp_month') {
                $input = $expiry;
            } else if (response.error.param === 'exp_year') {
                $input = $expiry;
            }
            return {
                message: response.error.message,
                input: $input
            };
        },

        /**
         * _getStripeFormattedExpiryMonth
         * 
         * @access  protected
         * @return  String
         */
        _getStripeFormattedExpiryMonth: function() {
            var $expiry = this.find('[data-stripe="expiry"]'),
                expiry = $expiry.payment('cardExpiryVal'),
                month = '';
            if (isNaN(expiry.month) === false) {
                month = expiry.month;
            }
            return month;
        },

        /**
         * _getStripeFormattedExpiryYear
         * 
         * @access  protected
         * @return  String
         */
        _getStripeFormattedExpiryYear: function() {
            var $expiry = this.find('[data-stripe="expiry"]'),
                expiry = $expiry.payment('cardExpiryVal'),
                year = '';
            if (isNaN(expiry.year) === false) {
                year = expiry.year;
            }
            return year;
        },

        /**
         * _getStripeTokenRequestObject
         * 
         * @access  protected
         * @return  Object
         */
        _getStripeTokenRequestObject: function() {
            var requestObject = {
                number: this._getCreditCardNumber(),
                cvc: this._getCreditCardCvc(),
                exp_month: this._getStripeFormattedExpiryMonth(),
                exp_year: this._getStripeFormattedExpiryYear(),
                name: this._getCreditCardName(),
                address_zip: this._getCreditCardZip()
            };
            return requestObject;
        },

        /**
         * _makeRequestForStripeToken
         * 
         * @access  protected
         * @return  void
         */
        _makeRequestForStripeToken: function() {
            var _this = this,
                stripeTokenRequestObject = this._getStripeTokenRequestObject();
            Stripe.card.createToken(
                stripeTokenRequestObject,
                function(status, response) {
                    _this.triggerHandler.delay(
                        _this._timeout,
                        _this,
                        ['card/returned']
                    );
                    if (status === 200) {
                        _this.triggerHandler.delay(
                            _this._timeout,
                            _this,
                            ['card/returned/succeeded', [response]]
                        );
                    } else {
                        var error = _this._getStripeError(response);
                        _this.triggerHandler.delay(
                            _this._timeout,
                            _this,
                            ['card/returned/failed', [error]]
                        );
                    }
                }
            );
        },

        /**
         * _requestStripeToken
         * 
         * Returns a boolean indicating whether or not a request for a Stripe
         * Token was made.
         * 
         * @access  protected
         * @return  Boolean
         */
        _requestStripeToken: function() {
            if (this._enabled === false) {
                return false;
            }
            this.disable();
            this.triggerHandler('card/submitted');
            var valid = this._validDataForTokenRequest();
            if (valid === false) {
                return false;
            }
            this._makeRequestForStripeToken();
            return true;
        },

        /**
         * _setInputRestrictions
         * 
         * This forces input restrictions on inputs to ensure valid data is
         * entered. For example, characters should be able to be entered into
         * the credit card number, cvc or expiry input fields.
         * 
         * @access  protected
         * @return  void
         */
        _setInputRestrictions: function() {
            var $number = this.find('[data-stripe="number"]'),
                $cvc = this.find('[data-stripe="cvc"]'),
                $expiry = this.find('[data-stripe="expiry"]');
            $number.payment('formatCardNumber');
            $cvc.payment('formatCardCVC');
            $expiry.payment('formatCardExpiry');
        },

        /**
         * _supportedCreditCard
         * 
         * Returns whether or not the passed in credit card type (which is
         * determined by using the Stripe helper method with the entered credit
         * card number) is a credit card that we accept.
         * 
         * @access  protected
         * @param   String number
         * @return  Boolean
         */
        _supportedCreditCard: function(number) {
            var creditCardType = Stripe.card.cardType(number),
                acceptedCreditCardTypes = this._acceptedCreditCardTypes;
            if (ArrayUtils.contains(creditCardType, acceptedCreditCardTypes) === false) {
                return false;
            }
            return true;
        },

        /**
         * _triggerFailedCardEvent
         * 
         * Triggers the two events that are related to a submission failing.
         * 
         * @access  protected
         * @param   String msg
         * @param   jQuery $element
         * @return  void
         */
        _triggerFailedCardEvent: function(msg, $element) {
            var timeout = this._timeout,
                args = ['card/returned'];
            this.triggerHandler.delay(timeout, this, args);
            args = [
                'card/returned/failed',
                [
                    {
                        message: msg,
                        input: $element
                    }
                ]
            ];
            this.triggerHandler.delay(
                timeout,
                this,
                args
            );
            return false;
        },

        /**
         * _validCreditCardTypeForTokenRequest
         * 
         * @access  protected
         * @return  Boolean
         */
        _validCreditCardTypeForTokenRequest: function() {
            var $number = this.find('[data-stripe="number"]'),
                number = $number.val();
            if (this._supportedCreditCard(number) === false) {
                var msg = 'Please enter a ';
                msg += this._acceptedCreditCardTypes.join(', ');
                msg = msg.replace(/, ([^,]+)$/, ' or $1') + ' ';
                msg += 'credit card number';
                this._triggerFailedCardEvent(msg, $number);
                return false;
            }
            return true;
        },

        /**
         * _validCreditCardNameForTokenRequest
         * 
         * @access  protected
         * @return  Boolean
         */
        _validCreditCardNameForTokenRequest: function() {
            var $name = this.find('[data-stripe="name"]'),
                name = $name.val();
            if (name === '') {
                var msg = this._messages.emptyName;
                this._triggerFailedCardEvent(msg, $name);
                return false;
            }
            return true;
        },

        /**
         * _validCreditCardZipForTokenRequest
         * 
         * @access  protected
         * @return  Boolean
         */
        _validCreditCardZipForTokenRequest: function() {
            var $zip = this.find('[data-stripe="zip"]'),
                zip = $zip.val();
            if (zip === '') {
                var msg = this._messages.emptyZip;
                this._triggerFailedCardEvent(msg, $zip);
                return false;
            }
            return true;
        },

        /**
         * _validDataForTokenRequest
         * 
         * @access  protected
         * @return  Boolean
         */
        _validDataForTokenRequest: function() {
            if (this._validCreditCardTypeForTokenRequest() === false) {
                return false;
            }
            if (this._validCreditCardNameForTokenRequest() === false) {
                return false;
            }
            // if (this._validCreditCardZipForTokenRequest() === false) {
            //     return false;
            // }
            return true;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * FormView
     * 
     * @events  submit
     *          submitted
     *          sent
     *          returned
     *          returned/shit
     *          returned/failed
     *          returned/succeeded
     * @extends View
     */
    window.FormView = View.extend({

        /**
         * _enabled
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _enabled: true,

        /**
         * _handlerDelay
         * 
         * @access  protected
         * @var     Number (default: 1500) in milliseconds
         */
        _handlerDelay: 1500,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('submit');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FormView')
         */
        _string: 'FormView',

        /**
         * _submissionTimeoutDuration
         * 
         * @access  protected
         * @var     false|Number (default: false)
         */
        _submissionTimeoutDuration: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'submit': this._submit,
                'returned': this.enable
            });
        },

        /**
         * _submit
         * 
         * @note    I serialize the form object before disabling to ensure I can
         *          access any disabled inputs
         * @access  protected
         * @return  void
         */
        _submit: function() {
            if (this._enabled === true) {
                this.triggerHandler('submitted');
                if (this._enabled === true) {
                    var formData = ElementUtils.getFormData(this._element),
                        _this = this;
                    this.disable();
                    RequestUtils.ajax({
                        signature: {"basename":"Form.js","line":123},
                        url: this._element.attr('action'),
                        type: this._element.attr('method'),
                        data: formData,
                        error: function(xhr, status, error) {
                            _this.triggerHandler.delay(
                                _this._handlerDelay,
                                _this,
                                ['returned']
                            );
                            _this.triggerHandler.delay(
                                _this._handlerDelay,
                                _this,
                                ['returned/shit']
                            );
                        },
                        timeout: this._submissionTimeoutDuration,
                        success: function(response) {
                            _this.triggerHandler.delay(
                                _this._handlerDelay,
                                _this,
                                ['returned']
                            );
                            var listener = 'returned/failed';
                            if (response.success === true) {
                                listener = 'returned/succeeded';
                            }
                            _this.triggerHandler.delay(
                                _this._handlerDelay,
                                _this,
                                [listener, [response]]
                            );
                        }
                    });
                    this.triggerHandler('sent');
                }
            }
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this._enabled = false;
            var selector = [
                // 'input[type="checkbox"]',
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this._enabled = true;
            var selector = [
                // 'input[type="checkbox"]',
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).attr('readonly', false);
        },

        /**
         * setHandlerDelay
         * 
         * @access  public
         * @param   Number handlerDelay in milliseconds
         * @return  void
         */
        setHandlerDelay: function(handlerDelay) {
            this._handlerDelay = handlerDelay;
        },

        /**
         * setSubmissionTimeoutDuration
         * 
         * @access  public
         * @param   Number duration in milliseconds
         * @return  void
         */
        setSubmissionTimeoutDuration: function(duration) {
            this._submissionTimeoutDuration = duration;
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CancelAccountModalView
     * 
     * @extends ModalView
     */
    window.CancelAccountModalView = ModalView.extend({

        /**
         * _account
         * 
         * @access  protected
         * @var     AccountAccessor|null
         */
        _account: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CancelAccountModalView')
         */
        _string: 'CancelAccountModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AccountAccessor account
         * @return  void
         */
        init: function(element, account) {
            this._super(element);
            this._account = account;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var modal = ModalUtils.get('Admin'),
                        section = modal.getSection('users'),
                        path = section.getPath();
                    Stencil.navigate(path);
                }
            });
            this.on({
                'later': function(event) {
                    var msg = Config.getMessage('admin.cancel.delay');
                    App.getBusy().show(msg);
                    var disapproveLastCommission = false,
                        $disapproveLastCommission = element.find(
                            '[name="disapproveLastCommission"]'
                        );
                    if ($disapproveLastCommission.length > 0) {
                        disapproveLastCommission = $disapproveLastCommission[0].checked;
                    }
                    this._account.cancel(
                        true,
                        disapproveLastCommission,
                        function(data) {
                            (function() {
                                location.reload();
                            }).delay(30 * 1000);
                        }
                    );
                    this.triggerHandler('leave');
                },
                'now': function(event) {
                    var msg = Config.getMessage('admin.cancel.delay');
                    App.getBusy().show(msg);
                    var disapproveLastCommission = false,
                        $disapproveLastCommission = element.find(
                            '[name="disapproveLastCommission"]'
                        );
                    if ($disapproveLastCommission.length > 0) {
                        disapproveLastCommission = $disapproveLastCommission[0].checked;
                    }
                    this._account.cancel(
                        false,
                        disapproveLastCommission,
                        function(data) {
                            (function() {
                                location.reload();
                            }).delay(30 * 1000);
                        }
                    );
                    this.triggerHandler('leave');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * AddRecordModalView
     * 
     * @extends ModalView
     */
    window.AddRecordModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access  protected
         * @var     null|AdminModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddRecordModalView')
         */
        _string: 'AddRecordModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this._cleanModalLeaveEvent();
            this._loadDependencies();
            this._setupDateTimePicker();
            this._setupDropdowns();
            this._setupForm();
            this._setupTooltips();
        },

        /**
         * _cleanModalLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _cleanModalLeaveEvent: function() {
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = this._fallbackPath;
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _formatFormData
         * 
         * @access  protected
         * @return  void
         */
        _formatFormData: function() {
        },

        /**
         * _loadDependencies
         * 
         * @access  protected
         * @return  void
         */
        _loadDependencies: function() {
        },

        /**
         * _setupDateTimePicker
         * 
         * @access  protected
         * @return  void
         */
        _setupDateTimePicker: function() {
            var $expiry = this.find('#expiry'),
                current = new Date();
            current.setDate(current.getDate());
            $expiry.datetimepicker({
                // debug: true,
                format: 'MM/DD/YYYY h:mm A',
                minDate: current,
                // showTodayButton: true,
                showClose: true,
                showClear: true,
                icons: {
                    time: 'fa fa-clock-o',
                    date: 'fa fa-calendar',
                    up: 'fa fa-chevron-up',
                    down: 'fa fa-chevron-down',
                    previous: 'fa fa-chevron-left',
                    next: 'fa fa-chevron-right',
                    today: 'fa fa-calendar-check-o',
                    clear: 'fa fa-trash-o',
                    close: 'fa fa-close'
                }
            });
            $expiry.val('');
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            var $select = this.find('select');
            $select.selectpicker({
                dropupAuto: false
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var $form = this.find('form');
            this._form = new AppFormView($form);
            this._form.setHandlerDelay(0);
            var _this = this;
            this._form.on({
                'submitted': this._formatFormData.proxy(this)
            });
            this._form.on({
                'submitted': function(event) {
                    _this._adminModal.pause();
                    _this.pause();
                }
            });
            this._form.on({
                'returned': function(event) {
                    _this._adminModal.unpause();
                    _this.unpause();
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                container: this._element,
                // html: true,
                placement: 'bottom',
                selector: '[tooltip]'
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * AdminModalView
     * 
     * @extends ModalView
     */
    window.AdminModalView = ModalView.extend({

        /**
         * _sections
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _sections: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminModalView')
         */
        _string: 'AdminModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupCoupons();
            this._setupDashboard();
            this._setupImages();
            this._setupPromoSets();
            this._setupUsers();
            this._setupVectorSets();
            this.on({
                'categories/add': function(event) {
                    Stencil.navigate('/app/admin/categories/add');
                },
                'coupons/add': function(event) {
                    Stencil.navigate('/app/admin/coupons/add');
                },
                'promoSets/add': function(event) {
                    Stencil.navigate('/app/admin/promoSets/add');
                },
                'users/search': function(event) {
                    Stencil.navigate('/app/admin/users/search');
                },
                'vectorSets/add': function(event) {
                    Stencil.navigate('/app/admin/vectorSets/add');
                }
            });
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._sections.categories = new AdminCategoriesView(
                $categories,
                this
            );
        },

        /**
         * _setupCoupons
         * 
         * @access  protected
         * @return  void
         */
        _setupCoupons: function() {
            var $coupons = this.find('section.coupons');
            this._sections.coupons = new AdminCouponsView($coupons, this);
        },

        /**
         * _setupDashboard
         * 
         * @todo!   Do not have dashboard.html contain all links; have them be
         *          sent down from the server upon navigation.
         * @access  public
         * @return  void
         */
        _setupDashboard: function() {
            var $dashboard = this.find('section.dashboard');
            this._sections.dashboard = new AdminDashboardView($dashboard, this);
        },

        /**
         * _setupImages
         * 
         * @access  protected
         * @return  void
         */
        _setupImages: function() {
            var $images = this.find('section.images');
            this._sections.images = new AdminImagesView($images, this);
        },

        /**
         * _setupPromoSets
         * 
         * @access  protected
         * @return  void
         */
        _setupPromoSets: function() {
            var $promoSets = this.find('section.promoSets');
            this._sections.promoSets = new AdminPromoSetsView($promoSets, this);
        },

        /**
         * _setupUsers
         * 
         * @access  protected
         * @return  void
         */
        _setupUsers: function() {
            var $users = this.find('section.users');
            this._sections.users = new AdminUsersView($users, this);
        },

        /**
         * _setupVectorSets
         * 
         * @access  protected
         * @return  void
         */
        _setupVectorSets: function() {
            var $vectorSets = this.find('section.vectorSets');
            this._sections.vectorSets = new AdminVectorSetsView($vectorSets, this);
        },

        /**
         * getSection
         * 
         * @access  public
         * @param   String section
         * @return  SectionView
         */
        getSection: function(section) {
            return this._sections[section];
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * AlertModalView
     * 
     * @extends ModalView
     */
    window.AlertModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AlertModalView')
         */
        _string: 'AlertModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Object settings
         * @return  void
         */
        init: function(element, settings) {
            this._super(element);
            this._settings = settings;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        },

        /**
         * getSettings
         * 
         * @access  public
         * @return  Object
         */
        getSettings: function() {
            return this._settings;
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * AssetsReimportModalView
     * 
     * @extends ModalView
     */
    window.AssetsReimportModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AssetsReimportModalView')
         */
        _string: 'AssetsReimportModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupForm();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/dashboard');
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on({
                'returned/succeeded': function(event, response) {
                    this.find('input').first().focus();
                    this.find('input').first().select();
                    LogUtils.log.simple(response.data, true);
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * AuthModalView
     * 
     * @extends ModalView
     */
    window.AuthModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _redirect
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _redirect: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AuthModalView')
         */
        _string: 'AuthModalView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   false|String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element);
            this._type = type;
            this._redirect = redirect;
            this._form = new AppFormView(this.find('form'));
        },

        /**
         * _flow
         * 
         * Manages the flow after a user is authenticated (either via a login or
         * signup redemption modal).
         * 
         * Worth noting: throughout auth flows (including in Promo.js and
         * Checkout.js), I always trigger the modal's leave-event, rather than
         * close, because it ensures that the user is sent back to the
         * location-path they were on before.
         * 
         * The exception to this is below: when a redirect parameter is
         * available, I simply close the modal (by triggering it's close-event).
         * This prevents an extra navigation event from happening, which is
         * useful since it prevents an unnecessary navigational-record, and
         * if the user landed directly in the app (eg. getstencil.com/checkout,
         * which redirects to login / signup before going on to the Checkout
         * modal), it prevents loading /app until _after_ they have been
         * authenticated and upgraded. Preventing /app from loading is
         * desirable, since that fires off a request for featured images, which
         * would result in using a bunch of bandwidth (and memory) when it is
         * not yet needed.
         * 
         * @access  public
         * @return  void
         */
        _flow: function() {
            if (this._type === 'curtain') {
                if (this._redirect === false) {
                    this._element.addClass('transition');
                    (function() {
                        App.getElement().removeClass('curtain');
                        this.triggerHandler('leave');
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/countdown?clean=1&onboard');
                        }
                    // }).delay(1800, this);
                    }).delay(0, this);
                } else {
                    // this.triggerHandler('leave');
                    this.triggerHandler('close');
                    var path = this._redirect;
                    // path += '?curtain';
                    Stencil.navigate(path);
                }
            } else {
                // this.triggerHandler('leave');
                if (this._redirect !== false) {
                    this.triggerHandler('close');
                    Stencil.navigate(this._redirect);
                } else {
                    this.triggerHandler('leave');
                    if (this._type === 'save') {
                        Footer.triggerHandler('save');
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/onboard?clean=1');
                        }
                    } else if (this._type === 'checkout') {
                        Stencil.navigate('/app/checkout/unlimited/annually');
                    } else if (this._type === 'upgrade') {
                        // Stencil.navigate('/app/checkout/unlimited/annually');
                        Stencil.navigate('/app/plans');
                    } else {
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/countdown?clean=1&onboard');
                        } else {
                            Stencil.get('user').showLegacyWelcome();
                        }
                    }
                }
            }
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * BrowserModalView
     * 
     * @extends ModalView
     */
    window.BrowserModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BrowserModalView')
         */
        _string: 'BrowserModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * BusyModalView
     * 
     * @extends ModalView
     */
    window.BusyModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BusyModalView')
         */
        _string: 'BusyModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * show
         * 
         * @access  public
         * @param   undefined|false|String copy
         * @param   undefined|false|String exception
         * @return  void
         */
        show: function(copy, exception) {
            if (copy === undefined || copy === false) {
                this.find('div.copy').html('');
            } else {
                this.find('div.copy').html(copy);
            }
            if (exception === undefined || exception === false) {
                this.find('div.exception').html('');
            } else {
                this.find('div.exception').html(exception);
            }
            this._super();
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CacheRefreshModalView
     * 
     * @extends ModalView
     */
    window.CacheRefreshModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CacheRefreshModalView')
         */
        _string: 'CacheRefreshModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupForm();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/dashboard');
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on({
                'returned/succeeded': function(event, response) {
                    this.find('input').first().focus();
                    this.find('input').first().select();
                    LogUtils.log.simple(response.data, true);
                }
            });
        }
    });
});
window.DependencyLoader.push('AddRecordModalView', function() {

    /**
     * AddCategoryModalView
     * 
     * @extends AddRecordModalView
     */
    window.AddCategoryModalView = AddRecordModalView.extend({

        /**
         * _fallbackPath
         * 
         * @access  protected
         * @var     String (default: '/app/admin/categories')
         */
        _fallbackPath: '/app/admin/categories',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddCategoryModalView')
         */
        _string: 'AddCategoryModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element, adminModal);
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._super();
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Category added');
                    var collection = _this._adminModal.getSection('categories')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/categories');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ApplyCategoriesModalView
     * 
     * @extends ModalView
     */
    window.ApplyCategoriesModalView = ModalView.extend({

        /**
         * _accessor
         * 
         * @access  protected
         * @var     null|Accessor (default: null)
         */
        _accessor: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ApplyCategoriesModalView')
         */
        _string: 'ApplyCategoriesModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @return  void
         */
        init: function(element, accessor) {
            this._super(element);
            this._accessor = accessor;
            this._setupCheckboxes();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
        },

        /**
         * _setupCheckboxes
         * 
         * @access  protected
         * @return  void
         */
        _setupCheckboxes: function() {
            var accessor = this._accessor,
                $checkboxes = this.find('input[type="checkbox"]');
            $checkboxes.on({
                'change': function(event) {
                    var key = $(this).attr('id'),
                        category = Stencil.getAccessor(key),
                        checked = $(this).is(':checked');
                    if (checked === true) {
                        if (accessor.get('class') === 'resource') {
                            Stencil.once({
                                'resource/feature/complete': function(event) {
                                    App.getBusy().hide();
                                }
                            });
                        } else {
                            accessor.once({
                                'feature/complete': function(event) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                        var msg = Config.getMessage('admin.categories.apply');
                        App.getBusy().show(msg);
                        accessor.feature(category);
                    } else {
                        accessor.unfeature(category);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CheckoutModalView
     * 
     * @todo    Add in a tooltip/question-mark icon for when a coupon is added,
     *          but the coupon does not apply to both intervals (monthly and
     *          annually). Something so that when they toggle away, they get
     *          messaging informing them why the coupon they might be expecting
     *          isn't showing up.
     * @extends ModalView
     */
    window.CheckoutModalView = ModalView.extend({

        /**
         * _coupon
         * 
         * @access  protected
         * @var     null|CouponAccessor (default: null)
         */
        _coupon: null,

        /**
         * _events
         * 
         * @access  protected
         * @var     Object
         */
        _events: {

            /**
             * detect
             * 
             * @access  private
             * @param   jQuery event
             * @param   jQuery $input
             * @return  void
             */
            detect: function(event, $input) {
                var $wrapper = this.find('div.cards'),
                    $imgs = $wrapper.find('img');
                if ($input.hasClass('identified') === true) {
                    $imgs.addClass('faded');
                    if ($input.hasClass('visa') === true) {
                        $wrapper.find('.visa').removeClass('faded');
                    } else if ($input.hasClass('mastercard') === true) {
                        $wrapper.find('.mastercard').removeClass('faded');
                    } else if ($input.hasClass('amex') === true) {
                        $wrapper.find('.amex').removeClass('faded');
                    } else {
                        $wrapper.find('.unknown').removeClass('faded');
                    }
                } else {
                    $imgs.removeClass('faded');
                }
            }
        },

        /**
         * _form
         * 
         * @access  protected
         * @var     null|CreditCardAppFormView (default: null)
         */
        _form: null,

        /**
         * _interval
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _interval: 'monthly',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keyup: {
                    '[data-stripe="number"]': this._events.detect
                },
                click: {
                    '.input div.cards': function(event, $cards) {
                        $cards.parent().find('input').focus();
                    },
                    '.toggler:not([disabled]) .monthly': function(event, $toggler) {
                        event.preventDefault();
                        var path = this.getPath('monthly');
                        Stencil.navigate(path);
                    },
                    '.toggler:not([disabled]) .status': function(event, $status) {
                        event.preventDefault();
                        var $toggler = $status.parent();
                        if ($toggler.hasClass('monthly') === true) {
                            var path = this.getPath('annually');
                            Stencil.navigate(path);
                        } else {
                            var path = this.getPath('monthly');
                            Stencil.navigate(path);
                        }
                    },
                    '.toggler:not([disabled]) .annually': function(event, $toggler) {
                        event.preventDefault();
                        var path = this.getPath('annually');
                        Stencil.navigate(path);
                    }
                }
            });
        },

        /**
         * _plan
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _plan: null,

        /**
         * _promotions
         * 
         * @access  protected
         * @var     Array
         */
        _promotions: {
            monthly: {
                refund: {
                    icon: 'fa-certificate',
                    copy: '7-Day Money Back',
                    tooltip: 'Cancel any time within 7 days to get a full refund.'
                }
            },
            annually: {
                refund: {
                    icon: 'fa-certificate',
                    copy: '7-Day Money Back',
                    tooltip: 'Cancel any time within 7 days to get a full refund.'
                },
                auto: {
                    icon: 'fa-calendar',
                    copy: 'Yearly Discount ([rate]% off)'
                }
            }
        },

        /**
         * _rates
         * 
         * @access  protected
         * @var     Object
         */
        _rates: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CheckoutModalView')
         */
        _string: 'CheckoutModalView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String plan
         * @param   String interval
         * @param   String type
         * @return  void
         */
        init: function(element, plan, interval, type) {
            this._super(element);
            this._type = type;
            this._trackCheckoutView();

            // Get the rates
            var rates = Account.rates.raw();
            this._rates = {
                pro: {
                    monthly: {
                        account: rates.monthly.pro,
                        current: rates.monthly.pro
                    },
                    annually: {
                        account: rates.annually.pro,
                        current: rates.annually.pro
                    }
                },
                unlimited: {
                    monthly: {
                        account: rates.monthly.unlimited,
                        current: rates.monthly.unlimited
                    },
                    annually: {
                        account: rates.annually.unlimited,
                        current: rates.annually.unlimited
                    }
                }
            };

            // Plan + create card form
            this._plan = plan;
            this._form = new CreditCardAppFormView(this.find('form'));
            if (User.blockedFromCheckout() === true) {
                this._form.unbind('card/submit');
                this._form.on({
                    'card/submit': function(event) {
                        Stencil.alert('users.checkout.blocked');
                    }
                });
            }
            this._form.setHandlerDelay(0);

            // Pausing/unpausing
            this._form.on({
                'card/submitted': this.pause.proxy(this),
                'card/returned': this.unpause.proxy(this),
                'submitted': this.pause.proxy(this),
                'returned': this.unpause.proxy(this),
                'coupon/remove': this.removeCoupon.proxy(this)
            });

            // Success
            var _this = this;
            this._form.unbind('returned/failed');
            this._form.on({
                'returned/failed': function(event, response) {
                    if (response.error && response.error.code) {
                        Track.event('Checkout failed', {
                            _errorCode: response.error.code
                        });
                    }
                    this.find('a.button').enable();
                    if (response.failedRules) {
                        var error = this.getError(response);
                        this.showError(error);
                    } else {
                        this.showError(response.error);
                    }
                },
                'returned/succeeded': function(event, response) {
                    var accountData = response.data.account,
                        userData = response.data.user;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    Stencil.account().merge(accountData);
                    Stencil.get('user').merge(userData);
                    var stripe = response.data.checkout.stripe;
                    User.upgrade(stripe);
                    var path = Stencil.account().getUpgradedPath();
                    if (_this._type !== 'curtain') {
                        _this.triggerHandler('leave');
                        Stencil.navigate(path);
                    } else {
                        _this._element.addClass('transition');
                        (function() {
                            App.getElement().removeClass('curtain');
                            _this.triggerHandler('leave');
                            Stencil.navigate(path);
                        // }).delay(1800);
                        }).delay(0);
                    }
                }
            });

            // Calculate annually discount rate
            var rate = (1 - (this._rates[this._plan].annually.account /
                (this._rates[this._plan].monthly.account * 12)
            )) * 100;
            this._promotions.annually.auto.copy = 'Yearly Discount (' +
                Math.round(rate) + '% off)';

            // Tooltips
            this._setupTooltips();

            // Clean up (because of how extend.js works, need to clear vars)
            this.removeCoupon();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * _trackCheckoutView
         * 
         * @access  protected
         * @return  void
         */
        _trackCheckoutView: function() {
            var user = Stencil.get('user');
            user.push('hasSeenCheckout', 1);
        },

        /**
         * getPath
         * 
         * @access  public
         * @param   String interval (default: false)
         * @return  String
         */
        getPath: function(interval) {
            interval = DataUtils.getDefaultValue(interval, false);
            if (interval === false) {
                interval = this._interval;
            }
            var path = '/app/checkout';
            path += '/' + (this._plan);
            path += '/' + (interval);
            if (this._type === 'curtain') {
                path += '?curtain';
            }
            return path;
        },

        /**
         * getPlan
         * 
         * @access  public
         * @return  String
         */
        getPlan: function() {
            return this._plan;
        },

        /**
         * getType
         * 
         * @access  public
         * @return  null|String
         */
        getType: function() {
            return this._type;
        },

        /**
         * interval
         * 
         * @access  public
         * @param   String interval
         * @return  void
         */
        interval: function(interval) {
            var $interval = this.find('input[name="data[interval]"]'),
                $coupon = this.find('input[name="data[coupon]"]');
            $interval.val(interval);
            $coupon.val('');
            this.find('.toggler').removeClass('monthly');
            this.find('.toggler').removeClass('annually');
            this.find('.toggler').addClass(interval);
            this._interval = interval;
            var plan = this._plan,
                type = this._type,
                path = '/app/checkout/' + (plan) + '/' + (interval) + '/coupon';
            if (type === 'curtain') {
                path += '?curtain';
            }
            this.find('[lookup="addCouponCode"]').attr('href', path);
            if (this._coupon) {
                if (this._coupon.get('interval') === 'both') {
                    $coupon.val(this._coupon.get('code'));
                } else {
                    if (this._coupon.get('interval') === interval) {
                        $coupon.val(this._coupon.get('code'));
                    }
                }
            }
            this.refresh();
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._super();
            this.find('div.toggler').disable();
            this.find('section.actions a').disable();
            this.find('section.actions').addClass('invisible');
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            this.update.button.apply(this);
            this.update.explanation.apply(this);
            this.update.promotions.apply(this);
            this.update.rate.after.apply(this);
            this.update.rate.before.apply(this);
        },

        /**
         * removeCoupon
         * 
         * @access  public
         * @return  void
         */
        removeCoupon: function() {
            var $coupon = this.find('input[name="data[coupon]"]');
            $coupon.val('');
            this.find('aside section.actions .add').removeClass('hidden');
            this.find('aside section.actions .remove').addClass('hidden');
            this._coupon = null;
            delete this._promotions.monthly.trial;
            delete this._promotions.annually.trial;
            delete this._promotions.monthly.discount;
            delete this._promotions.annually.discount;
            this._rates[this._plan].monthly.current = this._rates[this._plan].monthly.account;
            this._rates[this._plan].annually.current = this._rates[this._plan].annually.account;
            this.refresh();
        },

        /**
         * setCoupon
         * 
         * @access  public
         * @param   CouponAccessor coupon
         * @return  void
         */
        setCoupon: function(coupon) {

            // UI
            // this.find('[name="data[coupon]"]').val(coupon.get('key'));
            this.find('aside section.actions .add').addClass('hidden');
            this.find('aside section.actions .remove').removeClass('hidden');

            // Data
            this._coupon = coupon;
            this.find('input[name="data[coupon]"]').val(coupon.get('code'));

            // Interval
            if (this._coupon.get('interval') !== 'both') {
                this.interval(this._coupon.get('interval'));
            }

            // Trial
            var promotion;
            delete this._promotions.monthly.trial;
            delete this._promotions.annually.trial;
            if (this._coupon.get('trial').toInt() !== 0) {
                var days = this._coupon.get('trial');
                promotion = {
                    icon: 'fa-clock-o',
                    copy: (days) + ' Day Free Trial Applied',
                    tooltip: 'You will not be charged until your trial expires'
                };
                if (this._coupon.get('interval') === 'both') {
                    this._promotions.monthly.trial = promotion;
                    this._promotions.annually.trial = promotion;
                } else {
                    this._promotions[this._coupon.get('interval')].trial = promotion;
                }
            }

            // Discount
            delete this._promotions.monthly.discount;
            delete this._promotions.annually.discount;
            if (
                this._coupon.get('amount').toInt() !== 0
                || this._coupon.get('percentage').toInt() !== 0
            ) {
                // Cleanup
                promotion = {};

                // Amount
                if (this._coupon.get('amount').toInt() !== 0) {
                    if (this._coupon.get('frequency') === 'continuous') {
                        promotion = {
                            icon: 'fa-tag',
                            copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                ' Discount Applied'
                        };
                    } else {
                        if (this._coupon.get('duration').toInt() === 1) {
                            promotion = {
                                icon: 'fa-tag',
                                copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                    ' Discount Applied (for 1st [interval])'
                            };
                        } else {
                            promotion = {
                                icon: 'fa-tag',
                                copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                    ' Discount Applied (for first ' +
                                    (this._coupon.get('duration')) + ' [interval]s)'
                            };
                        }
                    }
                }
                // Percentage
                else {
                    if (this._coupon.get('frequency') === 'continuous') {
                        promotion = {
                            icon: 'fa-tag',
                            copy: (this._coupon.get('percentage')) +'% Discount ' +
                                'Applied'
                        };
                    } else {
                        if (this._coupon.get('duration').toInt() === 1) {
                            promotion = {
                                icon: 'fa-tag',
                                copy: (this._coupon.get('percentage')) +'% Discount ' +
                                    'Applied (for 1st [interval])'
                            };
                        } else {
                            promotion = {
                                icon: 'fa-tag',
                                copy: (this._coupon.get('percentage')) +'% Discount ' +
                                    'Applied (for first ' +
                                    (this._coupon.get('duration')) + ' [interval]s)'
                            };
                        }
                    }
                }

                // Let's do this
                if (this._coupon.get('interval') === 'both') {
                    this._promotions.monthly.discount = jQuery.extend({}, promotion);
                    this._promotions.monthly.discount.copy = this._promotions.monthly.discount.copy.replace(
                        '[interval]', 'month'
                    );
                    this._promotions.annually.discount = jQuery.extend({}, promotion);
                    this._promotions.annually.discount.copy = this._promotions.annually.discount.copy.replace(
                        '[interval]', 'year'
                    );
                } else {
                    var interval = this._coupon.get('interval');
                    this._promotions[interval].discount = jQuery.extend({}, promotion);
                    this._promotions[interval].discount.copy = this._promotions[interval].discount.copy.replace(
                        '[interval]',
                        (interval === 'monthly' ? 'month' : 'year')
                    );
                }

                // Discount data
                if (this._coupon.get('amount').toInt() !== 0) {
                    if (this._coupon.get('interval') === 'both') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account - this._coupon.get('amount'));
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account - this._coupon.get('amount'));
                    } else if (this._coupon.get('interval') === 'monthly') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account - this._coupon.get('amount'));
                    } else if (this._coupon.get('interval') === 'annually') {
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account - this._coupon.get('amount'));
                    }
                } else if (this._coupon.get('percentage').toInt() !== 0) {
                    var rate = 1 - (this._coupon.get('percentage').toInt() / 100);
                    if (this._coupon.get('interval') === 'both') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account * rate);
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account * rate);
                    } else if (this._coupon.get('interval') === 'monthly') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account * rate);
                    } else if (this._coupon.get('interval') === 'annually') {
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account * rate);
                    }
                }
            }


            // Refresh UI
            this.refresh();
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._super();
            this.find('div.toggler').enable();
            this.find('section.actions a').enable();
            this.find('section.actions').removeClass('invisible');
        },

        /**
         * update
         * 
         * @access  public
         * @var     Object
         */
        update: {

            /**
             * button
             * 
             * @access  public
             * @return  void
             */
            button: function() {
                var copy = 'Upgrade to PRO';
                if (this._plan === 'unlimited') {
                    copy = 'Upgrade to UNLIMITED';
                }
                if (
                    this._coupon
                    && this._coupon.get('trial')
                    && this._coupon.get('trial').toInt() !== 0
                ) {
                    if (
                        this._coupon.get('interval') === 'both'
                        || this._coupon.get('interval') === this._interval
                    ) {
                        copy = 'Start free trial';
                    }
                }
                this.find('a.button .copy').text(copy);
            },

            /**
             * explanation
             * 
             * @access  public
             * @return  void
             */
            explanation: function() {

                /**
                 * Amount
                 * 
                 */

                // Charge amount + interval
                var plan = this._plan,
                    amount = this._rates[this._plan][this._interval].current,
                    explanation = 'You\'ll be charged [$' +
                        (amount.centsToDollars(true)) + '] ';
                if (this._interval === 'monthly') {
                    explanation += '[/mo]';
                } else if (this._interval === 'annually') {
                    explanation += '[/yr]';
                }

                /**
                 * Conditions
                 * 
                 */
                if (this._coupon && this._coupon.get('key')) {
                    if (
                        this._coupon.get('frequency') === 'limited'
                        && (
                            this._coupon.get('interval') === 'both' ||
                            this._coupon.get('interval') === this._interval
                        )
                    ) {
                        var shorter = this._interval === 'monthly'
                                ? 'mo'
                                : 'yr',
                            longer = shorter === 'mo' ? 'month' : 'year';
                        if (this._coupon.get('duration').toInt() === 1) {
                            explanation += ' ';
                            explanation += '(for the 1st ' + (longer) + '; ' +
                                '$X /' + (shorter) + ' after that)';
                        } else {
                            explanation += ' ';
                            explanation += '(for the first ' +
                                (this._coupon.get('duration')) + ' ' + (longer) +
                                's; $X /' + (shorter) + ' after that)';
                        }

                        // Amount
                        explanation = explanation.replace(
                            '$X',
                            '$'  + (this._rates[this._plan][this._interval].account.centsToDollars(true))
                        );
                    }
                }

                /**
                 * Trial
                 * 
                 */

                // Trial
                var when;
                if (
                    this._coupon
                    && this._coupon.get('trial')
                    && this._coupon.get('trial').toInt() !== 0
                ) {
                    if (
                        this._coupon.get('interval') === 'both'
                        || this._coupon.get('interval') === this._interval
                    ) {
                        when = moment().add(this._coupon.get('trial'), 'days').format(
                            'MMMM Do, YYYY'
                        );
                        explanation += ' when your trial ends on [' + (when) + ']';
                    }
                }

                // Trailing period
                explanation += '[.]';

                /**
                 * Formatting
                 * 
                 */

                // Replacements
                explanation = explanation.replace(/\[/g, '<strong>');
                explanation = explanation.replace(/\]/g, '</strong>');

                /**
                 * DOM Update
                 * 
                 */

                // DOM
                this.find('div.explanation').html(explanation);
            },

            /**
             * promotions
             * 
             * @access  public
             * @return  void
             */
            promotions: function() {
                var _this = this;
                this._element.find('section.promotions').empty();
                jQuery.each(this._promotions[this._interval],
                    function(index, promotion) {
                        var $promotion = DataUtils.render('CheckoutPromotion', {
                            icon: promotion.icon,
                            copy: promotion.copy,
                            tooltip: promotion.tooltip || false
                        });
                        _this._element.find('section.promotions').append(
                            $promotion
                        );
                    }
                );
            },

            /**
             * rate
             * 
             * @access  public
             * @var     Object
             */
            rate: {

                /**
                 * after
                 * 
                 * @access  public
                 * @return  void
                 */
                after: function() {
                    var $before = this.find('section.pricing div.after'),
                        $dollar = $before.find('.dollar'),
                        $cents = $before.find('.cents'),
                        $interval = $before.find('.interval'),
                        interval = this._interval,
                        breakdown,
                        dollar,
                        cents;
                    if (interval === 'monthly') {
                        breakdown = this._rates[this._plan].monthly.current;
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    } else {
                        breakdown = Math.round(this._rates[this._plan].annually.current / 12);
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    }
                },

                /**
                 * before
                 * 
                 * @note    This should always show pricing relative to monthly
                 *          rates
                 * @access  public
                 * @return  void
                 */
                before: function() {
                    var plan = this._plan,
                        $before = this.find('section.pricing div.before'),
                        $dollar = $before.find('.dollar'),
                        $cents = $before.find('.cents'),
                        $interval = $before.find('.interval'),
                        interval = this._interval,
                        breakdown,
                        dollar,
                        cents;
                    if (
                        interval === 'monthly'
                        && this._rates[this._plan].monthly.account === this._rates[this._plan].monthly.current
                    ) {
                        $dollar.text('');
                        $cents.text('');
                        $interval.text('');
                    } else {
                        breakdown = this._rates[this._plan].monthly.account;
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    }
                }
            }
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ChromeExtensionInstalledModalView
     * 
     * @extends ModalView
     */
    window.ChromeExtensionInstalledModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChromeExtensionInstalledModalView')
         */
        _string: 'ChromeExtensionInstalledModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
});
window.DependencyLoader.push('ConfirmModalView', function() {

    /**
     * ClearCanvasConfirmModalView
     * 
     * @events  yes
     *          no
     * @extends ConfirmModalView
     */
    window.ClearCanvasConfirmModalView = ConfirmModalView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {
                    'input[type="checkbox"]:checked': function(event, $input) {
                        Stencil.account().userAccount().push(
                            'settings.canvasClearWatermarks',
                            '1'
                        );
                    },
                    'input[type="checkbox"]:not(:checked)': function(event, $input) {
                        Stencil.account().userAccount().push(
                            'settings.canvasClearWatermarks',
                            '0'
                        );
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ClearCanvasConfirmModalView')
         */
        _string: 'ClearCanvasConfirmModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * clearWatermarks
         * 
         * Returns whether any drawn Watermark layers should be cleared from the
         * canvas.
         * 
         * @access  public
         * @return  Boolean
         */
        clearWatermarks: function() {
            var key = 'canvasClearWatermarks';
            return Stencil.account().userAccount() !== undefined
                && Stencil.account().userAccount().setting(key).toInt() === 1;
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CreateCollectionModalView
     * 
     * @events  save
     * @extends ModalView
     */
    window.CreateCollectionModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CreateCollectionModalView')
         */
        _string: 'CreateCollectionModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned/failed': function(event) {
                    _this.unpause();
                },
                'returned/shit': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    _this.triggerHandler('save', [response.data.object]);
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ConfirmModalView
     * 
     * @events  yes
     *          no
     * @extends ModalView
     */
    window.ConfirmModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConfirmModalView')
         */
        _string: 'ConfirmModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ConfirmMobileModalView
     * 
     * @extends ModalView
     */
    window.ConfirmMobileModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConfirmMobileModalView')
         */
        _string: 'ConfirmMobileModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, shareModal, image) {
            this._super(element);
            this._shareModal = shareModal;
            this._setupForm();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = image.getSharePath('instagram');
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.unbind('returned/succeeded');
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned/failed': function(event) {
                    _this.unpause();
                },
                'returned/shit': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event) {
                    this.find('a.button').addClass('busy');
                    this.disable();
                    var network = _this._shareModal.getNetwork('instagram'),
                        form = network.getForm();
                    form.triggerHandler('submit');
                    form.once({
                        'returned/succeeded': function(event, response) {
                            var modal = ModalUtils.get('ImageSent');
                            modal.find('h1.first').addClass('hidden');
                            modal.find('h1.second').removeClass('hidden');
                        }
                    });
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ConnectionsModalView
     * 
     * @extends ModalView
     */
    window.ConnectionsModalView = ModalView.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|Collection (default: null)
         */
        _collection: null,

        /**
         * _network
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _network: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionsModalView')
         */
        _string: 'ConnectionsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String network
         * @return  void
         */
        init: function(element, network) {
            this._super(element);
            this._collection = Stencil.account().collection('connections');
            var _this = this;
            this._collection.on({
                'remove': function(event, accessor) {
                    _this.refresh();
                }
            });
            this._network = network;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/settings/social');
                }
            });
            this._drawConnections();
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }
        },

        /**
         * _drawConnection
         * 
         * @access  protected
         * @param   ConnectionAccessor connection
         * @param   Number position
         * @return  void
         */
        _drawConnection: function(connection, position) {
            var $list = this.find('div.list');
                $connection = DataUtils.render('ConnectionRow', {
                    connection: connection
                });
            if (position === 0) {
                $list.prepend($connection);
            } else {
                $list.append($connection);
            }
            new ConnectionRowView($connection, connection);
        },

        /**
         * _drawConnections
         * 
         * @access  protected
         * @return  void
         */
        _drawConnections: function() {
            var _this = this,
                connections = this._collection.network(this._network);
            jQuery.each(connections, function(index, connection) {
                _this._drawConnection(connection, index);
            });
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            // var resize = function() {
            //     $element.data('jsp').reinitialise();
            // };
            // $(window).resize(resize);
            // this.on({
            //     'destroy': function(event) {
            //         $(window).unbind('resize', resize);
            //     }
            // });
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            var $list = this.find('div.list');
            this._makeScrollable($list);
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CookiesModalView
     * 
     * @extends ModalView
     */
    window.CookiesModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CookiesModalView')
         */
        _string: 'CookiesModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('StickyModalView', function() {

    /**
     * CountdownModalView
     * 
     * @events  open/facebook/share
     * @extends StickyModalView
     */
    window.CountdownModalView = StickyModalView.extend({

        /**
         * _intervals
         * 
         * Keeps track of tweet/follow windows to prevent a bug whereby clicking
         * the tweet/follow link multiple times result in multiple intervals*
         * being created, which results in multiple callbacks firing (which,
         * resulted in 3, 6, 9, 12+ images being added as bonus to the user).
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _intervals: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CountdownModalView')
         */
        _string: 'CountdownModalView',

        /**
         * init
         * 
         * Width is set explicitly below when no <aside> tag can be found
         * because of issues with detecting the width of the modal. The modal
         * width can't be set since it's variable. But when that's the case, the
         * position method in the parent can't tell how wide the content is
         * _right_ after it's inserted into the DOM. Therefore I need to set it
         * explicitly.
         * 
         * @access  public
         * @param   jQuery element
         * @param   String direction
         * @param   jQuery $relative
         * @param   jQuery $highlight
         * @return  void
         */
        init: function(element, direction, $relative, $highlight) {
            if (element.find('aside').length === 0) {
                element.find('.content').first().css({
                    width: 335
                });
            }
            this._super(element, direction, $relative, $highlight);
            Scripts.load('facebook');
            this.on({
                'open/facebook/share': this._showFacebookShareDialog,
                'open/tweet': this._showTweet,
                'open/follow': this._showFollow
            });
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
        },

        /**
         * _getFacebookShareObject
         * 
         * @note    Specifying source attribute below shows slimmer preview:
         *          https://i.imgur.com/Ujfytbm.png
         * @see     http://stackoverflow.com/questions/20798314/using-facebooks-api-to-post-a-video-using-the-feed-dialog-fails
         * @access  protected
         * @return  Object
         */
        _getFacebookShareObject: function() {
            var share = Config.get('shares')['countdown.facebook'],
                shareObject = {
                    display: 'popup',
                    method: 'feed',
                    name: share.title,
                    description: share.description,
                    link: share.url,
                    picture: share.picture
                };
            return shareObject;
        },

        /**
         * _getTweetUrl
         * 
         * @access  protected
         * @return  String
         */
        _getTweetUrl: function() {
            var share = Config.get('shares')['countdown.twitter'],
                url = share.url,
                text = encodeURIComponent(share.message),
                tweetUrl = 'https://twitter.com/intent/tweet' +
                    '?url=' + (url) +
                    '&via=' + (share.via) +
                    '&text=' + (text);
            return tweetUrl;
        },

        /**
         * _getTwitterFollowUrl
         * 
         * @access  protected
         * @return  String
         */
        _getTwitterFollowUrl: function() {
            var twitterFollowUrl = 'https://twitter.com/intent/follow?screen_name=getstencil';
            return twitterFollowUrl;
        },

        /**
         * _listenForWindowClose
         * 
         * @note    Chrome/Safari handle parent existence checks different
                    Chrome has it set to null; Safari has it set to undefined
         * @access  protected
         * @param   String type
         * @param   Object win
         * @param   Function callback
         * @return  void
         */
        _listenForWindowClose: function(type, win, callback) {
            if (this._intervals[type] !== undefined) {
                IntervalPool.clear(this._intervals[type]);
                delete this._intervals[type];
            }
            var check = function() {
                // var parent = win.parent;
                // var parent = win.opener;
                if (win.closed === true) {
                // if (parent === null || parent === undefined) {
                    IntervalPool.clear(this._intervals[type]);
                    delete this._intervals[type];
                    callback();
                }
            };
            this._intervals[type] = check.interval(500, this);
        },

        /**
         * _showFacebookShareDialog
         * 
         * @access  protected
         * @return  Boolean
         */
        _showFacebookShareDialog: function() {
            if (Config.serviceAvailable('facebook') === false) {
                Stencil.alert('services.facebook.unavailable');
                return false;
            }
            if (Scripts.loaded('facebook') === false) {
                Scripts.waitFor('facebook');
                return false;
            }
            var _this = this,
                shareObject = this._getFacebookShareObject(),
                dialogShown = ClientWrappers.get('facebook').showShareDialog(
                    shareObject,
                    function(response) {
                        if (response !== undefined) {
                            _this._successfulShare();
                        }
                    }
                );
            return dialogShown;
        },

        /**
         * _showFollow
         * 
         * @access  protected
         * @return  void
         */
        _showFollow: function() {
            var win = window.open(
                this._getTwitterFollowUrl(),
                'Follow',
                'width=552, height=522'
            );
            this._listenForWindowClose(
                'follow',
                win,
                this._successfulFollow.proxy(this)
            );
        },

        /**
         * _showTweet
         * 
         * @access  protected
         * @return  void
         */
        _showTweet: function() {
            var win = window.open(
                this._getTweetUrl(),
                'Tweet',
                'width=552, height=522'
            );
            this._listenForWindowClose(
                'tweet',
                win,
                this._successfulTweet.proxy(this)
            );
        },

        /**
         * _successfulFollow
         * 
         * @access  protected
         * @param   Object obj
         * @return  void
         */
        _successfulFollow: function(obj) {
            var account = Stencil.account();
            account.set({
                followBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['followBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        },

        /**
         * _successfulTweet
         * 
         * @access  protected
         * @param   Object obj
         * @return  void
         */
        _successfulTweet: function(obj) {
            var account = Stencil.account();
            account.set({
                tweetBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['tweetBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        },

        /**
         * _successfulShare
         * 
         * @access  protected
         * @return  void
         */
        _successfulShare: function() {
            var account = Stencil.account();
            account.set({
                shareBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['shareBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        }
    });
});
window.DependencyLoader.push('AddRecordModalView', function() {

    /**
     * AddCouponModalView
     * 
     * @extends AddRecordModalView
     */
    window.AddCouponModalView = AddRecordModalView.extend({

        /**
         * _fallbackPath
         * 
         * @access  protected
         * @var     String (default: '/app/admin/coupons')
         */
        _fallbackPath: '/app/admin/coupons',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddCouponModalView')
         */
        _string: 'AddCouponModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element, adminModal);
        },

        /**
         * _formatCode
         * 
         * @access  protected
         * @return  void
         */
        _formatCode: function() {
            var $code = this.find('[name="data[code]"]'),
                value = $code.val(),
                formatted = value.toUpperCase();
            $code.val(formatted);
        },

        /**
         * _formatDiscount
         * 
         * @access  protected
         * @return  void
         */
        _formatDiscount: function() {
            var $discount = this.find('#discount'),
                discount = $discount.val(),
                $amount = this.find('[name="data[amount]"]'),
                $percentage = this.find('[name="data[percentage]"]');
            if (discount.indexOf('$') !== -1) {
                discount = discount.replace('$', '');
                discount = discount.toFloat() * 100;
                $amount.val(discount);
            } else if (discount.indexOf('%') !== -1) {
                discount = discount.replace('%', '').toFloat();
                $percentage.val(discount);
            }
        },

        /**
         * _formatDuration
         * 
         * @access  protected
         * @return  void
         */
        _formatDuration: function() {
            var $frequency = this.find('[name="data[frequency]"]'),
                $duration = this.find('#duration');
            if ($frequency.val() === 'limited') {
                this.find('[name="data[duration]"]').val(
                    $duration.val()
                );
            }
        },

        /**
         * _formatExpiry
         * 
         * Converts the expiry input value from a human-readable one to a unix
         * timestamp (milliseconds excluded).
         * 
         * @access  protected
         * @return  void
         */
        _formatExpiry: function() {
            var $expiry = this.find('#expiry'),
                expiry = $expiry.val(),
                mo = moment(expiry, 'MM/DD/YYYY h:mm A');
            this.find('[name="data[expiry]"]').val(
                mo.format('X')
            );
        },

        /**
         * _formatFormData
         * 
         * @note    After cleanup, did not confirm whether the order of the
         *          format calls below matter. Likely not, but heads up.
         * @access  protected
         * @return  void
         */
        _formatFormData: function() {
            this._formatCode();
            this._formatExpiry();
            this._formatDiscount();
            this._formatDuration();
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            var _this = this;
            this._super();
            var $frequency = this.find('select[name="data[frequency]"]');
            $frequency.change(
                function(event) {
                    var val = $(this).val(),
                        $duration = _this.find('#duration'),
                        $field = $duration.closest('div.field');
                    $field.addClass('hidden');
                    if (val === 'limited') {
                        $field.removeClass('hidden');
                    }
                }
            );
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._super();
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Coupon added');
                    var collection = _this._adminModal.getSection('coupons')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/coupons');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ApplyCouponModalView
     * 
     * @extends ModalView
     */
    window.ApplyCouponModalView = ModalView.extend({

        /**
         * _checkoutModal
         * 
         * @access  protected
         * @var     null|CheckoutModalView (default: null)
         */
        _checkoutModal: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ApplyCouponModalView')
         */
        _string: 'ApplyCouponModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CheckoutModalView checkoutModal
         * @return  void
         */
        init: function(element, checkoutModal) {
            this._super(element);
            this._checkoutModal = checkoutModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = checkoutModal.getPath();
                    Stencil.navigate(path);
                }
            });
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this._checkoutModal.pause();
                    _this.pause();
                }
            });
            this._form.on({
                'returned': function(event) {
                    _this._checkoutModal.unpause();
                    _this.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Coupon'),
                        coupon = model.setAccessor(response.data.coupon);
                    Track.event('Coupon applied');
                    _this._checkoutModal.setCoupon(coupon);
                    this.find('input[name="data[code]"]').attr('readonly', true);
                    _this.triggerHandler.delay(1000, _this, ['leave']);
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CropDownloadModalView
     * 
     * @extends ModalView
     */
    window.CropDownloadModalView = ModalView.extend({

        /**
         * _cropPositionData
         * 
         * @access  protected
         * @var     Object
         */
        _cropPositionData: {},

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="radio"][name="data[contentType]"]': function(event, $input) {
                        var $basename = this.find('[name="data[basename]"]'),
                            value = $basename.val().trim(),
                            contentType = this._getContentType(),
                            extension = 'jpg',
                            cleaned;
                        if (contentType === 'image/png') {
                            extension = 'png';
                        } else if (contentType === 'image/gif') {
                            extension = 'gif';
                        }
                        cleaned = value.replace(/\.[a-z]{3,4}$/i, '.' + extension);
                        $basename.val(cleaned);
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('download');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CropDownloadModalView')
         */
        _string: 'CropDownloadModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String key
         * @param   Object cropPositionData
         * @return  void
         */
        init: function(element, key, cropPositionData) {
            this._super(element);
            this._key = key;
            this._cropPositionData = cropPositionData;
            this._addDownloadListener();
            this._addEscapeEvent();
            this._cleanModalLeaveEvent();
            this._setupTooltips();
        },

        /**
         * _ad_addDownloadListenerdDownloadListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadListener: function() {
            this.on({
                'download': function(event) {
                    this._remoteDownloadAction();
                }
            });
        },

        /**
         * _addEscapeEvent
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeEvent: function() {
            var callback = this._closeByEscapeKeyEvent.proxy(this);
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _blurBasename
         * 
         * @access  protected
         * @return  void
         */
        _blurBasename: function() {
            var $input = this.find('input[name="data[basename]"]');
            $input.blur();
            if (DataUtils.valid(document.getSelection) === true) {
                var selection = document.getSelection();
                if (DataUtils.valid(selection.empty) === true) {
                    selection.empty();
                }
            }
        },

        /**
         * _cleanModalLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _cleanModalLeaveEvent: function() {
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        },

        /**
         * _closeByEscapeKeyEvent
         * 
         * @note    true must always be returned otherwise causes default
         *          actions will be suppressed
         * @access  protected
         * @param   jQuery event
         * @return  true
         */
        _closeByEscapeKeyEvent: function(event) {
            if (DataUtils.valid(event) === false) {
                return true;
            }
            if (DataUtils.valid(event.which) === false) {
                return true;
            }
            if (event.which.toInt() !== 27) {
                return true;
            }
            event.preventDefault();
            this.triggerHandler('close');
            return true;
        },

        /**
         * _disable
         * 
         * @access  protected
         * @return  void
         */
        _disable: function() {
            this.pause();
            var selector = [
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
            this.find('a.button').addClass('busy').disable();
        },

        /**
         * _enable
         * 
         * @access  protected
         * @return  void
         */
        _enable: function() {
            this.unpause();
            this.find('a.button').removeClass('busy').enable();
        },

        /**
         * _getBasename
         * 
         * @access  protected
         * @return  String
         */
        _getBasename: function() {
            var $basename = this.find('[name="data[basename]"]'),
                basename = $basename.val().trim(),
                $contentType = this.find('[name="data[contentType]"]:checked'),
                contentType = $contentType.val();

            // png
            if (contentType === 'image/png') {
                if (basename === '') {
                    basename = 'stencil.crop.png';
                    return basename;
                }
                if (basename.match(/\.png$/) === null) {
                    return basename.replace(/\.[a-z]{3,}$/i, '') + '.png';
                }
                return basename;
            }

            // jpeg
            if (contentType === 'image/jpeg') {
                if (basename === '') {
                    basename = 'stencil.crop.jpg';
                    return basename;
                }
                if (basename.match(/\.jpg$/) === null) {
                    return basename.replace(/\.[a-z]{3,}$/i, '') + '.jpg';
                }
                return basename;
            }

            // gif
            if (basename === '') {
                basename = 'stencil.crop.gif';
                return basename;
            }
            if (basename.match(/\.gif$/) === null) {
                return basename.replace(/\.[a-z]{3,}$/i, '') + '.gif';
            }
            return basename;
        },

        /**
         * _getContentType
         * 
         * @access  protected
         * @return  String
         */
        _getContentType: function() {
            return this.find('[name="data[contentType]"]:checked').val();
        },

        /**
         * _getCropDownloadPath
         * 
         * @access  protected
         * @return  String
         */
        _getCropDownloadPath: function() {
            var key = this._key,
                path = '/media/' + (key) + '/crop/download',
                queryData = ModalUtils.get('Cropper')._getCropQueryData();
            queryData.data.basename = this._getBasename();
            queryData.data.contentType = this._getContentType();
            queryData.data.mediaType = this._getMediaType();
            var queryDataString = StringUtils.getQueryDataString(queryData);
            path = (path) + '?' + (queryDataString);
            return path;
        },

        /**
         * _getMediaType
         * 
         * @access  protected
         * @return  String
         */
        _getMediaType: function() {
            return this.find('[name="data[mediaType]"]:checked').val();
        },

        /**
         * _remoteDownloadAction
         * 
         * @access  protected
         * @return  void
         */
        _remoteDownloadAction: function() {
            this._disable();
            var _this = this,
                downloadPath = this._getCropDownloadPath(),
                cookieKey = 'crop.download',
                alertKey = 'clients.electron.crop.download.complete',
                $input = this.find('input[name="data[basename]"]');
            this._blurBasename();
            Stencil.once({
                'redirect/complete': function(event) {
                    _this.triggerHandler('close');
                    if (UserAgentUtils.is.electron() === true) {
                        Stencil.alert(alertKey);
                    }
                }
            });
            DownloadUtils.attemptDownload(downloadPath, cookieKey);
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function(copy) {
            this._super();
            var $input = this.find('input[type="text"]').first();
            ElementUtils.select($input);
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CropLinkModalView
     * 
     * @extends ModalView
     */
    window.CropLinkModalView = ModalView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {
                    'input': this.selectInput
                },
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                },
                keydown: {
                    'input': function(event) {
                        var which = event.which.toInt();
                        if (which === 8) {
                            event.preventDefault();
                        }
                    }
                }
            });
        },

        /**
         * _shortUrl
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _shortUrl: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CropLinkModalView')
         */
        _string: 'CropLinkModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addCopyEventListener();
            this._addEscapeEvent();
            this._cleanModalLeaveEvent();
            this._requestShortUrl();
            this._setupTooltips();
            this.ui.showHide.copy.apply(this);
        },

        /**
         * _addCopyEventListener
         * 
         * @access  protected
         * @return  void
         */
        _addCopyEventListener: function() {
            this.on({
                'copy': function(event, $element) {
                    var $link = this.find('#link'),
                        $lookup = this.lookup('copy'),
                        content = $link.val();
                    DataUtils.copyToClipboard(content);
                    ElementUtils.changeTooltip($lookup, 'Copied!');
                }
            });
        },

        /**
         * _addEscapeEvent
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeEvent: function() {
            var callback = this._closeByEscapeKeyEvent.proxy(this);
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _cleanModalLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _cleanModalLeaveEvent: function() {
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        },

        /**
         * _closeByEscapeKeyEvent
         * 
         * @note    true must always be returned otherwise causes default
         *          actions will be suppressed
         * @access  protected
         * @param   jQuery event
         * @return  true
         */
        _closeByEscapeKeyEvent: function(event) {
            if (DataUtils.valid(event) === false) {
                return true;
            }
            if (DataUtils.valid(event.which) === false) {
                return true;
            }
            if (event.which.toInt() !== 27) {
                return true;
            }
            event.preventDefault();
            this.triggerHandler('close');
            return true;
        },

        /**
         * _requestCropUrl
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _requestCropUrl: function(callback) {
            var cropperModal = ModalUtils.get('Cropper');
            callback = callback.proxy(this);
            cropperModal.requestCropUrl(callback);
        },

        /**
         * _requestShortUrl
         * 
         * @access  protected
         * @return  void
         */
        _requestShortUrl: function() {
            this._requestCropUrl(function(url) {
                var _this = this,
                    request = new ServerRequest(),
                    events = {
                        'success/false': function(event, response) {
                            _this.ui.failed.apply(_this);
                        },
                        'success/true': function(event, response) {
                            var shortUrl = response.data.shortUrl;
                            if (shortUrl === null) {
                                _this.ui.failed.apply(_this);
                            } else {
                                _this._shortUrl = shortUrl;
                                _this.ui.showHide.copy.apply(_this);
                                _this.find('input[id="link"]').val(shortUrl);
                                _this.find('div.fields.placeholder').removeClass('placeholder');
                                _this.find('input:not(.placeholder)').focus();
                            }
                        }
                    },
                    path = '/utils/urls/short',
                    data = {
                        'url': url
                    },
                    signature = {"basename":"CropLink.js","line":192};
                request.setOptions({
                    data: data,
                    events: events,
                    logFailedValidation: true,
                    path: path,
                    signature: signature
                });
                request.post();
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            var $contianer = App.getElement();
            this._element.tooltip({
                selector: '[tooltip]',
                container: $contianer,
                placement: 'bottom'
            });
        },

        /**
         * selectInput
         * 
         * @access  public
         * @return  void
         */
        selectInput: function() {
            var $input = this.find('input#link');
            ElementUtils.select($input);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function(copy) {
            this._super();
            this.selectInput();
        },

        /**
         * ui
         * 
         * @access  public
         * @var     Object
         */
        ui: {

            /**
             * failed
             * 
             * @access  public
             * @return  void
             */
            failed: function() {
                var $icon = this.find('div.icon.placeholder').find('> div'),
                    $input = this.find('input.placeholder');
                $icon.removeClass('fa-spin');
                $icon.removeClass('fa-refresh');
                $icon.addClass('fa-exclamation-circle');
                $input.attr('placeholder', 'Could not load share link');
            },

            /**
             * showHide
             * 
             * @access  public
             * @var     Object
             */
            showHide: {

                /**
                 * showHide
                 * 
                 * @access  public
                 * @return  Boolean
                 */
                copy: function() {
                    var $copy = this.find('.copy');
                    $copy.addClass('hidden');
                    if (UserAgentUtils.supports.clipboard.copy() === false) {
                        return false;
                    }
                    if (this._shortUrl === null) {
                        return false;
                    }
                    $copy.removeClass('hidden');
                    return true;
                }
            }
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * CropperModalView
     * 
     * @events  toggle/resizer
     *          resize
     * @see     https://github.com/fengyuanchen/cropperjs/blob/master/examples/crop-a-round-image.html
     * @see     https://github.com/fengyuanchen/cropperjs
     * @see     https://fengyuanchen.github.io/cropperjs/
     * @see     http://cloudinary.com/documentation/image_transformations
     * @see     https://caniuse.com/#feat=css-masks
     * @see     https://jsbin.com/jowizeboki/edit?html,output
     * @extends ModalView
     */
    window.CropperModalView = ModalView.extend({

        /**
         * _$contextMenuThumbRelative
         * 
         * @access  protected
         * @var     jQuery (default: null)
         */
        _$contextMenuThumbRelative: null,

        /**
         * _accessor
         * 
         * @access  protected
         * @var     null|MediaAccessor (default: null)
         */
        _accessor: null,

        /**
         * _allowTrimFunctionality
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _allowTrimFunctionality: false,

        /**
         * _bitmapImageLayer
         * 
         * @access  protected
         * @var     null|BitmapImageLayer (default: null)
         */
        _bitmapImageLayer: null,

        /**
         * _cropBoxProperties
         * 
         * @access  protected
         * @var     Object
         */
        _cropBoxProperties: {
            aspectRatio: 1.5,
            locked: 0,
            shape: 'rectangle',
            styles: {
                radius: '0'
            }
        },

        /**
         * _cropDownloadModal
         * 
         * @access  protected
         * @var     null|CropDownloadModalView (default: null)
         */
        _cropDownloadModal: null,

        /**
         * _cropLinkModal
         * 
         * @access  protected
         * @var     null|CropLinkModalView (default: null)
         */
        _cropLinkModal: null,

        /**
         * _cropper
         * 
         * @access  protected
         * @var     null|Cropper (default: null)
         */
        _cropper: null,

        /**
         * _defaultCropAreaRatio
         * 
         * @access  protected
         * @var     Number (default: 0.6)
         */
        _defaultCropAreaRatio: 0.6,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|Image (default: null)
         */
        _image: null,

        /**
         * _imageBoundingBox
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _imageBoundingBox: null,

        /**
         * _key
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _key: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                contextmenu: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @return  void
                     */
                    '.outer': function(event) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _maxWindowDimensions
         * 
         * @access  protected
         * @var     Object
         */
        _maxWindowDimensions: {
            width: 1600,
            height: 1600
        },

        /**
         * _maxWindowRatios
         * 
         * @access  protected
         * @var     Object
         */
        _maxWindowRatios: {
            width: 0.7,
            height: 0.62
        },

        /**
         * _minCropBoxDimensions
         * 
         * @access  protected
         * @var     Object
         */
        _minCropBoxDimensions: {
            width: 40,
            height: 40
        },

        /**
         * _minImageDimensions
         * 
         * @access  protected
         * @var     Object
         */
        _minImageDimensions: {
            width: 150,
            height: 50
        },

        /**
         * _reCrop
         * 
         * @access  protected
         * @var     null|Boolean (default: null)
         */
        _reCrop: null,

        /**
         * _resetThresholdRatio
         * 
         * This number represents the ratio (or perecentage) value that is used
         * in calculating whether or not a crop action should be considered a
         * reset, which would remove cropPositionData from the associated layer.
         * 
         * It's worth nothing that this is only used/applicable when a cropping
         * action is initiated via a toolbar.
         * 
         * @access  protected
         * @var     Number (default: 0.015)
         */
        _resetThresholdRatio: 0.015,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CropperModalView')
         */
        _string: 'CropperModalView',

        /**
         * _trimThresholdRatio
         * 
         * This number represents the ratio (or perecentage) value that is used
         * in calculating whether or not the trim feature should be available.
         * It's represented as a ratio, because large images should be required
         * to meet a higher minimum standard of number of pixels that can be
         * stripped (via the bounding box lookup).
         * 
         * @access  protected
         * @var     Number (default: 0.02)
         */
        _trimThresholdRatio: 0.02,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String key
         * @param   Boolean reCrop
         * @return  void
         */
        init: function(element, key, reCrop) {
            this._key = key;
            this._reCrop = reCrop;
            this._super(element);
            this._setConfig();
            this._addAutoSizeListener();
            this._addDownloadListener();
            this._addShowCropLinkModalListener();
            this._addExpandCropBoxListener();
            this._addCropListener();
            this._addForegroundImageListener();
            this._addToggleMenuListeners();
            this._addTrimListener();
            this._addBackgroundImageListener();
            this._addEscapeEvent();
            this._addSaveToUploadsListener();
            this._addSaveToWatermarksListener();
            this._cleanModalLeaveEvent();
            this._drawResizer();
            this._setup();
            this._setupTooltips();
            this._addResizeListener();
            this._addSetCropBoxListener();
            this._addResizerToggleListener();
            this._loadMaskImages();
            this._showHideMaskShapes();
        },

        /**
         * _addAutoSizeListener
         * 
         * @access  protected
         * @return  void
         */
        _addAutoSizeListener: function() {
            var _this = this;
            this.on({
                'autoSize': function(event) {
                    var aspectRatio = window.Frame.getRatio(),
                        properties = {
                            aspectRatio: aspectRatio.round(4),
                            locked: 1,
                            shape: 'rectangle',
                            styles: {
                                radius: 0
                            }
                        };
                    this.setCropBox(properties);
                }
            });
        },

        /**
         * _addExpandCropBoxListener
         * 
         * @access  protected
         * @return  void
         */
        _addExpandCropBoxListener: function() {
            var _this = this;
            this.on({
                'expandCropBox': function(event) {
                    var properties = {
                        aspectRatio: 1.5,
                        locked: 0,
                        shape: 'rectangle',
                        styles: {
                            radius: 0
                        }
                    };
                    this.setCropBox(properties);
                    var image = this._image,
                        x = 0,
                        y = 0,
                        width = image.width,
                        height = image.height;
                    this.resizeCropBox(width, height);
                    this.moveCropBox(x, y);
                }
            });
        },

        /**
         * _addBackgroundImageListener
         * 
         * @access  protected
         * @return  void
         */
        _addBackgroundImageListener: function() {
            this.on({
                'setBackgroundImage': function(event) {
                    this.popover.hide.apply(this);
                    this._setBackgroundBitmapImageLayer();
                }
            });
        },

        /**
         * _addCropListener
         * 
         * @access  protected
         * @return  void
         */
        _addCropListener: function() {
            this.on({
                'crop': function(event) {
                    var type = this.getElement().attr('type');
                    this.popover.hide.apply(this);
                    if (type === 'backgroundBitmapImage') {
                        this._setBackgroundBitmapImageLayer();
                    } else if (type === 'foregroundBitmapImage') {
                        this._updateForegroundBitmapImageLayer();
                    } else if (type === 'watermarkBitmapImage') {
                        var modal = this._confirmWatermarkCrop(),
                            _this = this;
                        modal.lookup('no').addClass('quick');
                        modal.lookup('no').addClass('simple');
                        modal.once({
                            'yes': function(event) {
                                _this._updateWatermarkBitmapImageLayer();
                            }
                        });
                    }
                }
            });
        },

        /**
         * _addDownloadListener
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadListener: function() {
            this.on({
                'download': function(event) {
                    if (this._getLockedPropertyValue() === true) {
                        var path = '/app/upgrade/pro/locked-download?clean';
                        this._showUpgradeModal(path);
                        return false;
                    }
                    this.popover.hide.apply(this);
                    this._showCropDownloadModal();
                    return true;
                }
            });
        },

        /**
         * _addShowCropLinkModalListener
         * 
         * @access  protected
         * @return  void
         */
        _addShowCropLinkModalListener: function() {
            this.on({
                'showCropLinkModal': function(event) {
                    if (this._getLockedPropertyValue() === true) {
                        var path = '/app/upgrade/pro/locked-link?clean';
                        this._showUpgradeModal(path);
                        return false;
                    }
                    this.popover.hide.apply(this);
                    this._showCropLinkModal();
                    return true;
                }
            });
        },

        /**
         * _addEscapeEvent
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeEvent: function() {
            var callback = this._closeByEscapeKeyEvent.proxy(this);
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _addForegroundBitmapImageLayer
         * 
         * @access  protected
         * @return  Layer
         */
        _addForegroundBitmapImageLayer: function() {
            var canvas = Canvases.Preview,
                cropPositionData = this._getCropPositionData(),
                cropSourceKey = this._key;
            if (this._cropperReset() === true) {
                cropPositionData = {};
                // cropSourceKey = '';
            }
            var layer = canvas.addForegroundBitmapImageLayer({
                    image: this._key,
                    cropPositionData: cropPositionData,
                    cropSourceKey: cropSourceKey
                }),
                drawing = layer.getDrawing(),
                locked = this._getLockedPropertyValue();
            layer.setProperty('locked', locked);
            var _this = this,
                msgKey = 'app.crop.add.foregroundBitmapImage',
                msg = Config.getMessage(msgKey);
            App.getBusy().show(msg);
            layer.setChangeOperationType('added');
            drawing.once({
                'draw': function(event) {
                    App.getBusy().hide();
                    _this.close();
                    this.select();
                }
            });
            drawing.draw();
            return layer;
        },

        /**
         * _addForegroundImageListener
         * 
         * @access  protected
         * @return  void
         */
        _addForegroundImageListener: function() {
            this.on({
                'addForegroundImage': function(event) {
                    this.popover.hide.apply(this);
                    this._addForegroundBitmapImageLayer();
                }
            });
        },

        /**
         * _addResizeListener
         * 
         * @access  protected
         * @return  void
         */
        _addResizeListener: function() {
            this.on({
                'resize': function(event, frame) {
                    this.updateResizer(frame);
                }
            });
        },

        /**
         * _addResizerToggleListener
         * 
         * @access  protected
         * @return  void
         */
        _addResizerToggleListener: function() {
            this.on({
                'toggle/resizer': function(event, $element) {
                    $element.blur();
                    this._resizer.toggle();
                }
            });
        },

        /**
         * _addSetCropBoxListener
         * 
         * @access  protected
         * @return  void
         */
        _addSetCropBoxListener: function() {
            this.on({
                'setCropBox': function(event, $anchor) {
                    var properties = {
                        aspectRatio: $anchor.attr('ar').toFloat(),
                        locked: $anchor.attr('locked').toInt(),
                        shape: $anchor.attr('shape'),
                        styles: {
                            radius: $anchor.attr('radius')
                        }
                    };
                    if (properties.shape === 'mask') {
                        properties.maskKey = $anchor.attr('mask');
                    }
//                     var cropPositionData = this._getCropPositionData(),
//                         width = cropPositionData.width,
//                         height = cropPositionData.height,
//                         x = cropPositionData.x,
//                         y = cropPositionData.y;
// console.log(x, y);
                    this.setCropBox(properties);
                    // if (properties.aspectRatio === 1) {
                    //     width = height = Math.min(width, height);
                    // }
                    // this.resizeCropBox(width, height);
                    // this.moveCropBox(x, y);
                }
            });
        },

        /**
         * _addSaveToUploadsListener
         * 
         * @access  protected
         * @return  void
         */
        _addSaveToUploadsListener: function() {
            this.on({
                'saveToUploads': function(event) {
                    if (this._getLockedPropertyValue() === true) {
                        var path = '/app/upgrade/pro/locked-crop?clean';
                        this._showUpgradeModal(path);
                        return false;
                    }
                    var msgKey = 'app.crop.uploads',
                        msg = Config.getMessage(msgKey);
                    App.getBusy().show(msg);
                    this.popover.hide.apply(this);
                    this._saveCropToUploads();
                    return true;
                }
            });
        },

        /**
         * _addSaveToWatermarksListener
         * 
         * @access  protected
         * @return  void
         */
        _addSaveToWatermarksListener: function() {
            this.on({
                'saveToWatermarks': function(event) {
                    if (this._getLockedPropertyValue() === true) {
                        var path = '/app/upgrade/pro/locked-crop?clean';
                        this._showUpgradeModal(path);
                        return false;
                    }
                    var dropzone = App.getEditor().getArea('watermarks').getDropzone();
                    if (dropzone.availableForUpload() === false) {
                        return false;
                    }
                    var msgKey = 'app.crop.watermarks',
                        msg = Config.getMessage(msgKey);
                    App.getBusy().show(msg);
                    this.popover.hide.apply(this);
                    this._saveCropToWatermarks();
                    return true;
                }
            });
        },

        /**
         * _addToggleMenuListeners
         * 
         * @access  protected
         * @return  void
         */
        _addToggleMenuListeners: function() {
            var _this = this;
            this.on({
                'menu/toggle': function(event) {
                    this.popover.toggle.apply(this);
                }
            });
            App.getElement().on({
                'click': function(event) {
                    var $target = $(event.target);
                    if ($target.parents('.popover').length === 0) {
                        _this.popover.hide.apply(_this);
                    }
                }
            });
        },

        /**
         * _addTrimListener
         * 
         * @access  protected
         * @return  void
         */
        _addTrimListener: function() {
            var _this = this;
            this.on({
                'trim': function(event) {
                    var properties = {
                        aspectRatio: 1.5,
                        locked: 0,
                        shape: 'rectangle',
                        styles: {
                            radius: 0
                        }
                    };
                    this.setCropBox(properties);
                    var boundingBox = this._imageBoundingBox;
                    this.resizeCropBox(boundingBox.width, boundingBox.height);
                    this.moveCropBox(boundingBox.x, boundingBox.y);
                }
            });
        },

        /**
         * _adjustCropperForBitmapImageLayer
         * 
         * @access  protected
         * @return  Boolean
         */
        _adjustCropperForBitmapImageLayer: function() {
            var bitmapImageLayer = this._bitmapImageLayer;
            if (bitmapImageLayer === null) {
                return false;
            }
            var cropPositionData = bitmapImageLayer.getProperty('cropPositionData');
            if (DataUtils.valid(cropPositionData) === false) {
                return false;
            }
            if (cropPositionData.shape === undefined) {
                return false;
            }
            // this.setShape(cropPositionData.shape);
            return true;
        },

        /**
         * _cleanModalLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _cleanModalLeaveEvent: function() {
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.close();
                }
            });
        },

        /**
         * _closeByEscapeKeyEvent
         * 
         * @note    true must always be returned otherwise causes default
         *          actions will be suppressed
         * @access  protected
         * @param   jQuery event
         * @return  true
         */
        _closeByEscapeKeyEvent: function(event) {
            if (DataUtils.valid(event) === false) {
                return true;
            }
            if (DataUtils.valid(event.which) === false) {
                return true;
            }
            if (event.which.toInt() !== 27) {
                return true;
            }
            // if (Stencil.get('ignoreMouseDownLayerBlur') === true) {
            //     return true;
            // }
            if (this._cropDownloadModal !== null) {
                return true;
            }
            if (this._cropLinkModal !== null) {
                return true;
            }
            var $popover = this.find('.popover');
            if ($popover.hasClass('hidden') === false) {
                this.popover.hide.apply(this);
                return true;
            }
            event.preventDefault();
            this.close();
            // if (this._cropDownloadModal !== null) {
                // this._cropDownloadModal.triggerHandler('close');
            // }
            return true;
        },

        /**
         * _confirmWatermarkCrop
         * 
         * @access  protected
         * @return  ConfirmModalView
         */
        _confirmWatermarkCrop: function() {
            var _this = this,
                h1 = 'This will crop your<br />watermark / logo',
                h2 = 'You can always re-crop your watermark / logo later',
                modal = ModalUtils.showConfirm({
                    h1: h1,
                    h2: h2,
                    yes: 'Okay',
                    no: 'Cancel',
                    ctaClassName: 'icon sift sift-exclamation-point'
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * _cropperReset
         * 
         * Returns whether or not a crop is being reset to the full dimensions
         * of the image. This is determined by comparing the width and height of
         * the crop position data to that of the source image, and if it's
         * within a threshold value, it's fair to assume the user is trying to
         * reset the cropper.
         * 
         * @access  protected
         * @return  Boolean
         */
        _cropperReset: function() {
            var cropPositionData = this._getCropPositionData(),
                resetThresholdRatio = this._resetThresholdRatio,
                minWidth = (this._image.width * (1 - resetThresholdRatio)),
                minHeight = (this._image.height * (1 - resetThresholdRatio));
            if (cropPositionData.shape !== 'rectangle') {
                return false;
            }
            if (cropPositionData.styles.radius === '100000px') {
                return false;
            }
            if (cropPositionData.styles.radius === '50%') {
                return false;
            }
            if (cropPositionData.width > minWidth) {
                if (cropPositionData.height > minHeight) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _drawResizer
         * 
         * @access  protected
         * @return  void
         */
        _drawResizer: function() {
            var $resizer = DataUtils.render('Resizer'),
                $sizing = this._element.find('div.sizing');
            $sizing.append($resizer);
            this._resizer = new ResizerView($resizer, this);
            this._resizer.setSelectedFrame(Frame);
            this._resizer.updateSelected();
            this.updateResizer(Frame);
        },

        /**
         * _getActiveShapeElement
         * 
         * @access  protected
         * @return  jQuery
         */
        _getActiveShapeElement: function() {
            var lookup = 'rectangle';
            if (this._cropBoxProperties.shape === 'ellipse') {
                lookup = 'ellipse';
                if (this._cropBoxProperties.aspectRatio.toFloat() === 1) {
                    lookup = 'circle';
                }
            } else if (this._cropBoxProperties.shape === 'rectangle') {
                if (this._cropBoxProperties.aspectRatio === 1) {
                    lookup = 'square';
                } else if (this._cropBoxProperties.styles.radius === '100000px') {
                    lookup = 'roundedRectangle';
                } else if (this._cropBoxProperties.locked.toInt() === 1) {
                    lookup = 'autoSize';
                }
            } else if (this._cropBoxProperties.shape === 'mask') {
                lookup = 'mask.' + (this._cropBoxProperties.maskKey);
            }
            var $element = this.lookup(lookup);
            return $element;
        },

        /**
         * _getComputedCropperDimensions
         * 
         * @access  protected
         * @return  Object
         */
        _getComputedCropperDimensions: function() {
            var $cropperHide = this.find('.cropper-hide'),
                computedCropperDimensions = {},
                width = $cropperHide[0].style.width.toFloat(),
                height = $cropperHide[0].style.height.toFloat();
            computedCropperDimensions = {
                width: width,
                height: height
            };
            return computedCropperDimensions;
        },

        /**
         * _getCropDownloadPath
         * 
         * @access  protected
         * @return  String
         */
        // _getCropDownloadPath: function() {
        //     var key = this._key,
        //         path = '/media/' + (key) + '/crop/download',
        //         queryData = this._getCropQueryData(),
        //         queryDataString = StringUtils.getQueryDataString(queryData);
        //     path = (path) + '?' + (queryDataString);
        //     return path;
        // },

        /**
         * _getCropPositionData
         * 
         * @note    The Math.abs is required because when the crop box is
         *          expanded to fill the entire cropper, it can result in this:
         *          https://i.imgur.com/Ucqz9E4.jpg
         *          https://i.imgur.com/DA09hEG.jpg
         * @access  protected
         * @return  Object
         */
        _getCropPositionData: function() {
            var cropData = this._cropper.getData(),
                cropPositionData = {
                    height: cropData.height.round(4),
                    maskKey: this._cropBoxProperties.maskKey,
                    shape: this._cropBoxProperties.shape,
                    styles: this._cropBoxProperties.styles,
                    width: cropData.width.round(4),
                    x: Math.abs(cropData.x.round(4)),
                    y: Math.abs(cropData.y.round(4))
                };
            return cropPositionData;
        },

        /**
         * _getCropQueryData
         * 
         * @access  protected
         * @return  Object
         */
        _getCropQueryData: function() {
            var cropPositionData = this._getCropPositionData(),
                queryData = {
                    data: cropPositionData
                };
            return queryData;
        },

        /**
         * _getCropUrlLookupPath
         * 
         * @access  protected
         * @return  String
         */
        _getCropUrlLookupPath: function() {
            var key = this._key,
                path = '/media/' + (key) + '/crop/url',
                queryData = this._getCropQueryData(),
                queryDataString = StringUtils.getQueryDataString(queryData);
            path = (path) + '?' + (queryDataString);
            return path;
        },

        /**
         * _getDropzoneItemUrl
         * 
         * @access  protected
         * @return  String
         */
        _getDropzoneItemUrl: function() {
            var url = 'https://getstencil.com/app/static/images/200.png';
            return url;
        },

        /**
         * _getImageAspectRatio
         * 
         * @access  protected
         * @return  Number
         */
        _getImageAspectRatio: function() {
            var image = this._image,
                imageAspectRatio = image.width / image.height;
            return imageAspectRatio;
        },

        /**
         * _getLockedPropertyValue
         * 
         * @access  protected
         * @return  Boolean
         */
        _getLockedPropertyValue: function() {
            var upload = this._key.match(/^upld/) !== null;
            if (upload === true) {
                return false;
            }
            if (this._bitmapImageLayer === null) {
                var locked = this._$contextMenuThumbRelative.hasClass('locked');
                return locked;
            }
            var locked = this._bitmapImageLayer.getProperty('locked');
            return locked;
        },

        /**
         * _getWindowAspectRatio
         * 
         * @access  protected
         * @return  Number
         */
        _getWindowAspectRatio: function() {
            var ratio = window.innerWidth / window.innerHeight;
            return ratio;
        },

        /**
         * _hideActiveThumb
         * 
         * @access  protected
         * @return  void
         */
        // _hideActiveThumb: function() {
        //     var results = App.getEditor().getActiveArea().getActiveGroup().getActiveResults();
        //     results.deselectAll();
        // },

        /**
         * _hideContextMenu
         * 
         * @access  protected
         * @return  void
         */
        // _hideContextMenu: function() {
        //     var contextMenu = App.getEditor().getActiveArea().getContextMenu();
        //     contextMenu.hide();
        // },

        /**
         * _imageTooSmall
         * 
         * @access  protected
         * @return  Boolean
         */
        _imageTooSmall: function() {
            if (this._image.width < this._minImageDimensions.width) {
                return true;
            }
            if (this._image.height < this._minImageDimensions.height) {
                return true;
            }
            return false;
        },

        /**
         * _loadMaskImages
         * 
         * @access  protected
         * @return  Boolean
         */
        _loadMaskImages: function() {
            if (this._masksAvailable() === false) {
                return false;
            }
            var masks = Config.default('cropperMasks'),
                index,
                mask,
                url,
                urls = [];
            for (index in masks) {
                mask = masks[index];
                url = mask.url;
                urls.push(url);
            }
            ImageUtils.load.urls(urls);
            return true;
        },

        /**
         * _makeImagesUndraggable
         * 
         * @access  protected
         * @return  void
         */
        _makeImagesUndraggable: function() {
            var $images = this.find('img:not([draggable])');
            $images.attr('draggable', 'false');
        },

        /**
         * _makeOverwriteRequest
         * 
         * @access  protected
         * @param   UploadAccessor upload
         * @param   Function callback
         * @return  void
         */
        _makeOverwriteRequest: function(upload, callback) {
            this.requestCropUrl(function(url) {
                upload.overwrite(url, callback);
            });
        },

        /**
         * _masksAvailable
         * 
         * @access  protected
         * @return  Boolean
         */
        _masksAvailable: function() {
            if (UserAgentUtils.supports.css.masks() === false) {
                return false;
            }
            return true;
        },

        /**
         * _moveCloseAnchor
         * 
         * @access  protected
         * @return  void
         */
        _moveCloseAnchor: function() {
            var $content = this.find('.content').first(),
                width = $content.css('width').toInt(),
                height = $content.css('height').toInt(),
                $anchor = this.find('.content > a.close');
            if (width < 186) {
                $anchor.addClass('pulled');
            }
            if (height < 186) {
                $anchor.addClass('pulled');
            }
        },

        /**
         * _moveMaskVectors
         * 
         * @access  protected
         * @return  void
         */
        _moveMaskVectors: function() {
            var $masks = this.find('.mask'),
                $se = this.find('.cropper-point.point-se');
            $masks.insertAfter($se);
        },

        /**
         * _movePopover
         * 
         * @access  protected
         * @return  void
         */
        _movePopover: function() {
            var $content = this.find('.content').first(),
                $toggleMenu = this.lookup('toggleMenu'),
                $popover = this.find('.popover'),
                left = ($toggleMenu.offset().left - $content.offset().left) + ($toggleMenu.outerWidth() / 2) - ($popover.outerWidth() / 2);
            $popover.css({
                left: left
            });
        },

        /**
         * _positionSecondaryActions
         * 
         * @access  protected
         * @return  void
         */
        _positionSecondaryActions: function() {
            var $secondary = this.find('.actions.secondary'),
                halfHeight = $secondary.css('height').toInt() / 2;
            $secondary.css({
                'top': 'calc(50% - ' + (halfHeight) + 'px)'
            });
        },

        /**
         * _preloadImage
         * 
         * @access  protected
         * @return  void
         */
        _preloadImage: function() {
            var imageRequest = this._accessor.loadCropperImage(),
                _this = this;
            imageRequest.once({
                'load': function(event, image) {
                    _this._image = image;
                    if (_this._imageTooSmall() === true) {
                        _this.close();
                        _this._showTooSmallAlert();
                    } else {
                        _this.triggerHandler('image/preload');
                    }
                }
            });
        },

        /**
         * _updateMinCropBox
         * 
         * Updates the Cropper instance's minCropBoxHeight and minCropBoxWidth
         * properties such that if the image can be trimmed, those values
         * reflect the smallest possible crop box.
         * 
         * @access  protected
         * @return  Boolean
         */
        _updateMinCropBox: function() {
            if (this._showTrimFeature() === false) {
                return false;
            }
            var boundingBox = this._imageBoundingBox,
                containerData = this._cropper.getContainerData(),
                width = boundingBox.width,
                height = boundingBox.height,
                ratios = {
                    height: containerData.height / this._image.height,
                    width: containerData.width / this._image.width
                };
            width = Math.ceil(width * ratios.width);
            height = Math.ceil(height * ratios.height);
            if (width > this._minCropBoxDimensions.width) {
                if (height > this._minCropBoxDimensions.height) {
                    return false;
                }
            }
            this._minCropBoxDimensions = {
                width: Math.min(this._minCropBoxDimensions.width, width),
                height: Math.min(this._minCropBoxDimensions.height, height)
            },
            this._cropper.options.minCropBoxHeight = this._minCropBoxDimensions.height;
            this._cropper.options.minCropBoxWidth = this._minCropBoxDimensions.width;
            this._cropper.limitCropBox(true, true);
            return true;
        },

        /**
         * _requestBoundingBox
         * 
         * @access  protected
         * @return  void
         */
        _requestBoundingBox: function() {
            var _this = this;
            this._accessor.once({
                'boundingBox/request/error': function(event) {
                    _this._makeImagesUndraggable();
                    _this.triggerHandler('cropper/ready');
                },
                'boundingBox/request/success/false': function(event) {
                    _this._makeImagesUndraggable();
                    _this.triggerHandler('cropper/ready');
                },
                'boundingBox/request/success/true': function(event, boundingBox) {
                    _this._imageBoundingBox = boundingBox;
                    _this._updateMinCropBox();
                    _this._showHideTrimFeature();
                    _this._positionSecondaryActions();
                    _this._makeImagesUndraggable();
                    _this.triggerHandler('cropper/ready');
                }
            });
            this._accessor.requestBoundingBox();

        },

        /**
         * _requestMediaObject
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _requestMediaObject: function(callback) {
            var key = this._key;
            callback = callback.proxy(this);
            DataUtils.requestMediaObject(key, callback);
        },

        /**
         * _resizeContentElement
         * 
         * @access  protected
         * @return  void
         */
        _resizeContentElement: function() {
            var $content = this.find('.content').first(),
                windowAspectRatio = this._getWindowAspectRatio(),
                maxCropperWidth = window.innerWidth * this._maxWindowRatios.width,
                maxCropperHeight = window.innerHeight * this._maxWindowRatios.height,
                width,
                height;
            maxCropperWidth = Math.min(maxCropperWidth, this._maxWindowDimensions.width);
            maxCropperHeight = Math.min(maxCropperHeight, this._maxWindowDimensions.height);
            if (windowAspectRatio > this._getImageAspectRatio()) {
                height = Math.min(maxCropperHeight, this._image.height);
                width = this._image.width / (this._image.height / height);
                if (width > maxCropperWidth) {
                    width = maxCropperWidth;
                    height = (width * this._image.height) / this._image.width;
                }
            } else {
                width = Math.min(maxCropperWidth, this._image.width);
                height = this._image.height / (this._image.width / width);
                if (height > maxCropperHeight) {
                    height = maxCropperHeight;
                    width = (height * this._image.width) / this._image.height;
                }
            }
            $content.css({
                width: width,
                height: height
            });
        },

        /**
         * _resizeCropperElements
         * 
         * @access  protected
         * @return  void
         */
        _resizeCropperElements: function() {
            var $content = this.find('.content').first(),
                $cropperContainer = this.find('.cropper-container'),
                $cropperCanvas = this.find('.cropper-canvas'),
                computedCropperDimensions = this._getComputedCropperDimensions();
// console.log(computedCropperDimensions);
            $content.css({
                width: computedCropperDimensions.width,
                height: computedCropperDimensions.height
            });
            $cropperContainer.css({
                width: computedCropperDimensions.width,
                height: computedCropperDimensions.height
            });
            $cropperCanvas.css({
                'transform': 'none'
            });
        },

        /**
         * _setConfig
         * 
         * @access  protected
         * @return  void
         */
        _setConfig: function() {
            var allowCropperTrimFunctionality = Config.default('allowCropperTrimFunctionality');
            this._allowTrimFunctionality = allowCropperTrimFunctionality;
        },

        /**
         * _saveCropToUploads
         * 
         * @access  protected
         * @return  void
         */
        _saveCropToUploads: function() {
            var area = 'uploads',
                navigationPath = '/app/uploads';
            this._saveCropViaDropzone(area, navigationPath);
        },

        /**
         * _saveCropToWatermarks
         * 
         * @access  protected
         * @return  void
         */
        _saveCropToWatermarks: function() {
            var area = 'watermarks',
                navigationPath = '/app/logos';
            this._saveCropViaDropzone(area, navigationPath);
        },

        /**
         * _saveCropViaDropzone
         * 
         * @access  protected
         * @param   String area
         * @param   String navigationPath
         * @return  void
         */
        _saveCropViaDropzone: function(area, navigationPath) {
            var _this = this,
                key = this._key,
                cropPositionData = this._getCropPositionData(),
                url = this._getDropzoneItemUrl(),
                urls = [url];
            DataUtils.getUrlsAsBlobs(urls, function(blobs) {
                if (blobs === false) {
                    return false;
                }
                App.getBusy().hide();
                var dropzone = App.getEditor().getArea(area).getDropzone();
                if (dropzone.availableForUpload() === false) {
                    return false;
                }
                Stencil.navigate(navigationPath);
                dropzone.uploadItems(blobs);
                dropzone.setUploadInterstitialCallback(function(upload, callback) {
                    var settings = [
                        'settings.crop',
                        'settings.cropSourceKey',
                        'settings.cropPositionData'
                    ];
                    upload.set({
                        'settings.crop': 1,
                        'settings.cropSourceKey': key,
                        'settings.cropPositionData': JSON.stringify(cropPositionData)
                    });
                    upload.save(settings, {
                        success: function() {
                            _this._makeOverwriteRequest(upload, callback);
                        }
                    });
                });
                dropzone.once({
                    'complete/failed': function(event, response) {
                        Stencil.alert('services.cloudinary.maxResolution');
                    },
                    'complete/successful/pre': function(event, upload) {
                        this.resetUploadInterstitialCallback();
                    }
                });
                _this.close();
                return true;
            });
        },

        /**
         * _setAspectRatio
         * 
         * @access  protected
         * @return  void
         */
        _setAspectRatio: function() {
            var aspectRatio = this._cropBoxProperties.aspectRatio,
                locked = this._cropBoxProperties.locked;
            if (locked === 1) {
                this._cropper.setAspectRatio(aspectRatio);
            } else {
                this._cropper.setAspectRatio(NaN);
            }
        },

        /**
         * _setBackgroundBitmapImageLayer
         * 
         * @access  protected
         * @return  Layer
         */
        _setBackgroundBitmapImageLayer: function() {
            var _this = this,
                canvas = Canvases.Preview,
                layer = canvas.getBackgroundBitmapImageLayer(),
                drawing = layer.getDrawing(),
                key = this._key,
                cropSourceKey = this._key,
                cropPositionData = this._getCropPositionData(),
                msgKey = 'app.crop.set.backgroundBitmapImage',
                msg = Config.getMessage(msgKey)
                locked = this._getLockedPropertyValue();
            if (this._cropperReset() === true) {
                cropPositionData = {};
                // cropSourceKey = '';
            }
            layer.setProperty('locked', locked);
            App.getBusy().show(msg);
            layer.setChangeOperationType('image:cropped');
            layer.setImage(key);
            layer.setStyles({
                left: 50,
                top: 50
            });
            layer.setProperty('cropPositionData', cropPositionData);
            layer.setProperty('cropSourceKey', cropSourceKey);
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access  private
                 * @return  void
                 */
                'refresh': function(event) {
                    App.getBusy().hide();
                    _this.close();
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                    this.select();
                }
            });
            drawing.reload();
            return layer;
        },

        /**
         * _setup
         * 
         * @access  protected
         * @return  void
         */
        _setup: function() {
            this.once({
                'image/preload': function(event) {
                    this._resizeContentElement();
                    this._setupCropper();
                    var _this = this;
                    this._image.addEventListener('ready', function(event) {
                        _this._adjustCropperForBitmapImageLayer();
                        _this._resizeCropperElements();
                        _this._positionSecondaryActions();
                        _this._movePopover();
                        _this._moveCloseAnchor();
                        _this.setCropBox(_this._cropBoxProperties);
                        _this._moveMaskVectors();
                        if (_this._allowTrimFunctionality === false) {
                            _this._makeImagesUndraggable();
                            _this.triggerHandler('cropper/ready');
                        } else {
                            _this._requestBoundingBox();
                        }
                    });
                }
            });
            this._requestMediaObject(function(accessor) {
                this._accessor = accessor;
                this._preloadImage();
            });
        },

        /**
         * _setupCropper
         * 
         * @see     https://caniuse.com/#feat=css-masks
         * @see     https://support.cloudinary.com/hc/en-us/articles/202521462-Can-I-crop-images-by-custom-shapes-
         * @see     https://cloudinary.com/cookbook/custom_shapes_cropping
         * @see     https://github.com/fengyuanchen/cropperjs/issues/413#issuecomment-419896312
         * @access  protected
         * @return  void
         */
        _setupCropper: function() {
            var $container = this.find('.container');
            $container.append(this._image);
            this._cropper = new Cropper(this._image, {
                autoCropArea: this._defaultCropAreaRatio,
                // checkCrossOrigin: false,
                checkCrossOrigin: true,
                checkOrientation: false,
                guides: true,
                minContainerHeight: this._minImageDimensions.height,
                minContainerWidth: this._minImageDimensions.width,
                minCropBoxHeight: this._minCropBoxDimensions.height,
                minCropBoxWidth: this._minCropBoxDimensions.width,
                toggleDragModeOnDblclick: false,
                viewMode: 1,
                wheelZoomRatio: false,
                zoomOnTouch: false,
                zoomOnWheel: false
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: function() {
                    var placement = this.$element.attr('placement');
                    return placement;
                }
            });
        },

        /**
         * _showCropDownloadModal
         * 
         * @access  protected
         * @return  CropDownloadModalView
         */
        _showCropDownloadModal: function() {
            var key = this._key,
                cropPositionData = this._getCropPositionData(),
                modal = ModalUtils.showCropDownload(key, cropPositionData),
                _this = this;
            this._cropDownloadModal = modal;
            this._cropDownloadModal.once({
                'close leave': function(event) {
                    _this._cropDownloadModal = null;
                }
            });
            return modal;
        },

        /**
         * _showCropLinkModal
         * 
         * @access  protected
         * @return  false|CropLinkModalView
         */
        _showCropLinkModal: function() {
            if (Config.serviceAvailable('bitly') === false) {
                Stencil.alert('services.bitly.unavailable');
                return false;
            }
            var modal = ModalUtils.showCropLink(),
                _this = this;
            this._cropLinkModal = modal;
            this._cropLinkModal.once({
                'close leave': function(event) {
                    _this._cropLinkModal = null;
                }
            });
            return modal;
        },

        /**
         * _showHideMaskShapes
         * 
         * @access  protected
         * @return  void
         */
        _showHideMaskShapes: function() {
            var $secondary = this.find('.actions.secondary'),
                $masks = $secondary.find('.column.masks');
            $secondary.removeClass('masksAvailable');
            $masks.addClass('hidden');
            if (this._masksAvailable() === true) {
                $secondary.addClass('masksAvailable');
                $masks.removeClass('hidden');
            }
        },

        /**
         * _showTrimFeature
         * 
         * @note    The width === 0 and height === 0 is required to ensure
         *          images that are one solid color don't mess up
         * @access  protected
         * @return  Boolean
         */
        _showTrimFeature: function() {
            var boundingBox = this._imageBoundingBox,
                x = boundingBox.x.toInt(),
                y = boundingBox.y.toInt(),
                width = boundingBox.width.toInt(),
                height = boundingBox.height.toInt(),
                threshold = this._trimThresholdRatio,
                minXPixels = Math.ceil(this._image.width * threshold),
                minYPixels = Math.ceil(this._image.height * threshold);
            if (width === 0 && height === 0) {
                return false;
            }
            if (x > minXPixels) {
                return true;
            }
            if (y > minYPixels) {
                return true;
            }
            var widthDifference = this._image.width - width;
            if (widthDifference > minXPixels) {
                return true;
            }
            var heightDifference = this._image.height - height;
            if (heightDifference > minYPixels) {
                return true;
            }
            return false;
        },

        /**
         * _showHideTrimFeature
         * 
         * @access  protected
         * @return  void
         */
        _showHideTrimFeature: function() {
            var $trim = this.lookup('trim');
            $trim.addClass('hidden');
            if (this._showTrimFeature() === true) {
                $trim.removeClass('hidden');
            }
        },

        /**
         * _showHideViewBoxMask
         * 
         * @access  protected
         * @return  Boolean
         */
        _showHideViewBoxMask: function() {
            if (this._masksAvailable() === false) {
                return false;
            }
            var properties = this._cropBoxProperties,
                $content = this.find('.content').first(),
                $viewBox = $content.find('.cropper-view-box'),
                $masks = $content.find('.cropper-crop-box span.mask');
            $viewBox.css({
                '-webkit-mask-image': 'none'
            });
            $masks.addClass('hidden');
            if (properties.maskKey === undefined) {
                return false;
            }
            var mask = ImageUtils.getCropperMaskByKey(properties.maskKey);
            if (mask === null) {
                return false;
            }
            $viewBox.css({
                '-webkit-mask-image': 'url("' + (mask.url) + '")'
            });
            var $mask = $content.find('.cropper-crop-box span.mask[mask="' + (mask.key) + '"]');
            $mask.removeClass('hidden');
            return true;
        },

        /**
         * _showTooSmallAlert
         * 
         * @access  protected
         * @return  void
         */
        _showTooSmallAlert: function() {
            var alertKey = 'crop.image.tooSmall';
            Stencil.alert(alertKey);
        },

        /**
         * _showUpgradeModal
         * 
         * @note    Only effective when cropper is accessed through a
         *          ToolbarView
         * @access  protected
         * @param   String path
         * @return  void
         */
        _showUpgradeModal: function(path) {
            Stencil.navigate(path);
            Stencil.set('ignoreMouseDownLayerBlur', true);
            (function() {
                var modal = ModalUtils.get('Upgrade');
                modal.once({
                    'close': function() {
                        Stencil.set('ignoreMouseDownLayerBlur', false);
                    }
                });
            }).delay(0);
        },

        /**
         * _trackAccountOnboarding
         * 
         * @access  protected
         * @return  void
         */
        _trackAccountOnboarding: function() {
            var account = Stencil.account();
            if (account.getOnboardingValue('cropperOpened') !== true) {
                account.setOnboardingValue('cropperOpened', true);
            }
        },

        /**
         * _updateForegroundBitmapImageLayer
         * 
         * @access  protected
         * @return  void
         */
        _updateForegroundBitmapImageLayer: function() {
            var _this = this,
                cropPositionData = this._getCropPositionData(),
                cropSourceKey = this._key,
                layer = this._bitmapImageLayer,
                msgKey = 'app.crop.cropping',
                msg = Config.getMessage(msgKey);
            App.getBusy().show(msg);
            if (this._cropperReset() === true) {
                cropPositionData = {};
                // cropSourceKey = '';
            }
            layer.setProperty('cropPositionData', cropPositionData);
            layer.setProperty('cropSourceKey', cropSourceKey);
            layer.setChangeOperationType('cropped');
            layer.getDrawing().once({
                'resize/complete': function(event) {
                    App.getBusy().hide();
                    _this.close();
                    this.select();
                }
            });
            layer.getDrawing().refresh();
        },

        /**
         * _updateWatermarkBitmapImageLayer
         * 
         * @access  protected
         * @return  void
         */
        _updateWatermarkBitmapImageLayer: function() {
            var _this = this,
                cropPositionData = this._getCropPositionData(),
                cropSourceKey = this._key,
                layer = this._bitmapImageLayer,
                drawing = layer.getDrawing(),
                msgKey = 'app.crop.cropping',
                msg = Config.getMessage(msgKey);
            if (this._cropperReset() === true) {
                cropPositionData = {};
                // cropSourceKey = '';
            }
            App.getBusy().show(msg);
            layer.setProperty('cropPositionData', cropPositionData);
            layer.setProperty('cropSourceKey', cropSourceKey);
            layer.setChangeOperationType('cropped');
            drawing.once({
                'resize/complete': function(event) {
                    App.getBusy().hide();
                    _this.close();
                    this.select();
                }
            });
            drawing.refresh();

            // 
            // var key = this._bitmapImageLayer.getProperty('image');
            // console.log(this._accessor);
            // this._makeOverwriteRequest(this._accessor, function() {});
        },

        /**
         * close
         * 
         * @access  public
         * @return  Boolean
         */
        close: function() {
            // if (Stencil.get('ignoreMouseDownLayerBlur') === true) {
            //     return false;
            // }
            this.triggerHandler('close');
            // return true;
        },

        /**
         * moveCropBox
         * 
         * @access  public
         * @param   Number x
         * @param   Number y
         * @return  void
         */
        moveCropBox: function(x, y) {
            this._cropper.setData({
                x: x,
                y: y
            });
        },

        /**
         * popover
         * 
         * @access  public
         * @var     Object
         */
        popover: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                var $popover = this.find('.popover');
                $popover.addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $popover = this.find('.popover');
                $popover.removeClass('hidden');
            },

            /**
             * toggle
             * 
             * @access  public
             * @return  void
             */
            toggle: function() {
                var $popover = this.find('.popover');
                $popover.toggleClass('hidden');
            },
        },

        /**
         * requestCropUrl
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        requestCropUrl: function(callback) {
            var _this = this,
                path = this._getCropUrlLookupPath();
            RequestUtils.ajax({
                signature: {"basename":"Cropper.js","line":1881},
                url: path,
                type: 'GET',
                success: function(response) {
                    if (response.success === true) {
                        callback.apply(_this, [response.data.url]);
                    } else {
                        var error = Stencil.extractError(response),
                            code = '1889-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * resizeCropBox
         * 
         * @access  public
         * @param   Number width
         * @param   Number height
         * @return  void
         */
        resizeCropBox: function(width, height) {
            this._cropper.setData({
                width: width,
                height: height
            });
        },

        /**
         * setBitmapImageLayer
         * 
         * @access  public
         * @param   BitmapImageLayer bitmapImageLayer
         * @return  void
         */
        setBitmapImageLayer: function(bitmapImageLayer) {
            this._bitmapImageLayer = bitmapImageLayer;
        },

        /**
         * setCropBox
         * 
         * @access  public
         * @param   Object properties
         * @return  void
         */
        setCropBox: function(properties) {
            this.popover.hide.apply(this);
            this._cropBoxProperties = properties;
            var $content = this.find('.content').first(),
                $viewBox = $content.find('.cropper-view-box');
            $content.removeAttr('shape');
            $content.removeAttr('ar');
            $content.removeAttr('radius');
            $content.removeAttr('locked');
            $content.removeAttr('mask');
            $content.attr('shape', properties.shape);
            $content.attr('ar', properties.ar);
            $content.attr('radius', properties.styles.radius);
            $content.attr('locked', properties.locked);
            if (properties.maskKey !== undefined) {
                $content.attr('mask', properties.maskKey);
            }
            this._showHideViewBoxMask();
            this.find('a.active').removeClass('active');
            var $anchor = this._getActiveShapeElement();
            $anchor.addClass('active');
            this._setAspectRatio();
        },

        /**
         * setSource
         * 
         * @access  public
         * @param   String source
         * @return  void
         */
        setSource: function(source) {
            this._element.attr('source', source);
        },

        /**
         * setSourceType
         * 
         * @access  public
         * @param   String type
         * @return  void
         */
        setSourceType: function(type) {
            this._element.attr('type', type);
        },

        /**
         * setThumbRelative
         * 
         * @access  public
         * @param   jQuery $contextMenuThumbRelative
         * @return  void
         */
        setThumbRelative: function($contextMenuThumbRelative) {
            this._$contextMenuThumbRelative = $contextMenuThumbRelative;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            // this._hideActiveThumb();
            // this._hideContextMenu();
            this._super();
            this._trackAccountOnboarding();
            Track.event('Cropper modal opened');
        },

        /**
         * updateResizer
         * 
         * @access  public
         * @param   FrameAccessor frame
         * @return  void
         */
        updateResizer: function(frame) {
            var $sizing = this.find('div.sizing'),
                $anchor = $sizing.find('a').first(),
                $middot = $sizing.find('span.middot').first(),
                $label = $anchor.find('div.label'),
                $width = $anchor.find('span.width'),
                $height = $anchor.find('span.height');
            $label.text(frame.get('label'));
            $width.text(frame.get('width'));
            $height.text(frame.get('height'));
            $middot.removeClass('hidden');
            if (frame.get('label').trim() === '') {
                $middot.addClass('hidden');
            }
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * DelinquentModalView
     * 
     * @extends ModalView
     */
    window.DelinquentModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DelinquentModalView')
         */
        _string: 'DelinquentModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * DownloadModalView
     * 
     * @see     https://github.com/eligrey/FileSaver.js/
     * @see     http://stackoverflow.com/questions/13752984/html5-file-api-downloading-file-from-server-and-saving-it-in-sandbox
     * @see     http://stackoverflow.com/questions/8126623/downloading-canvas-element-to-an-image
     * @see     http://jsfiddle.net/AbdiasSoftware/7PRNN/
     * @extends ModalView
     */
    window.DownloadModalView = ModalView.extend({

        /**
         * _forceRemoteDownload
         * 
         * @access  protected
         * @var     null|Boolean (default: null)
         */
        _forceRemoteDownload: null,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="radio"][name="data[contentType]"]': function(event, $input) {
                        var $filename = this.find('[name="data[filename]"]'),
                            value = $filename.val().trim(),
                            contentType = this._getContentType(),
                            extension = contentType === 'image/png' ? 'png' : 'jpg',
                            cleaned = value.replace(/\.[a-z]{3,4}$/i, '.' + extension);
                        $filename.val(cleaned);
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('download');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _delays
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {

            /**
             * The duration in milliseconds to wait before triggering the
             * canvas export, to allow for the button transition to complete
             * properly.
             * 
             * This number should be greater than the button animation duration
             * (defined in buttons.scss), because in the browser, triggering
             * a canvas export is a data and memory heavy operation, causing
             * the css to freeze. So just wait a reasonable amount of time
             * before doing so.
             */
            animation: 175,

            /**
             * The duration in milliseconds to wait (at a minimum) before
             * pushing an exported file to the user. This is because sometimes
             * the canvas export is so fast (eg. 150ms) that it feels
             * disjointed, in that they click the button and while the button UI
             * changes to communication something, it stops right away and the
             * modal is hidden. This just ensures a minimum time so it doesn't
             * feel like things are jumping around.
             */
            download: 1500
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DownloadModalView')
         */
        _string: 'DownloadModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor image
         * @param   Boolean forceRemoteDownload used to allow previously saved
         *          images (eg. not the draft) to have options defined before the
         *          download begins.
         * @return  void
         */
        init: function(element, image, forceRemoteDownload) {
            this._super(element);
            this._image = image;
            this._forceRemoteDownload = forceRemoteDownload;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.on({
                'close': function(event) {
                    if (UserAgentUtils.is.electron() === true) {
                        var key = 'clients.electron.images.download.single.complete';
                        Stencil.alert(key);
                    }
                }
            });
            this._setupDownload();
            this._setupTooltips();
        },

        /**
         * _blurFilename
         * 
         * @access  protected
         * @return  void
         */
        _blurFilename: function() {
            var $input = this.find('input[name="data[filename]"]');
            $input.blur();
            if (DataUtils.valid(document.getSelection) === true) {
                var selection = document.getSelection();
                if (DataUtils.valid(selection.empty) === true) {
                    selection.empty();
                }
            }
        },

        /**
         * _disable
         * 
         * @access  protected
         * @return  void
         */
        _disable: function() {
            this.pause();
            var selector = [
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
            this.find('a.button').addClass('busy').disable();
        },

        /**
         * _enable
         * 
         * @access  protected
         * @return  void
         */
        _enable: function() {
            this.unpause();
            this.find('a.button').removeClass('busy').enable();
        },

        /**
         * _getContentType
         * 
         * @access  protected
         * @return  String
         */
        _getContentType: function() {
            return this.find('[name="data[contentType]"]:checked').val();
        },

        /**
         * _getFilename
         * 
         * @access  protected
         * @return  String
         */
        _getFilename: function() {
            var $filename = this.find('[name="data[filename]"]'),
                filename = $filename.val().trim(),
                $contentType = this.find('[name="data[contentType]"]:checked'),
                contentType = $contentType.val();

            // png
            if (contentType === 'image/png') {
                if (filename === '') {
                    filename = Stencil.account().draft().getDefaultFilename();
                    return filename.replace(/\.jpg$/, '.png');
                }
                if (filename.match(/\.png$/) === null) {
                    return filename.replace(/\.jpg$/, '') + '.png';
                }
                return filename;
            }

            // jpeg
            if (filename === '') {
                filename = Stencil.account().draft().getDefaultFilename();
                return filename.replace(/\.png$/, '.jpg');
            }
            if (filename.match(/\.jpg$/) === null) {
                return filename.replace(/\.png$/, '') + '.jpg';
            }
            return filename;
        },

        /**
         * _getMediaType
         * 
         * @access  protected
         * @return  String
         */
        _getMediaType: function() {
            return this.find('[name="data[mediaType]"]:checked').val();
        },

        /**
         * _getMultiplier
         * 
         * @access  protected
         * @return  String
         */
        _getMultiplier: function() {
            return this.find('[name="data[multiplier]"]:checked').val();
        },

        /**
         * _localDownloadAction
         * 
         * @access  protected
         * @return  void
         */
        _localDownloadAction: function() {
            var filename = this._getFilename(),
                contentType = this._getContentType(),
                recommendedExportContentType = Stencil.account().draft().getRecommendedExportContentType(),
                multiplier = this._getMultiplier(),
                check = Footer.validate.changedCanvas.apply(Footer),
                _this = this;

            /**
             * If the canvas contents have changed from the ImageAccessor that's
             * been loaded into the account draft, then ensure a traditional
             * save action goes on.
             */
            if (check.valid === true) {
                this._disable();
                var start = new Date();
                (function() {
                    Footer.save('download', false, function(image, dataURL) {

                        /**
                         * Now that the save has been initiated (but not yet
                         * fully completed), check if the multipler is 2x. This
                         * is because the dataURL that comes into this callback
                         * is by default the 2x version. So if they match, go
                         * ahead and push the dataURL to the browser right away.
                         */
                        if (multiplier === '2x') {
                            if (contentType !== recommendedExportContentType) {
                                DataUtils.convertDataURLContentType(
                                    dataURL,
                                    contentType,
                                    function(dataURL) {
                                        var blob = DataUtils.dataURLToBlob(dataURL);
                                        saveAs(blob, filename);
                                        _this.triggerHandler('close');
                                    }
                                );
                            } else {
                                var blob = DataUtils.dataURLToBlob(dataURL);
                                saveAs(blob, filename);
                                _this.triggerHandler('close');
                            }
                        }
                        /**
                         * Otherwise, the user is trying to download the 1x
                         * version. So in that case, I take the dataURL, and
                         * route it through a resize helper function, and then
                         * push that to the browser.
                         */
                        else {
                            var width = Frame.get('width').toInt(),
                                height = Frame.get('height').toInt();
                            DataUtils.resizeDataURL(
                                dataURL,
                                width,
                                height,
                                contentType,
                                function(dataURL) {
                                    var blob = DataUtils.dataURLToBlob(dataURL);
                                    saveAs(blob, filename);
                                    _this.triggerHandler('close');
                                }
                            );
                        }
                    });
                }).minDelay(start, this._delays.download);
            }
            /**
             * This is the case whereby the canvas contents are *not* different
             * from the account's draft (known by checking the JSON). In this
             * case, the image raw data either:
             * 1) Is currently being saved, specifically in the case of users
             *    who are Free or Pro, and need to click "Save" before the
             *    "Download" button becomes accessible.
             * 2) Is already stored in an S3 resource
             */
            else {
                var check = false;
                if (Canvases.Ghost.getImage() !== null) {
                    var json = {
                            draft: Stencil.account().draft().json(),
                            ghost: Canvases.Ghost.getImage().json()
                        };
                    check = JSON.stringify(json.draft) === JSON.stringify(json.ghost);
                }

                /**
                 * This is the case where the account draft and ghost canvas
                 * contents match. This happens when:
                 * 1) A save action was initiated *before* a download action,
                 */
                if (check === true) {
                    this._disable();
                    var start = new Date();
                    (function() {
                        if (Canvases.Ghost.get('saving') === true) {
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, exportedContentType) {
                                    if (multiplier === '2x') {
                                        if (contentType !== recommendedExportContentType) {
                                            DataUtils.convertDataURLContentType(
                                                dataURL,
                                                contentType,
                                                function(dataURL) {
                                                    var blob = DataUtils.dataURLToBlob(dataURL);
                                                    saveAs(blob, filename);
                                                    _this.triggerHandler('close');
                                                }
                                            );
                                        } else {
                                            var blob = DataUtils.dataURLToBlob(dataURL);
                                            saveAs(blob, filename);
                                            _this.triggerHandler('close');
                                        }
                                    } else {
                                        var width = Frame.get('width').toInt(),
                                            height = Frame.get('height').toInt();
                                        DataUtils.resizeDataURL(
                                            dataURL,
                                            width,
                                            height,
                                            contentType,
                                            function(dataURL) {
                                                var blob = DataUtils.dataURLToBlob(dataURL);
                                                saveAs(blob, filename);
                                                _this.triggerHandler('close');
                                            }
                                        );
                                    }
                                }
                            });
                        } else {
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, contentType) {
                                    var blob = DataUtils.dataURLToBlob(dataURL);
                                    saveAs(blob, filename);
                                    _this.triggerHandler('close');
                                }
                            });
                            Canvases.Ghost.export(contentType, multiplier === '2x');
                        }
                    }).minDelay(start, this._delays.download);
                }
                /**
                 * This is the case where the account draft and ghost canvas
                 * contents do not match. This happens when:
                 * 1) A previously saved image is loaded into the canvas, and as
                 *    a result, nothing is different from the previously saved
                 *    S3 resource.
                 * 2) The app is initially loaded and a previously saved image
                 *    is the draft (which means an S3 resource exists).
                 */
                else {
                    this._disable();
                    var start = new Date();
                    (function() {
                        var lastSavedImage = Footer.getLastSavedImage();
                        lastSavedImage.once({
                            'download': function(event) {
                                _this.triggerHandler('close');
                            }
                        });
                        lastSavedImage.download(
                            contentType,
                            filename,
                            multiplier === '2x',
                            false,
                            false,
                            false
                        );
                    }).minDelay(start, this._delays.download);
                }
            }
        },

        /**
         * _remoteDownloadAction
         * 
         * @access  protected
         * @param   Object timeouts
         * @return  void
         */
        _remoteDownloadAction: function(timeouts) {
            var filename = this._getFilename(),
                contentType = this._getContentType(),
                multiplier = this._getMultiplier(),
                mediaType = this._getMediaType(),
                check = Footer.validate.changedCanvas.apply(Footer),
                _this = this;

            /**
             * If the canvas contents have changed from the ImageAccessor that's
             * been loaded into the account draft, then ensure a traditional
             * save action goes on.
             */
            var imageToCheckForProgress = this._image;
            if (check.valid === true) {
                this._disable();
                var start = new Date();
                (function() {
                    Footer.save('download', false, function(image, dataURL) {
                        image.once({
                            'download': function(event) {
                                _this.triggerHandler('close');
                            }
                        });
                        image.download(
                            contentType,
                            filename,
                            multiplier === '2x',
                            false,
                            mediaType,
                            false
                        );
                    });
                }).minDelay(start, this._delays.download);
            } else {
                imageToCheckForProgress = Footer.getLastSavedImage();
                this._disable();
                var start = new Date();
                (function() {
                    var lastSavedImage = Footer.getLastSavedImage();
                    lastSavedImage.once({
                        'download': function(event) {
                            _this.triggerHandler('close');
                        }
                    });
                    lastSavedImage.download(
                        contentType,
                        filename,
                        multiplier === '2x',
                        false,
                        mediaType,
                        false
                    );
                }).minDelay(start, this._delays.download);
            }

            // Success
            this._showPercentageUploadedState('preparing');
            var $percentage = this.find('span[lookup="percentage"]');
            imageToCheckForProgress.on({

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @return  void
                 */
                'upload/success': function(event, response) {
                    _this._showPercentageUploadedState('starting');
                },

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   Number loaded
                 * @param   Number total
                 * @return  void
                 */
                'upload/progress': function(event, loaded, total) {
                    TimeoutPool.clear(timeouts.escape);
                    TimeoutPool.clear(timeouts.reporting);
                    timeouts = _this._setupDownloadFreezeLogic();
                    var percentage = Math.round(
                        (loaded / total) * 100
                    );
                    if (percentage > 2) {
                        _this._showPercentageUploadedState('processing');
                        $percentage.text(percentage);
                    }
                }
            });
        },

        /**
         * _setupDownload
         * 
         * @access  protected
         * @return  void
         */
        _setupDownload: function() {
            this.on({
                'download': function(event) {

                    // Flow for download
                    this._blurFilename();
                    var timeouts = this._setupDownloadFreezeLogic();
                    if (UserAgentUtils.supports.adownload() === false) {
                        this._remoteDownloadAction(timeouts);
                    } else {
                        if (this._getMediaType() === 'print') {
                            this._remoteDownloadAction(timeouts);
                        } else {
                            if (this._forceRemoteDownload === true) {
                                this._remoteDownloadAction(timeouts);
                            } else {
                                this._localDownloadAction();
                            }
                        }
                    }
                }
            });
        },

        /**
         * _setupDownloadFreezeLogic
         * 
         * @access  protected
         * @return  Object
         */
        _setupDownloadFreezeLogic: function() {

            // Logging potential errors
            var form = this.find('form').first(),
                timeouts = {
                    escape: (function() {
                        Stencil.alert('download.bug');
                        Stencil.kill.delay(0);
                    }).delay(75 * 1000),
                    reporting: (function() {
                        var sendReports = function(logRocketURL) {
                            var msg = {
                                form: ElementUtils.getFormData(form, false),
                                logRocketURL: logRocketURL,
                                raw: {
                                    images: {
                                        draft: Stencil.account().draft().data(),
                                        lastSavedImage: Footer.getLastSavedImage() === false ? false : Footer.getLastSavedImage().data()
                                    }
                                }
                            };
                            var title = 'Long download duration';
                            title += ' (' + DataUtils.getRandomString() + ')';
                            RequestUtils.report(title, msg);
                            Raven.captureMessage('Long download duration', {
                                extra: {
                                    logRocketURL: logRocketURL,
                                    msg: msg
                                }
                            });
                        };
                        ClientWrappers.get('logRocket').getSessionUrl(
                            function(sessionUrl) {
                                sendReports(sessionUrl);
                            }
                        );
                    }).delay(60 * 1000)
                    // }).delay(500)
                };
            this.on({
                'close': function(event) {
                    TimeoutPool.clear(timeouts.reporting);
                    TimeoutPool.clear(timeouts.escape);
                }
            });
            return timeouts;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * _showPercentageUploadedState
         * 
         * @access  protected
         * @param   String state
         * @return  void
         */
        _showPercentageUploadedState: function(state) {
            var $button = this.find('a.button');
            $button.removeClass('busy')
            $button.addClass('remote');
            $button.removeClass('preparing');
            $button.removeClass('processing');
            $button.removeClass('starting');
            $button.addClass(state);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function(copy) {
            this._super();
            var $input = this.find('input[type="text"]').first();
            ElementUtils.select($input);
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * DropModalView
     * 
     * @extends ModalView
     */
    window.DropModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DropModalView')
         */
        _string: 'DropModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addDragListeners();
        },

        /**
         * _addDragListeners
         * 
         * @access  protected
         * @return  void
         */
        _addDragListeners: function() {
            var _this = this,
                $element = this._element;
            $element.listenForFileAndTabDrag({
                allowDirectoryDropping: Config.default('allowDirectoryUploading')
            });
            $element.on({
                'custom/drag/leave': function(event) {
                    _this.hide();
                },
                'custom/drag/drop/files': function(event, files, directoryDragged) {
                    _this._processFileDrag(files, directoryDragged);
                },
                'custom/drag/drop/tab': function(event, imageUrl) {
                    _this._processTabDrag(imageUrl);
                }
            });
        },

        /**
         * _hideCopy
         * 
         * @access  protected
         * @return  void
         */
        _hideCopy: function() {
            var $copy = this._element.find('div.copy span');
            $copy.addClass('invisible');
        },

        /**
         * _removeNonFonts
         * 
         * @access  protected
         * @param   Array files
         * @return  Array
         */
        _removeNonFonts: function(files) {
            var validFontExtensions = ['otf', 'woff', 'woff2', 'ttf'],
                fonts = [],
                file,
                extension,
                index;
            for (index in files) {
                file = files[index];
                extension = DataUtils.getItemExtension(file);
                if (ArrayUtils.contains(extension, validFontExtensions) === true) {
                    fonts.push(file);
                }
            }
            return fonts;
        },

        /**
         * _removeNonImages
         * 
         * @access  protected
         * @param   Array files
         * @return  Array
         */
        _removeNonImages: function(files) {
            var imageTypes = Config.default('validImageUploadContentTypes'),
                images = [],
                file,
                type,
                index;
            for (index in files) {
                file = files[index];
                type = file.type;
                type = DataUtils.guessItemContentType(file);
                if (ArrayUtils.contains(type, imageTypes) === true) {
                    images.push(file);
                }
            }
            return images;
        },

        /**
         * _processFileDrag
         * 
         * @access  protected
         * @param   Array files
         * @param   Boolean directoryDragged
         * @return  void
         */
        _processFileDrag: function(files, directoryDragged) {
            if (directoryDragged === true) {
                var dropzone = App.getApplicableDropzone();
                if (dropzone.getType() === 'font') {
                    files = this._removeNonFonts(files);
                } else {
                    files = this._removeNonImages(files);
                }
            }
            this._uploadFiles(files);
        },

        /**
         * _processTabDrag
         * 
         * This is a fun one :)
         * 
         * This method processes a drop from another browser tab/window. It
         * allows for either an image url (eg. http://domain.com/image.png) to
         * be received (and via the /utils/proxy endpoint, have it's content
         * retrieved), or an image data uri (eg. data:image/png;base64,...).
         * 
         * The 4096 character length is checked because it's a safe enough bet
         * that if it's greater than that length, it's not an image url (rather
         * an image data uri). However it's possible that if the length is
         * _smaller_ than that, it may still be an image data uri (eg. a really
         * small image). So in that case, I use the StringUtils method to check
         * whether the string is a valid url.
         * 
         * The reason I don't do that test right away is because I don't want
         * to run a regular expression against a (potentially) huge string if I
         * don't have to.
         * 
         * @access  protected
         * @param   String imageUrl
         * @return  void
         */
        _processTabDrag: function(imageUrl) {
            var callback = (function(blobs) {
                if (blobs !== false) {
                    this._uploadFiles(blobs);
                }
            }).proxy(this);
            if (imageUrl.length > 4096) {
                var blob = DataUtils.dataURLToBlob(imageUrl);
                blob.name = 'unknown';
                callback([blob]);
            } else {
                if (StringUtils.url(imageUrl) === true) {
                    DataUtils.getUrlsAsBlobs([imageUrl], callback);
                } else {
                    var blob = DataUtils.dataURLToBlob(imageUrl);
                    blob.name = 'unknown';
                    callback([blob]);
                }
            }
        },

        /**
         * _showCopy
         * 
         * @access  protected
         * @return  void
         */
        _showCopy: function() {
            if (App.getStage().fontsDropzoneVisible() === true) {
                this._element.find('div.copy span.fonts').removeClass('invisible');
            } else if (
                App.getEditor().getActiveArea() !== undefined
                && App.getEditor().getActiveArea().getType() === 'watermarks'
            ) {
                this._element.find('div.copy span.watermarks').removeClass('invisible');
            } else {
                this._element.find('div.copy span.images').removeClass('invisible');
            }
        },

        /**
         * _uploadFiles
         * 
         * @note    I believe the files.length check below is done because there
         *          was a case wherbey in an IE browser, multiple File objects
         *          were getting sent to this method, one of which was empty.
         *          And from what I can recall, the jQuery.makeArray method
         *          filtered those out, which in some cases, could result in
         *          files actually being empty. Thus, the check you see below.
         * @access  protected
         * @param   Array files
         * @return  Boolean
         */
        _uploadFiles: function(files) {
            if (files.length === undefined) {
                return false;
            }
            var dropzone = App.getApplicableDropzone();
            if (dropzone.availableForUpload() === false) {
                return false;
            }
            files = jQuery.makeArray(files);
            if (files.length === 0) {
                return false;
            }
            if (dropzone.toString() === 'WatermarksDropzoneView') {
                Stencil.navigate('/app/logos');
            } else if (dropzone.toString() === 'DropzoneView') {
                Stencil.navigate('/app/uploads');
            }
            dropzone.uploadItems(files);
            return true;
        },

        /**
         * show
         * 
         * @note    getActiveArea check is done incase the first path the user
         *          navigates to is in a modal (eg. /app/login).
         * @access  public
         * @return  void
         */
        show: function() {
            this._hideCopy();
            this._showCopy();
            this._super();
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ErrorModalView
     * 
     * @extends ModalView
     */
    window.ErrorModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ErrorModalView')
         */
        _string: 'ErrorModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            AudioUtils.play('ohho.mp3');
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ExtrasModalView
     * 
     * @extends ModalView
     */
    window.ExtrasModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ExtrasModalView')
         */
        _string: 'ExtrasModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            // this.on({
            //     'install': function(event) {
            //         if (UserAgentUtils.extension() === true) {
            //             Stencil.alert('extension.install.window');
            //         } else if (UserAgentUtils.supports.chromeWebstore() === false) {
            //             Stencil.alert('extension.install.chrome');
            //         } else {
            //             this.promptInstall();
            //         }
            //     }
            // });
        },

        /**
         * promptInstall
         * 
         * @access  public
         * @return  Boolean
         */
        promptInstall: function() {
            var prompted = ClientWrappers.get('chromeWebstore').promptInstall();
            return prompted;
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * GoogleFontsModalView
     * 
     * @see     https://i.imgur.com/yaeZdcb.png
     * @extends ModalView
     */
    window.GoogleFontsModalView = ModalView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|ImagesCollection (default: null)
         */
        _collection: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        if (event.which === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            } else {
                                if (this._query !== '') {
                                    this.triggerHandler('clear');
                                }
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="clear"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('clear');
                    }
                },
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        $input.parent().removeClass('queried');
                        $input.parent().removeClass('active');
                        if ($input.val().length > 0) {
                            $input.parent().addClass('active');
                        }

                        // Mark UI as queried if user types their way back
                        if ($input.val() === this._query) {
                            $input.parent().removeClass('active');
                            $input.parent().addClass('queried');
                        }
                    }
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.googleFontRow': function(event, $div) {
                        $div.siblings().removeClass('hover');
                        $div.addClass('hover');
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.googleFontRow': function(event, $div) {
                        $div.removeClass('hover');
                    }
                }
            });
        },

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _more: false,

        /**
         * _query
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _query: '',

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.results > div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load(false);
                        }
                    }
                }
            },

            /**
             * plugin
             * 
             * @note    It's important that the selector for $inner below does
             *          not look directly at the children of div.results since
             *          jScrollPane changes the relationship of the elements.
             * @access  private
             * @param   jQuery event
             * @param   Number y
             * @param   Boolean top
             * @param   Boolean bottom
             * @return  void
             */
            plugin: function(event, y, top, bottom) {
                var $inner = this._element.find('div.results div.inner');
                bottom = y > ($inner.outerHeight() - this._element.find('div.results').outerHeight() - this._threshold);
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load(false);
                        }
                    }
                }
            }
        },

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontsModalView')
         */
        _string: 'GoogleFontsModalView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 200)
         */
        _threshold: 200,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupTooltips();
            this._addHoverEvents();
            this._setupCollection();
            this.on({
                'close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'createFontPreviewImages': function(event, $anchor) {
                    this._createFontPreviewImages();
                },
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
            this._setupScrollbar();
            this._addInfiniteScrollEvents();
            this._setupDropdowns();
            this._setupCheckboxes();
            this._setupSearch();
        },

        /**
         * _addHoverEvents
         * 
         * @access  protected
         * @return  void
         */
        _addHoverEvents: function() {
            this.find('div.results').scroll(function(event) {
                var element = document.elementFromPoint(App.getX(), App.getY()),
                    $element = $(element);
                if ($element.length > 0) {
                    $element.closest('.googleFontRow').trigger('mouseenter');
                }
            });
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            if (this._$scrollbar !== null) {
                check = this._scroll.plugin.proxy(this);
                listener = 'jsp-scroll-y';
            }
            this.find('div.results').first().bind(listener, check);
        },

        /**
         * _createFontPreviewImages
         * 
         * @note    After running this method (via the local anchor link), a zip
         *          file will be pushed at you. Run the following commands from
         *          OSX (new terminal session):
cd ~/Downloads/ \
&& mkdir ~/Sites/getstencil.com/tmp-fonts/ \
&& mkdir ~/Sites/getstencil.com/tmp-fonts/compressed/ \
&& mkdir ~/Sites/getstencil.com/tmp-fonts/original/ \
&& unzip images.zip -d ~/Sites/getstencil.com/tmp-fonts/compressed/ \
&& unzip images.zip -d ~/Sites/getstencil.com/tmp-fonts/original/ \
&& rsc
         *
vm3
         *
cd /var/www/getstencil.com/tmp-fonts/compressed/ \
&& pngquant *.png -f --ext .png --quality=65-80 \
&& exit
         *
scp -r ubuntu@10.211.55.16:/var/www/getstencil.com/tmp-fonts/compressed/* ~/Sites/getstencil.com/TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages/48px/compressed/ \
&& scp -r ubuntu@10.211.55.16:/var/www/getstencil.com/tmp-fonts/original/* ~/Sites/getstencil.com/TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages/48px/original/ \
&& rm -rf ~/Sites/getstencil.com/tmp-fonts/ \
&& rsc
         *
cd ~/Sites/getstencil.com/TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages \
&& echo "hi" >> LICENSE \
&& git stash \
&& git checkout master \
&& git pull \
&& git stash pop \
&& git checkout -- LICENSE \
&& git add * \
&& git commit -m "New fonts" \
&& git push \
&& cd ~/Sites/getstencil.com/ \
&& git add TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages \
&& git commit -m "New GoogleWebFonts submodule commit" \
&& git status
         * 
git checkout -- TurtlePHP/application/config/settings/defaults.inc.php \
TurtlePHP/application/controllers/GoogleFonts.class.php \
TurtlePHP/application/webroot/app/static/templates/modals/googleFonts.html
         * 
         * @see     https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
         * @access  protected
         * @return  void
         */
        _createFontPreviewImages: function() {
            var optimizeForRetina = true,
                drawCanvas = function(label, fontFamily) {
                    var canvas = document.createElement('canvas'),
                        context = canvas.getContext('2d'),
                        multiplier = optimizeForRetina === true ? UserAgentUtils.getDevicePixelRatio() : 1;
                    canvas.width = 800 * multiplier;
                    canvas.height = 300 * multiplier;
                    context.scale(multiplier, multiplier);
                    context.font = '48px "' + (fontFamily) + '"';
                    context.fillText(label, 10, 50);
                    return canvas;
                };
            var zip = new JSZip(),
                counter = 0,
                collection = this._collection;
            collection.each(function(index, googleFont) {
                if (googleFont.get('hasImage').toInt() === 0) {
                    googleFont.drawStyleSheet();

                    // Initiate the load
                    WebFont.load({
                        classes: false,
                        fontactive: function(familyName, fvd) {
                            ++counter;
                            var rawCanvas = drawCanvas(
                                    googleFont.get('family'),
                                    googleFont.get('id')
                                ),
                                trimDetails = CanvasElementUtils.trimTransparentPixels(rawCanvas),
                                resizedCanvas = document.createElement('canvas'),
                                resizedContext = resizedCanvas.getContext('2d'),
                                multiplier = optimizeForRetina === true ? UserAgentUtils.getDevicePixelRatio() : 1;
                            resizedCanvas.width = trimDetails.width / multiplier;
                            resizedCanvas.height = trimDetails.height / multiplier;
                            resizedContext.drawImage(
                                rawCanvas,
                                trimDetails.bounds.left,
                                trimDetails.bounds.top,
                                trimDetails.width,
                                trimDetails.height,
                                0,
                                0,
                                trimDetails.width / multiplier,
                                trimDetails.height / multiplier
                            );

                            // 
                            console.log('added to zip file #' + counter);
                            var name = (googleFont.get('id')) + '.' +
                                (googleFont.get('version')) + '.png';
                            zip.file(
                                name,
                                resizedCanvas.toDataURL('image/png').split(',')[1],
                                {
                                    base64: true
                                }
                            );

                            // 
                            var googleFontsWithoutImages = collection.filter(function(index, googleFont) {
                                return googleFont.get('hasImage').toInt() === 0;
                            });
                            if (counter === googleFontsWithoutImages.length) {
                                zip.generateAsync({type: 'blob'}).then(
                                    function(content) {
                                        saveAs(content, 'images.zip');
                                    }
                                );
                            }
                        },
                        fontinactive: function() {
                            console.log('bag');
                        },
                        custom: {
                            families: [googleFont.get('id')]
                        },
                        timeout: 5000
                    });
                }
            });
        },

        /**
         * _drawGoogleFont
         * 
         * @access  protected
         * @param   GoogleFontAccessor googleFont
         * @param   Number position
         * @return  void
         */
        _drawGoogleFont: function(googleFont, position) {
            var $element = DataUtils.render('GoogleFontRow', {
                googleFont: googleFont
            });
            if (position === 0) {
                this.find('div.results div.inner').prepend($element);
            } else {
                this.find('div.results div.inner').append($element);
            }
            new GoogleFontRowView($element, googleFont);
        },

        /**
         * _getCategories
         * 
         * @note    ['empty'] array is returned when no categories, because
         *          otherwise, there's an error on the backend because JavaScript
         *          can't submit an empty array as a parameter via ajax.
         * @access  protected
         * @return  Array
         */
        _getCategories: function() {
            var $checked = this.find('input[type="checkbox"]:checked'),
                categories = [], index;
            jQuery.each($checked, function(index, $input) {
                categories.push(
                    $($input).val()
                );
            });
            if (categories.length === 0) {
                return ['empty'];
            }
            return categories;
        },

        /**
         * _getSubset
         * 
         * @access  protected
         * @return  String
         */
        _getSubset: function() {
            return this.find('[name="data[subset]"]').val();
        },

        /**
         * _getQuery
         * 
         * @access  protected
         * @return  String
         */
        _getQuery: function() {
            return this._query;
        },

        /**
         * _getWeight
         * 
         * @access  protected
         * @return  String
         */
        _getWeight: function() {
            return this.find('[name="data[weight]"]').val();
        },

        /**
         * _getSort
         * 
         * @access  protected
         * @return  String
         */
        _getSort: function() {
            return this.find('[name="data[sort]"]').val();
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _resetInputs
         * 
         * @access  protected
         * @return  void
         */
        _resetInputs: function() {
            var $subset = this.find('select[name="data[subset]"]');
            $subset.val('all');
            $subset.selectpicker('refresh');
            var $weight = this.find('select[name="data[weight]"]');
            $weight.val('all');
            $weight.selectpicker('refresh');
            var $checkboxes = this.find('input[type="checkbox"]');
            $checkboxes.prop('checked', true);
        },

        /**
         * _setupCheckboxes
         * 
         * @access  protected
         * @return  void
         */
        _setupCheckboxes: function() {
            var _this = this;
            this.find('input[type="checkbox"]').on({
                'change': function(event) {
                    _this.pause();
                    _this.unload();
                    _this.trackLoad();
                    _this.load(true, function() {
                        _this.unpause();
                    });
                }
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new GoogleFontsCollection();
            this._collection.on({
                'add': function(event, googleFont, position) {
                    _this._drawGoogleFont(googleFont, position);
                },
                'list': function(event) {
                    _this.refreshScrollbar();
                },
                'empty': function(event) {
                    _this.find('.googleFontRow').remove();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.pause();
                    _this.unload();
                    _this.trackLoad();
                    _this.load(true, function() {
                        _this.unpause();
                    });
                    _this.find('label').focus();
                }
            );
        },

        /**
         * _setupScrollbar
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbar: function() {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                var $results = this.find('div.results');
                this._makeScrollable($results);
            }
        },

        /**
         * _setupSearch
         * 
         * @access  protected
         * @return  void
         */
        _setupSearch: function() {

            // Draw
            var total = Config.get('google').fonts.total.commas(),
                placeholder = 'Search for your font by name',
                $search = DataUtils.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this.find('h1').after($search);

            // Events
            this.on({
                'clear': function(event) {
                    var $input = this.find('input.search');
                    $input.val('');
                    this.find('div.field').removeClass('queried');
                    this.find('div.field').addClass('active');
                    this._query = '';
                    this.unload();
                    this.pause();
                    var _this = this;
                    this.trackLoad();
                    this.load(true, function() {
                        _this.unpause();
                        if (UserAgentUtils.is.tablet() === false) {
                            $input.focus();
                        }
                    });
                },
                'submit': function(event) {
                    this._resetInputs();
                    var $input = this.find('input.search'),
                        val = $input.val();
                    if (UserAgentUtils.is.tablet() === true) {
                        document.activeElement.blur();
                        $input.blur();
                    }
                    this.find('div.field').addClass('queried');
                    this.find('div.field').removeClass('active');
                    this._query = $input.val();
                    this.unload();
                    this.pause();
                    var _this = this;
                    this.trackLoad();
                    this.load(true, function() {
                        _this.unpause();
                        if (UserAgentUtils.is.tablet() === false) {
                            $input.focus();
                        }
                    });
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * getCollection
         * 
         * @access  public
         * @return  GoogleFontsCollection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * load
         * 
         * @note    We need to check for stats being defined because when the
         *          request times out, that property isn't available. See:
         *          https://i.imgur.com/cYAI9mt.png
         * @access  public
         * @param   Boolean delay
         * @param   undefined|Function callback
         * @return  void
         */
        load: function(delay, callback) {
            var _this = this;
            this._element.find('.empty').addClass('hidden');
            this._element.addClass('loading');
            this._collection.list({
                conditions: {
                    categories: this._getCategories(),
                    query: this._getQuery(),
                    subset: this._getSubset(),
                    weight: this._getWeight()
                },
                delay: delay === true ? 1 : 0,
                limit: Config.default('objectsPerPage').fonts.import,
                offset: this._collection.length(),
                sort: this._getSort()
            }, function(response) {
                _this._element.removeClass('loading');
                _this._loading = false;
                _this._more = response.data.more;
                if (response.data.stats !== undefined) {
                    _this.updateCount(
                        response.data.stats.found,
                        response.data.stats.total
                    );
                }
                if (_this._collection.length() === 0) {
                    _this._element.find('.empty').removeClass('hidden');
                }
                callback && callback();
            });
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._super();
            this.find('a.button.tiny').disable();
            this.find('div.field input').disable();
            this.find('aside').disable();
        },

        /**
         * refreshScrollbar
         * 
         * @access  public
         * @return  void
         */
        refreshScrollbar: function() {
            if (this._$scrollbar !== null) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            Stencil.set('ignoreMouseDownLayerBlur', true);
            if (UserAgentUtils.is.tablet() === false) {
                this.find('input[type="text"]').focus();
            }
            if (this._loaded === false) {
            // if (this._query !== query) {
                // this.unload();
                // this._query = query;
                this.trackLoad();
                this.load(true);
            }
        },

        /**
         * trackLoad
         * 
         * Tracks that results are being loaded.
         * 
         * @access  public
         * @return  void
         */
        trackLoad: function() {
            this._loaded = true;
            this._loading = true;
        },

        /**
         * unload
         * 
         * @access  public
         * @return  void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._super();
            this.find('a.button.tiny:not(.done)').enable();
            this.find('div.field input').enable();
            this.find('aside').enable();
        },

        /**
         * updateCount
         * 
         * @access  public
         * @param   Number found
         * @param   Number total
         * @return  void
         */
        updateCount: function(found, total) {
            var $counts = this.find('section footer div.counts'),
                $total = $counts.find('strong');
            $counts.removeClass('invisible');
            $total.text(total.commas());
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ImageSentModalView
     * 
     * @extends ModalView
     */
    window.ImageSentModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageSentModalView')
         */
        _string: 'ImageSentModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, shareModal, image) {
            this._super(element);
            this._shareModal = shareModal;
            this._setupTooltips();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = image.getSharePath('instagram');
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * LegacyModalView
     * 
     * @extends ModalView
     */
    window.LegacyModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LegacyModalView')
         */
        _string: 'LegacyModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * LegacyImageNormalizeModalView
     * 
     * @extends ModalView
     */
    window.LegacyImageNormalizeModalView = ModalView.extend({

        /**
         * _image
         * 
         * @access  protected
         * @var     false|ImageAccessor (default: false)
         */
        _image: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LegacyImageNormalizeModalView')
         */
        _string: 'LegacyImageNormalizeModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this._addLeaveEvent();
        },

        /**
         * _addLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _addLeaveEvent: function() {
            this.on({
                'leave': function(event) {
                    if (this._image.get('legacyNormalized').toInt() === 1) {
                        this._image.select('unknown', false, {});
                    } else {
                        var start = new Date(),
                            key = 'image.legacy.normalizing',
                            msg = Config.getMessage(key);
                        App.getBusy().show(msg);
                        this._image.once({
                            'normalize': function(event) {
                                (function() {
                                    App.getBusy().hide();
                                    this.select('unknown', false, {});
                                }).minDelay(start, 2500, this);
                            }
                        });
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('AuthModalView', function() {

    /**
     * LoginModalView
     * 
     * @extends AuthModalView
     */
    window.LoginModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LoginModalView')
         */
        _string: 'LoginModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   false|String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    var accountData = response.data.account,
                        userData = response.data.user;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    Stencil.account().swap(accountData);
                    Stencil.account().swapCategories();
                    var model = Stencil.getModel('User'),
                        user = model.setAccessor(userData);
                    Stencil.set('user', user);
                    User.login();
                    _this._flow();
                }
            });
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ModalView
     * 
     * @events  close
     *          leave
     * @extends View
     */
    window.ModalView = View.extend({

        /**
         * _fallbackPath
         * 
         * The path that a modal should fallback to if it was directly accessed
         * and is subsequently closed (eg. linking a user to a share modal from
         * an email).
         * 
         * @access  protected
         * @var     String (default: '/app')
         */
        _fallbackPath: '/app',

        /**
         * _paused
         * 
         * Tracks whether the modal is paused. Used to prevent the user from
         * navigating away and interrupting the UX.
         * 
         * @access  protected
         * @var     Boolean
         */
        _paused: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ModalView')
         */
        _string: 'ModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addCloseEvent();
            this._addHideEvent();
            this._addLeaveEvent();
        },

        /**
         * _addCloseEvent
         * 
         * Adds a close event to the modal, which in this case is responsible
         * for:
         * - hiding tooltips that may be showing in the modal
         * - Closing HelpScout if it's open
         * - Remove the modal from the DOM
         * - Removing the modal reference from the Modals singelton refernce of
         *   open modals
         * 
         * It's important to note that this listener does not affect app
         * navigation at all.
         * 
         * @access  protected
         * @return  void
         */
        _addCloseEvent: function() {
            this.on({
                'close': function(event) {
                    App.tooltips.hide();
                    var _this = this,
                        open = ModalUtils.getOpen();
                    ClientWrappers.get('helpScout').closeBeacon();
                    this.remove();
                    $(open).each(
                        function(index, modal) {
                            if (modal === _this) {
                                open.splice(index, 1);
                            }
                        }
                    );
                }
            });
        },

        /**
         * _addHideEvent
         * 
         * Adds a hide event to the modal, which at the time of documenting is
         * only being used by the SocialSettingsView class.
         * 
         * @access  protected
         * @return  void
         */
        _addHideEvent: function() {
            this.on({
                'hide': function(event) {
                    this.hide();
                }
            });
        },

        /**
         * _addLeaveEvent
         * 
         * Adds a leave event, which at the time of documenting, is similar to a
         * close event, with the exception that it will navigate the browser
         * back to a specific path.
         * 
         * @access  protected
         * @return  void
         */
        _addLeaveEvent: function() {
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var router = Stencil.getRouter(),
                        path = router.getPrevious() || this._fallbackPath;
                    router.setPrevious(false);
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * find
         * 
         * Middleware method to prevent lookups from going into any submodals.
         * This was happening between the CheckoutModal and ApplyCouponModal.
         * 
         * @access  public
         * @param   String selector
         * @return  jQuery
         */
        find: function(selector) {
            var $matches = this._super(selector);
            if (this._element.parents('.modal').length === 0) {
                return $matches.filter(function() {
                    return $(this).parents('.modal').length === 1;
                });
            }
            return $matches;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._element.addClass('hidden');
        },

        /**
         * leaveUponEscapeKey
         * 
         * @access  public
         * @return  void
         */
        leaveUponEscapeKey: function() {
            var check = (function(event) {
                if (event.which === 27) {
                    this.triggerHandler('leave');
                }
            }).proxy(this);
            App.getElement().on({
                'keydown': check
            });
            this.on({
                'leave': function(event) {
                    App.getElement().unbind('keydown', check);
                }
            });
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._paused = true;
            this.find('> div.overlay').removeAttr('click');
            this.find('a.close').addClass('invisible');
        },

        /**
         * remove
         * 
         * @access  public
         * @return  void
         */
        remove: function() {
            this._element.remove();
        },

        /**
         * setFallbackPath
         * 
         * @access  public
         * @param   String path
         * @return  void
         */
        // setFallbackPath: function(path) {
        //     this._fallbackPath = path;
        // },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._element.removeClass('hidden');
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._paused = false;
            this.find('> div.overlay').attr('click', 1);
            this.find('a.close').removeClass('invisible');
        }
    });
});
window.DependencyLoader.push('StickyModalView', function() {

    /**
     * OnboardModalView
     * 
     * @extends StickyModalView
     */
    window.OnboardModalView = StickyModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OnboardModalView')
         */
        _string: 'OnboardModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String point
         * @param   jQuery $relative
         * @param   jQuery $highlight
         * @return  void
         */
        init: function(element, point, $relative, $highlight) {
            // LogUtils.log.simple([$relative, $highlight], true);
            this._super(element, point, $relative, $highlight);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * OnboardingModalView
     * 
     * @extends ModalView
     */
    window.OnboardingModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OnboardingModalView')
         */
        _string: 'OnboardingModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Object settings
         * @return  void
         */
        init: function(element, settings) {
            this._super(element);
            this._settings = settings;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * OrientationModalView
     * 
     * @extends ModalView
     */
    window.OrientationModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OrientationModalView')
         */
        _string: 'OrientationModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * PasswordModalView
     * 
     * @extends ModalView
     */
    window.PasswordModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _redirect
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _redirect: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PasswordModalView')
         */
        _string: 'PasswordModalView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element);
            this._type = type;
            this._redirect = redirect;
            this._form = new AppFormView(this.find('form'));
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Password recovery email sent');
                    Stencil.alert('password.reset')
                    _this.getElement().addClass('hide');
                    // _this.triggerHandler('leave');
                    // Stencil.alert('password.reset');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * PlanSwitchModalView
     * 
     * @extends ModalView
     */
    window.PlanSwitchModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlanSwitchModalView')
         */
        _string: 'PlanSwitchModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * PlanSwitchedModalView
     * 
     * @extends ModalView
     */
    window.PlanSwitchedModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlanSwitchedModalView')
         */
        _string: 'PlanSwitchedModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * PlansModalView
     * 
     * @extends ModalView
     */
    window.PlansModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlansModalView')
         */
        _string: 'PlansModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addToggleListeners();
            // this.unbind('leave');
            // this.on({
            //     'leave': function(event) {
            //         this.triggerHandler('close');
            //     }
            // });
        },

        /**
         * _addToggleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addToggleListeners: function() {
            this.on({
                'showAnnuallyPricing': function(event) {
                    this._showAnnuallyPricing();
                },
                'showMonthlyPricing': function(event) {
                    this._showMonthlyPricing();
                },
                'togglePricing': function(event) {
                    this._togglePricing();
                }
            });
        },

        /**
         * _showAnnuallyPricing
         * 
         * @access  protected
         * @return  void
         */
        _showAnnuallyPricing: function() {
            var $element = this.getElement(),
                $ctas = this.find('.cta');
            $element.attr('interval', 'annually');
            $ctas.each(function(index, cta) {
                var $cta = $(cta),
                    $anchor = $cta.find('a'),
                    href = $anchor.attr('href');
                if (DataUtils.valid(href) === true) {
                    href = href.replace('monthly', 'annually');
                    $anchor.attr('href', href);
                }
            });
        },

        /**
         * _showMonthlyPricing
         * 
         * @access  protected
         * @return  void
         */
        _showMonthlyPricing: function() {
            var $element = this.getElement(),
                $ctas = this.find('.cta');
            $element.attr('interval', 'monthly');
            $ctas.each(function(index, cta) {
                var $cta = $(cta),
                    $anchor = $cta.find('a'),
                    href = $anchor.attr('href');
                if (DataUtils.valid(href) === true) {
                    href = href.replace('annually', 'monthly');
                    $anchor.attr('href', href);
                }
            });
        },

        /**
         * _togglePricing
         * 
         * @access  protected
         * @return  void
         */
        _togglePricing: function() {
            var $element = this.getElement(),
                interval = $element.attr('interval');
            this._showAnnuallyPricing();
            if (interval === 'annually') {
                this._showMonthlyPricing();
            }
        }
    });
});
window.DependencyLoader.push('AuthModalView', function() {

    /**
     * PromoModalView
     * 
     * @extends AuthModalView
     */
    window.PromoModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoModalView')
         */
        _string: 'PromoModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   false|String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {

                    // Data merge for change history
                    var userData = response.data.user,
                        accountData = response.data.account;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(
                        userData
                    );

                    /**
                     * Signup as well as promo redemption
                     * 
                     */
                    if (Stencil.get('user') === false) {
                        var model = Stencil.getModel('User'),
                            user;
                        user = model.setAccessor(userData);
                        Stencil.set('user', user);
                        User.signup();
                    }

                    /**
                     * Promo redemption for logged in account
                     * 
                     */
                    Stencil.account().merge(accountData);
                    Stencil.get('user').merge(userData);
                    User.upgrade(false);
                    var path = Stencil.account().getUpgradedPath();
                    if (_this._type !== 'curtain') {
                        _this.triggerHandler('leave');
                        Stencil.navigate(path);
                    } else {
                        _this._element.addClass('transition');
                        (function() {
                            App.getElement().removeClass('curtain');
                            _this.triggerHandler('leave');
                            Stencil.navigate(path);
                        // }).delay(1800);
                        }).delay(0);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('AddRecordModalView', function() {

    /**
     * AddPromoSetModalView
     * 
     * @extends AddRecordModalView
     */
    window.AddPromoSetModalView = AddRecordModalView.extend({

        /**
         * _fallbackPath
         * 
         * @access  protected
         * @var     String (default: '/app/admin/promoSets')
         */
        _fallbackPath: '/app/admin/promoSets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddPromoSetModalView')
         */
        _string: 'AddPromoSetModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element, adminModal);
        },

        /**
         * _formatExpiry
         * 
         * Converts the expiry input value from a human-readable one to a unix
         * timestamp (milliseconds excluded).
         * 
         * @access  protected
         * @return  void
         */
        _formatExpiry: function() {
            var $expiry = this.find('#expiry'),
                expiry = $expiry.val(),
                mo = moment(expiry, 'MM/DD/YYYY h:mm A');
            this.find('[name="data[expiry]"]').val(
                mo.format('X')
            );
        },

        /**
         * _formatFormData
         * 
         * @access  protected
         * @return  void
         */
        _formatFormData: function() {
            this._formatExpiry();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._super();
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Promo set added');
                    var collection = _this._adminModal.getSection('promoSets')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/promoSets');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * RenameModalView
     * 
     * @events  save
     * @extends ModalView
     */
    window.RenameModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RenameModalView')
         */
        _string: 'RenameModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned/failed': function(event) {
                    _this.unpause();
                },
                'returned/shit': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    _this.triggerHandler('save', [response.data.object]);
                }
            });
        }
    });
});
window.DependencyLoader.push('StickyModalView', function() {

    /**
     * RightClickModalView
     * 
     * @extends StickyModalView
     */
    window.RightClickModalView = StickyModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RightClickModalView')
         */
        _string: 'RightClickModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String direction
         * @param   jQuery $relative
         * @param   jQuery $highlight
         * @return  void
         */
        init: function(element, direction, $relative, $highlight) {
            // LogUtils.log.simple([$relative, $highlight], true);
            this._super(element, direction, $relative, $highlight);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ServicesSettingsModalView
     * 
     * @extends ModalView
     */
    window.ServicesSettingsModalView = ModalView.extend({

        /**
         * _configurableServices
         * 
         * @access  protected
         * @var     Array
         */
        _configurableServices: [
            'accountDock',
            'algolia',
            //'aws',
            'bitly',
            'buffer',
            'campaignMonitor',
            'checkout',
            //'cloudinary',
            'cronhub',
            'cropper',
            'facebook',
            'fontUploads',
            'headway',
            'helpScout',
            'iconfinder',
            'icons8',
            //'logRocket',
            'pexels',
            'pinterest',
            'pixabay',
            //'reCaptcha',
            //'segment',
            'sentry',
            //'shareASale',
            //'stripe',
            //'tapfiliate',
            'theNounProject',
            'twilio',
            'twitter',
            'unsplash',
            'uppy',
            'vectorSearch'
        ],

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ServicesSettingsModalView')
         */
        _string: 'ServicesSettingsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawServiceSettingRows();
            this._setupLeaveEvent();
        },

        /**
         * _drawServiceSettingRow
         * 
         * @access  protected
         * @param   String serviceKey
         * @return  void
         */
        _drawServiceSettingRow: function(serviceKey) {
            var $services = this.find('div.services'),
                $service = DataUtils.render('AdminServiceSettingRow', {
                    serviceKey: serviceKey
                }),
                view = new AdminServiceSettingRowView($service, serviceKey);
            $services.append($service);
        },

        /**
         * _drawServiceSettingRows
         * 
         * @access  protected
         * @return  void
         */
        _drawServiceSettingRows: function() {
            var index, serviceKey;
            for (index in this._configurableServices) {
                serviceKey = this._configurableServices[index];
                this._drawServiceSettingRow(serviceKey);
            }
        },

        /**
         * _setupLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupLeaveEvent: function() {
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/dashboard');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * SettingsModalView
     * 
     * @extends ModalView
     */
    window.SettingsModalView = ModalView.extend({

        /**
         * _settings
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _settings: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SettingsModalView')
         */
        _string: 'SettingsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupNotifications();
            this._setupObfuscate();
            this._setupPassword();
            this._setupPayment();
            this._setupPlan();
            this._setupProfile();
            this._setupReferral();
            this._setupSocial();
        },

        /**
         * _setupNotifications
         * 
         * @access  protected
         * @return  void
         */
        _setupNotifications: function() {
            var $notifications = this.find('section.notifications');
            this._settings.notifications = new NotificationsSettingsView(
                $notifications,
                this
            );
        },

        /**
         * _setupObfuscate
         * 
         * @access  protected
         * @return  void
         */
        _setupObfuscate: function() {
            var $obfuscate = this.find('section.obfuscate');
            this._settings.obfuscate = new ObfuscateSettingsView(
                $obfuscate,
                this
            );
        },

        /**
         * _setupPassword
         * 
         * @access  protected
         * @return  void
         */
        _setupPassword: function() {
            var $password = this.find('section.password');
            this._settings.password = new PasswordSettingsView($password, this);
        },

        /**
         * _setupPayment
         * 
         * @access  protected
         * @return  void
         */
        _setupPayment: function() {
            var $payment = this.find('section.payment');
            this._settings.payment = new PaymentSettingsView($payment, this);
        },

        /**
         * _setupPlan
         * 
         * @access  protected
         * @return  void
         */
        _setupPlan: function() {
            var $plan = this.find('section.plan');
            this._settings.plan = new PlanSettingsView($plan, this);
        },

        /**
         * _setupProfile
         * 
         * @access  protected
         * @return  void
         */
        _setupProfile: function() {
            var $profile = this.find('section.profile');
            this._settings.profile = new ProfileSettingsView($profile, this);
        },

        /**
         * _setupReferral
         * 
         * @access  protected
         * @return  void
         */
        _setupReferral: function() {
            var $referral = this.find('section.referral');
            this._settings.referral = new ReferralSettingsView($referral, this);
        },

        /**
         * _setupSocial
         * 
         * @access  protected
         * @return  void
         */
        _setupSocial: function() {
            var $social = this.find('section.social');
            this._settings.social = new SocialSettingsView($social, this);
        },

        /**
         * getSettings
         * 
         * @access  public
         * @param   String type
         * @return  SettingsView
         */
        getSettings: function(type) {
            return this._settings[type];
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ShareModalView
     * 
     * @todo    Preload connection profile/images, incase they change their
     *          desired connection.
     * @todo    Currently the 64 bit data encoded image is inserted into any
     *          share views that the user views, while the image is being
     *          uploaded
     *          For better quality, two things should happen:
     *          1. When the ghost is ready, switch that data encoded value in
     *          2. When the image has been uploaded, switch that src in
     * @extends ModalView
     */
    window.ShareModalView = ModalView.extend({

        /**
         * _fallback
         * 
         * See parent for documentation on this property.
         * 
         * @access  protected
         * @var     String (default: '/app/saved')
         */
        _fallback: '/app/saved',

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _networks
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _networks: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareModalView')
         */
        _string: 'ShareModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this._setupBuffer();
            this._setupFacebook();
            this._setupInstagram();
            this._setupLink();
            this._setupPinterest();
            this._setupTooltips();
            this._setupTwitter();
            this._setupVerifone();
            // this._addHoverEvents();
        },

        /**
         * _addVerifoneFrameAttribute
         * 
         * @access  protected
         * @return  void
         */
        _addVerifoneFrameAttribute: function() {
            this._element.removeAttr('frame');
            if (this._image.isVerifoneFrame() === true) {
                var frameKey = this._image.get('frame');
                this._element.attr('frame', frameKey);
            }
        },

        /**
         * _addHoverEvents
         * 
         * @access  protected
         * @var     void
         */
        _addHoverEvents: function() {
            var _this = this;
            this.find('a[network]:not([network="buffer"])').one({
                'mouseenter': function(event) {
                    var $target = $(event.currentTarget),
                        network = $target.attr('network');
                    _this._networks[network].drawImage('desktop');
                }
            });
            this.find('a[network="buffer"]').one({
                'mouseenter': function(event) {
                    var $target = $(event.currentTarget),
                        network = $target.attr('network');
                    _this._networks[network].drawImage();
                }
            });
        },

        /**
         * _setupBuffer
         * 
         * @access  protected
         * @return  void
         */
        _setupBuffer: function() {
            var $buffer = this.find('section.buffer');
            this._networks.buffer = new BufferShareView($buffer, this);
        },

        /**
         * _setupFacebook
         * 
         * @access  protected
         * @return  void
         */
        _setupFacebook: function() {
            var $facebook = this.find('section.facebook');
            this._networks.facebook = new FacebookShareView($facebook, this);
        },

        /**
         * _setupInstagram
         * 
         * @access  protected
         * @return  void
         */
        _setupInstagram: function() {
            var $instagram = this.find('section.instagram');
            this._networks.instagram = new InstagramShareView($instagram, this);
        },

        /**
         * _setupLink
         * 
         * @access  protected
         * @return  void
         */
        _setupLink: function() {
            var $link = this.find('section.link');
            this._networks.link = new LinkShareView($link, this);
        },

        /**
         * _setupPinterest
         * 
         * @access  protected
         * @return  void
         */
        _setupPinterest: function() {
            var $pinterest = this.find('section.pinterest');
            this._networks.pinterest = new PinterestShareView($pinterest, this);
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            var account = Stencil.account();
            // if (account.createdBefore('2 weeks') === false) {
            if (false) {
                this._element.tooltip({
                    html: true,
                    selector: '[tooltip]',
                    container: this._element,
                    placement: 'left'
                });
            }
        },

        /**
         * _setupTwitter
         * 
         * @access  protected
         * @return  void
         */
        _setupTwitter: function() {
            var $twitter = this.find('section.twitter');
            this._networks.twitter = new TwitterShareView($twitter, this);
        },

        /**
         * _setupVerifone
         * 
         * @access  protected
         * @return  void
         */
        _setupVerifone: function() {
            var $verifone = this.find('section.verifone');
            this._networks.verifone = new VerifoneShareView($verifone, this);
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getNetwork
         * 
         * @access  public
         * @param   String network
         * @return  NetworkView
         */
        getNetwork: function(network) {
            return this._networks[network];
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._super();
            this.find('nav a').disable();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._addVerifoneFrameAttribute();
            this._super();
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._super();
            this.find('nav a').enable();
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ShareErrorModalView
     * 
     * @extends ModalView
     */
    window.ShareErrorModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareErrorModalView')
         */
        _string: 'ShareErrorModalView',

        /**
         * init
         * 
         * @todo    Look into whether redirect below is needed; I don't think it
         *          is, since the success modal isn't a unique resource. Should
         *          be able to just close it.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @param   ConnectionAccessor connection
         * @return  void
         */
        init: function(element, shareModal, image, connection) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var network = connection.get('network'),
                        path = image.getSharePath(network);
                    Stencil.navigate(path);
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * ShareSuccessModalView
     * 
     * @extends ModalView
     */
    window.ShareSuccessModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareSuccessModalView')
         */
        _string: 'ShareSuccessModalView',

        /**
         * init
         * 
         * @todo    Look into whether redirect below is needed; I don't think it
         *          is, since the success modal isn't a unique resource. Should
         *          be able to just close it.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ShareAccessor share
         * @return  void
         */
        init: function(element, shareModal, share) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var network = share.reference('connection').get('network'),
                        path = share.reference('image').getSharePath(network);
                    Stencil.navigate(path);
                }
            });
        }
    });
});
window.DependencyLoader.push('AuthModalView', function() {

/*
Stencil.navigate('/app/signup');
Stencil.navigate('/app/signup?save');
Stencil.navigate('/app/signup?upgrade');
Stencil.navigate('/app/signup?checkout');
*/

    /**
     * SignupModalView
     * 
     * @extends AuthModalView
     */
    window.SignupModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SignupModalView')
         */
        _string: 'SignupModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            this._form.setHandlerDelay(0);
            this._deselectSelectedLayer();
            this._loadCaptchaScript();
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('User'),
                        userData = response.data.user,
                        user;
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    user = model.setAccessor(userData);
                    Stencil.set('user', user);
                    User.signup();
                    _this._flow();
                }
            });
        },

        /**
         * _loadCaptchaScript
         * 
         * @access  protected
         * @return  void
         */
        _loadCaptchaScript: function() {
            if (Account.requireCaptcha() === true) {
                Scripts.load('reCaptcha');
            }
        },

        /**
         * _deselectSelectedLayer
         * 
         * @note    This exists because there was a case whereby a user got to
         *          the signup modal and a toolbar was open. When that happened,
         *          which also meant a ToolbarView was showing, the keydown event
         *          listener for the page was preventing the tab key (since that
         *          event triggers the layer-tabbing flow) from working within
         *          the form. So I saw below that if a layer is selected, discard
         *          the active object, hide the controls for the drawing, and
         *          hide the toolbar.
         * @access  protected
         * @return  void
         */
        _deselectSelectedLayer: function() {
            // Canvases.Preview.deselectSelectedLayer();
        }
    });
});
window.DependencyLoader.push('AuthModalView', function() {

    /**
     * TemplatePreviewModalView
     * 
     * @extends AuthModalView
     */
    window.TemplatePreviewModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplatePreviewModalView')
         */
        _string: 'TemplatePreviewModalView',

        /**
         * _template
         * 
         * @access  protected
         * @var     null|TemplateAccessor (default: null)
         */
        _template: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplateAccessor template
         * @return  void
         */
        init: function(element, template) {
            this._super(element);
            this._template = template;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this._addImageListeners();
        },

        /**
         * _addImageListeners
         * 
         * @access  protected
         * @return  void
         */
        _addImageListeners: function() {
            var $img = this.find('img');
            $img.on({
                'contextmenu': function(event) {
                    event.preventDefault();
                }
            });
        },

        /**
         * position
         * 
         * @access  public
         * @return  void
         */
        position: function() {
            var $content = this.find('div.content').first(),
                $columns = $content.find('.columns').first(),
                $first = $columns.find('.column').first();
            var width = $columns.css('width').toInt();
            width = width.ceil();
            width = (width) + 'px';
            $content.css({
                width: width
            });
            var height = $first.find('> div.content').first().css('height').toInt();
            height = height.ceil();
            height = (height) + 'px';
            $columns.css({
                height: height
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * StickyModalView
     * 
     * @extends ModalView
     */
    window.StickyModalView = ModalView.extend({

        /**
         * _$highlight
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$highlight: null,

        /**
         * _$relative
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$relative: null,

        /**
         * _direction
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _direction: null,

        /**
         * _padding
         * 
         * @access  protected
         * @var     Number (default: 20)
         */
        _padding: 20,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StickyModalView')
         */
        _string: 'StickyModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String direction Which direction (eg. up down left right) the
         *          sticky modal should point
         * @param   jQuery $relative
         * @param   false|jQuery $highlight
         * @return  void
         */
        init: function(element, direction, $relative, $highlight) {
            this._super(element);
            this._direction = direction;
            this._$relative = $relative;
            this._$highlight = $highlight || this._$relative;
            this._addPositionEvent();
            this._addCloseEvent();
        },
        
        /**
         * _addCloseEvent
         * 
         * @access  protected
         * @return  void
         */
        _addCloseEvent: function() {
            this._super();
            this.on({
                'close': function(event) {
                    this._$highlight.css('z-index', 'auto');
                }
            });
        },
        
        /**
         * _addPositionEvent
         * 
         * @access  protected
         * @return  void
         */
        _addPositionEvent: function() {
            var reposition = function() {
                this.position();
            }.proxy(this);
            $(window).resize(reposition);
            this.on({
                'close': function(event) {
                    $(window).unbind('resize', reposition);
                }
            });
        },
        
        /**
         * _positionAbove
         * 
         * @note    Content offset is used, because without it, the positioning
         *          is off when the app is loaded externally. This is because of
         *          the padding on the body, which throws off the calculations.
         * @access  protected
         * @return  void
         */
        _positionAbove: function() {
            var offset = {
                    content: App.find('> div.content').offset(),
                    relative: this._$relative.offset()
                },
                width = this._$relative.css('width'),
                height = this._$relative.css('height'),
                position = {
                    middle: offset.relative.left.toInt() - offset.content.left.toInt() + (width.toInt() / 2),
                    top: offset.relative.top.toInt() - offset.content.top.toInt()
                },
                $inner = this._element.find('.inner').first(),
                $content = this._element.find('.content').first();
            $inner.first().css({
                position: 'absolute',
                top: position.top - $content.css('height').toInt() - this._padding,
                left: position.middle - ($content.css('width').toInt() / 2)
            });
            this._$highlight.css('z-index', 1000);
            this._$highlight.css('position', 'relative');
        },
        
        /**
         * _positionBelow
         * 
         * @note    Content offset is used, because without it, the positioning
         *          is off when the app is loaded externally. This is because of
         *          the padding on the body, which throws off the calculations.
         * @access  protected
         * @return  void
         */
        _positionBelow: function() {
            var offset = {
                    content: App.find('> div.content').offset(),
                    relative: this._$relative.offset()
                },
                width = this._$relative.css('width'),
                height = this._$relative.css('height'),
                position = {
                    middle: offset.relative.left.toInt() - offset.content.left.toInt() + (width.toInt() / 2),
                    bottom: offset.relative.top.toInt() - offset.content.top.toInt() + height.toInt()
                },
                $inner = this._element.find('.inner').first(),
                $content = this._element.find('.content').first();
            $inner.first().css({
                position: 'absolute',
                top: position.bottom + this._padding,
                left: position.middle - ($content.css('width').toInt() / 2)
            });
            this._$highlight.css('z-index', 1000);
            this._$highlight.css('position', 'relative');
        },
        
        /**
         * position
         * 
         * @access  public
         * @return  void
         */
        position: function() {
            if (this._direction === 'up') {
                this._positionBelow();
            } else {
                this._positionAbove();
            }
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * TutorialsModalView
     * 
     * @extends ModalView
     */
    window.TutorialsModalView = ModalView.extend({

        /**
         * _tutorials
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _tutorials: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TutorialsModalView')
         */
        _string: 'TutorialsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupSections();
        },

        /**
         * _setupSections
         * 
         * @access  protected
         * @return  void
         */
        _setupSections: function() {
            var tutorials = Config.get('tutorials'),
                _this = this;
            jQuery.each(tutorials, function(index, tutorial) {
                var slug = tutorial.slug,
                    selector = 'section.' + (slug),
                    $tutorials = _this.find(selector);
                _this._tutorials[slug] = new TutorialsView($tutorials, slug, _this);
            });
        },

        /**
         * getTutorials
         * 
         * @access  public
         * @param   String slug
         * @return  TutorialsView
         */
        getTutorials: function(slug) {
            return this._tutorials[slug];
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * UpgradeModalView
     * 
     * @extends ModalView
     */
    window.UpgradeModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradeModalView')
         */
        _string: 'UpgradeModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * UpgradedModalView
     * 
     * @extends ModalView
     */
    window.UpgradedModalView = ModalView.extend({

        /**
         * _plan
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _plan: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradedModalView')
         */
        _string: 'UpgradedModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String plan
         * @return  void
         */
        init: function(element, plan) {
            this._super(element);
            this._plan = plan;
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * SearchUsersModalView
     * 
     * @extends ModalView
     */
    window.SearchUsersModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="text"]': function(event, $input) {
                        if (event.which === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SearchUsersModalView')
         */
        _string: 'SearchUsersModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminUsersView section
         * @return  void
         */
        init: function(element, section) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = section.getPath();
                    Stencil.navigate(path);
                }
            });
            this.on({
                'submit': function(event) {
                    var $input = this.find('input[type="text"]'),
                        val = $input.val(),
                        query = encodeURIComponent(val),
                        path = '/app/admin/users/search/' + (query);
                    Stencil.navigate(path, true, true);
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * UpdateUserModalView
     * 
     * @extends ModalView
     */
    window.UpdateUserModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpdateUserModalView')
         */
        _string: 'UpdateUserModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String key
         * @param   AdminUsersView section
         * @return  void
         */
        init: function(element, key, section) {
            this._super(element);
            this.unbind('leave');
            this._setupDropdowns();
            this._setupTooltips();
            this._form = new AppFormView(this.find('form'));
            var modal = this;
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    var user = Stencil.getAccessor(key),
                        id = user.get('id'),
                        encoded = encodeURIComponent(id),
                        url = '/app/admin/users/search/' + (encoded);
                    Stencil.set('temporaryReloadUrl', url);
                    Stencil.alert('admin.user.update');
                    Stencil.kill();
                }
            });
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = section.getPath();
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            this.find('select').selectpicker();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
});
window.DependencyLoader.push('AddRecordModalView', function() {

    /**
     * AddVectorSetModalView
     * 
     * @extends AddRecordModalView
     */
    window.AddVectorSetModalView = AddRecordModalView.extend({

        /**
         * _fallbackPath
         * 
         * @access  protected
         * @var     String (default: '/app/admin/vectorSets')
         */
        _fallbackPath: '/app/admin/vectorSets',

        /**
         * _formSubmissionTimeoutDuration
         * 
         * @access  protected
         * @var     Number (default: (2 * 60 * 60) * 1000) aka 2 hours
         */
        _formSubmissionTimeoutDuration: (2 * 60 * 60) * 1000,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    '[name="data[overrideColor]"]': function(event, $input) {
                        var $color = this.find('[name="data[color]"]');
                        $color.parent().addClass('hidden');
                        if ($input.is(':checked') === true) {
                            $color.parent().removeClass('hidden');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddVectorSetModalView')
         */
        _string: 'AddVectorSetModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element, adminModal);
            this._addOpenUppyListener();
        },

        /**
         * _addOpenUppyListener
         * 
         * @access  protected
         * @return  void
         */
        _addOpenUppyListener: function() {
            this.on({
                'open/uppy': function(event, $element) {
                    this._openUppy();
                }
            });
        },

        /**
         * _loadDependencies
         * 
         * @access  protected
         * @return  void
         */
        _loadDependencies: function() {
            Scripts.load('uppy');
        },

        /**
         * _openUppy
         * 
         * @access  protected
         * @return  Boolean
         */
        _openUppy: function() {
            var callback = this._receiveUppyUrls.proxy(this),
                uppy = ClientWrappers.get('uppy').getReference(callback);
            if (uppy === false) {
                return false;
            }
            uppy.getPlugin('Dashboard').openModal();
            return true;
        },

        /**
         * _receiveUppyUrls
         * 
         * @access  protected
         * @param   Array urls
         * @return  void
         */
        _receiveUppyUrls: function(urls) {
            var $form = this.find('form'),
                index,
                url,
                $input;
            for (index in urls) {
                url = urls[index];
                $input = $('<input type="hidden" name="data[urls][]" value="' + (url) + '">');
                $form.append($input);
            }
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._super();
            var duration = this._formSubmissionTimeoutDuration;
            this._form.setSubmissionTimeoutDuration(duration);
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Vector set added');
                    var collection = _this._adminModal.getSection('vectorSets')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/vectorSets');
                },
                'sent': function(event) {
                    var role = Config.getRole();
                    if (role !== 'local') {
                        Stencil.alert('cloudflare.timeout')
                        Stencil.kill.delay(1000);
                    }
                }
            });
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * WelcomeTourModalView
     * 
     * @extends ModalView
     */
    window.WelcomeTourModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WelcomeTourModalView')
         */
        _string: 'WelcomeTourModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * step
         * 
         * @access  public
         * @param   Number step
         * @return  void
         */
        step: function(step) {
            this.find('div.step').addClass('hidden');
            this.find('[step="' + (step) + '"]').removeClass('hidden');
        }
    });
});
window.DependencyLoader.push('ModalView', function() {

    /**
     * YouTubeVideoModalView
     * 
     * @extends ModalView
     */
    window.YouTubeVideoModalView = ModalView.extend({

        /**
         * _options
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _options: {},

        /**
         * _slug
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _slug: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'YouTubeVideoModalView')
         */
        _string: 'YouTubeVideoModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String youTubeSlug
         * @param   Object options
         * @return  void
         */
        init: function(element, youTubeSlug, options) {
            this._super(element);
            this._youTubeSlug = youTubeSlug;
            this._options = options;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * AppPageView
     * 
     * @extends View
     */
    window.AppPageView = View.extend({

        /**
         * _dropModalShowing
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _dropModalShowing: false,

        /**
         * _editor
         * 
         * @access  protected
         * @var     null|EditorView (default: null)
         */
        _editor: null,

        /**
         * _hourglass
         * 
         * @access  protected
         * @var     null|HourglassView (default: null)
         */
        _hourglass: null,

        /**
         * _imagePreloadSets
         * 
         * @access  protected
         * @var     Object
         */
        _imagePreloadSets: {
            onboarding: [
                '/app/static/images/backgrounds/onboarding/backgroundSelected.jpg',
                '/app/static/images/backgrounds/onboarding/foregroundSelected.jpg'
            ],
            partners: {
                verifone: [
                    '/app/static/images/icons/verifone.png'
                ]
            },
            share: {
                all: [
                    '/app/static/images/backgrounds/phone.header.v2.png',
                    '/app/static/images/backgrounds/previews/desktop/facebook/actions.png',
                    '/app/static/images/backgrounds/previews/desktop/facebook/actions.v2.png',
                    '/app/static/images/backgrounds/previews/desktop/facebook/chevron.png',
                    '/app/static/images/backgrounds/previews/desktop/instagram/sidebar.bottom.v2.png',
                    '/app/static/images/backgrounds/previews/desktop/instagram/sidebar.top.v2.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/chevron.down.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/globe.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/instagram/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/pinterest/header.png',
                    '/app/static/images/icons/buffer.png',
                    '/app/static/vendors/source/external/intl-tel-input/v6.2.1/img/flags@2x.png'
                ],
                partners: {
                    verifone: [
                        '/app/static/images/backgrounds/verifone/masks/carbon8.jpg',
                        '/app/static/images/backgrounds/verifone/masks/vx.jpg',
                        '/app/static/images/icons/verifone.png'
                    ]
                }
            }
        },

        /**
         * _last
         * 
         * Tracks the mouse position
         * 
         * @access  protected
         * @var     Object
         */
        _last: {
            x: 0,
            y: 0
        },

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a[internal]:not([disabled])': function(event, $anchor) {
                        event.preventDefault();
                        var href = $anchor.attr('href');
                        Stencil.navigate(href);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Prevents disabled click events from default actions and going
                     * up the chain.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a[internal][disabled]': function(event, $anchor) {
                        event.preventDefault();
                    }
                }
                // keydown: {
                //     '[tabindex]': function(event, $element) {
                //         LogUtils.log.simple(event, true);
                //         if (event.which === 9) {
                //             event.preventDefault();
                //         }
                //     }
                // }
            });
        },

        /**
         * _sidebar
         * 
         * @access  protected
         * @var     null|SidebarView (default: null)
         */
        _sidebar: null,

        /**
         * _stage
         * 
         * @access  protected
         * @var     null|StageView (default: null)
         */
        _stage: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AppPageView')
         */
        _string: 'AppPageView',

        /**
         * _thresholds
         * 
         * @access  protected
         * @var     Object
         */
        _thresholds: {
            unrestrict: 2500
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            window.App = this;
            this._reInitFabricDevicePixelRatioSetting();
            this._addBrowserClasses();
            this._addCustomDragListeners();
            this._addDeviceClasses();
            this._addMousemoveEvent();
            this._addRenderEventListener();
            this._addChangeHistoryEventListeners();
            this._addDevicePixelRatioChangeEvent();
            this._drawDropModal();
            this._drawHourglass();
            this._preloadAssets();
            this._setupAuth();
            this._setupBodyPathAttributeChangeEvent();
            this._setupBusyModal();
            this._setupCookieCheck();
            this._setupEditor();
            this._setupEmergency();
            this._setupHelpScoutHide();
            this._setupHide();
            this._setupSelectAllListener();
            this._setupAdminKeyboardShortcuts();
            this._setupPasteListener();
            this._setupPartnerSource();
            this._setupSidebar();
            this._setupStage();
            this._setupTooltipHiding();
            this._setupUnload();
            // this._showNewBadge();
            if (UserAgentUtils.is.tablet() === true) {
                this._setupOrientationModal();
            }
        },

        /**
         * _addBrowserClasses
         * 
         * A bit of gotcha here is that Microsoft Edge passes the Google Chrome
         * check. So to get around this, I simply check for Edge first. Also
         * worth noting is that Edge identifies as webkit, perhaps because it's
         * goal is to support all webkit features. This can throw things for a
         * loop sometimes.
         * 
         * @access  protected
         * @return  void
         */
        _addBrowserClasses: function() {
            if (UserAgentUtils.is.edge() === true) {
                this._element.addClass('edge');
            } else if (UserAgentUtils.is.chrome() === true) {
                this._element.addClass('chrome');
            } else if (UserAgentUtils.is.safari() === true) {
                this._element.addClass('safari');
            } else if (UserAgentUtils.is.firefox() === true) {
                this._element.addClass('firefox');
            } else if (UserAgentUtils.is.ie() === true) {
                this._element.addClass('ie');
            }
        },

        /**
         * _addRenderEventListener
         * 
         * @access  protected
         * @return  void
         */
        _addRenderEventListener: function() {
            App.getElement().on({
                'mousedown': function(event) {
                    if (Canvases.Preview.get('rendering') === true) {
                        var msg = Config.getMessage('image.rendering'),
                            startTimestamp = new Date();
                        App.getBusy().show(msg);
                        Canvases.Preview.once({
                            'set/rendering': function(event, value) {
                                if (value === false) {
                                    var busy = App.getBusy();
                                    busy.hide.minDelay(
                                        startTimestamp,
                                        1000,
                                        busy
                                    );
                                }
                            }
                        });
                    }
                }
            });
        },

        /**
         * _addChangeHistoryEventListeners
         * 
         * @access  protected
         * @return  void
         */
        _addChangeHistoryEventListeners: function() {
            if (ChangeHistory.active() === true) {

                /**
                 * 
                 */
                this._element.on({
                    'mouseup keyup': function(event) {
                        ChangeHistory.track.delay(0, ChangeHistory, [true, event]);
                    }
                });
                this.on({
                    'changeHistory/track': function(event) {
                        ChangeHistory.track.delay(0, ChangeHistory, [true, event]);
                    }
                });

                /**
                 * Adds the keyboard shortcut listeners for redo and undo.
                 * 
                 */
                App.getElement().on({
                    'keydown': function(event) {
                        if (ChangeHistory.keyboardShortcuts.redo(event) === true) {
                            /**
                             * I prevent the browser default action if the y-key
                             * is pressed, because in Chrome the default action
                             * is to open the browser history.
                             * 
                             * @note    Safari error'd out when checking event.key.
                             *          For some reason, not available there.
                             */
                            // if (event.key.toLowerCase() === 'y') {
                            if (event.which.toInt() === 89) {
                                event.preventDefault();
                            }
                            ChangeHistory.initiate.redo(1);
                        } else if (ChangeHistory.keyboardShortcuts.undo(event) === true) {
                            /**
                             * I prevent the default behaviour, since in Safari,
                             * the default is to open any last closed tab.
                             * 
                             * @see     https://apple.stackexchange.com/questions/26834/how-can-i-get-safari-to-reopen-my-last-closed-tab
                             */
                            event.preventDefault();
                            ChangeHistory.initiate.undo(1);
                        }
                    }
                });
            }
        },

        /**
         * _addCustomDragListeners
         * 
         * @access  protected
         * @return  void
         */
        _addCustomDragListeners: function() {
            var _this = this,
                $element = this._element.find('> div.content');
            $element.listenForFileAndTabDrag({
                allowDirectoryDropping: Config.default('allowDirectoryUploading')
            });
            $element.on({
                'custom/drag/enter/files': function(event) {
                    _this._drop.show();
                },
                'custom/drag/enter/tab': function(event) {
                    _this._drop.show();
                }
            });
        },

        /**
         * _addDeviceClasses
         * 
         * @access  protected
         * @return  void
         */
        _addDeviceClasses: function() {
            if (UserAgentUtils.is.ipad() === true) {
                this._element.addClass('ipad');
            }
        },

        /**
         * _addDragAndDropEvents
         * 
         * @access  protected
         * @return  void
         */
        // _addDragAndDropEvents: function() {
        //     window.addEventListener('dragenter', function(e) {
        //         lastTarget = e.target; // cache the last target here
        //     });
        //     window.addEventListener('dragleave', function(e) {
        //     // this is the magic part. when leaving the window,
        //     // e.target happens to be exactly what we want: what we cached
        //     // at the start, the dropzone we dragged into.
        //     // so..if dragleave target matches our cache, we hide the dropzone.
        //     if (e.target === lastTarget)
        //     {
        //     document.querySelector('.dropzone').style.visibility = 'hidden';
        //     document.querySelector('.dropzone').style.opacity = 0;
        //     }
        //     });
        // },

        /**
         * _addDevicePixelRatioChangeEvent
         * 
         * Detects a change (any change) to the window's devicePixelRatio
         * property, and prompts the user to reload the app (since the canvas
         * will likely be bust otherwise).
         * 
         * @see     http://stackoverflow.com/questions/28905420/window-devicepixelratio-change-listener/29653772#29653772
         * @see     http://caniuse.com/#feat=matchmedia
         * @access  protected
         * @return  void
         */
        _addDevicePixelRatioChangeEvent: function() {
            var dPR = UserAgentUtils.getDevicePixelRatio().round(3),
                queries = {
                    min: 'screen and (min-resolution: ' + (dPR) + 'dppx)',
                    max: 'screen and (max-resolution: ' + (dPR) + 'dppx)'
                },
                kill = function(event) {
                    Stencil.account().draft().setConfiguration();
                    Stencil.account().draft().saveConfiguration();
                    Stencil.alert('devicePixelRatio.change');
                    Stencil.kill();
                };
            window.matchMedia(queries.max).addListener(kill);
            window.matchMedia(queries.min).addListener(kill);
        },

        /**
         * _addMousemoveEvent
         * 
         * @access  protected
         * @return  void
         */
        _addMousemoveEvent: function() {
            $(window).mousemove(
                function(event) {
                    this._last.x = event.pageX;
                    this._last.y = event.pageY;
                }.proxy(this)
            );
        },

        /**
         * _drawDropModal
         * 
         * @access  protected
         * @return  void
         */
        _drawDropModal: function() {
            var messages = Config.get('messages'),
                $drop = DataUtils.render('DropModal', {
                copy: {
                    fonts: messages['app.drag.fonts'],
                    images: messages['app.drag.images'],
                    watermarks: messages['app.drag.watermarks']
                }
            });
            this._element.find('> div.content').append($drop);
            this._drop = new DropModalView($drop);
        },

        /**
         * _drawHourglass
         * 
         * @access  protected
         * @return  void
         */
        _drawHourglass: function() {
            var $hourglass = DataUtils.render('Hourglass');
            this._element.append($hourglass);
            this._hourglass = new HourglassView($hourglass);
        },

        /**
         * _preloadAccountOnboardingImages
         * 
         * @access  protected
         * @return  Boolean
         */
        _preloadAccountOnboardingImages: function() {
            var account = Stencil.account(),
                backgroundSelected = account.getOnboardingValue('backgroundSelected'),
                foregroundSelected = account.getOnboardingValue('foregroundSelected');
            if (backgroundSelected === true) {
                return false;
            }
            if (foregroundSelected === true) {
                return false;
            }
            var paths = this._imagePreloadSets.onboarding;
            ImageUtils.load.paths(paths);
            return true;
        },

        /**
         * _preloadAssets
         * 
         * @access  protected
         * @return  void
         */
        _preloadAssets: function() {
            this._preloadAccountOnboardingImages();
            this._preloadStencilIconFont();
            this._preloadVerifoneAssets();
        },

        /**
         * _preloadStencilIconFont
         * 
         * @access  protected
         * @return  void
         */
        _preloadStencilIconFont: function() {
            var $regular = $('<div class="sif sif-cloud-up"></div>'),
                $thick = $('<div class="sift sift-cloud-up"></div>');
            $regular.css({
                'position': 'absolute',
                'top': '-100000px',
                'left': '-100000px'
            });
            $thick.css({
                'position': 'absolute',
                'top': '-100000px',
                'left': '-100000px'
            });
            this._element.append($regular);
            this._element.append($thick);
            (function() {
                $regular.remove();
                $thick.remove();
            }).delay(5 * 1000);
        },

        /**
         * _preloadVerifoneAssets
         * 
         * @access  protected
         * @return  Boolean
         */
        _preloadVerifoneAssets: function() {
            var partnerSource = Stencil.account().setting('partnerSource'),
                paths = this._imagePreloadSets.partners.verifone;
            if (partnerSource !== 'verifone') {
                return false;
            }
            ImageUtils.load.paths(paths);
            return true;
        },

        /**
         * _reInitFabricDevicePixelRatioSetting
         * 
         * Firefox has a pretty big bug whereby the devicePixelRatio is
         * undefined while an iframe is hidden. This causes issues with the
         * Firefox extension and Publisher embed because the global
         * fabric.devicePixelRatio is defined initially when the fabric library
         * is loaded. As a result, when the iframe is loaded, it gets
         * invalidally set to 1. To deal with this, I reset the devicePixelRatio
         * for the library when the app is setup, since at that point, the
         * iframe is visible.
         * 
         * @access  protected
         * @return  void
         */
        _reInitFabricDevicePixelRatioSetting: function() {
            fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                fabric.window.webkitDevicePixelRatio ||
                fabric.window.mozDevicePixelRatio ||
                1;
        },

        /**
         * _setupAdminKeyboardShortcuts
         * 
         * @access  protected
         * @return  void
         */
        _setupAdminKeyboardShortcuts: function() {

            /**
             * Admin navigation keyboard shortcuts
             * 
             */
            var bindingFunction = function() {

                /**
                 * Area navigation
                 * 
                 */
                var combos = ['1', '2', '3', '4', '5', '6', '7'];
                Mousetrap.bind(combos, function(event, combo) {
                    event.preventDefault();
                    var sidebar = App.getSidebar(),
                        path = $(sidebar.find('[area]').get(combo.toInt() - 1)).attr('href');
                    Stencil.navigate(path);
                    return false;
                });

                /**
                 * Favorites category
                 * 
                 */
                Mousetrap.bind('f', function(event, combo) {
                    event.preventDefault();
                    var area = App.getEditor().getActiveArea();
                    if (area !== undefined) {
                        if (area.canHaveCollections() === true) {
                            var type = area.getType(),
                                category = CategoryUtils.account.favorites(type),
                                path = category.getPath();
                            Stencil.navigate(path);
                            return false;
                        }
                    }
                });

                /**
                 * Admin area
                 * 
                 */
                Mousetrap.bind(['a', 'd'], function(event, combo) {
                    event.preventDefault();
                    var path = '/app/admin/dashboard';
                    Stencil.navigate(path);
                    return false;
                });

                /**
                 * Users
                 * 
                 */
                // Mousetrap.bind('u', function(event, combo) {
                //     event.preventDefault();
                //     Stencil.navigate('/app/admin/users');
                //     return false;
                // });

                /**
                 * User search
                 * 
                 */
                Mousetrap.bind('u', function(event, combo) {
                    event.preventDefault();
                    var path = '/app/admin/users/search';
                    Stencil.navigate(path);
                    return false;
                });
            };
            if (User.admin() === true) {
                bindingFunction();
            } else {
                User.once({
                    'login': function(event, user) {
                        if (User.admin() === true) {
                            bindingFunction();
                        }
                    }
                });
            }
        },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            var _this = this;
            if (User.admin() === true) {
                var email = Stencil.get('user').get('email');
                this._element.addClass('admin');
                this._element.attr('data-user-email', email);
            } else if (User.editor() === true) {
                var email = Stencil.get('user').get('email');
                this._element.addClass('editor');
                this._element.attr('data-user-email', email);
            } else {
                User.once({
                    'login': function(event, user) {
                        if (User.admin() === true) {
                            var email = Stencil.get('user').get('email');
                            _this._element.addClass('admin');
                            _this._element.attr('data-user-email', email);
                        } else if (User.editor() === true) {
                            var email = Stencil.get('user').get('email');
                            _this._element.addClass('editor');
                            _this._element.attr('data-user-email', email);
                        }
                    }
                });
            }
        },

        /**
         * _setupBodyPathAttributeChangeEvent
         * 
         * @see     http://backbonejs.org/#Events-catalog
         * @access  protected
         * @return  void
         */
        _setupBodyPathAttributeChangeEvent: function() {
            var router = Stencil.getRouter();
            router.on({
                'route': function(route, params) {
                    var path = this.current().fragment;
                    path = '/' + (path);
                    App.getElement().attr('data-path', path);
                }
            });
        },

        /**
         * _setupBusyModal
         * 
         * @access  protected
         * @return  void
         */
        _setupBusyModal: function() {
            var $busy = this.find('> div.content > div.modal.busy');
            this._busy = new BusyModalView($busy);
        },

        /**
         * _setupCookieCheck
         * 
         * @access  protected
         * @return  void
         */
        _setupCookieCheck: function() {
            (function() {
                var session = RequestUtils.cookies.get('session');
                if (session === undefined) {
                    Stencil.alert('cookies.cleared');
                    Stencil.kill();
                } else {
                    // var account = RequestUtils.cookies.get('account');
                    // if (account === undefined) {
                    //     Stencil.alert('cookies.missingAccountKey');
                    //     Stencil.kill();
                    // }
                }
            }).interval(250);
        },

        /**
         * _setupEditor
         * 
         * @access  protected
         * @return  void
         */
        _setupEditor: function() {
            var $editor = this.find('section.editor');
            this._editor = new EditorView($editor);
        },

        /**
         * _setupEmergency
         * 
         * @access  protected
         * @return  void
         */
        _setupEmergency: function() {
            var emergency = Config.get('emergency'),
                markup = '<div class="emergency">' +
                        '<div class="message"></div>' +
                        '<div class="close fa fa-close"></div>' +
                    '</div>',
                $element = $(markup);
            $element.find('.message').text(emergency.message);
            if (emergency.active === true) {
                this._element.prepend($element);
                $element.find('.close').one({
                    'click': function(event, $div) {
                        $element.remove();
                    }
                });
            }
        },

        /**
         * _setupHelpScoutHide
         * 
         * @access  protected
         * @return  void
         */
        _setupHelpScoutHide: function() {
            this._element.on({
                'click': function(event) {
                    ClientWrappers.get('helpScout').closeBeacon();
                }
            });
        },

        /**
         * _setupHide
         * 
         * @access  protected
         * @return  void
         */
        _setupHide: function() {
            this.on({
                'hide': this.hide.proxy(this)
            });
        },

        /**
         * _setupOrientationModal
         * 
         * @access  protected
         * @return  void
         */
        _setupOrientationModal: function() {
            var check = function() {
                if (UserAgentUtils.getOrientation() === 'portrait') {
                    Stencil.navigate('/app/orientation?clean=1');
                } else {
                    var modal = ModalUtils.get('Orientation');
                    if (modal) {
                        modal.triggerHandler('leave');
                    }
                }
            };
            window.addEventListener('orientationchange', check, false);
        },

        /**
         * _setupPartnerSource
         * 
         * @access  protected
         * @return  void
         */
        _setupPartnerSource: function() {
            var account = Stencil.account();
            if (account.setting('partnerSource') === 'verifone') {
                this._element.attr('partner', 'verifone');
            } else {
                User.once({
                    'login': function(event, user) {
                        if (account.setting('partnerSource') === 'verifone') {
                            App.getElement().attr('partner', 'verifone');
                        }
                    }
                });
            }
        },

        /**
         * _setupPasteListener
         * 
         * @access  protected
         * @return  void
         */
        _setupPasteListener: function() {
            if (UserAgentUtils.supports.file() === true) {
                var _this = this;
                $(document).on({
                    'custom/paste/images': function(event, blobs) {
                        var dropzone = _this.getApplicableDropzone(false);
                        if (dropzone.availableForUpload() === true) {
                            if (dropzone.toString() === 'WatermarksDropzoneView') {
                                Stencil.navigate('/app/logos');
                            } else {
                                Stencil.navigate('/app/uploads');
                            }
                            dropzone.uploadItems(blobs);
                        }
                    }
                });
            }
        },

        /**
         * _setupSelectAllListener
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectAllListener: function() {

            /**
             * selectAll
             * 
             * @note    Check for activeArea is done, since it's possible that in
             *          certain states (eg. /login flow), no area has been set as
             *          active.
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            var selectAll = function() {
                    var activeArea = App.getEditor().getActiveArea();
                    if (activeArea !== undefined) {
                        var results = activeArea.getActiveGroup().getActiveResults();
                        results.selectAll();
                    }
                },
                /**
                 * deselectAll
                 * 
                 * @note    I check for an active area in the below routing event for
                 *          cases whereby a navigation event happens without any area
                 *          having been set up. eg. https://i.imgur.com/txNe9mB.png
                 * @access  private
                 * @return  void
                 */
                deselectAll = function() {
                    var activeArea = App.getEditor().getActiveArea();
                    if (activeArea !== undefined) {
                        var results = activeArea.getActiveGroup().getActiveResults();
                        results.deselectAll();
                        activeArea.getContextMenu().triggerHandler('close');
                    }
                };

            // Deselect everything if a navigation event occurs
            Stencil.getRouter().on({
                'route': function(route, params) {
                    deselectAll();
                }
            });

            // Keyboard shortcuts for Windows + Mac for select/deselect all
            var commands = {
                selectAll: 'ctrl+a',
                deselectAll: 'ctrl+shift+a'
            };
            if (UserAgentUtils.is.mac() === true) {
                commands = {
                    selectAll: 'command+a',
                    deselectAll: 'command+shift+a'
                };
            }
            Mousetrap.bind(commands.selectAll, function(event, combo) {
                event.preventDefault();
                selectAll();
                return false;
            });
            Mousetrap.bind(commands.deselectAll, function(event, combo) {
                event.preventDefault();
                deselectAll();
                return false;
            });

            // Deselect everything if valid click occurs
            App.getElement().on({
                'click': function(event) {
                    var $target = $(event.target),
                        selectors = [
                            'div.thumb',
                            'div.quote.row',
                            'div.watermark',
                            'div.contextMenu'
                        ],
                        selector = selectors.join(',');
                    if (
                        $target.parents(selector).length === 0
                        && $target.is(selector) === false
                        && $target.parents('.modal.confirm').length === 0
                    ) {
                        if ($target.hasClass('contextMenu') === false) {
                            if (App.getBusy().getElement().hasClass('hidden') === true) {
                                var activeArea = App.getEditor().getActiveArea();
                                if (activeArea !== undefined) {
                                    var contextMenu = activeArea.getContextMenu();
                                    if (contextMenu.closable() === true) {
                                        deselectAll();
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // Deselect everything if valid escape key occurs
            App.getElement().on({
                'keydown': function(event) {
                    var deselectable = function(event) {
                        if (event.which !== 27) {
                            return false;
                        }
                        if (App.find('.modal.busy:not(.hidden)').length !== 0) {
                            return false;
                        }
                        if (App.find('.modal.confirm').length !== 0) {
                            return false;
                        }
                        if (App.find('.contextMenu:not(.hidden)').length !== 0) {
                            return false;
                        }
                        return true;
                    };
                    if (deselectable(event) === true) {
                        deselectAll();
                    }
                }
            });
        },

        /**
         * _setupSidebar
         * 
         * @access  protected
         * @return  void
         */
        _setupSidebar: function() {
            var $sidebar = this.find('aside.sidebar');
            this._sidebar = new SidebarView($sidebar);
        },

        /**
         * _setupStage
         * 
         * @access  protected
         * @return  void
         */
        _setupStage: function() {
            var $stage = this.find('section.stage'),
                view = new StageView($stage);
            this._stage = view;
        },

        /**
         * _setupTooltipHiding
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltipHiding: function() {
            var router = Stencil.getRouter();
            router.on({
                'route': function(route, params) {
                    App.tooltips.hide();
                }
            });
        },

        /**
         * _setupUnload
         * 
         * @todo    Stencil.kill? Not sure if possible
         * @access  protected
         * @return  void
         */
        _setupUnload: function() {
            $(window).bind({
                'beforeunload': function(event) {
                    if (XHRPool.length() > 0) {
                        return 'Still saving!';
                    }
                }
            });
        },

        /**
         * _showNewBadge
         * 
         * @access  protected
         * @return  void
         */
        _showNewBadge: function() {
            if (Stencil.account().get('created').toInt() <= 1500685200) {
                var $badge = this.find('a[href="/app/uploads"] span.full span.badge');
                $badge.removeClass('invisible');
            } else {
                User.once({
                    'login': this._showNewBadge.proxy(this)
                });
            }
        },

        // /**
        //  * busy
        //  * 
        //  * @access  public
        //  * @param   String type
        //  * @return  void
        //  */
        // busy: function(type) {
        //     if (type === 'popup') {
        //         var msg = 'If a window does not popup, please check that it ' +
        //             'was<br />not blocked by your browser or popup-blocker.';
        //         App.getBusy().show(msg);
        //     }
        // },

        /**
         * hide
         * 
         * @access  protected
         * @return  void
         */
        hide: function() {
            var slide = Config.default('slide');
            this.slide.up.apply(this);
            RequestUtils.postMessage.delay(
                slide,
                Stencil,
                ['message.app.hide']
            );
        },

        /**
         * getApplicableDropzone
         * 
         * @access  public
         * @param   undefined|Boolean includeFontsDropzone (default: true)
         * @return  DropzoneView
         */
        getApplicableDropzone: function(includeFontsDropzone) {
            includeFontsDropzone = DataUtils.getDefaultValue(
                includeFontsDropzone,
                true
            );
            if (
                includeFontsDropzone === true
                && App.getStage().fontsDropzoneVisible() === true
            ) {
                return Toolbars.getToolbar('text').getFontsDropdown().getDropzone();
            }
            if (App.getEditor().getActiveArea() !== undefined) {
                if (App.getEditor().getActiveArea().getType() === 'watermarks') {
                    return App.getEditor().getArea('watermarks').getDropzone();
                }
            }
            return App.getEditor().getArea('uploads').getDropzone();
        },

        /**
         * getEditor
         * 
         * @access  public
         * @return  EditorView
         */
        getEditor: function() {
            return this._editor;
        },

        /**
         * getHourglass
         * 
         * @access  public
         * @return  HourglassView
         */
        getHourglass: function() {
            return this._hourglass;
        },

        /**
         * getSidebar
         * 
         * @access  public
         * @return  SidebarView
         */
        getSidebar: function() {
            return this._sidebar;
        },

        /**
         * getStage
         * 
         * @access  public
         * @return  StageView
         */
        getStage: function() {
            return this._stage;
        },

        /**
         * getX
         * 
         * @access  public
         * @return  Number
         */
        getX: function() {
            return this._last.x;
        },

        /**
         * getY
         * 
         * @access  public
         * @return  Number
         */
        getY: function() {
            return this._last.y;
        },

        /**
         * preloadShareModalStaticAssets
         * 
         * @access  public
         * @return  void
         */
        preloadShareModalStaticAssets: function() {
            var paths = this._imagePreloadSets.share.all,
                account = Stencil.account();
            if (account.setting('partnerSource') === 'verifone') {
                paths = paths.concat(
                    this._imagePreloadSets.share.partners.verifone
                );
            }
            ImageUtils.load.paths(paths);
        },

        /**
         * setSelectedFrame
         * 
         * Sets the frame accessor that should be accessible via the global
         * window.Frame reference. Also updates the UI surrounding the canvas to
         * reference the selected frame (such as the dimensions copy and label
         * underneath the preview canvas).
         * 
         * @access  public
         * @return  void
         */
        setSelectedFrame: function() {
            var account = Stencil.account(),
                draft = account.draft(),
                orphan = account.orphanFrame(),
                key = draft.get('frame'),
                frame = account.collection('frames').find(key);
            if (frame === false) {
                frame = orphan;
                orphan.set({
                    width: draft.get('width').toInt(),
                    height: draft.get('height').toInt()
                });
            } else {
                if (
                    frame.get('width').toInt() !== draft.get('width').toInt()
                    || frame.get('height').toInt() !== draft.get('height').toInt()
                ) {
                    frame = orphan;
                    orphan.set({
                        width: draft.get('width').toInt(),
                        height: draft.get('height').toInt()
                    });
                }
            }
            frame.select();
            frame.updateMessaging();
        },

        /**
         * show
         * 
         * @access  protected
         * @return  void
         */
        show: function() {
            this.slide.down.apply(this);
            // RequestUtils.postMessage.delay(
            //     750,
            //     Stencil,
            //     ['message.app.opened']
            // );
        },

        /**
         * slide
         * 
         * @var     Object
         * @access  public
         */
        slide: {

            /**
             * down
             * 
             * @access  public
             * @return  void
             */
            down: function() {
                this._element.addClass('down');
            },

            /**
             * up
             * 
             * @access  public
             * @return  void
             */
            up: function() {
                this._element.removeClass('down');
            }
        },

        /**
         * tooltips
         * 
         * @var     Object
         * @access  public
         */
        tooltips: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                App.find('[tooltip]').tooltip('destroy');
            }
        },

        /**
         * unrestrict
         * 
         * @note    This is the function that upon initial page load, removes the
         *          busy modal. Look here, Oliver, look here!
         * @access  public
         * @return  void
         */
        unrestrict: function() {
            // var current = new Date.getTime();
            // if ((current - start) > this._thresholds.unrestrict) {
                this._busy.hide();
            // } else {
            //     this.unrestrict.delay(50, this);
            // }
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * NotificationsSettingsView
     * 
     * @extends SettingsView
     */
    window.NotificationsSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'NotificationsSettingsView')
         */
        _string: 'NotificationsSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'notifications')
         */
        _type: 'notifications',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.setHandlerDelay(100);
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                },
                /**
                 * 
                 * @note    setting notification below is to trigger a User::change
                 *          event, which inits an analytics tracking call
                 */
                'returned/succeeded': function(event, response) {
                    Track.event('Notifications settings updated');
                    var user = Stencil.get('user'),
                        notification = response.data.object.notification;
                    user.set({'notification': notification});
                }
            });
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * ObfuscateSettingsView
     * 
     * @extends SettingsView
     */
    window.ObfuscateSettingsView = SettingsView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ObfuscateSettingsView')
         */
        _string: 'ObfuscateSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'obfuscate')
         */
        _type: 'obfuscate',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._addListeners();
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this.on({
                'showConfirmObfuscateModal': function(event) {
                    var modal = ModalUtils.showConfirm({
                        h1: 'This will permanently delete your account.',
                        h2: 'This cannot be undone'
                    });
                    modal.on({
                        'no': function(event) {
                            this.triggerHandler('leave');
                        },
                        'yes': function(event) {
                            this.triggerHandler('leave');
                            var alertKeys = {
                                failed: {
                                    other: 'users.obfuscate.failed.other',
                                    subscription: 'users.obfuscate.failed.subscription'
                                },
                                success: 'users.obfuscate.success'
                            }
                            if (
                                Account.upgraded() === true
                                && Account.lifetime() === false
                            ) {
                                Stencil.alert(alertKeys.failed.subscription);
                            } else if (User.admin() === true || User.editor() === true) {
                                Stencil.alert(alertKeys.failed.other);
                            } else {
                                var msg = Config.getMessage('users.settings.obfuscate');
                                App.getBusy().show(msg);
                                var path = '/users/settings/obfuscate';
                                RequestUtils.ajax({
                                    signature: {"basename":"Obfuscate.js","line":77},
                                    url: path,
                                    type: 'POST',
                                    success: function(response) {
                                        if (response.success === true) {
                                            (function() {
                                                Stencil.alert(alertKeys.success);
                                                Stencil.kill();
                                            }).delay(2500);
                                        } else {
                                            var error = Stencil.extractError(response),
                                                code = '88-' + (error.code),
                                                reference = error.reference;
                                            Stencil.error(code, reference);
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
            });
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * PasswordSettingsView
     * 
     * @extends SettingsView
     */
    window.PasswordSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PasswordSettingsView')
         */
        _string: 'PasswordSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'password')
         */
        _type: 'password',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Password changed');
                    this.find('input').val('');
                }
            });
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * PaymentSettingsView
     * 
     * @events  show/history
     * @extends SettingsView
     */
    window.PaymentSettingsView = SettingsView.extend({

        /**
         * _events
         * 
         * @access  protected
         * @var     Object
         */
        _events: {

            /**
             * detect
             * 
             * @access  private
             * @param   jQuery event
             * @param   jQuery $input
             * @return  void
             */
            detect: function(event, $input) {
                var $wrapper = this.find('div.cards'),
                    $imgs = $wrapper.find('img');
                if ($input.hasClass('identified') === true) {
                    $imgs.addClass('faded');
                    if ($input.hasClass('visa') === true) {
                        $wrapper.find('.visa').removeClass('faded');
                    } else if ($input.hasClass('mastercard') === true) {
                        $wrapper.find('.mastercard').removeClass('faded');
                    } else if ($input.hasClass('amex') === true) {
                        $wrapper.find('.amex').removeClass('faded');
                    } else {
                        $wrapper.find('.unknown').removeClass('faded');
                    }
                } else {
                    $imgs.removeClass('faded');
                }
            }
        },

        /**
         * _form
         * 
         * @access  protected
         * @var     null|CreditCardAppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                keyup: {
                    '[data-stripe="number"]': this._events.detect
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PaymentSettingsView')
         */
        _string: 'PaymentSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'payment')
         */
        _type: 'payment',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCreditCardAppForm();
            this._setupPaymentHistory();
            this._setupPauseEvents();
            this._setupTooltips();
        },

        /**
         * _openAccountDockWindow
         * 
         * @access  protected
         * @return  Boolean
         */
        _openAccountDockWindow: function() {
            var account = Stencil.account(),
                key = account.upgrade().customer().get('gatewayKey'),
                opened = ClientWrappers.get('accountDock').openWindow(key);
            return opened;
        },

        /**
         * _setupCreditCardAppForm
         * 
         * @access  protected
         * @return  void
         */
        _setupCreditCardAppForm: function() {
            var $form = this.find('form');
            this._form = new CreditCardAppFormView($form);
            this._form.unbind('returned/failed');
            this._form.on({
                'returned/failed': function(event, response) {
                    this.find('a.button').enable();
                    if (response.failedRules) {
                        var error = this.getError(response);
                        this.showError(error);
                    } else {
                        this.showError(response.error);
                    }
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Payment settings updated');
                    var account = Stencil.account(),
                        customer = account.upgrade().customer();
                    customer.set({
                        delinquent: 0
                    });
                }
            });
            this._form.setHandlerDelay(0);
        },

        /**
         * _setupPauseEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupPauseEvents: function() {
            var modal = this._modal;
            this._form.on({
                'card/submitted': modal.pause.proxy(modal),
                'card/returned': modal.unpause.proxy(modal),
                'submitted': modal.pause.proxy(modal),
                'returned': modal.unpause.proxy(modal)
            });
        },

        /**
         * _setupPaymentHistory
         * 
         * @access  protected
         * @return  void
         */
        _setupPaymentHistory: function() {
            Scripts.load('accountDock');
            this.on({
                'show/history': this._openAccountDockWindow.proxy(this)
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * PlanSettingsView
     * 
     * @extends SettingsView
     */
    window.PlanSettingsView = SettingsView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlanSettingsView')
         */
        _string: 'PlanSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'plan')
         */
        _type: 'plan',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * ProfileSettingsView
     * 
     * @extends SettingsView
     */
    window.ProfileSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ProfileSettingsView')
         */
        _string: 'ProfileSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'profile')
         */
        _type: 'profile',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Profile settings updated');
                    var user = Stencil.get('user');
                    user.set({
                        email: response.data.object.email,
                        name: response.data.object.name
                    });
                }
            });
            // ElectronUtils.get('downloads.recent.path').then(function(value) {
            //     console.log('value: ' + value);
            // }).catch(function(err) {
            // });
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * ReferralSettingsView
     * 
     * @events  share/facebook
     *          share/twitter
     * @extends SettingsView
     */
    window.ReferralSettingsView = SettingsView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ReferralSettingsView')
         */
        _string: 'ReferralSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'referral')
         */
        _type: 'referral',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this.on({
                'share/facebook': this.showFacebookShareDialog,
                'share/twitter': this.showTwitterShareWindow
            });
            Scripts.load('facebook');
        },

        /**
         * _getFacebookShareObject
         * 
         * @access  protected
         * @return  Object
         */
        _getFacebookShareObject: function() {
            var share = Config.get('shares')['referral.facebook'],
                shareObject = {
                    display: 'popup',
                    method: 'feed',
                    name: share.title,
                    description: share.description,
                    link: this._getShareUrl(),
                    picture: share.picture
                };
            return shareObject;
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            var shareUrl = Stencil.account().getReferralUrl();
            return shareUrl;
        },

        /**
         * _getSnippet
         * 
         * @access  protected
         * @return  String
         */
        _getSnippet: function() {
            var snippet = 'Check out Stencil, the easiest way to create ' +
                'amazing graphics for #socialmedia:';
            return snippet;
        },

        /**
         * selectInput
         * 
         * @access  public
         * @return  void
         */
        selectInput: function() {
            var $input = this.find('input');
            ElementUtils.select($input);
        },

        /**
         * showFacebookShareDialog
         * 
         * @access  public
         * @return  Boolean
         */
        showFacebookShareDialog: function() {
            if (Config.serviceAvailable('facebook') === false) {
                Stencil.alert('services.facebook.unavailable');
                return false;
            }
            if (Scripts.loaded('facebook') === false) {
                Scripts.waitFor('facebook');
                return false;
            }
            var shareObject = this._getFacebookShareObject(),
                dialogShown = ClientWrappers.get('facebook').showShareDialog(
                    shareObject
                );
            return dialogShown;
        },

        /**
         * showTwitterShareWindow
         * 
         * @access  public
         * @return  void
         */
        showTwitterShareWindow: function() {
            var share = Config.get('shares')['referral.twitter'],
                url = this._getShareUrl(),
                message = encodeURIComponent(share.message),
                link = 'https://twitter.com/intent/tweet' +
                    '?url=' + (url) +
                    '&via=' + (share.via) +
                    '&text=' + (message);
            window.open(
                link,
                'Twitter Share',
                'width=640, height=420'
            );
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * SettingsView
     * 
     * @extends View
     */
    window.SettingsView = View.extend({

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|SettingsModalView (default: null)
         */
        _modal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SettingsView')
         */
        _string: 'SettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[settings="' + (this._type) + '"]');
            $anchor.siblings('[settings]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            if (UserAgentUtils.is.tablet() === false) {
                this._element.focusable().focus();
            }
        }
    });
});
window.DependencyLoader.push('SettingsView', function() {

    /**
     * SocialSettingsView
     * 
     * @todo    Preload connection profile/images, incase they click on
     *          "View/edit"
     * @events  connect/facebook
     *          connect/twitter
     * @extends SettingsView
     */
    window.SocialSettingsView = SettingsView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|Collection (default: null)
         */
        _collection: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SocialSettingsView')
         */
        _string: 'SocialSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'social')
         */
        _type: 'social',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('facebook');
            this._setupCollection();
            this.refresh();
            this.on({
                'connect/facebook': function(event) {
                    if (Config.serviceAvailable('facebook') === false) {
                        Stencil.alert('services.facebook.unavailable');
                    } else {
                        if (Scripts.loaded('facebook') === false) {
                            Scripts.waitFor('facebook');
                        } else {
                            this._showBusyModal();
                            // App.busy('popup');
                            var facebook = this._getModel('Facebook');
                            facebook.connect({
                                'connected': function(connections) {
                                    App.getBusy().hide();
                                },
                                'denied': function() {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    }
                },
                'connect/twitter': function(event) {
                    if (Config.serviceAvailable('twitter') === false) {
                        Stencil.alert('services.twitter.unavailable');
                    } else {
                        this._showBusyModal();
                        // App.busy('popup');
                        var twitter = this._getModel('Twitter');
                        twitter.setup();
                        twitter.connect({
                            'closed': function(connections) {
                                App.getBusy().hide();
                            }
                        });
                    }
                }
            });
        },

        /**
         * _count
         * 
         * @access  protected
         * @param   String network
         * @return  void
         */
        _count: function(network) {
            var connections = this._collection.network(network),
                $network = this.find('[network="' + (network) + '"]'),
                $count,
                type,
                hash = {
                    facebook: {
                        account: 'page',
                        profile: 'profile'
                    },
                    twitter: {
                        profile: 'account'
                    }
                },
                copy,
                matching,
                $counts = $network.find('[lookup="count"]');
            jQuery.each($counts, function(index, count) {
                matching = [];
                $count = $(count);
                type = $count.attr('type');
                jQuery.each(connections, function(index, connection) {
                    if (connection.get('type') === type) {
                        matching.push(connection);
                    }
                });
                copy = (matching.length) + ' ' +
                    (matching.length === 1 ? hash[network][type] : (hash[network][type] + 's'));
                $count.text(copy);
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = Stencil.account().collection('connections');
            this._collection.on({
                'update': function(event) {
                    _this.refresh();
                }
            });
        },

        /**
         * _show
         * 
         * @access  protected
         * @param   String network
         * @return  void
         */
        _show: function(network) {
            var connections = this._collection.network(network),
                $network = this.find('[network="' + (network) + '"]');
            $network.find('.prompt').addClass('hidden');
            $network.find('.details').addClass('hidden');
            if (connections.length === 0) {
                $network.find('.prompt').removeClass('hidden');
            } else {
                $network.find('.details').removeClass('hidden');
            }
        },

        /**
         * _showBusyModal
         * 
         * @access  protected
         * @return  void
         */
        _showBusyModal: function() {
            var exception = 'A window should have popped up. If you can\'t ' +
                'see it, it may appear behind this browser window, or on ' +
                'another monitor if you have one attached.<br />' +
                'If you cannot find it, ' +
                '<a click trigger="hide" class="text">go back to Stencil</a>.';
            App.getBusy().show(undefined, exception);
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            this._show('facebook');
            this._count('facebook');
            this._show('twitter');
            this._count('twitter');
            this._show('pinterest');
            this._count('pinterest');
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * BufferShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.BufferShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'buffer')
         */
        _network: 'buffer',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BufferShareView')
         */
        _string: 'BufferShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
            this.on({
                'open': this.open
            });
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            return '';
        },

        /**
         * _position
         * 
         * Ensures that the required <img> has a width by loading the same image
         * it is, and then onload, setting the left margin.
         * 
         * @access  protected
         * @return  void
         */
        _position: function() {
            var url = this._modal.getImage().getSrc(),
                crossOrigin = false,
                $shadow = this.find('.shadow'),
                $notShadow = this.find('img:not(.shadow)');
            ImageUtils.load.url(url, crossOrigin, function(reference) {
                var width = $notShadow.css('width').toInt(),
                    adjustedLeft = 0 - Math.round(width / 2);
                $shadow.css({
                    'margin-left': adjustedLeft
                });
            });
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access  public
         * @return  void
         */
        drawImage: function() {
            if (this._drawn === false) {

                // Done
                this._drawn = true;

                // Regular
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    selector = '[lookup="draw"]',
                    $first = $('<img />'),
                    $second = $('<img />');
                $first.attr('src', src);
                $first.attr('draggable', false);
                this.find(selector).replaceWith($first);

                // Shadow
                selector = '[lookup="draw.shadow"]';
                $second.attr('src', src);
                $second.attr('draggable', false);
                $second.addClass('shadow');
                this.find(selector).replaceWith($second);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    this._getImage().once({
                        'preload': function(event) {
                            // var height = $first.css('height').toInt();
                            $first.attr('src', this.getSrc());
                            // $first.css('height', height);
                            $second.attr('src', this.getSrc());
                            // $second.css('height', height);
                        }
                    });
                }
            }
        },

        /**
         * open
         * 
         * @note    Buffer breaks if I don't pass in a url parameter, so I
         *          override the NetworkShareView _getShareUrl method to return
         *          an empty string.
         * @note    I don't truncate, since Buffer offers it's own UI and UX to
         *          truncate the string. It's better for them to do it there,
         *          since the different networks off different degrees of
         *          truncation.
         * @access  public
         * @return  void
         */
        open: function() {
            if (Config.serviceAvailable('buffer') === false) {
                Stencil.alert('services.buffer.unavailable');
                return false;
            }

            var image = this._getImage();
            if (image.get('uploaded').toInt() === 1) {
                var snippetObject = this._getSnippet(false),
                    url = encodeURIComponent(this._getShareUrl()),
                    picture = encodeURIComponent(this._getOriginalImageUrl()),
                    text = encodeURIComponent(snippetObject.snippet),
                    link = 'https://buffer.com/add' +
                        '?url=' + (url) +
                        '&picture=' + (picture);
                if (snippetObject.default === false) {
                    link += '&text=' + (text);
                }
                window.open(
                    link,
                    'Buffer Share',
                    'width=900, height=840'
                );
            } else {
                var msg = Config.getMessage('image.share.pending');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function(event) {
                        App.getBusy().hide();
                        Stencil.alert('image.uploaded');
                    }
                });
            }
        },

        /**
         * show
         * 
         * Duplicated here only to prevent calling drawImage with a parameter
         * since BufferShareView doesn't require one. Also, the <_position> call
         * is needed for Buffer.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._position();
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * FacebookShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.FacebookShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $textarea
                     * @return  void
                     */
                    'textarea': function(event, $textarea) {
                        var $message = this.find('[lookup="message"]'),
                            message = $textarea.val();
                        this.setMessage(message);
                        this.triggerHandler('change/message');
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'facebook')
         */
        _network: 'facebook',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FacebookShareView')
         */
        _string: 'FacebookShareView',

        /**
         * _thresholds
         * 
         * @access  protected
         * @var     Object
         */
        _thresholds: {
            search: 15
        },

        /**
         * init
         * 
         * @todo!!  Instead of having image-uploaded property checked on backend,
         *          check it here, and if it is not yet uploaded, wait for it
         *          (via event listener), and then submit form.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('facebook');
            this.on({
                'connection/add': function(event) {
                    if (Config.serviceAvailable('facebook') === false) {
                        Stencil.alert('services.facebook.unavailable');
                    } else {
                        if (Scripts.loaded('facebook') === false) {
                            Scripts.waitFor('facebook');
                        } else {
                            this._showBusyModal();
                            var _this = this,
                                model = this._getModel('Facebook');
                            model.connect({
                                connected: function(connections) {
                                    App.getBusy().hide();
                                    _this.state('connections');
                                },
                                denied: function(connections) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    }
                }
            });
            this._setupForm();
            this.preview('desktop', false);

            // State
            if (this._connections().length === 0) {
                this.state('connect');
            } else {
                this.state('connections');
            }
        },

        /**
         * _connections
         * 
         * Returns all connections for Facebook, or else Facebook connections by
         * type (eg. page, profile).
         * 
         * @access  protected
         * @param   String type
         * @return  Array
         */
        _connections: function(type) {
            var connections = this._super(),
                matching = [];
            if (type === undefined) {
                return connections;
            }
            jQuery.each(connections, function(index, connection) {
                if (connection.get('type') === type) {
                    matching.push(connection);
                }
            });
            return matching;
        },

        /**
         * _drawConnections
         * 
         * @access  protected
         * @return  void
         */
        _drawConnections: function() {
            var connections = this._connections(),
                $connections;
            $connections = DataUtils.render('FacebookConnections', {
                live: connections.length > this._thresholds.search,
                connections: {
                    pages: this._connections('account')
                }
            });
            this.find('div.selector').append($connections);
        },

        /**
         * _initConnections
         * 
         * Creates the initial <selectpicker>, and listens for value changes
         * to have the preview update or prompt them to connect more accounts.
         * 
         * @access  protected
         * @return  void
         */
        _initConnections: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.update();
                    _this.find('textarea').focus();
                    if ($(this).val().toInt() === 0) {
                        _this.triggerHandler('connection/add');
                        _this.find('textarea').blur();
                        _this._setupConnections();
                    } else {
                        var userAccount = Stencil.account().userAccount();
                        userAccount.push(
                            'settings.shareFacebookRecent',
                            $(this).val()
                        );
                    }
                }
            );
        },

        /**
         * _preselectConnection
         * 
         * Looks up which connection should be preselected, based on a possible
         * cookie value.
         * 
         * @todo    Ensure preselected is cookied
         * @access  protected
         * @return  void
         */
        _preselectConnection: function() {
            var $select = this.find('select'),
                share = Stencil.account().userAccount().setting('shareFacebookRecent'),
                first = $select.find('option').first().val(),
                preselected = share.match(/^cnnc/) === null ? first : share;
            $select.val(preselected);
        },

        /**
         * _removeConnections
         * 
         * @access  protected
         * @return  void
         */
        _removeConnections: function() {
            var $selector = this.find('div.selector');
            $selector.empty();
        },

        /**
         * _setupConnections
         * 
         * @access  protected
         * @return  void
         */
        _setupConnections: function() {
            this._removeConnections();
            this._drawConnections();
            this._preselectConnection();
            this._initConnections();
            this.update();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.setHandlerDelay(0);
            this._form.on({
                'submitted': function(event) {
                    _this._modal.pause();
                },
                'returned': function(event) {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    if (response.data && response.data.connection) {
                        if (response.data.action === 'delete') {
                            var key = response.data.connection.key;
                            Stencil.getAccessor(key).delete();
                            if (_this._connections().length === 0) {
                                _this.state('connect');
                            } else {
                                _this.state('connections');
                            }

                            // Error handling
                            this.clearErrors();
                            var image = _this._getImage(),
                                path = '/app/images/' + (image.get('key')) +
                                    '/' + (key) + '/error?clean=1';
                            Stencil.navigate(path);
                        }
                    }
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Share'),
                        share = model.setAccessor(response.data.object);
                    Stencil.navigate(share.getPath());
                }
            });
        },

        /**
         * setMessage
         * 
         * @see     https://stackoverflow.com/questions/5002111/javascript-how-to-strip-html-tags-from-string
         * @note    Added the .textContent / .innerText logic to prevent people
         *          from pasting in markup that may include script tags. This
         *          logic simply strips out the html tags. But I don't think I
         *          actually want this. So instead, simply replacing open and
         *          close html tags to prevent tags from being rendered.
         * @todo    Match truncation for links in Facebook preview:
         *          https://i.imgur.com/WDJDlvy.png
         * @access  public
         * @param   String message
         * @return  void
         */
        setMessage: function(message) {
            var $message = this.find('[lookup="message"]');//,
                // div = document.createElement('div');
            // div.innerHTML = message;
            // message = (div.textContent || div.innerText || '');
            message = message.replace(/</g, '&lt;');
            message = message.replace(/>/g, '&gt;');
            message = message.replace(/^\n{1,}/g, '');
            message = message.encode('url');
            message = message.encode('hashtag', {
                href: 'https://www.facebook.com/hashtag/$hashtag'
            });
            message = message.replace(/\n{2,}/g, '\n');
            message = message.replace(/\n+$/, '');
            message = message.encode('newlines');
            $message.html(message);
        },

        /**
         * state
         * 
         * Show the proper state (eg. show connections w/ textarea, or button
         * prompting them to connect their FB account(s))
         * 
         * @access  public
         * @param   String state
         * @return  void
         */
        state: function(state) {
            this.find('.state').addClass('hidden');
            if (state === 'connect') {
                this.find('.state[lookup="connect"]').removeClass('hidden');
            } else {
                this._setupConnections();
                this.find('.state[lookup="connections"]').removeClass('hidden');
            }
        },

        /**
         * update
         * 
         * Updates the UI of the previews to have the corresponding name and
         * picture in there.
         * 
         * @todo    Preload all conncetion urls into memory for faster
         *          transitions between them
         * @access  public
         * @return  void
         */
        update: function() {

            // Get the selected connection
            var connections = Stencil.account().collection('connections'),
                $select = this.find('select'),
                value = $select.val(),
                selected = false;
            if (connections.find(value) !== false) {
                selected = connections.find(value);
            }

            // If a connection was found
            if (selected !== false) {
                var $names = this.find('[lookup="connection.label"]'),
                    $images = this.find('[lookup="connection.image"]');
                $names.text(selected.get('label'));
                $images.attr('src', selected.getImageSrc());
            }
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * InstagramShareView
     * 
     * @extends NetworkShareView
     */
    window.InstagramShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    '[type="tel"]': function(event, $input) {
                        this.find('[name="data[number]"]').val(
                            $input.intlTelInput('getNumber')
                        );
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'instagram')
         */
        _network: 'instagram',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'InstagramShareView')
         */
        _string: 'InstagramShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupForm();
            this.preview('desktop', false);
            this._setupMobileInput();
        },

        /**
         * _getCountryDropdownDefaultCodes
         * 
         * @access  protected
         * @return  Array
         */
        _getCountryDropdownDefaultCodes: function() {
            var countryDropdownDefaults = Config.default('countryDropdownDefaults'),
                codes = [],
                index = 0;
            for (index; index < countryDropdownDefaults.length; index++) {
                codes.push(countryDropdownDefaults[index].code);
            }
            return codes;
        },

        /**
         * _setupMobileInput
         * 
         * @note    Originally I was performing a RequestUtils.alive check before
         *          the Geo lookup, but that resulted in two things:
         *          1) In areas with firewalls (eg. Turkey), the
         *          RequestUtils.alive check would result in always showing a
         *          connection error.
         *          2) I don't believe a connection needs to be checked for
         *          first. Simply make the call, and if it bails, the connection
         *          check will come in.
         * @todo!   Abstract utils.js to only be loaded if Instagram view is used
         * @access  protected
         * @return  void
         */
        _setupMobileInput: function() {

            // Input
            var $tel = this.find('input[type="tel"]');

            // GitHub Repo
            $tel.intlTelInput({
                // utilsScript: '/app/static/vendors/source/external/libphonenumber/v7.0.11/utils.js',
                defaultCountry: 'auto',
                preferredCountries: this._getCountryDropdownDefaultCodes(),
                geoIpLookup: function(callback) {
                    var getCountryCode = function(accountGeoData) {
                        var fallbackCountryCode = 'us';
                        if (accountGeoData === false) {
                            return fallbackCountryCode;
                        }
                        var countryCode = accountGeoData.country.code;
                        if (countryCode === false) {
                            return fallbackCountryCode;
                        }
                        countryCode = countryCode.trim().toLowerCase();
                        if (countryCode === '') {
                            return fallbackCountryCode
                        }
                        return countryCode;
                    };
                    var fallback = function() {
                        var geo = Stencil.get('account').geo(),
                            countryCode = getCountryCode(geo);
                        callback(countryCode);
                    };
                    RequestUtils.ajax({
                        excludeDefaultData: true,
                        signature: {"basename":"Instagram.js","line":143},
                        url: '/utils/geo/ipStack',
                        type: 'GET',
                        cache: true,
                        timeout: 2500,
                        success: function(response) {
                            if (response.success === true) {
                                var geo = response.data,
                                    countryCode = getCountryCode(geo);
                                callback(countryCode);
                            } else {
                                fallback();
                            }
                        },
                        error: fallback
                    });
                }
            });

            // Number set
            if (Stencil.account().userAccount().setting('shareMobile') !== '') {
                this.find('[name="data[number]"]').val(
                    $tel.intlTelInput('getNumber')
                );
            }
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    _this._modal.pause();
                    this._enabled = true;
                    if (
                        Account.max.sms() === true
                        && User.admin() === false
                        && User.editor() === false
                    ) {
                    // if (true) {//&& User.admin() === false) {
                        this._enabled = false;
                        if (Account.upgraded() === true) {
                            if (Account.plan('unlimited') === true) {
                                Stencil.alert('account.unlimited.limit.sms');
                            } else {
                                Stencil.navigate('/app/upgrade/unlimited/sms?clean=1&additive');
                            }
                        } else {
                            Stencil.navigate('/app/upgrade/pro/sms?clean=1&additive');
                        }
                        this.enable.delay(0, this);
                        _this._modal.unpause();
                        this.find('a.button').enable();
                        this.find('a.button').removeClass('busy');
                    }
                },
                'returned': function(event) {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {

                    /**
                     * Have to check for failed rules here because of an
                     * exception (as always) whereby if the country is not in
                     * the whitelist, we trigger an email to myself (Oliver),
                     * and send back a success = false value (but without any
                     * failed rules).
                     * 
                     * @see     https://i.imgur.com/oaJfBCz.png
                     */
                    if (
                        response.failedRules !== undefined
                        && response.failedRules[0]
                        && response.failedRules[0].validator[1] === 'validMobileNumber'
                    ) {
                        var image = _this._getImage(),
                            key = image.get('key'),
                            mobileNumber = _this.find('[name="data[number]"]').val(),
                            path = '/app/images/' + (key) + '/confirm/mobile/' + (mobileNumber) + '?clean';
                        Stencil.navigate(path);
                        var $callout = this.find('.callout.errors');
                        $callout.addClass('hidden');
                    } else {
                        this.setErrorMessage(response.message);
                    }
                },
                'returned/succeeded': function(event, response) {
                    var path = _this._modal.getImage().getSentPath();
                    Stencil.navigate(path);

                    // Track the messages sent this month and in total in memory
                    var account = Stencil.account(),
                        monthlySentSmsMessages = account.get('monthlySentSmsMessages'),
                        totalSentSmsMessages = account.get('totalSentSmsMessages');
                    account.set({
                        'monthlySentSmsMessages': monthlySentSmsMessages + 1,
                        'totalSentSmsMessages': totalSentSmsMessages + 1
                    });
                    account.syncRefillData(function(changed) {
                        if (changed === true) {
                            this.set({
                                monthlySavedImages: this.get('monthlySavedImages').toInt(),
                                monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt() + 1,
                                totalSentSmsMessages: this.get('totalSentSmsMessages').toInt() + 1
                            });
                        }
                        // this.save([
                        //     'monthlySentSmsMessages',
                        //     'totalSentSmsMessages'
                        // ]);
                    });

                    /**
                     * Set mobile in accessor (saved on the backend by this
                     * point).
                     */
                    var userAccount = account.userAccount();
                    userAccount.set({
                        'settings.shareMobile': response.data.mobile
                    });
                }
            });
        },

        /**
         * getForm
         * 
         * @access  public
         * @return  AppFormView
         */
        getForm: function() {
            return this._form;
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * LinkShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.LinkShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {
                    'input': this.selectInput
                },
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                },
                keydown: {
                    'input': function(event) {
                        var which = event.which.toInt();
                        if (which === 8) {
                            event.preventDefault();
                        }
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'link')
         */
        _network: 'link',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LinkShareView')
         */
        _string: 'LinkShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
            this._addCopyEventListener();
            this._setupTooltips();
            this.ui.showHide.copy.apply(this);
        },

        /**
         * _addCopyEventListener
         * 
         * @access  protected
         * @return  void
         */
        _addCopyEventListener: function() {
            this.on({
                'copy': function(event, $element) {
                    var $link = this.find('#link'),
                        $lookup = this.lookup('copy'),
                        content = $link.val();
                    DataUtils.copyToClipboard(content);
                    ElementUtils.changeTooltip($lookup, 'Copied!');
                }
            });
        },

        /**
         * _position
         * 
         * Ensures that the required <img> has a width by loading the same image
         * it is, and then onload, setting the left margin.
         * 
         * @access  protected
         * @return  void
         */
        _position: function() {
            var url = this._modal.getImage().getSrc(),
                crossOrigin = false,
                $shadow = this.find('.shadow'),
                $notShadow = this.find('img:not(.shadow)');
            ImageUtils.load.url(url, crossOrigin, function(reference) {
                var width = $notShadow.css('width').toInt(),
                    adjustedLeft = 0 - Math.round(width / 2);
                $shadow.css({
                    'margin-left': adjustedLeft
                });
            });
        },

        /**
         * _setShortUrl
         * 
         * @note    The attempted parameter is used to determine if a request to
         *          the server has already been fired, and in cases in which it
         *          has, and no short url is available (eg. bitly error'd out, or
         *          what's more likely is the connection to it timed out),
         *          display an alert error to the user to notify them of an
         *          issue.
         * @access  protected
         * @param   undefined|Boolean attempted (default: false)
         * @return  Boolean
         */
        _setShortUrl: function(attempted) {
            attempted = DataUtils.getDefaultValue(attempted, false);

            // Short URL needs to be generated
            var image = this._getImage();
            if (image.setting('shortUrl') === '') {

                // Service unavailable
                if (Config.serviceAvailable('bitly') === false) {
                    Stencil.alert('services.bitly.unavailable');
                    this.ui.failed.apply(this);
                    return false;
                }

                // If already attempted, then it implies an error
                if (attempted === true) {
                    Stencil.alert('services.bitly.error');
                    this.ui.failed.apply(this);
                    return false;
                }

                // Re-attempt setting after generating
                image.once({
                    'change/settings.shortUrl': this._setShortUrl.proxy(
                        this,
                        [true]
                    )
                });
                image.generateShortUrl();
                return true;
            }

            // Success: set the value
            this.ui.showHide.copy.apply(this);
            var shortUrl = image.setting('shortUrl');
            this.find('input[id="link"]').val(shortUrl);
            this.find('div.fields.placeholder').removeClass('placeholder');
            this.find('input:not(.placeholder)').focus();
            return true;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            var $contianer = App.getElement();
            this._element.tooltip({
                selector: '[tooltip]',
                container: $contianer,
                placement: 'bottom'
            });
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access  public
         * @return  void
         */
        drawImage: function() {
            if (this._drawn === false) {

                // Done
                this._drawn = true;

                // Regular
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    selector = '[lookup="draw"]',
                    $first = $('<img />'),
                    $second = $('<img />');
                $first.attr('src', src);
                $first.attr('draggable', false);
                this.find(selector).replaceWith($first);

                // Shadow
                selector = '[lookup="draw.shadow"]';
                $second.attr('src', src);
                $second.attr('draggable', false);
                $second.addClass('shadow');
                this.find(selector).replaceWith($second);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    this._getImage().once({
                        'preload': function(event) {
                            // var height = $first.css('height').toInt();
                            $first.attr('src', this.getSrc());
                            // $first.css('height', height);
                            $second.attr('src', this.getSrc());
                            // $second.css('height', height);
                        }
                    });
                }
            }
        },

        /**
         * selectInput
         * 
         * @access  public
         * @return  void
         */
        selectInput: function() {
            var $input = this.find('input#link');
            ElementUtils.select($input);
        },

        /**
         * show
         * 
         * Duplicated here only to prevent calling drawImage with a parameter
         * since LinkShareView doesn't require one. Also, the <_position> call
         * is needed for Link.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._setShortUrl();
            this._position();
            this.find('input:not(.placeholder)').focus();
        },

        /**
         * ui
         * 
         * @access  public
         * @var     Object
         */
        ui: {

            /**
             * failed
             * 
             * @access  public
             * @return  void
             */
            failed: function() {
                var $icon = this.find('div.icon.placeholder').find('> div'),
                    $input = this.find('input.placeholder');
                $icon.removeClass('fa-spin');
                $icon.removeClass('fa-refresh');
                $icon.addClass('fa-exclamation-circle');
                $input.attr('placeholder', 'Could not load share link');
            },

            /**
             * showHide
             * 
             * @access  public
             * @var     Object
             */
            showHide: {

                /**
                 * showHide
                 * 
                 * @access  public
                 * @return  Boolean
                 */
                copy: function() {
                    var $copy = this.find('.copy');
                    $copy.addClass('hidden');
                    if (UserAgentUtils.supports.clipboard.copy() === false) {
                        return false;
                    }
                    var image = this._getImage();
                    if (image.setting('shortUrl') === '') {
                        return false;
                    }
                    $copy.removeClass('hidden');
                    return true;
                }
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * NetworkShareView
     * 
     * @events  show/desktop
     *          show/mobile
     * @extends View
     */
    window.NetworkShareView = View.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Object
         */
        _drawn: {
            desktop: false,
            mobile: false
        },

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _modal: null,

        /**
         * _network
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _network: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'NetworkShareView')
         */
        _string: 'NetworkShareView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
            this._drawn = {
                desktop: false,
                mobile: false
            };
            this.on({
                'show/desktop': function(event) {
                    this.preview('desktop', true);
                },
                'show/mobile': function(event) {
                    this.preview('mobile', true);
                }
            });
        },

        /**
         * _connections
         * 
         * @access  protected
         * @return  Array
         */
        _connections: function() {
            var _this = this;
            return Stencil.account().collection('connections').network(
                this._network
            );
        },

        /**
         * _getImage
         * 
         * @access  protected
         * @return  ImageAccessor
         */
        _getImage: function() {
            return this._modal.getImage();
        },

        // /**
        //  * _getImageUrl
        //  * 
        //  * @access  protected
        //  * @return  String
        //  */
        // _getImageUrl: function() {
        //     var image = this._getImage(),
        //         width = image.get('width');
        //     return this._getImage().url('scale', {
        //         width: width
        //     });
        // },

        /**
         * _getOriginalImageUrl
         * 
         * Returns the path to the original image on Cloudinary. This should
         * only be used by Buffer and Pinterest, to ensure they get the links to
         * the originally saved images.
         * 
         * @access  protected
         * @return  String
         */
        _getOriginalImageUrl: function() {
            return this._getImage().url('original');
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            var key = this._getImage().get('key');
            return 'https://getstencil.com/p/' + (key);
        },

        /**
         * _getSnippet
         * 
         * @access  protected
         * @param   Number limit
         * @return  Object
         */
        _getSnippet: function(limit) {
            return this._getImage().getSnippet(limit);
        },

        /**
         * _showBusyModal
         * 
         * @access  protected
         * @return  void
         */
        _showBusyModal: function() {
            var exception = 'A window should have popped up. If you can\'t ' +
                'see it, it may appear behind this browser window, or on ' +
                'another monitor if you have one attached.<br />' +
                'If you cannot find it, ' +
                '<a click trigger="hide" class="text">go back to Stencil</a>.';
            App.getBusy().show(undefined, exception);
        },

        /**
         * drawImage
         * 
         * This function was intended to put less strain (read: memory
         * requirements) on the browser by only writing images when the user
         * requests a section and/or preview-tab that ought to show the image.
         * Specifically, I didn't want to write the base-64 encoded image data
         * in 9 different places if the user was only going to look at one, and
         * even more so, if they look at more than one, it's better to show the
         * image-src if the image has been uploaded by that point.
         * 
         * @access  public
         * @param   String type
         * @return  void
         */
        drawImage: function(type) {
            if (this._drawn[type] === false) {
                this._drawn[type] = true;
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    lookup = 'draw.' + (type),
                    selector = '[lookup="' + (lookup) + '"]',
                    $img = $('<img />');
                if (uploaded === 0 || preloaded === false) {
                // if (uploaded === 0) {

                    /**
                     * The below commented code works, but I'm not sure it
                     * should be used because of the following:
                     * 1. It's heavy. A Ghost canvas can be more than 1mb quite
                     *    easily. Considering that the image will likely only be
                     *    noticably blurry when it's a Pinterest frame, and
                     *    they're viewing Facebook/Twitter (where 100% width
                     *    stretching happens), it might not be worth the weight.
                     * 2. After X seconds the image will have been uploaded, so
                     *    it's likely okay to wait until then.
                     * 3. Listeners on Ghost are fine, but Ghost fires very
                     *    quickly. So without a secondary-access method for
                     *    the above <_getImageUrl> call, this Ghost listener
                     *    will only actually be run once for whatever network
                     *    and tab the user first hits. After that, the Preview
                     *    canvas data string will be used. Would need to be
                     *    build a helper method for this, which would touch a
                     *    lot of parts of the app.
                     */
                    // Canvases.Ghost.once({
                    //     'export': function(event, dataURL, contentType) {
                    //         $img.attr('src', dataURL);
                    //     }
                    // });

                    // Once preloaded, swap out the image src
                    this._getImage().once({
                        'preload': function(event) {
                            $img.attr('src', this.getSrc());
                        }
                    });
                }
                $img.attr('src', src);
                $img.attr('draggable', false);
                this.find(selector).replaceWith($img);
            }
        },

        /**
         * getNav
         * 
         * @access  public
         * @return  jQuery
         */
        getNav: function() {
            return this.find('aside nav');
        },

        /**
         * getPreview
         * 
         * @access  public
         * @return  jQuery
         */
        getPreview: function() {
            return this.find('aside div.preview');
        },

        /**
         * preview
         * 
         * @access  public
         * @param   String type
         * @param   Boolean drawImage
         * @return  void
         */
        preview: function(type, drawImage) {
            if (drawImage === true) {
                this.drawImage(type);
            }
            this.getNav().find('a').removeClass('active');
            this.getNav().find('a.' + (type)).addClass('active');
            this.getPreview().find('> section').addClass('hidden');
            this.getPreview().find('> section.' + (type)).removeClass('hidden');
        },

        /**
         * show
         * 
         * @access  public
         * @param   undefined|Boolean focusOnInput
         * @return  void
         */
        show: function(focusOnInput) {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage('desktop');
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            if (UserAgentUtils.is.tablet() === false) {
                if (focusOnInput !== false) {
                    this._element.focusable().focus();
                }
            }
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * PinterestShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.PinterestShareView = NetworkShareView.extend({

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'pinterest')
         */
        _network: 'pinterest',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PinterestShareView')
         */
        _string: 'PinterestShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupKeyEvents();
            this.preview('desktop', false);
            this.on({
                'open': this.open
            });
        },

        /**
         * _getShareUrl
         * 
         * @acccess protected
         * @return  String
         */
        _getShareUrl: function() {
            var urlValue = this.find('[name="url"]').val();
            return urlValue;
        },

        /**
         * _setupKeyEvents
         * 
         * @note    13 = enter key
         * @acccess protected
         * @return  void
         */
        _setupKeyEvents: function() {
            var _this = this;
            this.find('input[name="url"]').on({
                'keydown': function(event) {
                    if (event.which === 13) {
                        _this.triggerHandler('open');
                    }
                }
            });
        },

        /**
         * open
         * 
         * @note    Pinterest (oddly) truncates (by adding three dots) at 500 or
         *          greater characters. So I truncate at 499, with my own three
         *          dots, to ensure things are in sync.
         * @note    It's okay to exclude the description (eg. if there is none)
         * @access  public
         * @return  Boolean
         */
        open: function() {
            if (Config.serviceAvailable('pinterest') === false) {
                Stencil.alert('services.pinterest.unavailable');
                return false;
            }
            var image = this._getImage();
            if (image.get('uploaded').toInt() === 1) {
                var snippetObject = this._getSnippet(499),
                    url = encodeURIComponent(this._getShareUrl()),
                    media = encodeURIComponent(this._getOriginalImageUrl()),
                    description = encodeURIComponent(snippetObject.snippet),
                    link = 'https://www.pinterest.com/pin/create/button/' +
                        '?url=' + (url) +
                        '&media=' + (media);
                if (snippetObject.default === false) {
                    link += '&description=' + (description);
                }
                window.open(
                    link,
                    'Pinterest Share',
                    'width=640, height=320'
                );
            } else {
                var msg = Config.getMessage('image.share.pending');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function(event) {
                        App.getBusy().hide();
                        Stencil.alert('image.uploaded');
                    }
                });
            }
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * TwitterShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.TwitterShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $textarea
                     * @return  void
                     */
                    'textarea': function(event, $textarea) {
                        var $message = this.find('[lookup="message"]'),
                            message = $textarea.val();
                        this.setMessage(message);
                        this.triggerHandler('change/message');
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'twitter')
         */
        _network: 'twitter',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TwitterShareView')
         */
        _string: 'TwitterShareView',

        /**
         * _thresholds
         * 
         * @access  protected
         * @var     Object
         */
        _thresholds: {
            search: 15
        },

        /**
         * init
         * 
         * @todo!!  Instead of having image-uploaded property checked on backend,
         *          check it here, and if it is not yet uploaded, wait for it
         *          (via event listener), and then submit form.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this.on({
                'connection/add': function(event) {
                    if (Config.serviceAvailable('twitter') === false) {
                        Stencil.alert('services.twitter.unavailable');
                    } else {
                        this._showBusyModal();
                        var _this = this,
                            model = this._getModel('Twitter');
                        model.setup();
                        model.connect({
                            closed: function() {
                                App.getBusy().hide();
                            },
                            connected: function(connections) {
                                _this.state('connections');
                            }
                        });
                    }
                }
            });
            this._setupForm();
            this.preview('desktop', false);
            this._addCountListener();
            this._refreshCount();
            this._setupTooltips();

            // State
            if (this._connections().length === 0) {
                this.state('connect');
            } else {
                this.state('connections');
            }
        },

        /**
         * _addCountListener
         * 
         * @access  protected
         * @return  void
         */
        _addCountListener: function() {
            this.on({
                'change/message': this._refreshCount
            });
        },

        /**
         * _drawConnections
         * 
         * @access  protected
         * @return  void
         */
        _drawConnections: function() {
            var connections = this._connections(),
                $connections = DataUtils.render('TwitterConnections', {
                    live: connections.length > this._thresholds.search,
                    connections: connections
                });
            this.find('div.selector').append($connections);
        },

        /**
         * _initConnections
         * 
         * Creates the initial <selectpicker>, and listens for value changes
         * to have the preview update or prompt them to connect more accounts.
         * 
         * @access  protected
         * @return  void
         */
        _initConnections: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.update();
                    _this.find('textarea').focus();
                    if ($(this).val().toInt() === 0) {
                        _this.triggerHandler('connection/add');
                        _this.find('textarea').blur();
                        _this._setupConnections();
                    } else {
                        var userAccount = Stencil.account().userAccount();
                        userAccount.push(
                            'settings.shareTwitterRecent',
                            $(this).val()
                        );
                    }
                }
            );
        },

        /**
         * _preselectConnection
         * 
         * Looks up which connection should be preselected, based on a possible
         * cookie value.
         * 
         * @todo    Ensure preselected is cookied
         * @access  protected
         * @return  void
         */
        _preselectConnection: function() {
            var $select = this.find('select'),
                share = Stencil.account().userAccount().setting('shareTwitterRecent'),
                first = $select.find('option').first().val(),
                preselected = share.match(/^cnnc/) === null ? first : share;
            $select.val(preselected);
        },

        /**
         * _refreshCount
         * 
         * @see     https://dev.twitter.com/rest/reference/get/help/configuration
         * @note    Count used to start at 24 since an image is attached to the
         *          tweet. No longer seems to be the case.
         * @access  protected
         * @return  void
         */
        _refreshCount: function() {
            var $textarea = this.find('textarea'),
                val = $textarea.val(),
                $status = this.find('.status'),
                $count = $status.find('[lookup="current"]'),
                // count = 24;
                count = 0;

            // Leading @ sign


            // Replace links with hardcoded-counts (23)
            count += val.replace(
                /h[A-Za-z]+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9-_:%&~\?\/.=]+/g,
                '12345678901234567890123'
            // Twitter doesn't require http(s) when a trailing .com is found
            ).replace(
                /^[a-z0-9]+\.com(\s)/gi,
                '12345678901234567890123$1'
            ).replace(
                /(\s)[a-z0-9]+\.com(\s)/gi,
                '$112345678901234567890123$2'
            ).replace(
                /(\s)[a-z0-9]+\.com$/gi,
                '$112345678901234567890123'
            ).replace(
                /^[a-z0-9]+\.com$/gi,
                '12345678901234567890123'
            ).length;
            // ).replace(
            //     /^[a-z0-9]+\.com\s/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /\s[a-z0-9]+\.com\s/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /\s[a-z0-9]+\.com$/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /^[a-z0-9]+\.com$/gi,
            //     '12345678901234567890123'
            // ).length;

            // Twitter doesn't require http(s) when a trailing .com is found
//             count += val.replace(
//                 /\s[a-z0-9]+\.com\s/gi,
//                 '12345678901234567890123'
//             ).length;
// LogUtils.log.simple(
//     val.replace(
//                 /\s[a-z0-9]+\.com\s/gi,
//                 '12345678901234567890123'
//             ), true
// );
//             count += val.replace(
//                 /\s[a-z0-9]+\.com$/gi,
//                 '12345678901234567890123'
//             ).length;

            // Set count, along with UI for overage
            $count.text(count);
            $status.removeClass('red');
            if (count > 280) {
                $status.addClass('red');
            }
        },

        /**
         * _removeConnections
         * 
         * @access  protected
         * @return  void
         */
        _removeConnections: function() {
            var $selector = this.find('div.selector');
            $selector.empty();
        },

        /**
         * _setupConnections
         * 
         * @access  protected
         * @return  void
         */
        _setupConnections: function() {
            this._removeConnections();
            this._drawConnections();
            this._preselectConnection();
            this._initConnections();
            this.update();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.setHandlerDelay(0);
            this._form.on({
                'submitted': function(event) {
                    _this._modal.pause();
                },
                'returned': function(event) {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    if (response.data && response.data.connection) {
                        if (response.data.action === 'delete') {
                            var key = response.data.connection.key;
                            Stencil.getAccessor(key).delete();
                            if (_this._connections().length === 0) {
                                _this.state('connect');
                            } else {
                                _this.state('connections');
                            }

                            // Error handling
                            this.clearErrors();
                            var image = _this._getImage(),
                                path = '/app/images/' + (image.get('key')) +
                                    '/' + (key) + '/error?clean=1';
                            Stencil.navigate(path);
                        } else if (response.data.action === 'error') {
                            this.setErrorMessage(response.message);
                        }
                    }
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Share'),
                        share = model.setAccessor(response.data.object);
                    Stencil.navigate(share.getPath());
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                // container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * setMessage
         * 
         * This function is very peculiar. The goal is to have the preview look
         * exactly like how Twitter will render it. To that end, note the
         * following:
         * - Twitter will strip lead whitespace
         * - It will cap more than 2 newline characters to just 2
         * - It will strip trailing whitespace
         * 
         * @see     https://stackoverflow.com/questions/5002111/javascript-how-to-strip-html-tags-from-string
         * @see     https://i.imgur.com/VTsHkJi.png
         *          https://i.imgur.com/p2Fg7a9.png
         *          Look into truncating url's to match how Twitter does it
         * @note    Added the .textContent / .innerText logic to prevent people
         *          from pasting in markup that may include script tags. This
         *          logic simply strips out the html tags. But I don't think I
         *          actually want this. So instead, simply replacing open and
         *          close html tags to prevent tags from being rendered.
         * @access  public
         * @param   String message
         * @return  void
         */
        setMessage: function(message) {
            var $message = this.find('[lookup="message"]');//,
                // div = document.createElement('div');
            // div.innerHTML = message;
            // message = (div.textContent || div.innerText || '');
            message = message.replace(/</g, '&lt;');
            message = message.replace(/>/g, '&gt;');
            message = message.replace(/^\n{1,}/g, '');
            message = message.encode('url');
            message = message.encode('hashtag', {
                href: 'https://twitter.com/hashtag/$hashtag'
            });
            message = message.encode('username', {
                href: 'https://twitter.com/$username'
            });
            message = message.replace(/\n{2,}/g, '\n\n');
            message = message.replace(/\n+$/, '');
            message = message.encode('newlines');
            $message.html(message);
        },

        /**
         * state
         * 
         * Show the proper state (eg. show connections w/ textarea, or button
         * prompting them to connect their FB account(s))
         * 
         * @access  public
         * @param   String state
         * @return  void
         */
        state: function(state) {
            this.find('.state').addClass('hidden');
            if (state === 'connect') {
                this.find('.state[lookup="connect"]').removeClass('hidden');
            } else {
                this._setupConnections();
                this.find('.state[lookup="connections"]').removeClass('hidden');
            }
        },

        /**
         * update
         * 
         * Updates the UI of the previews to have the corresponding name and
         * picture in there.
         * 
         * @todo    Preload all conncetion urls into memory for faster
         *          transitions between them
         * @access  public
         * @return  void
         */
        update: function() {

            // Get the selected connection
            var connections = Stencil.account().collection('connections'),
                $select = this.find('select'),
                value = $select.val(),
                selected = false;
            if (connections.find(value) !== false) {
                selected = connections.find(value);
            }

            // If a connection was found
            if (selected !== false) {
                var $names = this.find('[lookup="connection.label"]'),
                    $usernames = this.find('[lookup="connection.networkUserId"]'),
                    $images = this.find('[lookup="connection.image"]'),
                    label = '@' + (selected.get('label')),
                    raw = selected.getRaw(),
                    name = raw.name;

                // Inserts
                $names.text(name === undefined ? '' : name);
                $usernames.text(label);
                $images.attr('src', selected.getImageSrc());
            }
        }
    });
});
window.DependencyLoader.push('NetworkShareView', function() {

    /**
     * VerifoneShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.VerifoneShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'verifone')
         */
        _network: 'verifone',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VerifoneShareView')
         */
        _string: 'VerifoneShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
            this._addDownloadEvent();
            this._listenForUploadedChange();
        },

        /**
         * _addDownloadEvent
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadEvent: function() {
            var image = this._getImage();
            this.on({
                'download': function(event) {
                    var maxBytes = this._getMaxBytes();
                    image.download(false, false, false, maxBytes, false, false);
                }
            });
            var _this = this;
            Stencil.once({
                'redirect/start': function(event) {
                    _this._modal.pause();
                    var $buttons = _this.find('a.button');
                    $buttons.addClass('busy');
                    $buttons.disable();
                },
                'redirect/complete': function(event) {
                    _this._modal.unpause();
                    var $buttons = _this.find('a.button');
                    $buttons.removeClass('busy');
                    $buttons.addClass('done');
                    (function() {
                        $buttons.removeClass('done');
                        $buttons.enable();
                    }).delay(2000, this);
                }
            });
        },

        /**
         * _getMaxBytes
         * 
         * @access  protected
         * @return  Number
         */
        _getMaxBytes: function() {
            var image = this._getImage(),
                frameKey = image.get('frame');
            return Config.get('partners').verifone.frames[frameKey].maxBytes;
        },

        /**
         * _listenForUploadedChange
         * 
         * @access  protected
         * @return  void
         */
        _listenForUploadedChange: function() {
            var _this = this,
                image = this._getImage();
            if (image.get('uploaded').toInt() === 0) {
                image.once({
                    'update/uploaded': function(event) {
                        var $buttons = _this.find('a.button');
                        $buttons.removeClass('busy');
                        $buttons.enable();
                    }
                });
            }
        },

        /**
         * _showAppropriateFramePreview
         * 
         * @access  protected
         * @return  void
         */
        _showAppropriateFramePreview: function() {
            var image = this._getImage(),
                frameKey = image.get('frame');
            if (frameKey === 'frm-partner.verifone-carbon8') {
                this.find('[frame="frm-partner.verifone-carbon8"]').removeClass('hidden');
            } else if (frameKey === 'frm-partner.verifone-vx') {
                this.find('[frame="frm-partner.verifone-vx"]').removeClass('hidden');
            }
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access  public
         * @return  void
         */
        drawImage: function() {
            if (this._drawn === false) {
                this._drawn = true;
                var image = this._getImage(),
                    frameKey = image.get('frame'),
                    uploaded = image.get('uploaded').toInt(),
                    preloaded = image.preloaded(),
                    src = image.getSrc(),
                    selector = '[frame="' + (frameKey) + '"] [lookup="draw"]',
                    $img = $('<img />');
                $img.attr('src', src);
                $img.attr('draggable', false);
                this.find(selector).replaceWith($img);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    image.once({
                        'preload': function(event) {
                            $img.attr('src', this.getSrc());
                        }
                    });
                }
            }
        },

        /**
         * show
         * 
         * @note    Not pushing shareNetwork to the UserAccount record, since I
         *          don't want it remembered.
         * @access  public
         * @return  void
         */
        show: function() {
            this.drawImage();
            this._showAppropriateFramePreview();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * SidebarView
     * 
     * @extends View
     */
    window.SidebarView = View.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SidebarView')
         */
        _string: 'SidebarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * getNav
         * 
         * @access  public
         * @return  jQuery
         */
        getNav: function() {
            return this.find('nav');
        },

        /**
         * updatePath
         * 
         * @access  public
         * @param   AreaView area
         * @param   String path
         * @return  void
         */
        updatePath: function(area, path) {
            var $nav = this.getNav(),
                type = area.getType(),
                $anchor = $nav.find('a[area="' + (type) + '"]');
            $anchor.attr('href', path);
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * CanvasView
     * 
     * @see     http://rstgroup.github.io/fabricjs-viewport/
     *          Contains library to zoom in and out of a fabricjs canvas
     * @extends View
     */
    window.CanvasView = View.extend({

        /**
         * _cotton
         * 
         * Reference to the fabric.Canvas object.
         * 
         * @access  protected
         * @var     null|fabric.Canvas (default: null)
         */
        _cotton: null,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CanvasView')
         */
        _string: 'CanvasView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * _setupCotton
         * 
         * @note    Had to add the moveCursor property to prevent the move cursor
         *          from showing up when the BackgroundRectangle layer was being
         *          accidentally dragged
         * @see     https://gist.github.com/paulkaplan/6050309
         * @access  protected
         * @return  void
         */
        _setupCotton: function() {
            this._cotton = new fabric.Canvas(
                this._element.get(0),
                {
                    controlsAboveOverlay: true,
                    moveCursor: 'default',
                    magnets: {
                        drawings: []
                    },
                    selection: false
                    // ,targetFindTolerance: 5
                }
            );
            // if (UserAgentUtils.getDevicePixelRatio() !== 1) {
            //     var canvas = this._element.get(0),
            //         width = canvas.width,
            //         height = canvas.height,
            //         ratio = UserAgentUtils.getDevicePixelRatio();
            //     canvas.getContext('2d').scale(ratio, ratio);
            //     canvas.setAttribute('width', width * ratio);
            //     canvas.setAttribute('height', height * ratio);
            //     $(canvas).css({
            //         width: (width) + 'px',
            //         height: (height) + 'px'
            //     });
            // }
        },

        /**
         * drawLayers
         * 
         * Recursively draws layers onto the canvas since it may at time require
         * fetching further resources (eg. fonts, svg images, bitmap images,
         * etc). Also imortant for exporting (done via the Ghost canvas), since
         * the fully rendered image won't be available until it's assets have
         * been loaded.
         * 
         * @access  public
         * @return  void
         */
        drawLayers: function() {
            this._resizeCanvas();
            var _this = this,
                drawing,
                layer,
                layers = this._image.getImageDocument().getLayers(true),
                length = layers.length,
                next = function(index) {
                    layer = layers[index];
                    drawing = layer.getDrawing();
                    drawing.once({
                        'draw': function(event) {
                            if (index !== length - 1) {
                                next(index + 1);
                            } else {
                                _this.triggerHandler('draw');
                            }
                        }
                    });
                    drawing.draw();
                };
            next(0);
        },

        /**
         * getBackgroundBitmapImageLayer
         * 
         * @access  public
         * @return  BackgroundBitmapImageLayer
         */
        getBackgroundBitmapImageLayer: function() {
            return this._image.getImageDocument().getBackgroundBitmapImageLayer();
        },

        /**
         * getCotton
         * 
         * @access  public
         * @return  fabric.Canvas
         */
        getCotton: function() {
            return this._cotton;
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getRenderedDimensions
         * 
         * @access  public
         * @return  Object
         */
        getRenderedDimensions: function() {
            var height = this._cotton.getHeight(),
                width = this._cotton.getWidth(),
                ratio = width / height,
                dimensions = {
                    height: height,
                    ratio: ratio,
                    width: width
                };
            return dimensions;
        },

        /**
         * render
         * 
         * Reorders the drawn layers, assuming that the order in which they're
         * returned from getLayers is the order that they're desired via the UI.
         * 
         * A check is made against whether the drawings have successfully been
         * drawn, because it's possible that this method is called after a layer
         * has been added to the image document, but before it's been drawn. I
         * ran into this issue when I was a logged in user with more than one
         * watermark enabled. When I logged out, and then back in, one of the
         * calls below failed because the <cotton> property didn't yet exist.
         * The Canvas.render method was being triggered by the
         * WatermarkUploadAccessor.addToCanvas method.
         * 
         * The renderFilters check is always made to prevent rendering files
         * when actions unrelated to a bitmap operation is made. Without this
         * check, when a filter is specified, running non-filter based
         * operations against the canvas would be super-slow, since it would be
         * doing bitmap operations each time.
         * 
         * @todo    Look into fabric's moveTo method. It may be useful for
         *          ordering layers.
         * @access  public
         * @return  void
         */
        render: function() {

            // Reorder layers, including backdrop (if any)
            this.set({
                'rendering': true
            });
            var imageDocument = this._image.getImageDocument(),
                layers = imageDocument.getLayers(true),
                drawing,
                cotton;
            jQuery.each(layers, function(index, layer) {
                drawing = layer.getDrawing();
                if (drawing.drawn() === true) {
                    cotton = drawing.getCotton();
                    if (layer.getProperty('type') === 'text') {
                        if (cotton.backdrop !== undefined) {
                            cotton.backdrop.bringToFront();
                            // cotton.backdrop.setCoords();
                        }
                    }
                    if (layer.getProperty('background') === undefined) {
                        cotton.bringToFront();
                    }
                    if (drawing.getOutline() !== null) {
                        drawing.getOutline().centers.top.bringToFront();
                        drawing.getOutline().centers.right.bringToFront();
                        drawing.getOutline().centers.bottom.bringToFront();
                        drawing.getOutline().centers.left.bringToFront();
                        drawing.getOutline().red.bringToFront();
                        drawing.getOutline().white.bringToFront();
                    }
                    // cotton.setCoords();
                }
            });

            // Determine if a filter-rendering is required on any layer
            var layer, index, filterLayersToRender = [], filterLayers = [],
                filters;
            for (index in layers) {
                layer = layers[index];
                filters = layer.getProperty('filters');
                if (filters !== undefined && filters.length > 0) {
                    filterLayers.push(layer);
                }
                if (layer.get('renderFilters') === true) {
                    filterLayersToRender.push(layer);
                }
            }

            // Post filter-rendering callback
            if (filterLayersToRender.length > 0) {
                var _this = this,
                    recursiveFilterRendering = function(layers) {
                        if (layers.length === 0) {
                            _this._cotton.renderAll();
                            _this.set({
                                'rendering': false
                            });
                            _this.triggerHandler('render');
                        } else {
                            var layer = layers.shift();
                            layer.filters.sort.apply(layer);
                            layer.getDrawing().once({
                                'applyFilters/complete': function(event) {
                                    recursiveFilterRendering(layers);
                                }
                            });
                            layer.getCotton().applyFilters();
                            layer.set({'renderFilters': false});
                        }
                    };
                recursiveFilterRendering(filterLayersToRender);
            } else {
                this._cotton.renderAll();
                this.set({
                    'rendering': false
                });
                this.triggerHandler('render');
            }
        },

        /**
         * setImage
         * 
         * @access  public
         * @param   ImageAccessor image
         * @return  void
         */
        setImage: function(image) {
            this._image = image;
        }
    });
});
window.DependencyLoader.push('CanvasView', function() {

    /**
     * GhostCanvasView
     * 
     * @extends CanvasView
     */
    window.GhostCanvasView = CanvasView.extend({

        /**
         * _differenceRatioPadding
         * 
         * @access  protected
         * @var     Number (default: 0.001)
         */
        _differenceRatioPadding: 0.001,

        /**
         * _logToConsole
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _logToConsole: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GhostCanvasView')
         */
        _string: 'GhostCanvasView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            window.Canvases.Ghost = this;
            this._setupCotton();
            if (Config.getRole() === 'local') {
                this._logToConsole = true;
            }
        },

        /**
         * _calculatedDimensionsExceedFrameDimensions
         * 
         * Returns whether it's likely that the rendered dataURL representing
         * the image will have dimensions that exceed the selected frame's.
         * This is likely to lead to false-negatives, rather than
         * false-positives, since we're using the NumberUtils.floor call against
         * the dimensions.
         * 
         * @access  protected
         * @param   Object options
         * @return  Boolean
         */
        _calculatedDimensionsExceedFrameDimensions: function(options) {
            var dimensions = this._getRelevantDimensions(),
                // height = (options.height * options.multiplier).round(0),
                // width = (options.width * options.multiplier).round(0);
                height = NumberUtils.floor(options.height * options.multiplier),
                width = NumberUtils.floor(options.width * options.multiplier);
            if (height > dimensions.frame.height) {
                this._log('1a');
                this._log(height);
                this._log(width);
                return true;
            }
            if (width > dimensions.frame.width) {
                this._log('2a');
                this._log(height);
                this._log(width);
                return true;
            }
            return false;
        },

        /**
         * _checkForMatchingDimensions
         * 
         * Loads the passed in dataURL, and triggers a _track call if the
         * dimensions of the loaded image perfectly match the dimensions of the
         * frame (which is the conclusive desired dimensions).
         * 
         * The reason this is being checked is because this method is called at
         * a time when it's presumed they're different.
         * 
         * @access  protected
         * @param   String dataURL
         * @return  void
         */
        _checkForMatchingDimensions: function(dataURL) {
            var _this = this,
                dimensions = this._getRelevantDimensions(),
                imageRequest = new ImageRequest(dataURL);
            imageRequest.once({
                'load': function(event, image) {
                    if (image.width.toInt() !== dimensions.frame.width) {
                        return false;
                    }
                    if (image.height.toInt() !== dimensions.frame.height) {
                        return false;
                    }
                    _this._track('!!!matching dimensions');
                    return true;
                }
            });
            imageRequest.request();
        },

        /**
         * _cropDataURL
         * 
         * Crops the passed in dataURL (to the corresponding appropriate
         * contentType), according to the selected frame's dimensions.
         * 
         * @access  protected
         * @param   Boolean scaleForRetina
         * @param   String contentType
         * @param   String dataURL
         * @param   Function callback
         * @return  Boolean
         */
        _cropDataURL: function(scaleForRetina, contentType, dataURL, callback) {
            var dimensions = this._getRelevantDimensions(),
                width = dimensions.frame.width,
                height = dimensions.frame.height;
            if (scaleForRetina === false) {
                width /= 2;
                height /= 2;
            }
            callback = callback.proxy(this);
            DataUtils.cropDataURL(
                dataURL,
                width,
                height,
                contentType,
                callback
            );
        },

        /**
         * _dimensionsMatch
         * 
         * Returns whether the canvas currently being drawn to matches the
         * selected frame. The only time these are likely to not match is when
         * the user has zoomed their browser, and as a result, there may be a
         * rounding error between creating a canvas that matches the selected
         * frame.
         * 
         * @access  protected
         * @return  Boolean
         */
        _dimensionsMatch: function() {
            var dimensions = this._getRelevantDimensions();
            if (dimensions.canvas.height !== dimensions.frame.height) {
                return false;
            }
            if (dimensions.canvas.width !== dimensions.frame.width) {
                return false;
            }
            return true;
        },

        /**
         * _getCanvasBleed
         * 
         * Returns an object representing the bleed in x and y directions
         * (semantically identified as width and height). This will only happen
         * when the canvas and frame don't match, likely due to a zoom-level
         * that results in a rounding error when drawing a the canvas(es).
         * 
         * @access  protected
         * @return  Object
         */
        _getCanvasBleed: function() {
            var dimensions = this._getRelevantDimensions(),
                bleed = {
                    height: dimensions.frame.height - dimensions.canvas.height,
                    width: dimensions.frame.width - dimensions.canvas.width
                };
            return bleed;
        },

        /**
         * _getCropDimensions
         * 
         * Returns an object representing which part of the canvas should be
         * cropped during the fabric toDataURL call. Generally, this will simply
         * be the dimensions of the canvas, but if there's bleed (arrising from
         * the canvas-dimensions not matching the selected frame's dimensions),
         * then the bleed will be deducted from the frame-dimensions.
         * 
         * @access  protected
         * @return  Object
         */
        _getCropDimensions: function() {
            var dimensions = this._getRelevantDimensions(),
                cropDimensions = {
                    width: dimensions.frame.width,
                    height: dimensions.frame.height
                };
            if (this._dimensionsMatch() === true) {
                return cropDimensions;
            }
            var bleed = this._getCanvasBleed();
            cropDimensions.width -= bleed.width;
            cropDimensions.height -= bleed.height;
            return cropDimensions;
        },

        /**
         * _getDevicePixelRatioAdjustedMultiplier
         * 
         * This method detects whether the multiplier needs to be adjusted to
         * account for a devicePixelRatio value that is resulting in space
         * around the canvas (which at the moment occurs when the user zooms in
         * or out at a percentage that results in a rounding error when
         * calculating the canvas-dimensions).
         * 
         * It works by first checking whether the canvas and frame-dimensions
         * match (in which case, the multiplier isn't adjusted).
         * 
         * However if they don't match, that implies that either the width or
         * height isn't the same, and so the multiplier should be increased to
         * ensure there isn't any whitespace (which for jpeg-exported images,
         * gets rendered as black pixels, and for png-exported images, gets
         * rendered as transparent pixels). This will result in some of the
         * image being trimmed / cropped, but it'll only be a few pixels at
         * most, and it's more ideal than black space showing up.
         * 
         * The 0.0001 is added to the difference ratio because it helps to
         * account for rounding errors whereby the exact select frame's
         * dimensions cannot be reached.
         * 
         * While that may result in false-positives, it's better for an image to
         * be rendered as too large (and then cropped down), than too small
         * (which would then require that the image being increased in size, and
         * then cropped down).
         * 
         * @access  protected
         * @param   Number multiplier
         * @return  Number
         */
        _getDevicePixelRatioAdjustedMultiplier: function(multiplier) {
            if (this._dimensionsMatch() === true) {
                return multiplier;
            }
            var dimensions = this._getRelevantDimensions(),
                bleed = this._getCanvasBleed(),
                differenceRatios = {
                    height: bleed.height / dimensions.canvas.height,
                    width: bleed.width / dimensions.canvas.width
                },
                differenceRatio = Math.max(
                    differenceRatios.height,
                    differenceRatios.width
                );
            differenceRatio += this._differenceRatioPadding;
            multiplier += differenceRatio;
            // this._track('bleed');
            return multiplier;
        },

        /**
         * _getExportContentType
         * 
         * @access  protected
         * @return  String
         */
        _getExportContentType: function() {
            var contentType = this._image.getRecommendedExportContentType();
            return contentType;
        },

        /**
         * _getExportOptions
         * 
         * @access  protected
         * @param   String contentType
         * @param   Number multiplier
         * @return  Object
         */
        _getExportOptions: function(contentType, multiplier) {
            var cropDimensions = this._getCropDimensions(),
                options = {
                    format: contentType === 'image/jpeg' ? 'jpeg' : 'png',
                    quality: 1,
                    multiplier: multiplier,
                    left: 0,
                    top: 0,
                    width: cropDimensions.width,
                    height: cropDimensions.height
                };
            return options;
        },

        /**
         * _getRelevantDimensions
         * 
         * Returns an object representing the dimensions of the canvas element
         * and the selected frame.
         * 
         * @access  protected
         * @return  Object
         */
        _getRelevantDimensions: function() {
            var minDevicePixelRatio = Config.default('minPixelDensity').toInt(),
                $canvas = this._element,
                dimensions = {
                    canvas: {
                        height: $canvas.attr('height').toInt(),
                        width: $canvas.attr('width').toInt()
                    },
                    frame: {
                        height: Frame.get('height').toInt() * minDevicePixelRatio,
                        width: Frame.get('width').toInt() * minDevicePixelRatio
                    }
                };
            return dimensions;
        },

        /**
         * _getReportMessage
         * 
         * Returns an object representing what should be sent the server side
         * for reporting when an issue arrises.
         * 
         * @access  protected
         * @return  Object
         */
        _getReportMessage: function() {
            var dimensions = this._getRelevantDimensions(),
                bleed = this._getCanvasBleed(),
                differenceRatios = {
                    height: bleed.height / dimensions.canvas.height,
                    width: bleed.width / dimensions.canvas.width
                },
                differenceRatio = Math.max(
                    differenceRatios.height,
                    differenceRatios.width
                ),
                image = Footer.getLastSavedImage(),
                message = {
                    bleed: bleed,
                    dpr: UserAgentUtils.getDevicePixelRatio(),
                    differenceRatio: differenceRatio,
                    differenceRatios: differenceRatios,
                    dimensions: dimensions,
                    image: {}
                };
            if (image !== false) {
                var key = image.get('key');
                message.image.key = key;
                message.image.url = RequestUtils.url.s3(key);
            }
            return message;
        },

        /**
         * _log
         * 
         * @access  protected
         * @param   String msg
         * @return  Boolean
         */
        _log: function(msg) {
            if (this._logToConsole === false) {
                return false;
            }
            LogUtils.log.simple(msg, true);
            return true;
        },

        /**
         * _report
         * 
         * @access  protected
         * @param   String source
         * @return  void
         */
        _report: function(source) {
            var subject = 'Ghost export',
                msg = this._getReportMessage();
            subject = (subject) + ' (' + (source) + ')';
            RequestUtils.report(subject, msg, true);
        },

        /**
         * _resizeCanvas
         * 
         * Fabric.js automatically creates a secondary canvas behind the main
         * one. They do this to deal with retina issues: they want to ensure
         * that whatever is exported, it's optimized for the display (read
         * "number of pixels"). So in the case where the device pixel ratio
         * matches the minPixelDensity property of 2 set in the config file,
         * nothing needs to be done, since Fabric.js will create the proper
         * sized canves.
         * 
         * But in the case:
         * 1) The device has a lower device pixel ratio (eg. 1), the canvas
         *    is blown up to deliver whatever download the user desires (eg.
         *    retina).
         * 2) The device has a higher device pixel ratio (eg. zoomed in to 2.2),
         *    the canvas is made a bit smaller to ensure whatever is downloaded
         *    fits the proper dimensions.
         * 
         * @access  protected
         * @return  void
         */
        _resizeCanvas: function() {
            var width = Frame.get('width'),
                height = Frame.get('height'),
                devicePixelRatio = UserAgentUtils.getDevicePixelRatio(),
                minDevicePixelRatio = Config.default('minPixelDensity').toInt();
            if (devicePixelRatio === minDevicePixelRatio) {
                this._cotton.resizeTo(width, height);
            } else {
                width *= (minDevicePixelRatio / devicePixelRatio);
                height *= (minDevicePixelRatio / devicePixelRatio);
                this._cotton.resizeTo(width, height);
            }
        },

        /**
         * _setupCotton
         * 
         * @access  protected
         * @return  void
         */
        _setupCotton: function() {
            this._super();
            this._element.parent().addClass('ghost-canvas-container');
        },

        /**
         * _syncBackgroundBitmapImage
         * 
         * @access  protected
         * @param   Function callback
         * @return  Boolean
         */
        _syncBackgroundBitmapImage: function(callback) {
            var layer = this.getBackgroundBitmapImageLayer(),
                key = layer.getProperty('image');
            if (key.match(/^asst/) !== null) {
                callback();
                return true;
            }
            if (key.match(/^img0/) !== null) {
                callback();
                return true;
            }
            if (key.match(/^upld/) !== null) {
                callback();
                return true;
            }

            // 
            var accessor = Stencil.getAccessor(key);
            accessor.once({
                'save': function(event, resource, asset) {
                    callback();
                }
            });
            accessor.save();
            return false;
        },

        /**
         * _track
         * 
         * @access  protected
         * @param   String source
         * @return  void
         */
        _track: function(source) {
            var msg = 'Ghost export';
            msg = (msg) + ' (' + (source) + ')';
            Track.event(msg);
            this._report(source);
        },

        /**
         * draw
         * 
         * Waits for a background image, if defined, to be saved to the backend
         * to ensure a frame-dimension-specific background image can be loaded
         * (via Cloudinary). After that's completed, standard call to
         * <drawLayers> method.
         * 
         * @note    <clear> call to get rid of any previously drawn objects
         * @access  public
         * @return  void
         */
        draw: function() {
            this.once({
                'draw': function(event) {
                    this.render();
                }
            });
            this._cotton.clear();
            var layer = this.getBackgroundBitmapImageLayer(),
                key = layer.getProperty('image');
            if (key === false) {
                this.drawLayers();
            } else {
                this._syncBackgroundBitmapImage(this.drawLayers.proxy(this));
            }
        },

        /**
         * export
         * 
         * @access  public
         * @param   false|String contentType
         * @param   Boolean scaleForRetina
         * @return  Boolean
         */
        export: function(contentType, scaleForRetina) {
            if (contentType === false) {
                contentType = this._getExportContentType();
            }

            // Numbers based on device pixel ratio and retina desire
            var multiplier = 0.5;
            if (scaleForRetina === true) {
                multiplier = 1;
            }

            // Export
            multiplier = this._getDevicePixelRatioAdjustedMultiplier(multiplier);
            window.exportingMultiplier = multiplier;
            this.time('export');
            var options = this._getExportOptions(contentType, multiplier),
                dataURL = this._cotton.toDataURL(options);
            delete window.exportingMultiplier;

            // Multiplier adjustments weren't required
            if (this._dimensionsMatch() === true) {
                this._log('1');
                this.time('export');
                this.triggerHandler('export', [dataURL, contentType]);
                return true;
            }

            // Multipler was modified but the dimensions are not larger
            if (scaleForRetina === true) {
                if (this._calculatedDimensionsExceedFrameDimensions(options) === false) {
                    this._log('2');
                    this._log(options);
                    this.time('export');
                    // this._track('modified multiplier');
                    this.triggerHandler('export', [dataURL, contentType]);
                    return true;
                }
            }

            // Precaution for now
            this._checkForMatchingDimensions(dataURL);

            // Dimensions are off; crop that shit yo
            this._log('3');
            this._log(options);
            this._log('exceeds');
            // this._track('dimensions adjusted');
            this._cropDataURL(scaleForRetina, contentType, dataURL, function(dataURL) {
                this.time('export');
                this.triggerHandler('export', [dataURL, contentType]);
            });
            return true;
        }
    });
});
window.DependencyLoader.push('CanvasView', function() {

    /**
     * PreviewCanvasView
     * 
     * @extends CanvasView
     */
    window.PreviewCanvasView = CanvasView.extend({

        /**
         * _events
         * 
         * Behinds a number of events to the app. This works a bit differently
         * than other views, in that events are sometimes bound to other view
         * elements, as well as elements that aren't selected via the
         * traditional <find> method.
         * 
         * @access  protected
         * @var     Function
         */
        _events: function() {
            return {

                /**
                 * center.snap
                 * 
                 * @access  protected
                 * @return  void
                 */
                'center.snap': function() {
                    var $app = App.getElement();
                    this._cotton.on({
                        'mouse:up': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        },
                        'object:moving': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        },
                        'object:modified': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        }
                    });
                },

                /**
                 * body.click
                 * 
                 * @access  protected
                 * @return  void
                 */
                'body.click': function() {
                    var _this = this;
                    App.getElement().on({
                        'mousedown': function(event) {
                            _this._handleBodyMouseDownEvent(event);
                        }
                    });
                },

                /**
                 * canvas.click
                 * 
                 * @access  protected
                 * @return  void
                 */
                'canvas.click': function() {
                    var _this = this;
                    this._cotton.on({
                        'mouse:down': function(event) {
                            _this._handleCanvasClickEvent(event);
                        }
                    });
                },

                /**
                 * canvas.dblclick
                 * 
                 * Allows for double-click insertion of an empty text layer.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'canvas.dblclick': function() {
                    var _this = this;
                    App.find('canvas#preview').parent().on({
                        'dblclick': function(event) {
                            _this._handleCanvasDoubleClickEvent(event);
                        }
                    });
                },

                /**
                 * canvas.rclick
                 * 
                 * @access  protected
                 * @return  void
                 */
                'canvas.rclick': function() {
                    var _this = this;
                    App.find('canvas#preview').parent().on({
                        'contextmenu': function(event) {
                            _this._handleCanvasRightClickEvent(event);
                        }
                    });
                },

                /**
                 * canvas.hover
                 * 
                 * @access  protected
                 * @return  void
                 */
                // 'canvas.hover': function() {
//                     var _this = this;
// LogUtils.log.simple(App.find('canvas#preview').siblings('canvas'), true);
//                     App.find('canvas#preview').siblings('canvas').on({
//                         'hover': function(event) {
//                             var layers = this._imageDocument.filter(function(index, layer) {
//                                 return layer.getStyle('order').toInt() >= 2;
//                             });
//                             LogUtils.log.simple(layers, true);
//                         }
//                     });
                // },

                /**
                 * canvas.render
                 * 
                 * Method to throttle requests to Footer.reset whenever the
                 * canvas is updated. Nice central place to do this.
                 * 
                 * @access  protected
                 * @return  void
                 */
                // 'canvas.render': function() {
                    // var callback = Footer.reset.proxy(Footer);
                    // this._cotton.on({
                    //     'after:render': _.throttle(callback, 75)
                    // });
                // },

                /**
                 * key.center
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.center': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleCenterKeyEvent(event);
                        }
                    });
                },

                /**
                 * key.delete
                 * 
                 * Allows for delete-key deletion.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.delete': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleDeleteKeysEvent(event);
                        }
                    });
                },

                /**
                 * key.directional
                 * 
                 * Allows for directional-key-based positioning. Directional
                 * keys in this case are the up, down, right and left keys.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.directional': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleDirectionalKeysEvent(event);
                        }
                    });
                },

                /**
                 * key.enter
                 * 
                 * Allows for enter-key-based text editing.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.enter': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleEnterKeyEvent(event);
                        }
                    });
                },

                /**
                 * key.escape
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.escape': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleEscapeKeyEvent(event);
                        }
                    });
                },

                /**
                 * key.tab
                 * 
                 * Allows for tabbing and shift-tabbing between layers.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.tab': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleTabKeysEvent(event);
                        }
                    });
                }
            };
        },

        /**
         * _fabricGuides
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _fabricGuides: {},

        /**
         * _facebookAdGrid
         * 
         * @access  protected
         * @var     Object (default: [])
         */
        // _facebookAdGrid: [],

        /**
         * _htmlGuides
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _htmlGuides: {},

        /**
         * _max
         * 
         * Object that has the maximum size of the canvas defined. There are
         * three possible hashes. <absolute> defines the maximum across browser
         * resolutions, <viewport> defines the maximum values according to the
         * space within the canvas container (after instantiation). Defined
         * defines what should be actually used during canvas drawing/resizing.
         * 
         * This will be defined by:
         * - Math.min(absolute.height, viewport.height)
         * - Math.min(absolute.width, viewport.width)
         * 
         * @access  protected
         * @var     Object
         */
        _max: {
            absolute: {
                // height: 600,
                // width: 600
                height: 900,
                width: 900
            },
            defined: {
                height: false,
                width: false
            },
            viewport: {
                height: false,
                width: false
            }
        },

        /**
         * _positionMap
         * 
         * Tracks the position of background images, within the context of a
         * Frame, so that if a user sets a position in, for example, a Pinterest
         * Frame, switches to a Facebook one, sets the background image position
         * relative to that Frame, and then switches back, it remembers where
         * the background image was (manully, purposefully) set for the
         * Pinterest one.
         * 
         * Without this, it can feel disjointed when you position your
         * background image, switch to a frame and think "Ahh, I don't want this
         * one", switch back, and now your background image isn't set to where
         * it was before.
         * 
         * An exception here is if the user loads the app, sees a background
         * image in a specific place, switches to a different Frame before
         * adjusting the position of the background image at all, adjusts the
         * background image in that new Frame, and then switches back to the
         * first one, the background image will be adjusted relative to the
         * positioning data for the second Frame. This is because this hash
         * won't contain any data on the initial Frame, since the user didn't
         * interact with it.
         * 
         * I could update this to ensure this data is present as soon as an
         * image is set as a background image on a Frame, but not sure if that's
         * needed.
         * 
         * Frame positioning works in such a way that it'll always try to
         * best-guess the position of a background image relative to a frame
         * since the position coordinates (left/top) are relative numbers.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _positionMap: {},

        /**
         * _previouslySelectedLayer
         * 
         * Tracks the previously selected layer, for usage with font preview
         * closing.
         * 
         * @access  protected
         * @var     false|Layer (default: false)
         */
        _previouslySelectedLayer: false,

        /**
         * _selectedLayer
         * 
         * @access  protected
         * @var     Layer (default: false)
         */
        _selectedLayer: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PreviewCanvasView')
         */
        _string: 'PreviewCanvasView',

        /**
         * init
         * 
         * @see     http://alvarotrigo.com/blog/firing-resize-event-only-once-when-resizing-is-finished/
         * @note    Order here is very important
         * @todo    Don't run a refresh if the canvas size hasn't actually
         *          changed. Waste of resources.
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCotton();
            window.Canvases.Preview = this;
            this._setupFabricGuides();
            // this._setupHtmlGuides();
            this._setMaximumsDimensions();
            this._setupAuth();
            this._setupEvents();
            // this._listenForLockedChange();
        },

        /**
         * _handleBodyMouseDownEvent
         * 
         * Listeners for mousedown events to allow the selected layer to be
         * blurred, so long as anything other than the text toolbar is clicked.
         * When the text toolbar is clicked, simply force the selected layer out
         * of editing mode.
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleBodyMouseDownEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Layer deselection is off
            if (Stencil.get('ignoreMouseDownLayerBlur') === true) {
                return false;
            }

            // TextToolbarView (exit editing mode, but keep layer selected)
            var $target = $(event.target);
            if ($target.parents('.toolbar.text').length === 1) {
                var drawing = layer.getDrawing(),
                    cotton = drawing.getCotton();
                if (cotton.isEditing === false) {
                    return false;
                }
                cotton.exitEditing();
                drawing.select();
                return true;
            }

            // ToolbarView
            if ($target.parents('.toolbar').length === 1) {
                return false;
            }

            // Canvas clicked
            if ($target.tag() === 'canvas') {
                return false;
            }

            // Let's do this
            canvas.deselectSelectedLayer();
            return true;
        },

        /**
         * _handleCanvasClickEvent
         * 
         * Ensures the selected layer is blurred when the canvas is clicked on,
         * and another fabric object is focused, or simply the canvas itself is
         * focused on. The key here being that the selected object's fabric
         * object is _not_ the target event that's clicked on.
         * 
         * At the moment, the only time I could find whereby the deselect code
         * is run is where a TextDrawing has a backdrop specified, set to
         * "Full width", and then clicking between the
         * BackgroundRectangleDrawing and the backdrop itself causes the below
         * code to be successfully executed.
         * 
         * I believe this is because in almost all cases, clicking on a canvas
         * cotton object results in that layer being "activated", which then
         * already takes care of deselecting the selected layer.
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleCanvasClickEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // The target click on and the drawing are the same
            var drawing = layer.getDrawing();
            if (event.target === drawing.getCotton()) {
                return false;
            }

            // Let's do this!
            this.deselectSelectedLayer();
            return true;
        },

        /**
         * _handleCanvasDoubleClickEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleCanvasDoubleClickEvent: function(event) {

            // busy modal is visible
            var $target = $(event.target);
            if ($target.parent('.busy.modal').length > 0) {
                return false;
            }

            // Valid layers for inserting a TextLayer
            var canvas = Canvases.Preview,
                selected = canvas.getSelectedLayer(),
                validLayerTypes = [
                    'BackgroundRectangleLayer',
                    'BackgroundBitmapImageLayer',
                    'ForegroundBitmapImageLayer'
                ];

            // No layer, or valid layer for text insertion
            if (
                selected === false
                || ArrayUtils.contains(selected.toString(), validLayerTypes) === true
            ) {
                // Position of click
                var cotton = canvas.getCotton(),
                    options = {
                        left: ((event.offsetX / cotton.getWidth()) * 100).round(4),
                        top: ((event.offsetY / cotton.getHeight()) * 100).round(4)
                    };

                // Add layer
                var layer = canvas.addTextLayer(options),
                    drawing = layer.getDrawing();
                layer.setChangeOperationType('added');
                drawing.once({
                    'draw': function(event) {
                        var cotton = this._cotton;
                        this.select();
                        drawing.animate();
                        // cotton.enterEditing();
                        // cotton.selectAll();
                    }
                });
                drawing.draw();
            }

            // 
            return true;
        },

        /**
         * _handleCanvasRightClickEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleCanvasRightClickEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Not a TextLayer layer
            var drawing = layer.getDrawing();
            if (drawing.toString() !== 'TextDrawing') {
                return false;
            }

            // Show alert
            Stencil.set('ignoreMouseDownLayerBlur', true);
            Stencil.alert('canvas.text.rclick');
            setTimeout(function() {
                drawing.getCotton().exitEditing();
                drawing.select();
            }, 100);
            ModalUtils.get('Alert').once({
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                    setTimeout(function() {
                        drawing.select();
                        drawing.getCotton().enterEditing();
                        drawing.getCotton().selectAll();
                    }, 0);
                }
            });
            return true;
        },

        /**
         * _handleCenterKeyEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleCenterKeyEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Wrong key
            if (event.which !== 67) {
                return false;
            }

            // Modal(s) open
            if (ModalUtils.getOpen().length > 0) {
                return false;
            }

            // $target is a text-input
            var $target = $(event.target);
            if ($target.tag() === 'input' && $target.attr('type') === 'text') {
                return false;
            }

            // Layer filtering
            var layerType = layer.toString();
            if (layerType === 'BackgroundBitmapImageLayer') {
                return false;
            }
            if (layerType === 'BackgroundRectangleLayer') {
                return false;
            }

            // EyeDropper is open
            var eyeDropper = App.getStage().getContent().getEyeDropper();
            if (eyeDropper.enabled() === true) {
                return false;
            }

            // TextLayer
            if (layerType === 'TextLayer') {
                var cotton = layer.getCotton();
                if (cotton.isEditing === false) {
                    layer.autoAlign();
                    return true;
                }
                return false;
            }

            // Align
            layer.autoAlign();
            return true;
        },

        /**
         * _handleDeleteKeysEvent
         * 
         * Checks whether a correct keyCode was detected, a layer is currently
         * selected, and the user is currently not focused on a text input
         * (since if they are, they may intend to delete a hex code value,
         * rather than the layer).
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleDeleteKeysEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Wrong key
            if (event.which !== 8 && event.which !== 46) {
                return false;
            }

            // Modal(s) open
            if (ModalUtils.getOpen().length > 0) {
                return false;
            }

            // $target is a text-input
            var $target = $(event.target);
            if ($target.tag() === 'input' && $target.attr('type') === 'text') {
                return false;
            }

            /**
             * BackgroundBitmapImageLayer
             * 
             * @note    The ChangeHistory.clearOperationType() below is used to
             *          account for the case where a user is dragging the
             *          BackgroundBitmapImageLayer around and while doing so,
             *          hits the delete key.
             */
            if (layer.toString() === 'BackgroundBitmapImageLayer') {
                event.preventDefault();
                ChangeHistory.clearOperationType();
                layer.setChangeOperationType('deleted');
                canvas.clearBackgroundImageLayer();
                canvas.render();
                canvas.getBackgroundRectangleLayer().select();
                return true;
            }

            /**
             * BackgroundRectangleLayer
             * 
             * It's important that color values are formatted exactly as they
             * below (including spaces), because the rest of the platform
             * formats things this way, and if the formatting is different, it
             * can cause issues with the ChangeHistory system (since it might
             * think something is different in the image, even if it's just
             * formatting).
             */
            if (layer.toString() === 'BackgroundRectangleLayer') {
                event.preventDefault();
                var backgroundColor = layer.getStyle('backgroundColor'),
                    white = ColorUtils.getWhite('rgba');
                backgroundColor = ColorUtils.addSpaces(backgroundColor);

                // Background color is white; set to full transparency
                if (backgroundColor === white) {
                    Toolbars.getToolbar('backgroundRectangle').triggerHandler('clear/backgroundColor');
                    return true;
                }

                // Set to white
                Canvases.Preview.getSelectedLayer().triggerHandler(
                    'change/backgroundColor',
                    [white, true]
                );
                Toolbars.getToolbar('backgroundRectangle').show();
                return true
            }

            /**
             * TextLayer
             * 
             * There was a bug whereby if the user highlighted text by dragging,
             * and their mouse ended up outside the canvas, clicking delete
             * would delete the whole text field. I account for this by checking
             * if the fabric object is currently being edited, and if, return
             * false.
             */
            if (layer.toString() === 'TextLayer') {
                var drawing = layer.getDrawing();
                if (drawing.getCotton().isEditing === true) {
                    return false;
                }
            }

            /**
             * Watermark layers
             * 
             */
            if (layer.getProperty('watermark') === true) {
                var watermark = layer.getWatermark();
                watermark.set({
                    'settings.active': 0
                });
                watermark.save([
                    'settings.active'
                ]);
            }

            // Let's do this
            event.preventDefault();
            layer.triggerHandler('delete', [
                {
                    trigger: 'key.delete'
                }
            ]);
            return true;
        },

        /**
         * _handleDirectionalKeysEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleDirectionalKeysEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Modal(s) open
            if (ModalUtils.getOpen().length > 0) {
                return false;
            }

            // Wrong layer type
            if (layer.toString() === 'BackgroundBitmapImageLayer') {
                return false;
            }
            if (layer.toString() === 'BackgroundRectangleLayer') {
                return false;
            }

            // EyeDropper is open
            var eyeDropper = App.getStage().getContent().getEyeDropper();
            if (eyeDropper.enabled() === true) {
                return false;
            }

            // $target is a text-input
            var $target = $(event.target);
            if ($target.tag() === 'input' && $target.attr('type') === 'text') {
                return false;
            }

            // Left
            if (event.which === 37) {
                event.preventDefault();
                layer.triggerHandler('move/left');
                // layer.getDrawing().getCotton().trigger('lock');
                return true;
            }

            // Up
            if (event.which === 38) {
                event.preventDefault();
                layer.triggerHandler('move/up');
                // layer.getDrawing().getCotton().trigger('lock');
                return true;
            }

            // Right
            if (event.which === 39) {
                event.preventDefault();
                layer.triggerHandler('move/right');
                // layer.getDrawing().getCotton().trigger('lock');
                return true;
            }

            // Down
            if (event.which === 40) {
                event.preventDefault();
                layer.triggerHandler('move/down');
                // layer.getDrawing().getCotton().trigger('lock');
                return true;
            }

            // Whoops
            return false;
        },

        /**
         * _handleEnterKeyEvent
         * 
         * @note    Checking for a modal open, since in a modal, hitting enter
         *          ought to submit for the form; not possibly focus on a text
         *          layer.
         * @see     https://i.imgur.com/wEll3Ab.png
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleEnterKeyEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Wrong key
            if (event.which !== 13) {
                return false;
            }

            // Modal(s) open
            if (ModalUtils.getOpen().length > 0) {
                return false;
            }

            // $target is a text-input
            var $target = $(event.target);
            if ($target.tag() === 'input' && $target.attr('type') === 'text') {
                return false;
            }

            // TextDrawing is selected
            var drawing = layer.getDrawing();
            if (drawing.toString() === 'TextDrawing') {

                // Editing
                if (layer.getCotton().isEditing === true) {
                    return false;
                }

                // Made it!
                event.preventDefault();
                var cotton = layer.getCotton();
                layer.select();
                canvas.render();
                cotton.enterEditing();
                cotton.selectAll();
                return true;
            }

            // BackgroundRectangleDrawing is selected
            if (drawing.toString() === 'BackgroundRectangleDrawing') {

                // Made it!
                event.preventDefault();
                var layer = canvas.addTextLayer(),
                    drawing = layer.getDrawing();
                layer.setChangeOperationType('added');
                drawing.once({
                    'draw': function(event) {
                        this.select();
                        drawing.animate();
                    }
                });
                drawing.draw();
                return true;
            }

            // 
            return false;
        },

        /**
         * _handleEscapeKeyEvent
         * 
         * Allows for escape-key blurring of layer. Requires the following:
         * - Escape key pressed (code: 27)
         * - Layer selected
         * - Layer not in editing mode (incase text)
         * - Target element when key pressed down is not an <input> element,
         *   or it's got a type of "range" or "checkbox"
         * - Dropdown menu for fonts not open (since escape key here is more
         *   important from a UX perspective).
         * - Modal not open
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleEscapeKeyEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Wrong key
            if (event.which !== 27) {
                return false;
            }

            // Modal(s) open
            if (ModalUtils.getOpen().length > 0) {
                return false;
            }

            // Color picker is open
            if (Toolbars.getVisibleToolbar().colorPickerVisible() === true) {
                return false;
            }

            // $target is a text-input
            var $target = $(event.target);
            if ($target.tag() === 'input' && $target.attr('type') === 'text') {
                return false;
            }

            // Fonts dropdown is open
            if (Toolbars.getToolbar('text').getFontsDropdown().getElement().hasClass('open') === true) {
                return false;
            }

            // TextDrawing is selected
            var drawing = layer.getDrawing();
            if (drawing.toString() === 'TextDrawing') {

                /**
                 * This is a fix to a fabric bug, whereby if the user started
                 * editing a text drawing, highlighted some text, but during
                 * that highlight process their mouse left the canvas, clicking
                 * the escape key would not do anything. I believe the issue
                 * exists because fabric is listening for events in the canvas,
                 * which can't be accessed in this case because the event is
                 * happening elsewhere (the html element outside of the canvas).
                 * So to deal with this, I just ensure the layer exits editing
                 * mode.
                 */
                var cotton = layer.getCotton();
                if (cotton.isEditing === true) {
                    cotton.exitEditing();
                    drawing.select();
                    return false;
                }
            }

            // Made it!
            event.preventDefault();
            canvas.deselectSelectedLayer();
            return true;
        },

        /**
         * _handleTabKeysEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _handleTabKeysEvent: function(event) {
            if (this._validTabEvent(event) === false) {
                return false;
            }
            var layer = Canvases.Preview.getSelectedLayer();
            event.preventDefault();
            if (event.shiftKey === true) {
                layer.goto.previous.apply(layer);
            } else {
                layer.goto.next.apply(layer);
            }
            return true;
        },

        /**
         *_listenForLockedChange
         * 
         * @access  protected
         * @return  void
         */
       // _listenForLockedChange: function() {
       //      Stencil.account().draft().on({
       //          'change/settings.locked': function(event, value) {
       //              var $lock = App.getStage().getContent().find('div.sandbox a.lock');
       //              $lock.addClass('hidden');
       //              if (value.toInt() === 1) {
       //                  $lock.removeClass('hidden');
       //              }
       //          }
       //      });
       //  },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            var unlockLayers = function() {
                var lockedLayers = Stencil.account().draft().getImageDocument().getLockedLayers();
                if (lockedLayers.length > 0) {
                    jQuery.each(lockedLayers, function(index, layer) {
                        layer.setProperty('locked', false);
                    });
                }
                ChangeHistory.syncLockedOperations();
            };
            User.once({
                'login': function(event, user) {
                    if (
                        User.admin() === true
                        || User.editor() === true
                        || Account.upgraded() === true
                    ) {
                        unlockLayers();
                    }
                }
            });
            Account.once({
                'upgrade': unlockLayers
            });
        },

        /**
         *_setupEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupEvents: function() {
            var _this = this;
            this._events = this._events();
            jQuery.each(
                this._events,
                function(type, event) {
                    event.apply(_this);
                }
            );
        },

        /**
         * _setupCotton
         * 
         * @access  protected
         * @return  void
         */
        _setupCotton: function() {
            this._super();
            this._element.parent().addClass('preview-canvas-container');
        },

        /**
         * _setupFabricGuides
         * 
         * @access  protected
         * @return  void
         */
        _setupFabricGuides: function() {
            var options = {
                    visible: false,
                    strokeDashArray: [5, 5],
                    // stroke: '#aaa',
                    stroke: ColorUtils.getBlack('rgba', 0.65),
                    selectable: false,
                    strokeWidth: 1
                },
                horizontal = [
                    new fabric.Line([0, 0, 0, 0], options),
                    new fabric.Line([0, 0, 0, 0], options)
                ],
                vertical = [
                    new fabric.Line([0, 0, 0, 0], options),
                    new fabric.Line([0, 0, 0, 0], options)
                ];
            this._cotton.add(horizontal[0]);
            this._cotton.add(horizontal[1]);
            this._cotton.add(vertical[0]);
            this._cotton.add(vertical[1]);

            // Backgrounds
            options.stroke = ColorUtils.getWhite('rgba', 0.65);
            options.strokeDashArray = false;
            var backdrop = [
                new fabric.Line([0, 0, 0, 0], options),
                new fabric.Line([0, 0, 0, 0], options)
            ];
            horizontal[0].backdrop = backdrop[0];
            horizontal[1].backdrop = backdrop[1];
            this._cotton.add(backdrop[0]);
            this._cotton.add(backdrop[1]);
            backdrop = [
                new fabric.Line([0, 0, 0, 0], options),
                new fabric.Line([0, 0, 0, 0], options)
            ];
            vertical[0].backdrop = backdrop[0];
            vertical[1].backdrop = backdrop[1];
            this._cotton.add(backdrop[0]);
            this._cotton.add(backdrop[1]);

            // 
            this._fabricGuides.vertical = vertical;
            this._fabricGuides.horizontal = horizontal;

            // 
            this._cotton.on({
                'mouse:move': function(options) {
                    vertical[0].set('visible', false);
                    vertical[1].set('visible', false);
                    vertical[0].backdrop.set('visible', false);
                    vertical[1].backdrop.set('visible', false);
                    horizontal[0].set('visible', false);
                    horizontal[1].set('visible', false);
                    horizontal[0].backdrop.set('visible', false);
                    horizontal[1].backdrop.set('visible', false);
                }
            });
        },

        /**
         * _setupHtmlGuides
         * 
         * @access  protected
         * @return  void
         */
        _setupHtmlGuides: function() {
            var $app = App.getElement();
            this._cotton.on({
                'object:moving': function(options) {
                    var $guides = $app.find('div.guides');
                    $guides.find('div.guide').addClass('hidden');
                }
            });
        },

        /**
         * _setMaximumsDimensions
         * 
         * This method sets the maximum possible width and height that a canvas
         * can be set to. Values are set to be the lowest between the viewport
         * (set to a maximum of 70% of available space) and an absolute defined
         * Stencil-wide.
         * 
         * @access  protected
         * @return  void
         */
        _setMaximumsDimensions: function() {
            var $content = App.find('section.stage > div.inner > div.content'),
                $outer = $content.find('> div.outer'),
                height,
                width;
            $outer.addClass('hidden');
            height = $content.height();
            width = $content.width();
            $outer.removeClass('hidden');
            this._max.viewport = {
                // height: Math.floor(height * 0.7),
                height: Math.floor(height * 0.75),
                // width: Math.floor(width * 0.7)
                width: Math.floor(width * 0.85)
            };
            this._max.defined.height = Math.min(
                this._max.absolute.height,
                this._max.viewport.height
            );
            this._max.defined.width = Math.min(
                this._max.absolute.width,
                this._max.viewport.width
            );
        },

        /**
         * _resizeCanvas
         * 
         * @access  protected
         * @return  void
         */
        _resizeCanvas: function() {

            // Get maximum dimension allowed
            var max = this._max.defined,
                ratio = Frame.getRatio(),
                width, height;

            // Square: just set to the lowest of the max width/height
            if (ratio === 1) {
                width = height = Math.min(max.height, max.width);
            } else {

                // Wide rectangle
                var scale;
                if (ratio > 1) {

                    // Frame width is smaller than max allowed
                    if (Frame.get('width').toInt() < max.width) {
                        width = Frame.get('width').toInt();
                        height = Frame.get('height').toInt();

                        // Frame height is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                    // Frame width is larger than max allowed
                    else {
                        width = max.width;
                        scale = Frame.get('width').toInt() / width;
                        height = Frame.get('height').toInt() / scale;

                        // Converted/relative height is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                }
                // Tall rectangle
                else {

                    // Frame height is smaller than max allowed
                    if (Frame.get('height').toInt() < max.height) {
                        width = Frame.get('width').toInt();
                        height = Frame.get('height').toInt();

                        // Frame width is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                    // Frame height is larger than max allowed
                    else {
                        height = max.height;
                        scale = Frame.get('height').toInt() / height;
                        width = Frame.get('width').toInt() / scale;

                        // Converted/relative widht is larger than max allowed
                        if (width > max.width) {
                            width = max.width;
                            scale = Frame.get('width').toInt() / width;
                            height = Frame.get('height').toInt() / scale;
                        }
                    }
                }
            }

            // Resize to maximum allowed
            this._cotton.resizeTo(width.ceil(), height.ceil());
        },

        /**
         * _validTabEvent
         * 
         * @note    Checking for a modal open, since in a modal, tabbing
         *          ought to toggle between inputs; not any possibly
         *          selected layer. Use case for this:
         *          https://i.imgur.com/oO3imXE.png
         * @note    It looks like keyCode may not always be available; when I
         *          used toInt on it, I got a report via Sentry within
         *          30-minutes that keyCode may be undefined. So don't use that
         *          method.
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _validTabEvent: function(event) {

            // No layer selected
            var canvas = Canvases.Preview,
                layer = canvas.getSelectedLayer();
            if (layer === false) {
                return false;
            }

            // Wrong key
            if (event.which !== 9) {
                return false;
            }

            // Modal(s) open
            if (ModalUtils.getOpen().length > 0) {
                return false;
            }

            // Made it!
            var $target = $(event.target);
            if ($target.parents('.toolbar').length > 0) {
                var $inputs = Toolbars.getVisibleToolbar().find('input[type="text"]');
                if ($inputs.length > 1) {
                    if (event.shiftKey === false) {
                        var $last = $inputs.last();
                        if ($target.is($last) === false) {
                            return false;
                        }
                    } else {
                        var $first = $inputs.first();
                        if ($target.is($first) === false) {
                            return false;
                        }
                    }
                }
            }
            return true;
        },

        /**
         * addTextLayer
         * 
         * @access  public
         * @param   undefined|Object options (default: {})
         * @return  TextLayer
         */
        addTextLayer: function(options) {
            options = DataUtils.getDefaultValue(options, {});
            var imageDocument = this._image.getImageDocument(),
                properties = {
                    locked: false,
                    styles: {
                        align: options.align || 'center',
                        angle: 0,
                        // backdropColor: '#00ff00',
                        backdropColor: false,
                        backdropPaddingFactor: Config.default('backdropPaddingFactor'),
                        backdropStretch: 'slim',
                        bold: false,
                        fontFamily: options.fontFamily || Stencil.account().getDefaultFontFamily(),
                        fontSize: options.fontSize || 50,
                        italic: false,
                        left: options.left || 50,
                        lineHeight: 1.1,
                        shadowStrength: 0,
                        strokeColor: false,
                        strokeWidthDividingFactor: Config.default('strokeWidthDividingFactor'),
                        // textColor: 'rgba(69, 69, 69, 1)',// #454545
                        textColor: ColorUtils.getBlack('rgba'),// #000000
                        top: options.top || 50,
                        underline: false,
                        width: options.width || 30
                    },
                    // text: 'I repeat. We are out of Bort license plates!',
                    text: options.text || 'Text',
                    type: 'text'
                },
                textLayers = imageDocument.getTextLayers(),
                layer;
            properties.styles.order = imageDocument.getOrderedLayers(false).length;

            // Inheritance
            if (textLayers.length > 0) {
                var index = textLayers.length - 1;
                if (options.align === undefined) {
                    properties.styles.align = textLayers[index].getStyle('align');
                }
                properties.styles.bold = textLayers[index].getStyle('bold');
                if (options.align === undefined) {
                    properties.styles.fontFamily = textLayers[index].getStyle('fontFamily');
                }
                if (options.fontSize === undefined) {
                    properties.styles.fontSize = textLayers[index].getStyle('fontSize');
                }
                properties.styles.italic = textLayers[index].getStyle('italic');
                properties.styles.lineHeight = textLayers[index].getStyle('lineHeight');
                properties.styles.textColor = textLayers[index].getStyle('textColor');
            }

            // Create and run overhead
            layer = new TextLayer(properties, imageDocument);
            imageDocument.addLayer(layer);
            imageDocument.reorderWatermarks();
            // layer.getDrawing().draw();
            return layer;
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @access  public
         * @param   Object options
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(options) {
            var imageDocument = this._image.getImageDocument(),
                properties = {
                    cropPositionData: options.cropPositionData || {},
                    cropSourceKey: options.cropSourceKey || '',
                    filters: [],
                    image: options.image,
                    locked: options.locked === undefined ? false : options.locked,
                    styles: {
                        angle: 0,
                        flipX: false,
                        flipY: false,
                        left: options.left || 50,
                        stretchX: 1,
                        stretchY: 1,
                        top: options.top || 50,
                        width: 30
                    },
                    type: 'image'
                },
                layer;
            properties.styles.order = imageDocument.getOrderedLayers(false).length;
            layer = new ForegroundBitmapImageLayer(properties, imageDocument);
            imageDocument.addLayer(layer);
            imageDocument.reorderWatermarks();
            return layer;
        },

        /**
         * addVectorImageLayer
         * 
         * Sets the color of the added vector to either the default, or else if
         * a vector has already been drawn to the canvas, grabs that color
         * (which makes a large assumption).
         * 
         * @access  public
         * @param   Object options
         * @param   Boolean color
         * @return  VectorImageLayer
         */
        addVectorImageLayer: function(options, color) {
            var imageDocument = this._image.getImageDocument(),
                properties = {
                    color: color === true,
                    filters: [],
                    image: options.image,
                    locked: options.locked === undefined ? false : options.locked,
                    styles: {
                        angle: 0,
                        // fillColor: ColorUtils.getBlack('rgba'),
                        // fillColor: ColorUtils.getBlack('rgba', 0),
                        // fillColor: 'rgba(255, 0, 0, 1)',
                        flipX: false,
                        flipY: false,
                        left: options.left || 50,
                        stretchX: 1,
                        stretchY: 1,
                        top: options.top || 50,
                        width: 15
                    },
                    type: 'image',
                    vector: true
                },
                layer;
            if (color === false) {
                properties.styles.fillColor = ColorUtils.getBlack('rgba');
            } else {
                properties.styles.opacity = 1;
            }
            properties.styles.order = imageDocument.getOrderedLayers(false).length;

            // Inheritance
            if (color === false) {
                var bWVectorImageLayers = imageDocument.getBwVectorImageLayers();
                if (bWVectorImageLayers.length > 0) {
                    var index = bWVectorImageLayers.length - 1;
                    properties.styles.fillColor = bWVectorImageLayers[index].getStyle('fillColor');
                }
            }

            // Overhead
            if (color === false) {
                layer = new VectorImageLayer(properties, imageDocument);
            } else {
                layer = new ColorVectorImageLayer(properties, imageDocument);
            }
            imageDocument.addLayer(layer);
            imageDocument.reorderWatermarks();
            return layer;
        },

        /**
         * addWatermarkBitmapImageLayer
         * 
         * @access  public
         * @param   Object properties
         * @return  WatermarkBitmapImageLayer
         */
        addWatermarkBitmapImageLayer: function(properties) {
            var imageDocument = this._image.getImageDocument();
            properties.styles.order = imageDocument.getOrderedLayers().length;
            var layer = new WatermarkBitmapImageLayer(properties, imageDocument);
            imageDocument.addLayer(layer);
            imageDocument.reorderWatermarks();
            return layer;
        },

        /**
         * addWatermarkVectorImageLayer
         * 
         * @access  public
         * @param   Object properties
         * @return  WatermarkVectorImageLayer|WatermarkColorVectorImageLayer
         */
        addWatermarkVectorImageLayer: function(properties) {
            var imageDocument = this._image.getImageDocument();
            properties.styles.order = imageDocument.getOrderedLayers().length;
            properties.styles.opacity = 1;
            var klass = WatermarkVectorImageLayer;
            if (properties.color === true) {
                klass = WatermarkColorVectorImageLayer;
            }
            var layer = new klass(properties, imageDocument);
            imageDocument.addLayer(layer);
            imageDocument.reorderWatermarks();
            return layer;
        },

        /**
         * addWindowResizeListener
         * 
         * @access  public
         * @return  void
         */
        addWindowResizeListener: function() {
            var delay = Config.getResizeDelay('canvas'),
                callback = _.debounce(
                    this.resize.proxy(this),
                    delay
                );
            $(window).on({
                'resize': callback
            });
        },

        /**
         * addWindowOrientationChangeListener
         * 
         * Listener for orientation change needed to happen, because at times on
         * Adam's iPad, the resize function would not be triggered when he
         * changed his orientation. So to be safe, I trigger a resize on
         * orientation change as well.
         * 
         * Not sure if this will cause a problem since resize might be called
         * twice (especially since the debounce reference is different). Might
         * want to look into this, or else use a common debounce reference.
         * 
         * @todo    Look into the note above on possibly multiple calls to
         *          resize.
         * @access  public
         * @return  void
         */
        addWindowOrientationChangeListener: function() {
            var delay = Config.getResizeDelay('canvas'),
                callback = _.debounce(
                    this.resize.proxy(this),
                    delay
                );
            $(window).on({
                'orientationchange': callback
            });
        },

        /**
         * clear
         * 
         * Filter here is made against the position being greater than
         * or equal to two. This is because the first two layers are the
         * BackgroundRectangleLayer and BackgroundBitmapImageLayer.
         * 
         * Note that I need to perform a set + save against the sourceImageId
         * property, rather than a push, because a push does a checks
         * 
         * @access  public
         * @param   Boolean prompt
         * @param   undefined|String promptType
         * @return  void
         */
        clear: function(prompt, promptType) {

            /**
             * callback
             * 
             * @access  private
             * @param   Boolean clearWatermarks
             * @return  void
             */
            var callback = function(clearWatermarks) {
                var layers = this._image.getImageDocument().getOrderedLayers(
                    clearWatermarks === true
                );
                jQuery.each(layers, function(index, layer) {
                    layer.triggerHandler('delete');
                    if (layer.getProperty('watermark') === true) {
                        layer.getWatermark().push('settings.active', 0);
                    }
                });
                this.resetBackgroundRectangleLayer();
                this.clearBackgroundImageLayer();
                this.render();
                var draft = Stencil.account().draft();
                draft.removeSourceImage();
                // if (Account.draftIsLocked() === true) {
                //     draft.set({
                //         'settings.locked': 0
                //     });
                //     draft.save(['settings.locked']);
                // }
            };

            /**
             * 
             */
            if (prompt === true) {
                var _this = this;
                if (promptType === 'unsaved') {
                    this.unsavedChangesClearCanvasConfirm().on({
                        'yes': function(event) {
                            ChangeHistory.setOperationType('image // newImage:created');
                            callback.apply(_this, [this.clearWatermarks()]);
                        }
                    });
                } else {
                    this.clearCanvasConfirm().on({
                        'yes': function(event) {
                            ChangeHistory.setOperationType('image // cleared');
                            callback.apply(_this, [this.clearWatermarks()]);
                        }
                    });
                }
            } else {
                ChangeHistory.setOperationType('image // newImage:created');
                callback.apply(this, [false]);
            }
        },

        /**
         * clearCanvasConfirm
         * 
         * @access  public
         * @return  ConfirmModalView
         */
        clearCanvasConfirm: function() {
            var h1 = 'Clearing will remove all images and text.',
                h2 = 'Are you sure?',
                modal = ModalUtils.showClearCanvasConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * clearBackgroundImageLayer
         * 
         * @access  public
         * @return  void
         */
        clearBackgroundImageLayer: function() {
            var layer = this.getBackgroundBitmapImageLayer();
            layer.filters.clear.apply(layer);
            if (layer.getProperty('image') !== false) {
                layer.setImage(false);
                layer.setProperty('cropPositionData', {});
                layer.setProperty('cropSourceKey', '');
            }
        },

        /**
         * deselectSelectedLayer
         * 
         * @access  public
         * @return  void
         */
        deselectSelectedLayer: function() {
            var layer = this.getSelectedLayer();
            this._cotton.discardActiveObject();
            this.setSelectedLayer(false);
            Toolbars.hide();
            if (layer !== false) {
                var drawing = layer.getDrawing();
                drawing.bb.hide.apply(drawing);
            }
        },

        /**
         * draw
         * 
         * @access  public
         * @param   Boolean showBusyModal This variable was introduced to offer
         *          up the option of not showing the busy modal when the image
         *          being redrawn was being done so through a redo / undo action
         * @return  void
         */
        draw: function(showBusyModal) {
            var start = new Date(),
                imageDocument = this._image.getImageDocument();
            this.set({drawing: true});
            if (showBusyModal === true) {
                this.getBusy().show();
            }
            imageDocument.mergeWatermarks();
            imageDocument.setupLayers();
            imageDocument.sortLayers();
            this.once({
                'draw': function(event) {
                    this.render();
                },
                'render': function(event) {
                    this.set({drawing: false});
                    if (showBusyModal === true) {
                        var busy = this.getBusy();
                        busy.hide.minDelay(start, 500, busy);
                    }
                }
            });
            this.drawLayers();
        },

        /**
         * getActiveBackgroundLayer
         * 
         * Returns the active background layer. Note that the active background
         * may not actually be selected. For example, the user could have a
         * text layer selected (eg. the TextToolbar is open), but calling this
         * method will return the BackgroundRectangleLayer if no image is set
         * as the background, or else the BackgroundBitmapImageLayer.
         * 
         * @access  public
         * @return  BackgroundBitmapImageLayer|BackgroundRectangleLayer
         */
        getActiveBackgroundLayer: function() {
            var backgroundBitmapImageLayer = this.getBackgroundBitmapImageLayer();
            if (backgroundBitmapImageLayer.getProperty('image') !== false) {
                return backgroundBitmapImageLayer;
            }
            var backgroundRectangleLayer = this.getBackgroundRectangleLayer();
            return backgroundRectangleLayer;
        },

        /**
         * getBackgroundRectangleLayer
         * 
         * @access  public
         * @return  BackgroundRectangleLayer
         */
        getBackgroundRectangleLayer: function() {
            var image = this._image,
                imageDocument = image.getImageDocument(),
                backgroundRectangleLayer = imageDocument.getBackgroundRectangleLayer();
            return backgroundRectangleLayer;
        },

        /**
         * getBusy
         * 
         * @access  public
         * @return  BusyModalView
         */
        getBusy: function() {
            if (this._busy === false) {
                var $busy = DataUtils.render('BusyModal');
                this._busy = new BusyModalView($busy);
                this._element.parent('.canvas-container').append($busy);
            }
            return this._busy;
        },

        /**
         * getFabricGuides
         * 
         * @access  public
         * @return  Object
         */
        getFabricGuides: function() {
            var fabricGuides = this._fabricGuides;
            return fabricGuides;
        },

        /**
         * getForegroundBitmapImageLayers
         * 
         * @access  public
         * @return  Array
         */
        getForegroundBitmapImageLayers: function() {
            var imageDocument = this._image.getImageDocument(),
                foregroundBitmapImageLayers = imageDocument.getForegroundBitmapImageLayers();
            return foregroundBitmapImageLayers;
        },

        /**
         * getHtmlGuides
         * 
         * @access  public
         * @return  Object
         */
        getHtmlGuides: function() {
            var $app = App.getElement(),
                $guides = $app.find('div.guides');
            return $guides.find('div.guide');
        },

        /**
         * getImageDocument
         * 
         * @access  public
         * @return  ImageDocument
         */
        // getImageDocument: function() {
        //     return this._image.getImageDocument();
        // },

        /**
         * getPreviouslySelectedLayer
         * 
         * @access  public
         * @return  false|Layer
         */
        getPreviouslySelectedLayer: function() {
            var previouslySelectedLayer = this._previouslySelectedLayer;
            return previouslySelectedLayer;
        },

        /**
         * getSelectedLayer
         * 
         * @access  public
         * @return  false|Layer
         */
        getSelectedLayer: function() {
            var selectedLayer = this._selectedLayer;
            return selectedLayer;
        },

        /**
         * getWatermarkBitmapLayers
         * 
         * @access  public
         * @return  Array
         */
        getWatermarkBitmapLayers: function() {
            var image = this._image,
                imageDocument = image.getImageDocument(),
                watermarkBitmapLayers = imageDocument.getWatermarkBitmapLayers();
            return watermarkBitmapLayers;
        },

        /**
         * getWatermarkLayers
         * 
         * @access  public
         * @return  Array
         */
        getWatermarkLayers: function() {
            var image = this._image,
                imageDocument = image.getImageDocument(),
                watermarkLayers = imageDocument.getWatermarkLayers();
            return watermarkLayers;
        },

        /**
         * refreshLayers
         * 
         * @note    A <drawn> check is made against the drawing to prevent trying
         *          to, for example, resize a vector image that hasn't yet been
         *          fully loaded. An example of when this might happen:
         *          You load the app, and while it's loading, resize your window.
         *          Since one of the vectors may have yet been drawn, it doesn't
         *          make sense to refresh it. If that happens, I wait for the
         *          drawn event on the layer before trying to refresh it again.
         * @access  public
         * @return  void
         */
        refreshLayers: function() {
            this._resizeCanvas();
            var _this = this,
                drawing,
                layer,
                layers = this._image.getImageDocument().getLayers(true),
                length = layers.length,
                next = function(index) {
                    layer = layers[index];
                    drawing = layer.getDrawing();
                    if (drawing.drawn() === true) {
                        drawing.once({
                            'refresh': function(event) {
                                if (index !== length - 1) {
                                    next(index + 1);
                                } else {
                                    _this.triggerHandler('refresh');
                                }
                            }
                        });
                        drawing.refresh();
                    } else {
                        drawing.once({
                            'draw': function(event) {
                                next(index);
                            }
                        });
                    }
                };
            next(0);
        },

        /**
         * resetBackgroundRectangleLayer
         * 
         * @access  public
         * @return  void
         */
        resetBackgroundRectangleLayer: function() {
            var layer = this.getBackgroundRectangleLayer();
            layer.triggerHandler('reset/backgroundColor');
        },

        // /**
        //  * setBackgroundBitmapImage
        //  * 
        //  * @access  public
        //  * @param   String resource
        //  * @return  BackgroundBitmapImageLayer
        //  */
        // setBackgroundBitmapImage: function(resource) {
        //     options = options || {};
        //     var properties = {
        //             background: true,
        //             resource: options.resource,
        //             styles: {
        //                 left: options.left || 50,
        //                 top: options.top || 50,
        //                 position: 1,
        //                 visible: true
        //             },
        //             type: 'image'
        //         },
        //         layer;
        //     layer = new BackgroundBitmapImageLayer(properties, this._image.getImageDocument());
        //     this._image.getImageDocument().addLayer(layer);
        //     this._image.getImageDocument().reorderWatermarks();
        //     return layer;
        // },

        /**
         * resize
         * 
         * @access  public
         * @return  void
         */
        resize: function() {
            this._setMaximumsDimensions();
            this.deselectSelectedLayer();
            this.once({
                'refresh': function(event) {
                    this.render();
                }
            });
            this.refreshLayers();
        },

        /**
         * restoreFrameSpecificPosition
         * 
         * @access  public
         * @return  void
         */
        restoreFrameSpecificPosition: function() {
            var layer = this.getBackgroundBitmapImageLayer(),
                image = layer.getProperty('image'),
                key = Frame.get('key'),
                position;
            if (image !== false) {
                position = {
                    left: layer.getStyle('left'),
                    top: layer.getStyle('top')
                };
                if (typeof this._positionMap[image] !== 'undefined') {
                    if (typeof this._positionMap[image][key] !== 'undefined') {
                        position = this._positionMap[image][key];
                        layer.setStyles(position);
                        layer.triggerHandler('position/restored');
                    } else {
                        layer.setStyles(position);
                    }
                } else {
                    layer.setStyles(position);
                }
            }
        },

        /**
         * setSelectedLayer
         * 
         * Sets the passed in Layer as the the selected one in the canvas, which
         * is then used to determine which layer should be affected when events
         * happen (for example, key-nudging).
         * 
         * It's worth noting that I'm keeping track of the previously selected
         * layer, as it's being used the TextToolbar view. In that case, it's
         * used to determine which layer should have it's font-family reinstated
         * if the font dropdown is shown, and then the user clicks elsewhere on
         * the canvas (or on another layer).
         * 
         * @access  public
         * @param   false|Layer layer
         * @return  void
         */
        setSelectedLayer: function(layer) {
            this._previouslySelectedLayer = this._selectedLayer;
            this._selectedLayer = layer;
        },

        /**
         * trackBackgroundImageLayerPosition
         * 
         * @access  public
         * @return  void
         */
        trackBackgroundImageLayerPosition: function() {
            var layer = this.getBackgroundBitmapImageLayer(),
                image = layer.getProperty('image'),
                key = Frame.get('key');
            if (typeof this._positionMap[image] === 'undefined') {
                this._positionMap[image] = {};
            }
            if (typeof this._positionMap[image][key] === 'undefined') {
                this._positionMap[image][key] = {};
            }
            this._positionMap[image][key].left = layer.getStyle('left');
            this._positionMap[image][key].top = layer.getStyle('top');
        },

        /**
         * unsavedChangesClearCanvasConfirm
         * 
         * @access  public
         * @return  ClearCanvasConfirmModalView
         */
        unsavedChangesClearCanvasConfirm: function() {
            // var h1 = 'You have unsaved changes.<br />Creating a new image will remove all images and text.',
            var h1 = 'You have unsaved changes.',
                h2 = 'Are you sure you\'d like to proceed?',
                modal = ModalUtils.showClearCanvasConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ChangeHistoryPopoverView
     * 
     * @events  hide
     *          show
     *          toggle
     * @extends View
     */
    window.ChangeHistoryPopoverView = View.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _changeHistoryPopoverList
         * 
         * @access  protected
         * @var     undefined|ChangeHistoryPopoverListView (default: undefined)
         */
        _changeHistoryPopoverList: undefined,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChangeHistoryPopoverView')
         */
        _string: 'ChangeHistoryPopoverView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addHideListeners();
            this._addWindowResizeListener();
            this._drawChangeHistoryPopoverList();
            this._setupScrollbars();
            this.on({
                'hide': function(event) {
                    this.hide();
                },
                'show': function(event) {
                    this.show();
                },
                'toggle': function(event) {
                    this.toggle();
                }
            });
        },

        /**
         * _addHideListeners
         * 
         * @access  protected
         * @return  void
         */
        _addHideListeners: function() {
            var autoHidePopover = Config.default('changeHistory').autoHidePopover;
            if (autoHidePopover === true) {
                this.on({
                    'show': function(event) {
                        var _this = this,
                            $app = App.getElement(),
                            hide = {
                                'body/keydown/escape': function(event) {
                                    if (event.which === 27) {
                                        _this.triggerHandler('hide');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                },
                                'body/mousedown': function(event) {
                                    var closable = function() {
                                        var $target = $(event.target);
                                        if ($target.parents('div.changeHistoryPopover').length > 0) {
                                            return false;
                                        }
                                        if ($target.hasClass('changeHistoryPopover') === true) {
                                            return false;
                                        }
                                        if ($target.parents('div.sandbox').length > 0) {
                                            return false;
                                        }
                                        return true;
                                    };
                                    if (closable() === true) {
                                        _this.triggerHandler('hide');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            };
                        $app.on({
                            'mousedown': hide['body/mousedown'],
                            'keydown': hide['body/keydown/escape']
                        });
                    }
                });
            }
        },

        /**
         * _addWindowResizeListener
         * 
         * @access  protected
         * @return  void
         */
        _addWindowResizeListener: function() {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                var delay = Config.getResizeDelay('canvas'),
                    callback = _.debounce(
                        // console.log.proxy(console, ['test']),
                        this.refresh.proxy(this),
                        delay
                    );
                $(window).on({
                    'resize': callback
                });
            }
        },

        /**
         * _drawChangeHistoryPopoverList
         * 
         * @access  protected
         * @return  void
         */
        _drawChangeHistoryPopoverList: function() {
            var $element = DataUtils.render('ChangeHistoryPopoverList', {
                changeHistory: ChangeHistory.history.all()
            });
            this._element.find('div.content').append($element);
            this._changeHistoryPopoverList = new ChangeHistoryPopoverListView(
                $element
            );
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _refreshScrollbar
         * 
         * @access  protected
         * @return  void
         */
        _refreshScrollbar: function() {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                var $content = this.find('div.content'),
                    $caret = $content.find('.stencil-caret');
                this._makeScrollable($content);
                $content.addClass('dark');
                $content.append($caret);
            }
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._element.addClass('hidden');
            App.find('[lookup="changeHistory"]').removeClass('active');
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            // this._changeHistoryPopoverList.refresh();
            this._changeHistoryPopoverList.reRender();
            this._refreshScrollbar();
            this.scrollToActive();
        },

        /**
         * scrollToActive
         * 
         * @see     http://stackoverflow.com/questions/2905867/how-to-scroll-to-specific-item-using-jquery
         * @access  public
         * @return  void
         */
        scrollToActive: function() {
            var list = this._changeHistoryPopoverList,
                $parent = list.getElement().parent(),
                $active = list.find('.active').parent();
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._$scrollbar.data('jsp').scrollToY(0, false);
                this._$scrollbar.data('jsp').scrollToY(
                    $active.position().top - 4,
                    false
                );
            } else {
                var topPosition = $active.offset().top - $parent.offset().top +
                        $parent.scrollTop();
                $parent.scrollTop(topPosition);
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.scrollToActive();
            // this._changeHistoryPopoverList.scrollToActive();
            App.find('[lookup="changeHistory"]').addClass('active');
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            if (this._element.hasClass('hidden') === true) {
                this.triggerHandler('show');
            } else {
                this.triggerHandler('hide');
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ChangeHistoryPopoverListView
     * 
     * @extends View
     */
    window.ChangeHistoryPopoverListView = View.extend({

        /**
         * _lastRenderHash
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastRenderHash: '',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChangeHistoryPopoverListView')
         */
        _string: 'ChangeHistoryPopoverListView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'redo': function(event, $anchor) {
                    var stepsForward = $anchor.attr('steps');
                    ChangeHistory.initiate.redo(stepsForward);
                },
                'undo': function(event, $anchor) {
                    var stepsBack = $anchor.attr('steps');
                    ChangeHistory.initiate.undo(stepsBack);
                }
            });
        },

        /**
         * _hasChangedSinceLastRender
         * 
         * Determines whether or not anything in the change history (redo and
         * undo) is different, by checking against a previously stored hash.
         * If something is different, it naturally returns true, which at the
         * moment is used for refreshing the list.
         * 
         * @access  protected
         * @return  Boolean
         */
        _hasChangedSinceLastRender: function() {
            var history = ChangeHistory.history.all(),
                hash = StringUtils.getHash(
                    JSON.stringify(history)
                );
            if (hash === this._lastRenderHash) {
                return false;
            }
            this._lastRenderHash = hash;
            return true;
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        // refresh: function() {
        //     if (this._hasChangedSinceLastRender() === true) {
        //         this.rerender();
        //         // this.scrollToActive();
        //     }
        // },

        /**
         * reRender
         * 
         * @access  public
         * @return  void
         */
        reRender: function() {
            if (this._hasChangedSinceLastRender() === true) {
                var $element = DataUtils.render('ChangeHistoryPopoverList', {
                    changeHistory: ChangeHistory.history.all()
                });
                this._element.replaceWith($element);
                this._element = $element;
                this._setupListeners();
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * StageContentView
     * 
     * @events  toggle/changeHistory
     *          toggle/resizer
     *          toggle/grid
     *          clear
     * @extends View
     */
    window.StageContentView = View.extend({

        /**
         * _canvases
         * 
         * @access  protected
         * @var     Object
         */
        _canvases: {

            /**
             * ghost
             * 
             * @access  protected
             * @var     null|GhostCanvasView (default: null)
             */
            ghost: null,

            /**
             * preview
             * 
             * @access  protected
             * @var     null|PreviewCanvasView (default: null)
             */
            preview: null
        },

        /**
         * _changeHistoryPopover
         * 
         * @access  protected
         * @var     null|ChangeHistoryPopoverView (default: null)
         */
        _changeHistoryPopover: null,

        /**
         * _eyeDropper
         * 
         * @access  protected
         * @var     null|EyeDropperView (default: null)
         */
        _eyeDropper: null,

        /**
         * _resizer
         * 
         * @access  protected
         * @var     null|ResizerView (default: null)
         */
        _resizer: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                contextmenu: {

                    /**
                     * (anonymous)
                     * 
                     * Prevents right-click on the canvas.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $canvas
                     * @return  void
                     */
                    'canvas': function(event, $canvas) {
                        event.preventDefault();
                    }
                },
                dragenter: {
                    '> div.outer > div.inner > div.sandbox > section.messages:not(.hidden) div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = DataUtils.getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {
                            $outline.parents('div.tbl').addClass('active');
                        }
                    }
                },
                dragleave: {
                    '> div.outer > div.inner > div.sandbox > section.messages:not(.hidden) div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = DataUtils.getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {
                            $outline.parents('div.tbl').removeClass('active');
                        }
                    }
                },
                dragover: {
                    '> div.outer > div.inner > div.sandbox > section.messages:not(.hidden) div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },
                drop: {
                    '> div.outer > div.inner > div.sandbox div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = DataUtils.getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {

                            // 
                            var type = decoded.type,
                                token = decoded.token;
                            accessor = ExchangeTokenUtils.retrieve(token);
                            accessor = Stencil.getAccessor(accessor);
                            this.find('section.messages > div.message:not(.hidden) .active').removeClass('active');
                            var options = {
                                x: event.originalEvent.layerX,
                                y: event.originalEvent.layerY
                            };
                            if ($outline.parents('.tbl').attr('destination') !== undefined) {
                                options.destination = $outline.parents('.tbl').attr('destination');
                                options.autoSelect = true;
                            }
                            accessor.select.apply(
                                accessor,
                                ['drop', decoded.locked, options]
                            );

                            // 
                            if (
                                decoded.type === 'photo'
                                || decoded.type === 'graphic'
                                || decoded.type === 'upload'
                            ) {
                                var start = new Date(),
                                    busy = Canvases.Preview.getBusy();
                                Canvases.Preview.once({
                                    'render': function(event) {
                                        var busy = this.getBusy();
                                        // busy.hide.minDelay(start, 500, busy);
                                        busy.hide.minDelay(start, 0, busy);
                                    }
                                });
                                busy.show();
                            }

                            /**
                             * There's a weird bug that I ran into while
                             * building change history. When an asset, resource
                             * or upload is dropped on the canvas, sometimes
                             * (about 1 in 5), the mouseup event does not fire.
                             * I tried for a number of hours to figure out why,
                             * to noavail. So I'm manully firing here.
                             * 
                             * It should not cause any issues, since even if the
                             * mouseup event does fire correctly, the change
                             * history operation will have already been tracked,
                             * and won't be inserted into the array again.
                             */
                            App.triggerHandler('changeHistory/track');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageContentView')
         */
        _string: 'StageContentView',

        /**
         * _toolbars
         * 
         * @access  protected
         * @var     Object
         */
        // _toolbars: {
        //     backgroundBitmapImage: null,
        //     backgroundRectangle: null,
        //     foregroundBitmapImage: null,
        //     text: null,
        //     vectorImage: null,
        //     watermarkBitmapImage: null,
        //     watermarkColorVectorImage: null
        // },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawResizer();
            window.Canvases = {};
            this._setupGhostCanvas();
            this._setupPreviewCanvas();
            this._setupEyeDropper();
            this._drawToolbars();
            this._setupChangeHistoryPopover();
            this._setupTooltips();
            this._setupButterBar();
            this._setupFacebookAdGrid();
            this._setupBackgroundHandles();
            this.on({
                'interaction/block': function(event, $element) {
                    this.interaction.block.apply(this);
                },
                'toggle/changeHistory': function(event, $element) {
                    $element.blur();
                    this.getChangeHistoryPopover().triggerHandler('toggle');
                },
                'toggle/resizer': function(event, $element) {
                    $element.blur();
                    this._resizer.toggle();
                },
                'toggle/grid': function(event, $element) {
                    $element.blur();
                    this.find('div.butter.bar [lookup="toggle/grid"]').toggleClass('hidden');
                    this.find('div.ui.actions [lookup="toggle/grid"]').toggleClass('active');
                    this.find('div.sandbox div.grid').toggleClass('hidden');
                },
                'addText': function(event, $element) {
                    $element.blur();
                    this.addText();
                },
                'clear': function(event, $element) {
                    $element.blur();
                    App.tooltips.hide();
                    Canvases.Preview.clear(true);
                },
                'createNewImage': function(event, $element) {
                    $element.blur();
                    App.tooltips.hide();
                    var canvasHasbeenChanged = Footer.validate.changedCanvas.apply(Footer).valid;
                    if (canvasHasbeenChanged === true) {
                        Canvases.Preview.clear(true, 'unsaved');
                    } else {
                        Canvases.Preview.clear(false);
                    }
                },
                'redo': function(event, $element) {
                    $element && $element.blur();
                    ChangeHistory.initiate.redo(1);
                },
                'undo': function(event, $element) {
                    $element && $element.blur();
                    ChangeHistory.initiate.undo(1);
                }
            });
        },

        /**
         * _drawResizer
         * 
         * @access  protected
         * @return  void
         */
        _drawResizer: function() {
            var $resizer = DataUtils.render('Resizer'),
                $section = this._element.find('section.sizing');
            $section.append($resizer);
            this._resizer = new ResizerView($resizer, this);
            // this._resizer.setSelectedFrame(Frame);
        },

        /**
         * _drawToolbars
         * 
         * @access  protected
         * @return  void
         */
        _drawToolbars: function() {
            var $toolbars = this._element.find('> .outer > div.inner div.toolbars'),
                view = new ToolbarsView($toolbars, this);
            window.Toolbars = view;
        },

        /**
         * _setupBackgroundHandles
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundHandles: function() {
            var $handles = this.find('div.handles');
            this.find('.preview-canvas-container').append($handles);
        },

        /**
         * _setupButterBar
         * 
         * @access  protected
         * @return  void
         */
        _setupButterBar: function() {
            var $bar = this.find('div.butter.bar');
            this.find('.sandbox').parent().append($bar);
            // this.find('.preview-canvas-container').append($bar);
        },

        /**
         * _setupChangeHistoryPopover
         * 
         * @access  protected
         * @return  void
         */
        _setupChangeHistoryPopover: function() {
            var $element = this.find('.changeHistoryPopover'),
                view = new ChangeHistoryPopoverView($element);
            this._changeHistoryPopover = view;
        },

        /**
         * _setupEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _setupEyeDropper: function() {
            var $element = this.find('div.eyedropper'),
                view = new EyeDropperView($element, this);
            this._eyeDropper = view;
        },

        /**
         * _setupFacebookAdGrid
         * 
         * @access  protected
         * @return  void
         */
        _setupFacebookAdGrid: function() {
            var $grid = this.find('div.inner > div.grid');
            this.find('.preview-canvas-container').append($grid);
        },

        /**
         * _setupGhostCanvas
         * 
         * @access  protected
         * @return  void
         */
        _setupGhostCanvas: function() {
            var $ghost = this.find('canvas#ghost'),
                ghost = new GhostCanvasView($ghost);
            this._canvases.ghost = ghost;
        },

        /**
         * _setupPreviewCanvas
         * 
         * @access  protected
         * @return  void
         */
        _setupPreviewCanvas: function() {
            var $preview = this.find('canvas#preview'),
                preview = new PreviewCanvasView($preview);
            this._canvases.preview = preview;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            var $actions = this.find('div.ui.actions');
            this._element.tooltip({
                html: true,
                selector: [
                    'a.icon[trigger="import"][tooltip]',
                    'div.butter.bar [tooltip]',
                    '[lookup="undo"]',
                    '[lookup="changeHistory"]',
                    '[lookup="redo"]',
                    'div.ui.actions [tooltip]'
                ].join(','),
                container: App.getElement(),
                placement: function() {
                    var placement = this.$element.attr('placement');
                    if (placement === undefined) {
                        placement = 'bottom';
                    }
                    if (placement === 'smart') {
                        var offset = $actions.offset(),
                            widths = {
                                body: App.getElement().width()
                            };
                        // if ((widths.body - offset.left) >= 142) {
                        if ((widths.body - offset.left) >= 153) {
                            return 'right';
                        }
                        return 'bottom';
                    }
                    return placement;
                }
            });
        },

        /**
         * addText
         * 
         * @access  public
         * @return  void
         */
        addText: function() {
            var canvas = Canvases.Preview,
                layer = canvas.addTextLayer(),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * drawPreviewCanvas
         * 
         * @access  public
         * @return  void
         */
        drawPreviewCanvas: function() {
            var draft = Stencil.account().draft(),
                document = draft.json(),
                preview = this._canvases.preview,
                imageDocument = new ImageDocument(document, draft, preview);
            draft.loadDependentFonts();
            draft.setImageDocument(imageDocument);
            preview.setImage(draft);
            preview.once({
                'render': preview.addWindowResizeListener
            });
            preview.once({
                'render': preview.addWindowOrientationChangeListener
            });
            preview.once({
                'render': function(event) {
                    var sourceImage = draft.getSourceImage();
                    if (sourceImage !== undefined) {
                        if (sourceImage.owned() === true) {
                            Footer.setLastSavedImage(sourceImage);
                        }
                    }
                }
            });
            preview.once({
                'render': function(event) {
                    var callback = Footer.reset.proxy(Footer);
                    // var callback = function() {
                    //     Footer.reset();//.proxy(Footer);
                    //     console.log('t');
                    // };
                    // var callback = Footer.reset.proxy(Footer);
                    this._cotton.on({
                        'after:render': _.throttle(callback, 75)
                        // 'after:render': _.throttle(callback, 75),
                        // 'applyFilters/complete': function() {
                        //     console.log('w00t');
                        // }
                    });
                    Footer.reset();
                }
            });
            preview.draw(true);
            draft.markConfigurationAsSaved();
        },

        /**
         * getChangeHistoryPopover
         * 
         * @access  public
         * @return  ChangeHistoryPopoverView
         */
        getChangeHistoryPopover: function() {
            return this._changeHistoryPopover;
        },

        /**
         * getEyeDropper
         * 
         * @access  public
         * @return  EyeDropperView
         */
        getEyeDropper: function() {
            return this._eyeDropper;
        },

        /**
         * getResizer
         * 
         * @access  public
         * @return  ResizerView
         */
        getResizer: function() {
            return this._resizer;
        },

        /**
         * getMessage
         * 
         * @access  public
         * @param   String type
         * @return  jQuery
         */
        getMessage: function(type) {
            var selector = 'section.messages div.message[type="' + (type) + '"]';
            return this.find(selector);
        },

        /**
         * getMessages
         * 
         * @access  public
         * @return  jQuery
         */
        getMessages: function() {
            return this.find('section.messages div.message');
        },

        /**
         * handles
         * 
         * @access  public
         * @var     Object
         */
        handles: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                this.find('div.handles').addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                this.find('div.handles').removeClass('hidden');
            }
        },

        /**
         * interaction
         * 
         * @access  public
         * @var     Object
         */
        interaction: {

            /**
             * block
             * 
             * @access  public
             * @return  void
             */
            block: function() {
                var busy = Canvases.Preview.getBusy(),
                    $element = busy.getElement(),
                    msg = Config.getMessage('interaction.block');
                if ($element.hasClass('hidden') === true) {
                    $element.addClass('light');
                    busy.show(msg);
                }
            },

            /**
             * unblock
             * 
             * @access  public
             * @return  void
             */
            unblock: function() {
                var busy = Canvases.Preview.getBusy();
                busy.hide();
                busy.getElement().removeClass('light');
            }
        },

        /**
         * refreshChangeHistoryElements
         * 
         * This method is pretty simple: it disables the redo and undo CTAs,
         * and then checks the length of the redo and undo history stacks. In
         * the case of the redo history stack, I enable the redo CTA if there
         * are any entries.
         * 
         * The undo history stack is different, because there will *always* be
         * at least one entry: the original image state. So in that case, I
         * check if there's greater than 1 entry, and if so, enable the CTA.
         * 
         * @access  public
         * @return  void
         */
        refreshChangeHistoryElements: function() {
            var $redo = this.find('a.redo'),
                $undo = this.find('a.undo'),
                history = ChangeHistory.history.all();
            $redo.disable();
            $undo.disable();
            if (history.redo.length > 0) {
                $redo.enable();
            }
            if (history.undo.length > 1) {
                $undo.enable();
            }
        },

        /**
         * updateResizer
         * 
         * @access  public
         * @return  void
         */
        updateResizer: function() {
            var $section = this.find('section.sizing'),
                $anchor = $section.find('a').first(),
                $middot = $section.find('span.middot').first(),
                $label = $anchor.find('div.label'),
                $width = $anchor.find('span.width'),
                $height = $anchor.find('span.height');
            $label.text(Frame.get('label'));
            $width.text(Frame.get('width'));
            $height.text(Frame.get('height'));
            $middot.removeClass('hidden');
            if (Frame.get('label').trim() === '') {
                $middot.addClass('hidden');
            }
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * EyeDropperView
     * 
     * @extends View
     * @fires   select
     *          disable
     *          enable
     */
    window.EyeDropperView = View.extend({

        /**
         * _enabled
         * 
         * @access  protected
         * @var     false (default: false)
         */
        _enabled: false,

        /**
         * _imageData
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _imageData: null,

        /**
         * _stageContent
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _stageContent: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'EyeDropperView')
         */
        _string: 'EyeDropperView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   StageContentView stageContent
         * @return  void
         */
        init: function(element, stageContent) {
            this._super(element);
            this._stageContent = stageContent;
            this._addMessageListeners();
            this._addColorActionListeners();
        },

        /**
         * _addClickListener
         * 
         * @access  protected
         * @return  void
         */
        _addClickListener: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'click': function(event) {
                    _this._triggerEvent(event, 'select');
                }
            });
        },

        /**
         * _addColorActionListeners
         * 
         * @access  protected
         * @return  void
         */
        _addColorActionListeners: function() {
            this._addMouseMoveMouseDownListener();
            this._addMouseMoveMetaKeyListener();
            this._addClickListener();
        },

        /**
         * _addMessageListeners
         * 
         * @access  protected
         * @return  void
         */
        _addMessageListeners: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'mousedown': function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                },
                'mouseenter': function(event) {
                    _this._element.removeClass('hidden');
                },
                'mouseleave': function(event) {
                    _this._element.addClass('hidden');
                },
                'mousemove': function(event) {
                    var position = {
                            x: event.offsetX,
                            y: event.offsetY
                        },
                        dimensions = {
                            width: _this._element.css('width').toInt(),
                            height: _this._element.css('height').toInt()
                        },
                        rgbaColorStr = _this._getColorAtPosition(position),
                        hex = ColorUtils.convert(rgbaColorStr, 'hex');
                    _this._element.find('.tooltip-inner').text(hex);
                    _this._element.css({
                        'background-color': rgbaColorStr,
                        'left': (position.x - dimensions.width / 2) + 'px',
                        'top': (position.y - dimensions.height / 2) + 'px'
                    });
                }
            });
        },

        /**
         * _addMouseMoveMetaKeyListener
         * 
         * @access  protected
         * @return  void
         */
        _addMouseMoveMetaKeyListener: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'mousemove': function(event) {
                    if (event.metaKey === true) {
                        _this._triggerEvent(event, 'preview');
                        var position = {
                                x: event.offsetX,
                                y: event.offsetY
                            },
                            rgbaColorStr = _this._getColorAtPosition(position);
                        _this.triggerHandler('preview', [rgbaColorStr]);
                    }
                }
            });
        },

        /**
         * _addMouseMoveMouseDownListener
         * 
         * @see     https://i.imgur.com/WkNKzs3.png
         * @see     https://stackoverflow.com/questions/18177818/why-jquerys-event-which-gives-different-results-in-firefox-and-chrome/18184976
         * @see     https://stackoverflow.com/questions/4065992/jquery-detecting-pressed-mouse-button-during-mousemove-event
         * @note    There was a bug when using .which instead of .buttons
         *          Firefox would evaluate .which to be 1 regardless of whether
         *          the mouse button was pressed.
         * @access  protected
         * @return  void
         */
        _addMouseMoveMouseDownListener: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'mousemove': function(event) {
                    if (DataUtils.valid(event.buttons) === true) {
                        if (event.buttons.toInt() === 1) {
                            _this._triggerEvent(event, 'preview');
                        }
                    }
                }
            });
        },

        /**
         * _getColorAtPosition
         * 
         * @see     https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
         * @see     https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData
         * @access  protected
         * @param   Object position
         * @return  String
         */
        _getColorAtPosition: function(position) {
            var dpr = UserAgentUtils.getDevicePixelRatio(),
                x = (position.x * dpr).round(0),
                y = (position.y * dpr).round(0),
                position = ((y * (this._imageData.width * 4)) + (x * 4)),
                rgba = [
                    this._imageData.data[position + 0],
                    this._imageData.data[position + 1],
                    this._imageData.data[position + 2],
                    this._imageData.data[position + 3]
                ],
                rgbaColorStr = 'rgba(' + rgba.toString() + ')';
            return rgbaColorStr;
        },

        /**
         * _loadImageData
         * 
         * @access  protected
         * @return  void
         */
        _loadImageData: function() {
            var $canvas = Canvases.Preview.getElement(),
                canvas = $canvas[0],
                context = canvas.getContext('2d'),
                width = canvas.width,
                height = canvas.height,
                imageData = context.getImageData(0, 0, width, height);
            this._imageData = imageData;
        },

        // /**
        //  * _loadImageData
        //  * 
        //  * @access  protected
        //  * @return  void
        //  */
        // _loadImageData: function() {
        //     var dpr = UserAgentUtils.getDevicePixelRatio().round(3),
        //         cotton = Canvases.Preview.getCotton(),
        //         width = cotton.width * dpr,
        //         height = cotton.height * dpr;
        //     this._imageData = cotton.getContext().getImageData(
        //         0,
        //         0,
        //         width,
        //         height
        //     );
        // },

        /**
         * _triggerEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @param   String action
         * @return  void
         */
        _triggerEvent: function(event, action) {
            var eventType = action,
                position = {
                    x: event.offsetX,
                    y: event.offsetY
                },
                rgbaColorStr = this._getColorAtPosition(position);
            this.triggerHandler(eventType, [rgbaColorStr]);
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this.triggerHandler('disable');
            if (this._enabled === true) {
                this.unbind('preview');
                this.unbind('select');
                this._enabled = false;
                Stencil.set('ignoreMouseDownLayerBlur', false);
                var previewCanvas = Canvases.Preview,
                    cotton = Canvases.Preview.getCotton(),
                    $message = this._stageContent.getMessage('color'),
                    $messages = this._stageContent.find('section.messages');
                $message.addClass('hidden');
                $messages.addClass('mirage');
                this._element.addClass('hidden');
                var selectedLayer = previewCanvas.getSelectedLayer();
                if (selectedLayer !== false) {
                    var selectedDrawing = selectedLayer.getDrawing();
                    selectedDrawing.bb.show.apply(selectedDrawing);
                }
            }
        },

        /**
         * enable
         * 
         * @note    selectedDrawing.bb.hide needs to be before _loadImageData
         *          because otherwise the layer handles and border outline
         *          would be interpreted by the eye dropper.
         * @access  public
         * @return  void
         */
        enable: function() {
            this.triggerHandler('enable');
            if (this._enabled === false) {
                this._enabled = true;
                Stencil.set('ignoreMouseDownLayerBlur', true);
                var previewCanvas = Canvases.Preview,
                    cotton = previewCanvas.getCotton(),
                    $message = this._stageContent.getMessage('color'),
                    $messages = this._stageContent.find('section.messages'),
                    selectedDrawing = previewCanvas.getSelectedLayer().getDrawing();
                $message.removeClass('hidden');
                $messages.removeClass('mirage');
                selectedDrawing.bb.hide.apply(selectedDrawing);
                this._loadImageData();
            }
        },

        /**
         * enabled
         * 
         * @access  public
         * @return  Boolean
         */
        enabled: function() {
            var enabled = this._enabled;
            return enabled;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * StageFooterView
     * 
     * @events  download
     *          save
     *          template
     *          menu/save/close
     *          menu/save/open
     * @extends View
     */
    window.StageFooterView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    '[lookup="previewAndShare"]': function(event, $anchor) {
                        App.preloadShareModalStaticAssets();
                    }
                }
            });
        },

        /**
         * _lastSavedImage
         * 
         * Reference to the last saved ImageAccessor object (used by downloading
         * and sharing methods).
         * 
         * @access  protected
         * @var     false|ImageAccessor (default: false)
         */
        _lastSavedImage: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageFooterView')
         */
        _string: 'StageFooterView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            window.Footer = this;
            this._setupSecondarySaveMenu();
            this._setupAuth();
            this._setupDownload();
            this._setupPreviewAndShare();
            this._setupSave();
            this._setupSaveAsTemplate();
            this._setupTooltips();
        },

        /**
         * _closeOnboardModal
         * 
         * @access  protected
         * @return  void
         */
        _closeOnboardModal: function() {
            var onboard = ModalUtils.get('Onboard');
            if (onboard !== false) {
                onboard.triggerHandler('leave');
            }
        },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            User.once({
                'login': function(event, user) {
                    Footer.reset();
                }
            });
            Account.once({
                'upgrade': function(event, account) {
                    Footer.reset();
                }
            });
        },

        /**
         * _setupDownload
         * 
         * @access  protected
         * @return  void
         */
        _setupDownload: function() {
            this.on({
                'download': function(event) {
                    var check = this.validate.download.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {
                        var draft = Stencil.account().draft(),
                            key = draft.get('key');
                        if (draft.isVerifoneFrame() === true) {
                            check = this.validate.changedCanvas.apply(this);
                            if (check.valid === true) {
                                Stencil.account().draft().share();
                                this.save('share', false);
                            } else {
                                this._lastSavedImage.share();
                            }
                        } else {
                            ModalUtils.showDownload(key, false);
                        }
                    }
                }
            });
        },

        /**
         * _setupPreviewAndShare
         * 
         * @todo    Look into whether an image needs to actually be saved when
         *          the P+S button is clicked. Might make more sense to only
         *          save the image once they try to get interact with it via the
         *          share modal? More complicated, since there are non-OAuth
         *          based interaction methods (eg. Buffer, Pinterest, SMS), but
         *          it's much more efficient, in that no image gets saved to the
         *          DB or S3 if they just want to see what it looks like. It thus
         *          also saves browser-memory.
         * @access  protected
         * @return  void
         */
        _setupPreviewAndShare: function() {
            this.on({
                'previewAndShare': function(event) {
                    this._closeOnboardModal();
                    var check = this.validate.previewAndShare.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {
                        check = this.validate.changedCanvas.apply(this);
                        if (check.valid === true) {
                            Stencil.account().draft().share();
                            // var msg = Config.getMessage('image.saving');
                            // App.getBusy().show(msg);
                            this.save('share', false);
                        } else {
                            this._lastSavedImage.share();
                        }
                    }
                }
            });
        },

        /**
         * _setupSave
         * 
         * @note    I set the account's monthlySavedImages and totalSavedImages
         *          right away (and delay the syncing to the db) because I want
         *          the UI to change immediately (eg.
         *          https://i.imgur.com/M5fueDd.png), but I don't want the
         *          account record to be patched until _after_ a new shadow draft
         *          has been created. This is to prevent a possible
         *          race-condition when the AccountAccessor is patched before
         *          the new shadow draft has been created. This can happen if the
         *          server is lagging. Specifically, the draft ImageAccessor is
         *          updated, a new shadow draft ImageAccessor is created, but
         *          before that completes, the existing AccountAccessor is
         *          updated. If the AccountAccessor is patched before the new
         *          shadow draft ImageAccessor has been created, this line of
         *          code will fire, which will result in two draft records in the
         *          db for the account: https://i.imgur.com/1hyuGwa.png
         *          Here's the result: https://i.imgur.com/pKApJAK.png
         *          Tough one to crack..
         * @access  protected
         * @return  void
         */
        _setupSave: function() {
            this.on({
                'save': function(event) {
                    var check = this.validate.save.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {

                        /**
                         * Account quota saving / syncing
                         * 
                         */
                        var account = Stencil.account();
                        account.set({
                            monthlySavedImages: account.get('monthlySavedImages').toInt() + 1,
                            totalSavedImages: account.get('totalSavedImages').toInt() + 1
                        });
                        account.once({
                            'draft/create': function(event, draft) {
                                this.syncRefillData(function(changed) {
                                    if (changed === true) {
                                        this.set({
                                            monthlySavedImages: this.get('monthlySavedImages').toInt() + 1,
                                            monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt(),
                                            totalSavedImages: this.get('totalSavedImages').toInt() + 1
                                        });
                                        Stencil.alert('account.refilled');
                                    }
                                    this.save([
                                        'monthlySavedImages',
                                        'totalSavedImages'
                                    ]);
                                });
                            }
                        });

                        // Image collection addition
                        var draft = account.draft(),
                            category = CategoryUtils.account.list('images'),
                            key = category.get('key'),
                            child = App.getEditor().getArea('images').getChild('categories').getChild(key),
                            images = child.getCollection();
                        images.add(draft, false);

                        // Save and navigate to images tab
                        // var msg = Config.getMessage('image.saving');
                        // App.getBusy().show(msg);
                        category.features.add.apply(category, [draft]);
                        this.save('save', false);

                        /**
                         * Scrolling + Navigation
                         * 
                         */
                        var fragmentPath = category.getPath(true);
                        if (Stencil.getRouter().current().fragment === fragmentPath) {
                            child.scrollToTop();
                        } else {
                            var routeEventKey = 'route:' + (fragmentPath);
                            Stencil.getRouter().once(
                                routeEventKey,
                                function() {
                                    child.scrollToTop();
                                }
                            );
                        }
                        Stencil.navigate(category.getPath());

                        // Image count warning
                        if (
                            User.admin() === false
                            && User.editor() === false
                        ) {
                            var remaining = account.getImagesRemaining();
                            if (remaining === 0 || remaining === 1) {
                                Stencil.navigate('/app/countdown?clean=1');
                            }
                        }

                        // Actions
                        Footer.reset();
                        // this.disable.save.apply(this);
                        // this.enable.distribution.apply(this);
                    }
                }
            });
        },

        /**
         * _setupSaveAsTemplate
         * 
         * @access  protected
         * @return  void
         */
        _setupSaveAsTemplate: function() {
            this.on({
                'saveAsTemplate': function(event) {
                    this.triggerHandler('menu/save/close');
                    var check = this.validate.saveAsTemplate.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {

                        /**
                         * Account quota saving / syncing
                         * 
                         */
                        var account = Stencil.account();
                        account.set({
                            monthlySavedImages: account.get('monthlySavedImages').toInt() + 1,
                            totalSavedImages: account.get('totalSavedImages').toInt() + 1
                        });
                        account.once({
                            'draft/create': function(event, draft) {
                                this.syncRefillData(function(changed) {
                                    if (changed === true) {
                                        this.set({
                                            monthlySavedImages: this.get('monthlySavedImages').toInt() + 1,
                                            monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt(),
                                            totalSavedImages: this.get('totalSavedImages').toInt() + 1
                                        });
                                        Stencil.alert('account.refilled');
                                    }
                                    this.save([
                                        'monthlySavedImages',
                                        'totalSavedImages'
                                    ]);
                                });
                            }
                        });

                        // 
                        Stencil.account().draft().template();
                        // throw new Error('s');
                        // var msg = Config.getMessage('image.saving');
                        // App.getBusy().show(msg);
                        this.save('template', false);
                        Track.event('Template saved');

                        /**
                         * Scrolling + Navigation
                         * 
                         */
                        var category = CategoryUtils.account.list('templates'),
                            key = category.get('key'),
                            child = App.getEditor().getArea('templates').getChild('categories').getChild(key),
                            fragmentPath = category.getPath(true);
                        if (Stencil.getRouter().current().fragment === fragmentPath) {
                            child.scrollToTop();
                        } else {
                            var routeEventKey = 'route:' + (fragmentPath);
                            Stencil.getRouter().once(
                                routeEventKey,
                                function() {
                                    child.scrollToTop();
                                }
                            );
                        }
                        Stencil.navigate(category.getPath());
                    }
                }
            });
        },

        /**
         * _setupSecondarySaveMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupSecondarySaveMenu: function() {
            this.on({
                'menu/save/close': function(event) {
                    this.find('div.save').removeClass('expanded');
                },
                'menu/save/open': function(event) {
                    var _this = this;
                    this.find('div.save').addClass('expanded');
                    ClientWrappers.get('helpScout').closeBeacon();

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover[button="save"]').length === 0) {
                                    _this.triggerHandler('menu/save/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.which === 27) {
                                    _this.triggerHandler('menu/save/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: this._element,
                placement: 'top'
            });
        },

        /**
         * disable
         * 
         * @access  public
         * @var     Object
         */
        disable: {

            /**
             * all
             * 
             * @access  public
             * @param   undefined|Boolean quick (default: false)
             * @return  void
             */
            all: function(quick) {
                quick = DataUtils.getDefaultValue(quick, false);
                this.disable.distribution.apply(this, [quick]);
                this.disable.save.apply(this, [quick]);
            },

            /**
             * distribution
             * 
             * Disables the "Download" and "Preview & Share" buttons. Adds the
             * tooltips to them.
             * 
             * @access  public
             * @param   undefined|Boolean quick (default: false)
             * @return  void
             */
            distribution: function(quick) {
                quick = DataUtils.getDefaultValue(quick, false);
                if (quick === true) {
                    this.find('[lookup="download"]').addClass('quick');
                    this.find('[lookup="previewAndShare"]').addClass('quick');
                }
                this.find('[lookup="download"]').disable();
                this.find('[lookup="previewAndShare"]').disable();
                this.find('[lookup="download"]').tooltips(true);
                this.find('[lookup="previewAndShare"]').tooltips(true);
                if (quick === true) {
                    (function() {
                        this.find('[lookup="download"]').removeClass('quick');
                        this.find('[lookup="previewAndShare"]').removeClass('quick');
                    }).delay(150, this);
                }
            },

            /**
             * save
             * 
             * Disables the "Save" and "Save as template" buttons. Adds the
             * tooltip to the parent save button.
             * 
             * @access  public
             * @param   undefined|Boolean quick (default: false)
             * @return  void
             */
            save: function(quick) {
                quick = DataUtils.getDefaultValue(quick, false);
                if (quick === true) {
                    this.find('[lookup="save"]').addClass('quick');
                    this.find('[lookup="saveChevron"]').addClass('quick');
                }
                this.find('[lookup="save"]').disable();
                this.find('[lookup="saveChevron"]').disable();
                this.find('[lookup="saveWrapper"]').tooltips(true);
                if (quick === true) {
                    (function() {
                        this.find('[lookup="save"]').removeClass('quick');
                        this.find('[lookup="saveChevron"]').removeClass('quick');
                    }).delay(150, this);
                }
            }
        },

        /**
         * enable
         * 
         * @access  public
         * @var     Object
         */
        enable: {

            /**
             * all
             * 
             * Helper method for the other two enable methods. Enables all three
             * actions, and removes all tooltips.
             * 
             * @access  public
             * @return  void
             */
            all: function() {
                this.enable.distribution.apply(this);
                this.enable.save.apply(this);
            },

            /**
             * distribution
             * 
             * Enables the "Download" and "Preview & Share" buttons. Removes the
             * tooltips from them.
             * 
             * @access  public
             * @return  void
             */
            distribution: function() {
                this.find('[lookup="download"]').enable();
                this.find('[lookup="previewAndShare"]').enable();
                this.find('[lookup="download"]').tooltips(false);
                this.find('[lookup="previewAndShare"]').tooltips(false);
            },

            /**
             * save
             * 
             * Enables the "Save" and "Save as template" buttons. Removes the
             * tooltip from the parent save button.
             * 
             * @access  public
             * @return  void
             */
            save: function() {
                this.find('[lookup="save"]').enable();
                this.find('[lookup="saveChevron"]').enable();
                this.find('[lookup="saveWrapper"]').tooltips(false);
            }
        },

        /**
         * getLastSavedImage
         * 
         * @access  public
         * @return  false|ImageAccessor
         */
        getLastSavedImage: function() {
            return this._lastSavedImage;
        },

        /**
         * setLastSavedImage
         * 
         * @access  public
         * @param   false|ImageAccessor image
         * @return  void
         */
        setLastSavedImage: function(image) {//, disableSave) {
    // console.log('Footer.setLastSavedImage called');
    // console.log(arguments);
    // console.trace();
            this._lastSavedImage = image;
            // disableSave === true && this.disable.save.apply(this);
            // this.enable.distribution.apply(this);
        },

        /**
         * validate
         * 
         * @access  public
         * @var     Object
         */
        validate: {

            /**
             * changedCanvas
             * 
             * This validation method is intended to determine whether the draft
             * is different than the source image defined (if any). It does this
             * by first checking if a saved image is stored in the footer (which
             * would be the source image of any draft). If none is, then the
             * canvas is identified as different (this would happen for
             * brand-new guests).
             * 
             * See ImageStateUtils.js for more information on this validation
             * check.
             * 
             * @access  public
             * @return  Object
             */
            changedCanvas: function() {
                if (this._lastSavedImage === false) {
                    return {
                        valid: true
                    };
                }
                var draft = Stencil.account().draft(),
                    lastSavedImage = this._lastSavedImage,
                    response = {
                        valid: ImageStateUtils.match(draft, lastSavedImage) === false
                    };
                return response;
            },

            /**
             * download
             * 
             * Series of validation methods to determine whether a download can
             * take place. Of particular interest is the saving-check, which
             * also checks whether the <_lastSavedImage> property is set to
             * null. This is to allow for the case whereby a user saves an image
             * first, and before updating anything about it, attempts to use the
             * Download or Preview & Share buttons. In that case, the user
             * should be allow to proceed, since those flows manage themselves
             * nicely already with respect to an image that is still being
             * uploaded.
             * 
             * The <_lastSavedImage> property is set to null only when a change
             * to the canvas is made. Otherwise, it is a reference to the
             * ImageAccessor that was last saved (and possibly still being
             * uploaded).
             * 
             * @access  public
             * @return  Object
             */
            download: function() {
                if (Config.serviceAvailable('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (
                    Canvases.Ghost.get('saving') === true
                    // && Canvases.Ghost.getImage() !== this._lastSavedImage
                    && this.validate.changedCanvas.apply(this).valid === true
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, contentType) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (this.validate.changedCanvas.apply(this).valid === false) {
                    return {
                        valid: true
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                if (User.frozen() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('user.settings.frozen');
                            Stencil.kill();
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * previewAndShare
             * 
             * Series of validation methods to determine whether a Preview &
             * Share can take place. Of particular interest is the saving-check,
             * which also checks whether the <_lastSavedImage> property is set
             * to null. This is to allow for the case whereby a user saves an
             * image first, and before updating anything about it, attempts to
             * use the Download or Preview & Share buttons. In that case, the
             * user should be allow to proceed, since those flows manage
             * themselves nicely already with respect to an image that is still
             * being uploaded.
             * 
             * The <_lastSavedImage> property is set to null only when a change
             * to the canvas is made. Otherwise, it is a reference to the
             * ImageAccessor that was last saved (and possibly still being
             * uploaded).
             * 
             * @access  public
             * @return  Object
             */
            previewAndShare: function() {
                if (Config.serviceAvailable('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (
                    Canvases.Ghost.get('saving') === true
                    // && Canvases.Ghost.getImage() !== this._lastSavedImage
                    && this.validate.changedCanvas.apply(this).valid === true
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, contentType) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (this.validate.changedCanvas.apply(this).valid === false) {
                    return {
                        valid: true
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                if (User.frozen() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('user.settings.frozen');
                            Stencil.kill();
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * save
             * 
             * @access  public
             * @return  Object
             */
            save: function() {
                if (Config.serviceAvailable('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (Canvases.Ghost.get('saving') === true) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, contentType) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (Account.draftIsLocked() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/upgrade/pro/locked-save?clean');
                        }
                    };
                }
                if (User.exists() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/signup?save');
                        }
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                if (User.frozen() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('user.settings.frozen');
                            Stencil.kill();
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * saveAsTemplate
             * 
             * @access  public
             * @return  Object
             */
            saveAsTemplate: function() {
                if (Config.serviceAvailable('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (Canvases.Ghost.get('saving') === true) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Config.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, contentType) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (
                    Account.upgraded() === false
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/upgrade/pro/templates?clean=1');
                        }
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                if (User.frozen() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('user.settings.frozen');
                            Stencil.kill();
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * sourceImageContext
             * 
             * Checks whether the source image for the draft was saved under a
             * specific context (eg. save, template, download or share). This is
             * used to determine whether the Footer save button should be
             * enabled. For example, if save is passed in, it will ensure that
             * the source image for the account's draft image was in fact saved,
             * rather than possibly saved as a template or via a download or
             * share action.
             * 
             * @access  public
             * @param   String context
             * @return  Object
             */
            sourceImageContext: function(context) {
                if (this._lastSavedImage === false) {
                    return {
                        valid: false
                    };
                }
                var draft = Stencil.account().draft(),
                    sourceImage = draft.getSourceImage();
                if (sourceImage === undefined) {
                    return {
                        valid: false
                    };
                }
                return {
                    valid: sourceImage.get('context') === context
                };
            }
        },

        /**
         * reset
         * 
         * @access  public
         * @return  void
         */
        reset: function() {
            var changedCanvas = this.validate.changedCanvas.apply(this).valid;
            if (changedCanvas === true) {
                this.enable.save.apply(this);
                if (
                    User.admin() === false
                    && User.editor() === false
                ) {
                    if (
                        Account.guest() === true
                        || Account.free() === true
                        || Account.plan('pro') === true
                    ) {
                        this.disable.distribution.apply(this);
                    } else {
                        this.enable.distribution.apply(this);
                    }
                } else {
                    this.enable.distribution.apply(this);
                }
            } else {
                var saveContext = this.validate.sourceImageContext.apply(this, ['save']).valid;
                if (saveContext === true) {
                    this.disable.save.apply(this);
                } else {
                    this.enable.save.apply(this);
                }
                this.enable.distribution.apply(this);
                // if (User.admin() === false) {
                //     if (Account.guest() === true || Account.free() === true) {
                //         this.enable.distribution.apply(this);
                //     }
                // }
            }
        },

        /**
         * save
         * 
         * @access  public
         * @param   String context
         * @param   false|String contentType
         * @param   undefined|Function callback
         * @return  void
         */
        save: function(context, contentType, callback) {

            // Draft swapping
            this.time('save');
            Canvases.Ghost.set({'saving': true});
            var account = Stencil.account(),
                saving = account.draft(),
                imageDocument = saving.getImageDocument(),
                draft = account.createNewDraft(saving);
            this._lastSavedImage = saving;
            draft.setImageDocument(imageDocument);
            imageDocument.setImage(draft);
            draft.markConfigurationAsSaved();
            Canvases.Preview.setImage(draft);

            // Change history operation
            if (context !== 'download') {
                var operationType = 'image // saved';
                if (context === 'template') {
                    operationType = 'template // saved';
                }
                ChangeHistory.setOperationType(operationType);
                ChangeHistory.track(true, false);
            } else {
                ChangeHistory.syncSourceImageId(
                    saving.get('sourceImageId').toInt(),
                    saving.get('id').toInt()
                );
            }

            // Settings
            saving.setConfiguration();
            saving.set({
                'context': context,
                'draft': 0
            });

            /**
             * It's important to clear the configuration save timeout to prevent
             * the following possible race-condition:
             * 
             * If an image is really simple, and the user makes a change and
             * then quickly saves it, it's possible that the PATCH call to save
             * the image gets dispatched *after* the image has been fully
             * uploaded. If this happens, then the ImageValidator::notUploaded
             * check will fail, since the image has technically already been
             * uploaded.
             * 
             * Cancelling this call is fine, because it really is only
             * cancelling the dispatching of the PATCH call. The data itself is
             * already changed in the ImageAccessor reference, and will be
             * synced in the below .save call anyhow
             */
            saving.clearSaveConfigurationTimeout();

            // Create new image document and layers for saving image
            var document = saving.json(),
                ghost = Canvases.Ghost;
            imageDocument = new ImageDocument(document, saving, ghost);
            imageDocument.mergeWatermarks();
            imageDocument.setupLayers();
            saving.setImageDocument(imageDocument);

            // Save through the Ghost canvas
            var _this = this;
            Canvases.Ghost.setImage(saving);
            Canvases.Ghost.once({
                'export': function(event, dataURL, contentType) {

                    // Image saved
                    _this.time('save');
                    Canvases.Ghost.set({'saving': false});
                    Track.event('Image pushed', {
                        label: context,
                        _label: context
                    });

                    // Promote the draft to a saved image
                    saving.set({
                        filesize: dataURL.length,
                        contentType: contentType
                    });
                    saving.save([
                        'context', 'draft', 'filesize', 'contentType', 'width', 'height',
                        'sourceImageId', 'frame', 'settings.json',
                        'settings.watermarks'
                    ]);
                    // saving.markConfigurationAsSaved();
                    saving.once({
                        'update/context': function(event, columns) {

                            // Init and start upload
                            var model = Stencil.getModel('S3Upload');
                            saving.once({
                                'upload/error': function(event, err) {
                                    Stencil.alert('image.upload.error');
                                    Stencil.kill();
                                    LogUtils.log.simple([event, err], true);
                                    var msg = {
                                        response: err
                                    };
                                    try {
                                        msg.raw = {
                                            code: err.code,
                                            hostname: err.hostname,
                                            message: err.message,
                                            name: err.name,
                                            region: err.region,
                                            time: err.time
                                        };
                                    } catch(exception) {}
                                    RequestUtils.report('image:upload/error', msg);
                                },
                                'upload/success': function(event, response) {
                                    this.set({
                                        'uploaded': 1,
                                        'uploadedTimestamp': 1,
                                        'settings.icons': JSON.stringify(
                                            this.getTheNounProjectIcons()
                                        )
                                    });
                                    this.save([
                                        'uploaded',
                                        'uploadedTimestamp',
                                        'settings.icons'
                                    ]);
                                    if (context === 'save') {
                                        this.once({
                                            'update/uploaded': function(event) {
                                                var category = CategoryUtils.account.list('images'),
                                                    model = Stencil.getModel('Image');
                                                model.feature(
                                                    this.get('key'),
                                                    {
                                                        category: category.get('key')
                                                    }
                                                );
                                            }
                                        });
                                    }
                                    this.preload(function(references) {
                                        this.triggerHandler('preload');
                                    });
                                }
                            });
                            try {
                                model.uploadDataURL(
                                    dataURL,
                                    saving.get('key'),
                                    saving
                                );

                                // Send response to callback if defined
                                callback && callback.apply(_this, [saving, dataURL]);
                            } catch (err) {
                                Stencil.alert('image.upload.exception');
                                Stencil.kill();
                            }
                        }
                    });
                },

                /**
                 * I wait for the render event, rather than the draw, to allow
                 * for filters that may take some time to be applied, to be
                 * applied. Without this listener, filters weren't coming
                 * through in the data
                 */
                'render': function(event) {
                    // var _this = this;
                    // setTimeout(function() {
                    //     _this.export(contentType, true);
                    // }, 10000);
                    this.export(contentType, true);
                }
            });
            Canvases.Ghost.draw();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * StageHeaderView
     * 
     * @events  menu/close
     *          menu/open
     * @extends View
     */
    window.StageHeaderView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'div.popover div.content > a': function(event, $anchor) {
                        this.triggerHandler('menu/close');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @note    I needed to add a 0 millisecond delay to get the
                     *          event triggering at the end of the call-stack.
                     *          This is because I believe Headway is cancelling
                     *          out right away. Namely, it opens the menu, and
                     *          then hide's it immediately.
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.notifications': function(event, $div) {
                        var $target = $(event.target);
                        if ($target.hasClass('icon') === true) {
                            (function() {
                                $div.find('#HW_badge_cont').trigger('click');
                            }).delay(0);
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageHeaderView')
         */
        _string: 'StageHeaderView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupHeadway();
            this.on({
                'menu/close': function(event) {
                    this.find('div.text').removeClass('expanded');
                },
                'menu/open': function(event) {
                    var _this = this;
                    this.find('div.text').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover').length === 0) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.which === 27) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                    // var escape = function(event) {
                    //     if (event.which === 27) {
                    //         _this.triggerHandler('menu/close');
                    //         App.getElement().unbind('keydown', escape);
                    //     }
                    // };
                    // App.getElement().on({
                    //     'keydown': escape
                    // });
                    // App.getElement().one({
                    //     'mousedown': function(event) {
                    //         _this.triggerHandler('menu/close');
                    //         App.getElement().unbind('keydown', escape);
                    //     }
                    // });
                },
                'logout': function(event) {
                    // App.getBusy().show();
                    User.logout();//.delay(1000);
                    // User.logout.delay(1000);
                }
            });
            var _this = this;
            Stencil.account().on({
                'change': function(event) {
                    var remaining = this.getImagesRemaining(),
                        $count = _this.find('div.count');
                    $count.text(remaining);
                    $count.attr('class', 'count');
                    if (remaining <= 0) {
                        $count.addClass('red');
                    } else if (remaining < 4) {
                        $count.addClass('orange');
                    }

                    // Date
                    var $date = _this.find('div.date'),
                        $strong = $date.find('strong'),
                        refillDate = this.getRefillDate();
                    $strong.text(refillDate);
                }
            });
            User.once({
                'login': this.render.proxy(this),
                'signup': this.render.proxy(this)
            });
            Account.once({
                'upgrade': this.render.proxy(this)
            });
        },

        /**
         * _setupHeadway
         * 
         * @access  protected
         * @return  Boolean
         */
        _setupHeadway: function() {
            if (Config.serviceAvailable('headway') === false) {
                return false;
            }
            App.getElement().on({
                'keydown': function(event) {
                    if (event.which === 27) {
                        if ($(this).find('#HW_badge_cont').length > 0) {
                            ClientWrappers.get('headway').hide();
                        }
                    }
                },
                'mousedown': function(event) {
                    if ($(this).find('#HW_badge_cont').length > 0) {
                        ClientWrappers.get('headway').hide();
                    }
                }
            });
            var $notifications = this.find('div.notifications');
            ClientWrappers.get('headway').once({
                'failed': function(event) {
                    $notifications.on({
                        'click': function(event) {
                            Stencil.alert('scripts.headway.failed');
                        }
                    });
                }
            });
            var clientWrapper = ClientWrappers.get('headway');
            User.once({
                'login': clientWrapper.setup.proxy(clientWrapper),
                'signup': clientWrapper.setup.proxy(clientWrapper)
            });
            return true;
        },

        /**
         * render
         * 
         * @access  public
         * @return  void
         */
        render: function() {
            var $header = DataUtils.render('StageHeader', {
                account: Stencil.account()
            });
            this._element.replaceWith($header);
            this._element = $header;
            this._setupListeners();
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * StageView
     * 
     * @extends View
     */
    window.StageView = View.extend({

        /**
         * _content
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _content: null,

        /**
         * _footer
         * 
         * @access  protected
         * @var     null|StageFooterView (default: null)
         */
        _footer: null,

        /**
         * _header
         * 
         * @access  protected
         * @var     null|StageHeaderView (default: null)
         */
        _header: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageView')
         */
        _string: 'StageView',

        /**
         * init
         * 
         * @note    Purposelly ordered the drawing so that the content is drawn
         *          last, to ensure that the height is properly calculated for
         *          the canvas.
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawHeader();
            this._drawFooter();
            this._drawContent();
            this._setupHide();
            // this.find('> div.spinner').addClass('invisible');
        },

        /**
         * _drawContent
         * 
         * @access  protected
         * @return  void
         */
        _drawContent: function() {
            var $content = DataUtils.render('StageContent');
            this.find('> div.inner > footer').before($content);
            this._content = new StageContentView($content);
        },

        /**
         * _drawFooter
         * 
         * @access  protected
         * @return  void
         */
        _drawFooter: function() {
            var $footer = DataUtils.render('StageFooter');
            this.find('> div.inner').append($footer);
            this._footer = new StageFooterView($footer);
        },

        /**
         * _drawHeader
         * 
         * @access  protected
         * @return  void
         */
        _drawHeader: function() {
            var $header = DataUtils.render('StageHeader', {
                account: Stencil.account()
            });
            this.find('> div.inner').append($header);
            this._header = new StageHeaderView($header);
        },

        /**
         * _setupHide
         * 
         * @access  protected
         * @return  void
         */
        _setupHide: function() {
            this.on({
                'hide': App.hide.proxy(App)
            });
        },

        /**
         * fontsDropzoneVisible
         * 
         * @access  public
         * @return  Boolean
         */
        fontsDropzoneVisible: function() {
            return this.find('.fontsDropdown .prompt.visible').filter(':visible').length === 1;
        },

        /**
         * getContent
         * 
         * @access  public
         * @return  StageContentView
         */
        getContent: function() {
            return this._content;
        },

        /**
         * getFooter
         * 
         * @access  public
         * @return  StageFooterView
         */
        getFooter: function() {
            return this._footer;
        },

        /**
         * getHeader
         * 
         * @access  public
         * @return  StageHeaderView
         */
        getHeader: function() {
            return this._header;
        }
    });
});
window.DependencyLoader.push('View', function() {

    /**
     * ToolbarView
     * 
     * @fires   show
     *          hide
     * @extends View
     */
    window.ToolbarView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        // _listeners: function() {
        //     return DataUtils.merge(this._super(), {
        //         mouseover: {
        //             'input[type="range"]': function(event, $range) {
        //                 $range.addClass('active');
        //             }
        //         }
        //     });
        // },

        /**
         *_colorPickers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _colorPickers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ToolbarView')
         */
        _string: 'ToolbarView',

        /**
         * _toolbars
         * 
         * @access  protected
         * @var     null|ToolbarsView (default: null)
         */
        _toolbars: null,

        /**
         * _visible
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _visible: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._colorPickers = {};
            this._toolbars = toolbars;
            this._super(element);
            this.on({
                'change/order/back': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/order', [false]);
                    this.order.auto.apply(this);
                },
                'change/order/forward': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/order', [true]);
                    this.order.auto.apply(this);
                },
                'clone': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('clone');
                },
                'delete': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('delete');
                }
            });
        },

        /**
         * _positionTooltip
         * 
         * @access  protected
         * @param   jQuery $range
         * @return  void
         */
        _positionTooltip: function($range) {
            var $tooltip = $range.siblings('.tooltip');
            if ($tooltip.length > 0) {
                var value = $range.val().toFloat(),
                    uiValue = value;
                if ($range.attr('data-ui-value') !== undefined) {
                    uiValue = $range.attr('data-ui-value');
                }
                $tooltip.find('.tooltip-inner').text(uiValue);
                var max = $range.attr('max').toFloat(),
                    min = $range.attr('min').toFloat(),
                    paddingLeft = $range.parent().css('padding-left').toFloat(),
                    rangeWidth = $range.css('width').toFloat(),
                    tooltipWidth = $tooltip.css('width').toFloat(),
                    thumbWidth = 16,
                    left = 0;
                left = left + paddingLeft;
                left = left - (tooltipWidth / 2);
                left = left + (thumbWidth / 2);
                left = left + (rangeWidth - thumbWidth) * ((value - min) / (max - min));
                $tooltip.css({
                    left: left.round(0) + ('px')
                });
            }
        },

        /**
         * _drawColorPicker
         * 
         * @access  protected
         * @param   jQuery $input
         * @param   Object options
         * @return  ColorPickerView
         */
        _drawColorPicker: function($input, options) {
            var $colorPicker = DataUtils.render('ColorPicker'),
                colorPicker = new ColorPickerView(
                    $colorPicker,
                    $input,
                    this,
                    options
                );
            return colorPicker;
        },

        /**
         * _getSelectedLayer
         * 
         * @access  protected
         * @return  false|Layer
         */
        _getSelectedLayer: function() {
            var layer = Canvases.Preview.getSelectedLayer();
            return layer;
        },

        /**
         * _reposition
         * 
         * @access  protected
         * @return  void
         */
        _reposition: function() {
            var height = this._element.outerHeight(),
                $inner = this._element.parent().parent(),
                innerHeight = $inner.outerHeight(),
                $sizing = App.getStage().getContent().find('section.sizing'),
                sizingHeight = $sizing.outerHeight(),
                topPull = (height - innerHeight) / 2 + (sizingHeight / 2),
                $caret = this.find('> div.content > div.stencil-caret');
            this._element.css({
                'top': (0 - topPull) + 'px'
            });
            $caret.css({
                'top': 'calc(50% - 9px)'
            });
        },

        /**
         * _setupStrengthSlider
         * 
         * @access  protected
         * @param   String type
         * @return  void
         */
        _setupStrengthSlider: function(type) {
            var _this = this,
                label = (type) + 'Strength',
                selector = 'input[type="range"][name="' + (label) + '"]',
                $range = this.find(selector),
                listener = function(event) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        layer.triggerHandler('change/' + (label), [value]);

                        // Ensure anchor is / isn't showing (where appropriate)
                        _this.clearAllAnchor.reset.apply(_this);
                    }
                },
                filterResampleDelay = Config.getFilterResampleDelay();
            if (UserAgentUtils.is.ie() === true) {
                $range.on({
                    'change': _.debounce(listener, filterResampleDelay)
                });
                $range.on({
                    'change': function(event) {
                        _this._positionTooltip($range);
                    }
                });
            } else {
                $range.on({
                    'input': _.debounce(listener, filterResampleDelay)
                });
                $range.on({
                    'input': function(event) {
                        _this._positionTooltip($range);
                    }
                });
            }

            // Change history
            $range.on({
                'mouseup': function(event) {
                    (function() {
                        App.triggerHandler('changeHistory/track');
                    }).delay(filterResampleDelay);
                }
            });
        },

        /**
         * _setupTooltip
         * 
         * @access  protected
         * @param   String name
         * @return  void
         */
        _setupTooltip: function(name) {
            var $range = this.find('input[name="' + (name) + '"]');
            $range.after('' +
                '<div class="tooltip bottom" lookup="tooltip/' + (name) + '">' +
                    '<div class="tooltip-arrow"></div>' +
                    '<div class="tooltip-inner">#</div>' +
            '</div>');
        },

        /**
         * colorPickerVisible
         * 
         * @access  public
         * @return  Boolean
         */
        colorPickerVisible: function() {
            var index;
            for (index in this._colorPickers) {
                if (this._colorPickers[index].visible() === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * getToolbars
         * 
         * @access  public
         * @return  null|ToolbarsView
         */
        getToolbars: function() {
            return this._toolbars;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            if (this._visible === true) {
                this._visible = false;
                this._element.addClass('hidden');
                this.triggerHandler('hide');
                Toolbars.setVisibleToolbar(false);
            }
        },

        /**
         * order
         * 
         * @access  public
         * @var     Object
         */
        order: {

            /**
             * auto
             * 
             * Enables/disables the ordering UI options by checking the selected
             * layer's position within the other layers.
             * 
             * @access  public
             * @return  void
             */
            auto: function() {
                var layer = Canvases.Preview.getSelectedLayer();
                this.order.enable.apply(this);
                if (layer.front() === true) {
                    this.order.disable.apply(this, ['forward']);
                }
                if (layer.back() === true) {
                    this.order.disable.apply(this, ['back']);
                }
            },

            /**
             * disable
             * 
             * @access  public
             * @param   String direction
             * @return  void
             */
            disable: function(direction) {
                var selector = 'a[direction="' + (direction) + '"]';
                this.find(selector).disable();
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                this.find('div.tool.layer').find('a').enable();
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            if (this._visible === false) {
                this._visible = true;
                this._element.removeClass('hidden');
                this.triggerHandler('show');
                Toolbars.setVisibleToolbar(this);
                this._reposition();
            }
        }
    });
});
window.DependencyLoader.push('BitmapImageToolbarView', function() {

    /**
     * BackgroundBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.BackgroundBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundBitmapImageToolbarView')
         */
        _string: 'BackgroundBitmapImageToolbarView',

        /**
         * _toolbarType
         * 
         * @access  protected
         * @var     String (default: 'backgroundBitmapImage')
         */
        _toolbarType: 'backgroundBitmapImage',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupBackgroundClear();
            this._setupBackgroundUpload();
            this._listenForConversion();
        },

        /**
         * _listenForConversion
         * 
         * @note    See ForegroundBitmapImageToolbarView for an important note on
         *          this method.
         * @access  protected
         * @return  void
         */
        _listenForConversion: function() {
            this.on({
                'convert/foreground': function(event) {
                    var canvas = Canvases.Preview,
                        selectedLayer = canvas.getSelectedLayer(),
                        key = selectedLayer.getProperty('image'),
                        locked = selectedLayer.getProperty('locked'),
                        cropPositionData = selectedLayer.getProperty('cropPositionData') || {},
                        cropSourceKey = selectedLayer.getProperty('cropSourceKey') || '',
                        accessor = Stencil.getAccessor(key),
                        start = new Date(),
                        busy = canvas.getBusy();
                    if (accessor === false) {
                        if (key.match(/^asst/) !== null) {
                            accessor = Stencil.setAccessor(key, 'PhotoAsset', {
                                key: key
                            });
                        } else if (key.match(/^img0/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Image', {
                                key: key
                            });
                        } else if (key.match(/^upld/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Upload', {
                                key: key
                            });
                        } else {
                            var msg = 'Invalid type during convert/foreground';
                            throw new Error(msg);
                            // accessor = Stencil.setAccessor(key, 'Resource', {
                            //     key: key
                            // });
                        }
                    }
                    Toolbars.hide();
                    ChangeHistory.clearOperationType();
                    selectedLayer.setChangeOperationType('convert:foreground');
                    canvas.clearBackgroundImageLayer();
                    var layer = accessor.addForegroundBitmapImageLayer(locked, {
                        animate: false,
                        autoSelect: false,
                        cropPositionData: cropPositionData,
                        cropSourceKey: cropSourceKey
                    });
                    layer.getDrawing().once({
                        'draw': function(event) {
                            busy.hide.minDelay(start, 300, busy);
                            this.select.minDelay(start, 300, this);
                        }
                    });
                    busy.show();
                }
            });
        },

        /**
         * _setupBackgroundClear
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundClear: function() {
            this.on({
                'clear': function(event, $anchor) {
                    var canvas = Canvases.Preview;
                    canvas.getSelectedLayer().setChangeOperationType('deleted');
                    canvas.clearBackgroundImageLayer();
                    canvas.render();
                    canvas.getBackgroundRectangleLayer().select();
                }
            });
        },

        /**
         * _setupBackgroundUpload
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundUpload: function() {
            this.on({
                'upload': function(event, $anchor) {
                    var uploads = App.getEditor().getArea('uploads'),
                        dropzone = uploads.getDropzone();
                    dropzone.unbind('start');
                    dropzone.once({
                        'start': function(event) {
                            Stencil.navigate('/app/uploads');
                            Canvases.Preview.deselectSelectedLayer();
                        }
                    });
                    dropzone.find('input[type="file"].files').trigger('click');
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            var content = App.getStage().getContent();
            content.handles.show.apply(content);
        }
    });
});
window.DependencyLoader.push('ToolbarView', function() {

    /**
     * BackgroundRectangleToolbarView
     * 
     * @extends ToolbarView
     */
    window.BackgroundRectangleToolbarView = ToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * backgroundColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'backgroundColor': function(rgbaColorStr) {
                this._colorPickers.backgroundColor.setColor(
                    rgbaColorStr,
                    false
                );
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundRectangleToolbarView')
         */
        _string: 'BackgroundRectangleToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupBackgroundColor();
            this._setupUpload();
            this.on({
                'clear/backgroundColor': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.backgroundColor.clear.apply(this);
                    layer.triggerHandler('clear/backgroundColor');
                }
            });
        },

        /**
         * backgroundColor
         * 
         * @access  protected
         * @var     Object
         */
        backgroundColor: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $backgroundColor = this.find('[name="backgroundColor"]');
                this._colorPickers.backgroundColor.clearMinicolors();
                // this._colorPickers.backgroundColor.setColor(
                //     ColorUtils.getWhite('rgba', 0),
                //     true
                // );
            }
        },

        /**
         * _setupBackgroundColor
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundColor: function() {
            var _this = this,
                $input = this.find('[name="backgroundColor"]'),
                colorPicker = this._drawColorPicker($input);
            this._colorPickers.backgroundColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/backgroundColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr, false]);
                    // _this.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupUpload
         * 
         * @access  protected
         * @return  void
         */
        _setupUpload: function() {
            this.on({
                'upload': function(event, $anchor) {
                    var uploads = App.getEditor().getArea('uploads'),
                        dropzone = uploads.getDropzone();
                    dropzone.unbind('start');
                    dropzone.once({
                        'start': function(event) {
                            Stencil.navigate('/app/uploads');
                            Canvases.Preview.deselectSelectedLayer();
                        }
                    });
                    dropzone.find('input[type="file"].files').trigger('click');
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            var layer = this._getSelectedLayer();
            this.order.auto.apply(this);
            var backgroundColor = layer.getStyle('backgroundColor');
            if (ColorUtils.addSpaces(backgroundColor) === ColorUtils.getBlack('rgba', 0)) {
                this.backgroundColor.clear.apply(this);
            } else {
                this._set.backgroundColor.apply(
                    this,
                    [backgroundColor]
                );
            }
            var content = App.getStage().getContent();
            content.handles.show.apply(content);
            this._colorPickers.backgroundColor.removeLastChange();
        }
    });
});
window.DependencyLoader.push('ImageToolbarView', function() {

    /**
     * BitmapImageToolbarView
     * 
     * @extends ImageToolbarView
     */
    window.BitmapImageToolbarView = ImageToolbarView.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _colorOverlayColorPickerOpenDirection
         * 
         * @access  protected
         * @var     String (default: 'up')
         */
        _colorOverlayColorPickerOpenDirection: 'up',

        /**
         * _cropperModalMinDelay
         * 
         * Number of milliseconds to wait, at a minimum, before show the cropper
         * modal.
         * 
         * @access  protected
         * @var     Number (default: 850)
         */
        _cropperModalMinDelay: 850,

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * blurStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'blurStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="blurStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * colorOverlay
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'colorOverlay': function(rgbaColorStr) {
                this._colorPickers.colorOverlay.setColor(rgbaColorStr, false);
            },

            /**
             * colorOverlayStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'colorOverlayStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="colorOverlayStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * darkenStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'darkenStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="darkenStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * lightenStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'lightenStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="lightenStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * opacityStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'opacityStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="opacityStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BitmapImageToolbarView')
         */
        _string: 'BitmapImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupColorOverlay();
            this._setupStrengthSlider('blur');
            this._setupStrengthSlider('colorOverlay');
            this._setupStrengthSlider('darken');
            this._setupStrengthSlider('lighten');
            this._setupStrengthSlider('opacity');
            this._setupTooltips();
            this._listenForPresetFilterEvents();
            this._addCropListener();
            if (UserAgentUtils.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }

            // Color Overlay
            this.on({

                /**
                 * (anonymous)
                 * 
                 * @note    I need to use the show method (instead of the reset
                 *          method) here, because BitmapImage layers debounce
                 *          before adding a filter object to the filters-array.
                 *          This can be seen in the BitmapImage.js layer class.
                 */
                'change/colorOverlay': function(event) {
                    this.colorOverlay.show.apply(this);
                    this.clearAllAnchor.show.apply(this);
                },
                'clear/all': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    layer.filters.clear.apply(layer);
                    Toolbars.hide();
                    this.show({
                        focusOnActiveFilter: false
                    });
                    layer.setChangeOperationType('filter:allCleared');
                },
                'clear/colorOverlay': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.colorOverlay.clear.apply(this);
                    this._set.colorOverlayStrength.apply(this, [0]);
                    layer.triggerHandler('clear/colorOverlay');
                    this.clearAllAnchor.reset.apply(this);
                }
            });

            // Firefox scrollbar init
            this.once({
                'show': function(event) {
                    this._refreshScrollbar();
                }
            });
        },

        /**
         * _addCropListener
         * 
         * @access  protected
         * @return  void
         */
        _addCropListener: function() {
            this.on({
                'crop': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', true);
                    if (this._imagePropertyIsResource() === false) {
                        var modal = this._showCropperModal();
                        modal.once({
                            'close': function() {
                                Stencil.set('ignoreMouseDownLayerBlur', false);
                            }
                        });
                    } else {
                        var resource = this._getImagePropertyResourceAccessor();
                        if (resource !== false) {
                            var _this = this,
                                msg = Config.getMessage('app.crop.resource.saving');
                            App.getBusy().show(msg);
                            resource.once({
                                'save': function(event) {
                                    var modal = _this._showCropperModal();
                                    modal.once({
                                        'close': function() {
                                            Stencil.set('ignoreMouseDownLayerBlur', false);
                                        }
                                    });
                                }
                            });
                            resource.save();
                        }
                    }
                }
            });
        },

        /**
         * _focusOnActiveFilter
         * 
         * Focuses on the active filter (always one, since No Filter is an
         * option). Takes into consideration custom scrollbars, and when that's
         * the case, nulls the left margin calculation, since it's not used
         * with custom scrollbars.
         * 
         * Also note that it's important that the offset calculation occurs
         * after the scrollLeft offset reset (to value: 0), since not doing so
         * messes up things (not sure why at the moment).
         * 
         * @access  protected
         * @return  void
         */
        _focusOnActiveFilter: function() {
            var $content = this.find('div.tool.filters div.content'),
                $ul = $content.find('ul'),
                $li = $ul.find('li.active'),
                $thumb = $li.find('div.thumb');
            if ($li.length > 0) {
                if (UserAgentUtils.supports.css.scrollbars() === false) {
                    this._$scrollbar.data('jsp').scrollToX(0, false);
                    var offset = $li.position().left
                        - (
                            $ul.width() - $thumb.width()
                        ) / 2;
                    this._$scrollbar.data('jsp').scrollToX(offset, false);
                } else {
                    $content.animate({
                        scrollLeft: 0
                    }, 0);
                    var offset = $li.position().left
                        - $content.css('margin-left').toInt()
                        - (
                            $ul.width() - $thumb.width()
                        ) / 2;
                    $content.animate({
                        scrollLeft: offset
                    }, 0);
                }
            }
        },

        /**
         * _getCropKey
         * 
         * @access  protected
         * @return  String
         */
        _getCropKey: function() {
            var canvas = Canvases.Preview,
                selectedLayer = canvas.getSelectedLayer(),
                cropSourceKey = selectedLayer.getProperty('cropSourceKey');
            if (cropSourceKey === '') {
                var key = selectedLayer.getProperty('image');
                return key;
            }
            if (cropSourceKey === undefined) {
                var key = selectedLayer.getProperty('image');
                return key;
            }
            var key = cropSourceKey;
            return key;
        },

        /**
         * _getImagePropertyResourceAccessor
         * 
         * @access  protected
         * @return  false|ResourceAccessor
         */
        _getImagePropertyResourceAccessor: function() {
            var canvas = Canvases.Preview,
                selectedLayer = canvas.getSelectedLayer(),
                key = selectedLayer.getProperty('image'),
                accessor = Stencil.getAccessor(key);
            return accessor;
        },

        /**
         * _imagePropertyIsResource
         * 
         * @access  protected
         * @return  Boolean
         */
        _imagePropertyIsResource: function() {
            var canvas = Canvases.Preview,
                selectedLayer = canvas.getSelectedLayer(),
                key = selectedLayer.getProperty('image');
            if (key.indexOf(':') === -1) {
                return false;
            }
            return true;
        },

        /**
         * _listenForPresetFilterEvents
         * 
         * @note    I am adding an empty properties object when triggering a
         *          filter addition to ensure a consistent JSON makeup of filter
         *          objects. If I don't do this, Footer.js's changedCanvas method
         *          will fail, because the signature of a filter will sometimes
         *          include a properties object (because of the _normalizeFilters
         *          method in BitmapImage layers), and sometimes now.
         * @access  protected
         * @return  void
         */
        _listenForPresetFilterEvents: function() {
            this.on({
                'setFilter': function(event, $element) {
                    if ($element.hasClass('active') === false) {
                        var filter = $element.attr('filter'),
                            layer = this._getSelectedLayer(),
                            filters = layer.getProperty('filters');

                        // 
                        var blacklist = ['blur', 'colorOverlay', 'darken', 'lighten', 'opacity'];
                        for (var i = filters.length - 1; i >= 0; i--) {
                            if (ArrayUtils.contains(filters[i].type, blacklist) === false) {
                                // layer.set({'renderFilters': true});
                                layer.triggerHandler('filter/remove', [filters[i]]);
                            }
                        }
// LogUtils.log.simple([filters[i], obj], true);
//                             if (filters[i].type === obj.type) {
//                                 filters.splice(i, 1);
//                             }
//                         }
//                         var cotton = this.getCotton(),
//                             filters = cotton.filters || [];
//                         for (var i = filters.length - 1; i >= 0; i--) {
//                         jQuery.each(filters, function(index, obj) {
//                             if (ArrayUtils.contains(obj.type, blacklist) === false) {
//                                 layer.triggerHandler('filter/remove', [obj]);
//                             }
//                         });

                        // Add filter and refresh the UI
                        layer.set({'renderFilters': true});
                        if (filter !== 'noFilter') {
                            layer.triggerHandler('filter/add', [{
                                type: filter,
                                properties: {}
                            }]);
                            layer.setChangeOperationType('filter:preset:set');
                        } else {
                            Canvases.Preview.render();
                            layer.setChangeOperationType('filter:preset:cleared');
                        }

                        // Ensure anchor is / isn't showing (where appropriate)
                        this.clearAllAnchor.reset.apply(this);

                        // UI in toolbar
                        var $filters = this.find('li[filter]'),
                            $filter = this.find('li[filter="' + (filter) + '"]'),
                            cotton = layer.getDrawing().getCotton(),
                            callback = function() {
                                $filters.enable();
                                cotton.off('applyFilters/complete', callback);
                                $filter.removeClass('loading');
                                $filter.addClass('active');
                            };
                        $filters.disable();
                        $filters.removeClass('active');
                        $filters.removeClass('loading');
                        if (filter === 'noFilter') {
                            callback();
                        } else {
                            $filter.addClass('loading');
                            cotton.on({
                                'applyFilters/complete': callback
                            });
                        }
                    }
                }
            });
        },

        /**
         * _loadCropperDependencies
         * 
         * @access  protected
         * @return  Boolean
         */
        _loadCropperDependencies: function() {
            var key = this._getCropKey();
            if (StringUtils.contains(key, ':') === true) {
                return false;
            }
            DataUtils.requestMediaObject(key, function(accessor) {
                accessor.loadCropperDependencies();
            });
            return false;
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200
            });
        },

        /**
         * _refreshScrollbar
         * 
         * @note    The jsp check is done after discovering a number of bugs in
         *          Sentry. The bugs were related to the
         *          WatermarkBitmapImageToolbarView. It seems that since the
         *          .filters element is hidden, the below reinitialise call
         *          would fail.
         * @access  protected
         * @return  void
         */
        _refreshScrollbar: function() {
            if (this._$scrollbar !== null) {
                var jsp = this._$scrollbar.data('jsp');
                if (jsp !== undefined) {
                    jsp.reinitialise();
                }
            }
        },

        /**
         * _setupColorOverlay
         * 
         * @access  protected
         * @return  void
         */
        _setupColorOverlay: function() {
            var _this = this,
                openDirection = this._colorOverlayColorPickerOpenDirection,
                $input = this.find('[name="colorOverlay"]'),
                colorPicker = this._drawColorPicker($input, {
                    openDirection: openDirection,
                    showOpacitySlider: false

                });
            this._colorPickers.colorOverlay = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/colorOverlay',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(
                        type,
                        [rgbaColorStr]
                    );
                    _this.triggerHandler(type, [rgbaColorStr]);
                },
                'show': function(event) {
                    var layer = _this._getSelectedLayer(),
                        callback = function(event) {
                            var filter = this.filters.get.apply(this, ['colorOverlay']),
                                strength = filter.properties.strength;
                            _this._set.colorOverlayStrength.apply(_this, [strength]);
                        };
                    layer.once({
                        'filter/add': callback
                    });
                    this.once({
                        'hide': function(event) {
                            layer.unbind('filter/add', callback);
                        }
                    })
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @see     https://jsfiddle.net/8bnp7c39/8/
         * @access  public
         * @return  void
         */
        _setupScrollbars: function() {
            var $filters = this.find('div.tool.filters');
            if ($filters.length > 0) {
                this._makeScrollable($filters.find('.content'));
            }
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._setupTooltip('blurStrength');
            this._setupTooltip('opacityStrength');
            this._setupTooltip('lightenStrength');
            this._setupTooltip('darkenStrength');
            this._setupTooltip('colorOverlayStrength');
        },

        /**
         * _showCropperModal
         * 
         * @access  protected
         * @return  AlertModalView|CropperModalView
         */
        _showCropperModal: function() {
            if (Config.serviceAvailable('cropper') === false) {
                var alertModal = Stencil.alert('services.cropper.unavailable');
                return alertModal;
            }
            var start = new Date(),
                canvas = Canvases.Preview,
                selectedLayer = canvas.getSelectedLayer(),
                key = this._getCropKey(),
                delay = this._cropperModalMinDelay,
                modal = ModalUtils.showCropper(key),
                msg = Config.getMessage('app.crop.preparing');
            // this.hide();
            // this._hideActiveThumb();
            this.ui.cropper.badge.hide.apply(this);
            modal.setSource('toolbar');
            modal.setSourceType(this._toolbarType);
            modal.setBitmapImageLayer(selectedLayer);
            App.getBusy().show(msg);
            modal.once({
                'cropper/ready': function(event) {
                    (function() {
                        var cropPositionData = selectedLayer.getCropBoxPositionData();
                        this.setCropBox(cropPositionData);
                        if (cropPositionData.x !== undefined) {
                            var x = cropPositionData.x,
                                y = cropPositionData.y,
                                width = cropPositionData.width,
                                height = cropPositionData.height;
                            this.resizeCropBox(width, height);
                            this.moveCropBox(x, y);
                        }
                        App.getBusy().hide();
                        modal.getElement().removeClass('invisible');
                    }).minDelay(start, delay, this);
                }
            });
            return modal;
        },

        /**
         * colorOverlay
         * 
         * @access  public
         * @var     Object
         */
        colorOverlay: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $lookup = this.find('[lookup="clear/colorOverlay"]');
                $lookup.addClass('hidden');
                this._colorPickers.colorOverlay.clearMinicolors();
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the stroke
             * color input (when a value is defined).
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $outline = this.find('[name="colorOverlay"]'),
                    $clear = $outline.closest('div.column').find('a');
                $clear.addClass('hidden');
                if ($outline.val() !== '') {
                    $clear.removeClass('hidden');
                }
            }
        },

        /**
         * clearAllAnchor
         * 
         * @access  public
         * @var     Object
         */
        clearAllAnchor: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.removeClass('hidden');
            },

            /**
             * reset
             * 
             * @access  public
             * @return  void
             */
            reset: function() {
                var layer = this._getSelectedLayer(),
                    filters = layer.getProperty('filters');
                this.clearAllAnchor.hide.apply(this);
                if (filters.length > 0) {
                    this.clearAllAnchor.show.apply(this);
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @param   undefined|Object options (default: {})
         * @return  void
         */
        show: function(options) {
            options = DataUtils.getDefaultValue(options, {});
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            var layer = this._getSelectedLayer(),
                filters = layer.getProperty('filters');
            this.find('[filter]').removeClass('active');
            this.find('[filter="noFilter"]').addClass('active');
            this.clearAllAnchor.reset.apply(this);
            if (filters.length > 0) {
                var index, type;
                for (index in filters) {
                    type = filters[index].type
                    if (this.find('[filter="' + (type) + '"]').length > 0) {
                        this.find('[filter]').removeClass('active');
                        this.find('[filter="' + (type) + '"]').addClass('active');
                        break;
                    }
                }
            }

            // Whether to auto scroll to the active filter
            if (
                options.focusOnActiveFilter === undefined
                || options.focusOnActiveFilter === true
            ) {
                this._focusOnActiveFilter();
            }

            // Color Overlay
            // if (layer.getStyle('colorOverlay') !== false) {
            //     this._set.colorOverlay.apply(
            //         this,
            //         [layer.getStyle('colorOverlay')]
            //     );
            //     this.colorOverlay.show.apply(this);
            // } else {
            //     this.colorOverlay.clear.apply(this);
            // }

            // 
            this._colorPickers.colorOverlay.removeLastChange();

            /**
             * Secondary filters
             * 
             */

            // Blur
            var filter = layer.filters.get.apply(layer, ['blur']),
                strength = filter === false ? 0 : filter.properties.strength;
            this._set.blurStrength.apply(this, [strength]);

            // Opacity
            filter = layer.filters.get.apply(layer, ['opacity']);
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.opacityStrength.apply(this, [strength]);

            // Lighten
            filter = layer.filters.get.apply(layer, ['lighten']);
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.lightenStrength.apply(this, [strength]);

            // Darken
            filter = layer.filters.get.apply(layer, ['darken']);
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.darkenStrength.apply(this, [strength]);

            // Color Overlay (strength)
            filter = layer.filters.get.apply(layer, ['colorOverlay']);
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.colorOverlayStrength.apply(this, [strength]);

            // Color Overlay (color)
            filter = layer.filters.get.apply(layer, ['colorOverlay']);
            if (filter !== false) {
                var color = filter.properties.color;
                color = ColorUtils.convert(color, 'rgba');
                this._set.colorOverlay.apply(this, [color]);
                this.colorOverlay.show.apply(this);
            } else {
                this.colorOverlay.clear.apply(this);
            }

            /**
             * Crop badge
             * 
             */
            var account = Stencil.account();
            this.ui.cropper.badge.hide.apply(this);
            if (account.getOnboardingValue('cropperOpened') !== true) {
                this.ui.cropper.badge.show.apply(this);
            }

            /**
             * Cropper preload
             * 
             */
            this._loadCropperDependencies();

            /**
             * Re-Crop UI
             * 
             */
            var $crop = this.find('div.column[lookup="crop"]'),
                cropPositionData = layer.getProperty('cropPositionData');
            $crop.removeClass('re-crop');
            if (DataUtils.valid(cropPositionData) === true) {
                if (cropPositionData.shape !== undefined) {
                    $crop.addClass('re-crop');
                }
            }
        }
    });
});
window.DependencyLoader.push('ImageToolbarView', function() {

    /**
     * ColorVectorImageToolbarView
     * 
     * @extends ImageToolbarView
     */
    window.ColorVectorImageToolbarView = ImageToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * opacityStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'opacityStrength': function(strength) {
                var $range = this.find(
                        'input[type="range"][name="opacityStrength"]'
                    ),
                    rangeValue = 100 - (strength * 100).round(0);
                $range.val(rangeValue);
                this._positionTooltip($range);
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorVectorImageToolbarView')
         */
        _string: 'ColorVectorImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupStrengthSlider('opacity');
            this._setupTooltips();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._setupTooltip('opacityStrength');
        },

        /**
         * clearAllAnchor
         * 
         * @access  public
         * @var     Object
         */
        clearAllAnchor: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.removeClass('hidden');
            },

            /**
             * reset
             * 
             * @access  public
             * @return  void
             */
            reset: function() {
                var layer = this._getSelectedLayer(),
                    filters = layer.getProperty('filters');
                this.clearAllAnchor.hide.apply(this);
                if (filters.length > 0) {
                    this.clearAllAnchor.show.apply(this);
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            var layer = this._getSelectedLayer();
            this.order.auto.apply(this);
            this._set.opacityStrength.apply(this, [layer.getStyle('opacity')]);
        }
    });
});
window.DependencyLoader.push('BitmapImageToolbarView', function() {

    /**
     * ForegroundBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.ForegroundBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ForegroundBitmapImageToolbarView')
         */
        _string: 'ForegroundBitmapImageToolbarView',

        /**
         * _toolbarType
         * 
         * @access  protected
         * @var     String (default: 'foregroundBitmapImage')
         */
        _toolbarType: 'foregroundBitmapImage',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._listenForConversion();
        },

        /**
         * _listenForConversion
         * 
         * @note    It's important that the ChangeHistory.clearOperationType()
         *          call be made, because otherwise, the ChangeHistory would
         *          register the layer being deleted as just that: a deletion.
         *          And what we want is for it to be registered as a conversion.
         *          Here is what the change history looks like when removed (the
         *          first screen shot), and when it's added back in (as it should
         *          be; second screenshot):
         *          https://i.imgur.com/X9jOkWz.png
         *          https://i.imgur.com/AgueWry.png
         * @access  protected
         * @return  void
         */
        _listenForConversion: function() {
            this.on({
                'convert/background': function(event) {
                    var canvas = Canvases.Preview,
                        selectedLayer = canvas.getSelectedLayer(),
                        key = selectedLayer.getProperty('image'),
                        locked = selectedLayer.getProperty('locked'),
                        cropPositionData = selectedLayer.getProperty('cropPositionData') || {},
                        cropSourceKey = selectedLayer.getProperty('cropSourceKey') || '',
                        accessor = Stencil.getAccessor(key),
                        start = new Date(),
                        busy = canvas.getBusy();
                    if (accessor === false) {
                        if (key.match(/^asst/) !== null) {
                            accessor = Stencil.setAccessor(key, 'PhotoAsset', {
                                key: key
                            });
                        } else if (key.match(/^img0/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Image', {
                                key: key
                            });
                        } else if (key.match(/^upld/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Upload', {
                                key: key
                            });
                        } else {
                            var msg = 'Invalid type during convert/background';
                            throw new Error(msg);
                            // accessor = Stencil.setAccessor(key, 'Resource', {
                            //     key: key
                            // });
                        }
                    }
                    Toolbars.hide();
                    canvas.clearBackgroundImageLayer();
                    selectedLayer.triggerHandler('delete');
                    ChangeHistory.clearOperationType();
                    selectedLayer.setChangeOperationType('convert:background');
                    var layer = accessor.setBackgroundBitmapImageLayer(locked, {
                        autoSelect: false,
                        cropPositionData: cropPositionData,
                        cropSourceKey: cropSourceKey
                    });
                    layer.getDrawing().once({
                        'refresh': function(event) {
                            busy.hide.minDelay(start, 300, busy);
                            this.select.minDelay(start, 300, this);
                        }
                    });
                    busy.show();
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            this.order.auto.apply(this);
        }
    });
});
window.DependencyLoader.push('ToolbarView', function() {

    /**
     * ImageToolbarView
     * 
     * @extends ToolbarView
     */
    window.ImageToolbarView = ToolbarView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageToolbarView')
         */
        _string: 'ImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._addFlipListeners();
        },

        /**
         * _addFlipListeners
         * 
         * @access  public
         * @return  void
         */
        _addFlipListeners: function() {
            this.on({
                'flip/x': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        flip = layer.getStyle('flipX') === false;
                    if (layer.getStyle('flipX') === undefined) {
                        flip = true;
                    }
                    this.ui.orientation.x.revert.apply(this);
                    if (flip === true) {
                        this.ui.orientation.x.flip.apply(this);
                    }
                    layer.triggerHandler('flip/x', [flip]);
                },
                'flip/y': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        flip = layer.getStyle('flipY') === false;
                    if (layer.getStyle('flipY') === undefined) {
                        flip = true;
                    }
                    this.ui.orientation.y.revert.apply(this);
                    if (flip === true) {
                        this.ui.orientation.y.flip.apply(this);
                    }
                    layer.triggerHandler('flip/y', [flip]);
                }
            });
        },

        /**
         * ui
         * 
         * @access  public
         * @var     Object
         */
        ui: {

            /**
             * cropper
             * 
             * @access  public
             * @var     Object
             */
            cropper: {

                /**
                 * badge
                 * 
                 * @access  public
                 * @var     Object
                 */
                badge: {

                    /**
                     * hide
                     * 
                     * @access  public
                     * @return  void
                     */
                    hide: function() {
                        var $badge = this.lookup('crop').find('.badge');
                        $badge.addClass('hidden');
                    },

                    /**
                     * show
                     * 
                     * @access  public
                     * @return  void
                     */
                    show: function() {
                        var $badge = this.lookup('crop').find('.badge');
                        $badge.removeClass('hidden');
                    }
                }
            },

            /**
             * orientation
             * 
             * @access  public
             * @var     Object
             */
            orientation: {

                /**
                 * x
                 * 
                 * @access  public
                 * @var     Object
                 */
                x: {

                    /**
                     * flip
                     * 
                     * @access  public
                     * @return  void
                     */
                    flip: function() {
                        var $flipX = this.find('div.column.x');
                        $flipX.addClass('revert');
                    },

                    /**
                     * revert
                     * 
                     * @access  public
                     * @return  void
                     */
                    revert: function() {
                        var $flipX = this.find('div.column.x');
                        $flipX.removeClass('revert');
                    }
                },

                /**
                 * y
                 * 
                 * @access  public
                 * @var     Object
                 */
                y: {

                    /**
                     * flip
                     * 
                     * @access  public
                     * @return  void
                     */
                    flip: function() {
                        var $flipY = this.find('div.column.y');
                        $flipY.addClass('revert');
                    },

                    /**
                     * revert
                     * 
                     * @access  public
                     * @return  void
                     */
                    revert: function() {
                        var $flipY = this.find('div.column.y');
                        $flipY.removeClass('revert');
                    }
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {

            // Defaults
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);

            /**
             * Flip/revert UI
             * 
             */
            var layer = this._getSelectedLayer();
            this.ui.orientation.x.revert.apply(this);
            if (layer.getStyle('flipX') === true) {
                this.ui.orientation.x.flip.apply(this);
            }
            this.ui.orientation.y.revert.apply(this);
            if (layer.getStyle('flipY') === true) {
                this.ui.orientation.y.flip.apply(this);
            }
        }
    });
});
window.DependencyLoader.push('ToolbarView', function() {

    /**
     * TextToolbarView
     * 
     * @fires   change/backdropColor
     *          change/fontFamily
     *          change/strokeColor
     * @extends ToolbarView
     */
    window.TextToolbarView = ToolbarView.extend({

        /**
         * _font
         * 
         * The font that is currently set (used in conjunction with font
         * previewing).
         * 
         * @access  protected
         * @var     false|Object (default: false)
         */
        _font: false,

        /**
         * _fontsDropdown
         * 
         * @access  protected
         * @var     false|FontsDropdownView (default: false)
         */
        _fontsDropdown: false,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return DataUtils.merge(this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input#backdropStretch': function(event, $checkbox) {
                        var checked = $checkbox.prop('checked'),
                            backdropStretch = checked === true
                                ? 'full'
                                : 'slim';
                        this.triggerHandler(
                            'change/backdropStretch',
                            [backdropStretch]
                        );
                    }
                }
            });
        },

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * align
             * 
             * @access  protected
             * @param   String position
             * @return  void
             */
            'align': function(position) {
                this.find('[name^="align"]').removeClass('active');
                this.find('[name="align[' + (position) + ']"]').addClass(
                    'active'
                );
            },

            /**
             * backdropColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'backdropColor': function(rgbaColorStr) {
                this._colorPickers.backdropColor.setColor(rgbaColorStr, false);
            },

            /**
             * backdropStretch
             * 
             * @access  protected
             * @param   String backdropStretch
             * @return  void
             */
            'backdropStretch': function(backdropStretch) {
                var $backdropStretch = this.find('[id="backdropStretch"]');
                $backdropStretch.prop('checked', backdropStretch === 'full');
            },

            /**
             * bold
             * 
             * @access  protected
             * @param   Boolean on
             * @return  void
             */
            'bold': function(on) {
                var $bold = this.find('[name="bold"]');
                $bold.removeClass('active');
                if (on === true) {
                    $bold.addClass('active');
                }
            },

            /**
             * fontFamily
             * 
             * @note    <select> call below triggers dropdown <select>
                        handler, which triggers <change/fontFamily> handler
             * @access  protected
             * @param   String font
             * @return  void
             */
            'fontFamily': function(font) {
                var font = Stencil.account().collection('fonts').findByFamilyName(font);
                this._fontsDropdown.selectFont(font);
            },

            /**
             * fontSize
             * 
             * @access  protected
             * @param   String size
             * @return  void
             */
            'fontSize': function(size) {
                var $range = this.find('input[type="range"][name="fontSize"]'),
                    uiValue = size;
                size = this._getFontSizeStepValue(size);
                $range.attr('data-ui-value', uiValue);
                $range.val(size);
                this._positionTooltip($range);
            },

            /**
             * italic
             * 
             * @access  protected
             * @param   Boolean on
             * @return  void
             */
            'italic': function(on) {
                var $italic = this.find('[name="italic"]');
                $italic.removeClass('active');
                if (on === true) {
                    $italic.addClass('active');
                }
            },

            /**
             * lineHeight
             * 
             * @access  protected
             * @param   String height
             * @return  void
             */
            'lineHeight': function(height) {
                var $range = this.find(
                    'input[type="range"][name="lineHeight"]'
                );
                $range.val(height);
                this._positionTooltip($range);
            },

            /**
             * position
             * 
             * @access  protected
             * @param   Number position
             * @return  void
             */
            // 'position': function(position) {
            //     LogUtils.log.simple('positioning', true);
            // },

            /**
             * shadowStrength
             * 
             * @note    undefined check here is to prevent possible issues with
             *          text layers created previously that do not have a
             *          shadowStrength property defined
             * @access  protected
             * @param   String height
             * @return  void
             */
            'shadowStrength': function(value) {
                var $range = this.find(
                    'input[type="range"][name="shadowStrength"]'
                );
                value = value === undefined ? 0 : value;
                $range.val(value);
                this._positionTooltip($range);
            },

            /**
             * strokeColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'strokeColor': function(rgbaColorStr) {
                this._colorPickers.strokeColor.setColor(rgbaColorStr, false);
            },

            /**
             * textColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'textColor': function(rgbaColorStr) {
                this._colorPickers.textColor.setColor(rgbaColorStr, false);
            },

            /**
             * underline
             * 
             * @access  protected
             * @param   Boolean on
             * @return  void
             */
            'underline': function(on) {
                var $underline = this.find('[name="underline"]');
                $underline.removeClass('active');
                if (on === true) {
                    $underline.addClass('active');
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TextToolbarView')
         */
        _string: 'TextToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._drawFontsDropdown();
            this._setupBackdropColor();
            this._setupShadowStrength();
            this._setupFontSize();
            this._setupLineHeight();
            this._setupStrokeColor();
            this._setupTextColor();
            this._setupTooltips();
            // this._setupListeners();

            // Outline + Backdrop
            this.on({

                /**
                 * (anonymous)
                 * 
                 * Enables/disables parts of the UI based on what styles of the
                 * font are available.
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'change/fontFamily': function(event, font) {
                    font.loadFull();
                    this.toggleBoldAction();
                    this.toggleItalicAction();
                },
                'change/backdropColor': function(event) {
                    this.backdropColor.show.apply(this);
                },
                'change/strokeColor': function(event) {
                    this.strokeColor.show.apply(this);
                }
            });

            // Events
            this.on({
                'clear/backdropColor': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.backdropColor.clear.apply(this);
                    layer.triggerHandler('clear/backdropColor');
                },
                'clear/strokeColor': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.strokeColor.clear.apply(this);
                    layer.triggerHandler('clear/strokeColor');
                },
                'set/align/center': function(event) {
                    var layer = this._getSelectedLayer();
                    this._set.align.apply(this, ['center']);
                    layer.triggerHandler('change/align', ['center']);
                },
                'set/align/left': function(event) {
                    var layer = this._getSelectedLayer();
                    this._set.align.apply(this, ['left']);
                    layer.triggerHandler('change/align', ['left']);
                },
                'set/align/right': function(event) {
                    var layer = this._getSelectedLayer();
                    this._set.align.apply(this, ['right']);
                    layer.triggerHandler('change/align', ['right']);
                },
                'change/backdropStretch': function(event, type) {
                    var layer = this._getSelectedLayer();
                    layer.triggerHandler('change/backdropStretch', [type]);
                },
                'toggle/bold': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.bold.apply(this, [!on]);
                    layer.triggerHandler('change/bold', [!on]);
                },
                'toggle/italic': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.italic.apply(this, [!on]);
                    layer.triggerHandler('change/italic', [!on]);
                },
                'toggle/underline': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.underline.apply(this, [!on]);
                    layer.triggerHandler('change/underline', [!on]);
                }
            });
        },

        /**
         * _drawFontsDropdown
         * 
         * @access  protected
         * @return  void
         */
        _drawFontsDropdown: function() {

            // Draw and create view
            var fontsCollection = Stencil.account().collection('fonts'),
                $fontsDropdown = DataUtils.render('FontsDropdown', {
                    fontsCollection: fontsCollection
                });
            this._element.find('div.tool.font').append($fontsDropdown);
            this._fontsDropdown = new FontsDropdownView(
                $fontsDropdown,
                fontsCollection
            );

            // Events
            var _this = this;
            this._fontsDropdown.on({

                /**
                 * Note that the order here is very important. Some listeners
                 * on the TextToolbarView's change/fontFamily-event lookup the
                 * selected-layer's font. So to ensure the value it receives is
                 * up-to-date, I need to trigger the layer's
                 * change/fontFamily-event first.
                 */

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'select': function(event, font) {
                    _this._getSelectedLayer().triggerHandler(
                        'change/fontFamily',
                        [font]
                    );
                    _this.triggerHandler('change/fontFamily', [font]);
                },

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'hover': function(event, font) {
                    _this._getSelectedLayer().getDrawing().triggerHandler(
                        'preview/fontFamily',
                        [font]
                    );
                },

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'open': function(event) {
                    this.once({
                        'hover': function(event, font) {
                            var layer = _this._getSelectedLayer();
                            layer.triggerHandler('revert/bold');
                            layer.triggerHandler('revert/italic');
                            _this._set.bold.apply(_this, [false]);
                            _this._set.italic.apply(_this, [false]);
                        }
                    });
                },
                /**
                 * (anonymous)
                 * 
                 * This one is a bit more complicated. It's written to
                 * accommodate two cases:
                 * 1) Users focus on a text layer, choose the font dropdown,
                 *    highlight a font, and then click out of the toolbar. In
                 *    that case, the layer becomes the previously selected one
                 *    (since the event that discards it fires first).
                 * 2) Users focus on a text layer, choose the font dropdown,
                 *    highlight a font, and then click escape key to get out of
                 *    it. In that case, the layer is still selected, and
                 *    therefore should be accessed through that to have the font
                 *    revert.
                 * 
                 * @note    Always check selected before previous, otherwise
                 *          it might change the wrong text layer.
                 * @access  private
                 * @param   Object event
                 * @return  void
                 */
                'close': function(event) {
                    var font = this.getSelectedFont(),
                        selectedLayer = _this._getSelectedLayer(),
                        previouslySelectedLayer = Canvases.Preview.getPreviouslySelectedLayer();
                    if (selectedLayer !== false) {
                        selectedLayer.triggerHandler(
                            'change/fontFamily',
                            [font]
                        );
                    } else if (previouslySelectedLayer !== false) {
                        previouslySelectedLayer.triggerHandler(
                            'change/fontFamily',
                            [font]
                        );
                    }
                    // else if (selected !== false) {
                    //     selected.triggerHandler('change/fontFamily', [font]);
                    // }
                }
            });
        },

        /**
         * _getFontSizeSkewedValue
         * 
         * @see     http://www.xuru.org/rt/PR.asp
         * @see     https://local.getstencil.com/test/polynomial
         * @access  protected
         * @param   Number value
         * @return  Number
         */
        _getFontSizeSkewedValue: function(value) {
            value = value.toInt();
            if (value <= 100) {
                return value;
            }
            if (value <= 200) {
                return 2 * value - 101;// incremement by 2
            }
            if (value <= 225) {
                return 4 * value - 503;// incrememnt by 4
            }
            return 400;
        },

        /**
         * _getFontSizeStepValue
         * 
         * Returns the step number (used in the range input) based on the font
         * size value. I'm rounding here, because since we no longer have every
         * font size value represented as a possible step in the range input,
         * it's possible the calculations below result in a non-whole number,
         * which wouldn't make sense when setting the value of the input. It
         * would likely cause issues with the tooltips that are shown.
         * 
         * @access  protected
         * @param   Number value
         * @return  Number
         */
        _getFontSizeStepValue: function(value) {
            value = value.toInt();
            if (value <= 100) {
                return value;
            }
            if (value <= 301) {
                return ((value + 101) / 2).round(0);
            }
            if (value <= 397) {
                return ((value + 503) / 4).round(0);
            }
            return 226;
        },

        /**
         * _setupBackdropColor
         * 
         * @access  protected
         * @return  void
         */
        _setupBackdropColor: function() {
            var _this = this,
                $input = this.find('[name="backdropColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    openDirection: 'up'
                });
            this._colorPickers.backdropColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/backdropColor',
                        layer = _this._getSelectedLayer();
// console.log(rgbaColorStr);
                    layer.triggerHandler(type, [rgbaColorStr]);
                    _this.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupFontSize
         * 
         * @see     http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access  protected
         * @return  void
         */
        _setupFontSize: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="fontSize"]'),
                listener = function(event) {
                    // var tooltip = $range.data('bs.tooltip');
                    // var size = _this._sizes.min + this.getStep()[0] - 1,
                    //     type = 'change/fontSize';
                    var layer = _this._getSelectedLayer(),
                        value = $(this).val(),
                        value = _this._getFontSizeSkewedValue(value);
                    $range.attr('data-ui-value', value);
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/fontSize', [value]);
                    }
                };
            if (UserAgentUtils.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupLineHeight
         * 
         * @see     http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access  protected
         * @return  void
         */
        _setupLineHeight: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="lineHeight"]'),
                listener = function(event) {
                    var layer = _this._getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/lineHeight', [value]);
                    }
                };
            if (UserAgentUtils.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupShadowStrength
         * 
         * @see     http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access  protected
         * @return  void
         */
        _setupShadowStrength: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="shadowStrength"]'),
                listener = function(event) {
                    var layer = _this._getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/shadowStrength', [value]);
                    }
                };
            if (UserAgentUtils.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._setupTooltip('fontSize');
            this._setupTooltip('lineHeight');
            this._setupTooltip('shadowStrength');
        },

        /**
         * _setupStrokeColor
         * 
         * @access  protected
         * @return  void
         */
        _setupStrokeColor: function() {
            var _this = this,
                $input = this.find('[name="strokeColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    openDirection: 'up'
                });
            this._colorPickers.strokeColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/strokeColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr]);
                    _this.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupTextColor
         * 
         * @access  protected
         * @return  void
         */
        _setupTextColor: function() {
            var _this = this,
                $input = this.find('[name="textColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    fallbackColor: ColorUtils.getBlack(),
                    openDirection: 'up'
                });
            this._colorPickers.textColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/textColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupListeners
         * 
         * @access  protected
         * @return  void
         */
        // _setupListeners: function() {
        //     var events = [
        //         'change/align',
        //         'change/backdropColor',
        //         'change/bold',
        //         'change/fontFamily',
        //         'change/fontSize',
        //         'change/italic',
        //         'change/strokeColor',
        //         'change/textColor',
        //         'change/underline',
        //         'preview/fontFamily'
        //     ];
        //     this.on(events.join(' '), function(event, value) {
        //         var layer = this._getSelectedLayer();
        //         if (layer !== false) {
        //             layer.triggerHandler(event.type, [value]);
        //         }
        //     });
        // },

        /**
         * bold
         * 
         * @access  protected
         * @var     Object
         */
        bold: {

            /**
             * disable
             * 
             * @access  public
             * @return  void
             */
            disable: function() {
                this.find('[name="bold"]').disable();
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                this.find('[name="bold"]').enable();
            }
        },

        /**
         * backdropColor
         * 
         * @access  protected
         * @var     Object
         */
        backdropColor: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $backdropStretch = this.find('[lookup="backdropStretch"]'),
                    $clear = this.find('[lookup="clear/backdropColor"]');
                $backdropStretch.addClass('hidden');
                $clear.addClass('hidden');
                this.getElement().removeClass('backdropExpanded');
                this._colorPickers.backdropColor.clearMinicolors();
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the backdrop
             * color input (when a value is defined).
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $backdropColor = this.find('[name="backdropColor"]'),
                    $column = $backdropColor.closest('div.column'),
                    $clear = $column.find('a'),
                    $type = $column.find('div.type');
                $clear.addClass('hidden');
                $type.addClass('hidden');
                if ($backdropColor.val() !== '') {
                    $clear.removeClass('hidden');
                    this.getElement().addClass('backdropExpanded');
                    $type.removeClass('hidden');
                }
            }
        },

        /**
         * getFontsDropdown
         * 
         * @access  public
         * @return  FontsDropdownView
         */
        getFontsDropdown: function() {
            return this._fontsDropdown;
        },

        /**
         * italic
         * 
         * @access  protected
         * @var     Object
         */
        italic: {

            /**
             * disable
             * 
             * @access  public
             * @return  void
             */
            disable: function() {
                this.find('[name="italic"]').disable();
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                this.find('[name="italic"]').enable();
            }
        },

        /**
         * strokeColor
         * 
         * @access  protected
         * @var     Object
         */
        strokeColor: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $lookup = this.find('[lookup="clear/strokeColor"]');
                $lookup.addClass('hidden');
                this._colorPickers.strokeColor.clearMinicolors();
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the stroke
             * color input (when a value is defined).
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $outline = this.find('[name="strokeColor"]'),
                    $clear = $outline.closest('div.column').find('a');
                $clear.addClass('hidden');
                if ($outline.val() !== '') {
                    $clear.removeClass('hidden');
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            var layer = this._getSelectedLayer();
            this._set.fontFamily.apply(this, [layer.getStyle('fontFamily')]);
            this._set.align.apply(this, [layer.getStyle('align')]);
            if (layer.getStyle('backdropColor') !== false) {
                this._set.backdropColor.apply(
                    this,
                    [layer.getStyle('backdropColor')]
                );
                this._set.backdropStretch.apply(
                    this,
                    [layer.getStyle('backdropStretch')]
                );
                this.backdropColor.show.apply(this);
            } else {
                this.backdropColor.clear.apply(this);
                this._set.backdropStretch.apply(
                    this,
                    ['slim']
                );
            }
            this._set.bold.apply(this, [layer.getStyle('bold')]);
            this.toggleBoldAction();
            this._set.italic.apply(this, [layer.getStyle('italic')]);
            this.toggleItalicAction();
            // this._set.order.apply(this, [layer.getStyle('order')]);
            this._set.fontSize.apply(this, [layer.getStyle('fontSize')]);
            this._set.lineHeight.apply(this, [layer.getStyle('lineHeight')]);
            this._set.shadowStrength.apply(this, [layer.getStyle('shadowStrength')]);
            this.order.auto.apply(this);
            this._set.underline.apply(this, [layer.getStyle('underline')]);
            this._set.textColor.apply(this, [layer.getStyle('textColor')]);
            if (layer.getStyle('strokeColor') !== false) {
                this._set.strokeColor.apply(
                    this,
                    [layer.getStyle('strokeColor')]
                );
                this.strokeColor.show.apply(this);
            } else {
                this.strokeColor.clear.apply(this);
            }

            // 
            this._colorPickers.backdropColor.removeLastChange();
            this._colorPickers.strokeColor.removeLastChange();
            this._colorPickers.textColor.removeLastChange();
        },

        /**
         * toggleBoldAction
         * 
         * This method is used to determine whether or not the bold-button
         * should be clickable.
         * 
         * @access  public
         * @return  void
         */
        toggleBoldAction: function() {
            var layer = this._getSelectedLayer(),
                fontFamily = layer.getStyle('fontFamily'),
                font = Stencil.account().collection('fonts').findByFamilyName(fontFamily);
            if (font.get('bold').toInt() === 1) {
                this.bold.enable.apply(this);
            } else {
                this.bold.disable.apply(this);
            }
        },

        /**
         * toggleItalicAction
         * 
         * This method is used to determine whether or not the italic-button
         * should be clickable.
         * 
         * @access  public
         * @return  void
         */
        toggleItalicAction: function() {
            var layer = this._getSelectedLayer(),
                fontFamily = layer.getStyle('fontFamily'),
                font = Stencil.account().collection('fonts').findByFamilyName(fontFamily);
            if (
                UserAgentUtils.supports.canvas.italic() === true
                || font.get('italic').toInt() === 1
            ) {
                this.italic.enable.apply(this);
            } else {
                this.italic.disable.apply(this);
            }
        }
    });
});
window.DependencyLoader.push('ImageToolbarView', function() {

    /**
     * VectorImageToolbarView
     * 
     * @extends ImageToolbarView
     */
    window.VectorImageToolbarView = ImageToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * fillColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'fillColor': function(rgbaColorStr) {
                this._colorPickers.fillColor.setColor(rgbaColorStr, false);
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorImageToolbarView')
         */
        _string: 'VectorImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupFillColor();
        },

        /**
         * _setupFillColor
         * 
         * @access  protected
         * @return  void
         */
        _setupFillColor: function() {
            var _this = this,
                $input = this.find('[name="fillColor"]'),
                openDirection = this._colorOverlayColorPickerOpenDirection || 'down',
                colorPicker = this._drawColorPicker($input, {
                    openDirection: openDirection,
                    fallbackColor: ColorUtils.getBlack()
                });
            this._colorPickers.fillColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/fillColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            var layer = this._getSelectedLayer();
            this.order.auto.apply(this);
            this._set.fillColor.apply(this, [layer.getStyle('fillColor')]);
            this._colorPickers.fillColor.removeLastChange();
        }
    });
});
window.DependencyLoader.push('BitmapImageToolbarView', function() {

    /**
     * WatermarkBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.WatermarkBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _colorOverlayColorPickerOpenDirection
         * 
         * @access  protected
         * @var     String (default: 'down')
         */
        _colorOverlayColorPickerOpenDirection: 'down',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkBitmapImageToolbarView')
         */
        _string: 'WatermarkBitmapImageToolbarView',

        /**
         * _toolbarType
         * 
         * @access  protected
         * @var     String (default: 'watermarkBitmapImage')
         */
        _toolbarType: 'watermarkBitmapImage',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
        },

        /**
         * show
         * 
         * Removing the previously set delete listener to ensure that a weird
         * race-condition does not happen whereby the layer is deleted, and then
         * can no longer (efficiently) be accessed. Cleaner to have the delete
         * listener all here.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            this.unbind('delete');
            this.on({
                'delete': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        watermark = layer.getWatermark();
                    layer.triggerHandler('delete');
                    watermark.set({
                        'settings.active': 0
                    });
                    watermark.save(['settings.active']);
                }
            });
            this.order.auto.apply(this);
        }
    });
});
window.DependencyLoader.push('ColorVectorImageToolbarView', function() {

    /**
     * WatermarkColorVectorImageToolbarView
     * 
     * @extends ColorVectorImageToolbarView
     */
    window.WatermarkColorVectorImageToolbarView = ColorVectorImageToolbarView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkColorVectorImageToolbarView')
         */
        _string: 'WatermarkColorVectorImageToolbarView',

        /**
         * _toolbarType
         * 
         * @access  protected
         * @var     String (default: 'watermarkColorVectorImage')
         */
        _toolbarType: 'watermarkColorVectorImage',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
        },

        /**
         * show
         * 
         * Removing the previously set delete listener to ensure that a weird
         * race-condition does not happen whereby the layer is deleted, and then
         * can no longer (efficiently) be accessed. Cleaner to have the delete
         * listener all here.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            this.unbind('delete');
            this.on({
                'delete': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        watermark = layer.getWatermark();
                    layer.triggerHandler('delete');
                    watermark.set({
                        'settings.active': 0
                    });
                    watermark.save(['settings.active']);
                }
            });
            this.order.auto.apply(this);
        }
    });
});
window.DependencyLoader.push('VectorImageToolbarView', function() {

    /**
     * WatermarkVectorImageToolbarView
     * 
     * @extends VectorImageToolbarView
     */
    window.WatermarkVectorImageToolbarView = VectorImageToolbarView.extend({

        /**
         * _colorOverlayColorPickerOpenDirection
         * 
         * @access  protected
         * @var     String (default: 'down')
         */
        _colorOverlayColorPickerOpenDirection: 'down',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkVectorImageToolbarView')
         */
        _string: 'WatermarkVectorImageToolbarView',

        /**
         * _toolbarType
         * 
         * @access  protected
         * @var     String (default: 'watermarkVectorImage')
         */
        _toolbarType: 'watermarkVectorImage',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
        },

        /**
         * show
         * 
         * Removing the previously set delete listener to ensure that a weird
         * race-condition does not happen whereby the layer is deleted, and then
         * can no longer (efficiently) be accessed. Cleaner to have the delete
         * listener all here.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var args = ArrayUtils.clone(arguments);
            this._super.apply(this, args);
            this.unbind('delete');
            this.on({
                'delete': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        watermark = layer.getWatermark();
                    layer.triggerHandler('delete');
                    watermark.set({
                        'settings.active': 0
                    });
                    watermark.save(['settings.active']);
                }
            });
            this.order.auto.apply(this);
        }
    });
});
window.DependencyLoader.push('Base', function() {

    /**
     * View
     * 
     * @extends Base
     */
    window.View = Base.extend({

        /**
         * _busy
         * 
         * @access  protected
         * @var     false|BusyModalView (default: false)
         */
        _busy: false,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'view')
         */
        _classType: 'view',

        /**
         * _element
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _element: null,

        /**
         * _events
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _events: {},

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @note    Without the <stopPropagation> call below, multiple views
                     *          will catch the event since events are bound as live
                     *          events. This is needed to say "only count it once"
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger]:not([disabled])': function(event, $element) {
                        event.preventDefault();
                        event.stopPropagation();
                        var trigger = $element.attr('trigger');
                        this.triggerHandler(trigger, [$element, event]);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Prevents disabled click events from default actions and going
                     * up the chain.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger][disabled]': function(event, $element) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },
                focus: {

                    /**
                     * (anonymous)
                     * 
                     * Firefox bug where you can focus on a readonly element
                     * 
                     * @note    Without the <stopPropagation> call below, multiple views
                     *          will catch the event since events are bound as live
                     *          events. This is needed to say "only count it once"
                     * @see     http://stackoverflow.com/questions/7917592/html-cursor-showing-in-readonly-input-text
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[readonly]': function(event, $element) {
                        event.stopPropagation();
                        $element.blur();
                    }
                }
            };
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'View')
         */
        _string: 'View',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            if (element.length > 1) {
                var msg = 'Invalid view instantiation';
                throw new Error(msg);
            }
            this._element = element;
            this._super();
            this._setupTabindex();
            this._setupListeners();
            // this._events = this._events();
        },

        /**
         * _getModel
         * 
         * @access  protected
         * @param   String model
         * @return  Model
         */
        _getModel: function(model) {
            return Stencil.getModel(model);
        },

        /**
         * _setupListeners
         * 
         * @note    Passes event and jQuery reference to current target
         * @access  protected
         * @return  void
         */
        _setupListeners: function() {
            var _this = this,
                listeners = this._listeners();
            // if (this._listeners.constructor === Function.constructor) {
            // this._listeners = this._listeners();
            // }
            jQuery.each(
                listeners,
                function(type, listener) {
                    jQuery.each(
                        listener,
                        function(selector, callback) {
                            _this._element.on(
                                type,
                                selector,
                                function(event) {
                                    if (typeof callback === 'string') {
                                        callback = _this._events[callback];
                                    }
                                    callback.apply(_this, [
                                        event,
                                        $(event.currentTarget)
                                    ]);
                                }
                            );
                        }
                    );
                }
            );
        },

        /**
         * _setupTabindex
         * 
         * Sets the tabindex value for any inputs found within the view,
         * ensuring that it's never a duplicate, and always incremented
         * properly. Important to use .find call to ensure modals do not repeat
         * defining the tabindex on an input.
         * 
         * @access  protected
         * @return  void
         */
        _setupTabindex: function() {
            if (UserAgentUtils.is.firefox() === true) {
                this.find('[tabindex]').removeAttr('tabindex');
            } else {
                var tabindex = Stencil.get('tabindex');
                if (tabindex === undefined) {
                    tabindex = 0;
                }
                var $tabs = this.find('[tabindex]'),
                    $tab;
                jQuery.each($tabs, function(index, tab) {
                    $tab = $(tab);
                    if ($tab.data('tabindexed') === undefined) {
                        tabindex++;
                        $tab.data('tabindexed', true);
                        $tab.attr('tabindex', tabindex);
                    }
                });
                Stencil.set('tabindex', tabindex);
            }
        },

        /**
         * find
         * 
         * @access  public
         * @param   String selector
         * @return  jQuery
         */
        find: function(selector) {
            var $match = this._element.find(selector);
            return $match;
        },

        /**
         * getBusy
         * 
         * @access  public
         * @return  BusyModalView
         */
        getBusy: function() {
            if (this._busy === false) {
                var $busy = DataUtils.render('BusyModal');
                this._busy = new BusyModalView($busy);
                this._element.append($busy);
            }
            return this._busy;
        },

        /**
         * getElement
         * 
         * @access  public
         * @return  HTMLElement
         */
        getElement: function() {
            return this._element;
        },

        /**
         * hourglass
         * 
         * @access  public
         * @return  void
         */
        hourglass: function() {
            this._element.hourglass();
        },

        /**
         * lookup
         * 
         * @access  public
         * @param   String key
         * @return  jQuery
         */
        lookup: function(key) {
            var selector = '[lookup="' + (key) + '"]',
                $match = this.find(selector);
            return $match;
        }
    });
});
window.DependencyLoader.push('Stencil', function() {

    /**
     * Router
     * 
     * @note    This class is not using /app/static/js/helpers/singleton.js
     *          because it's extending a Backbone class, not the Base class.
     * @see     http://pragmatic-backbone.com/routing-and-controllers
     * @see     http://stackoverflow.com/questions/14526752/backbone-refresh-the-same-route-path-for-twice
     * @see     https://viget.com/extend/finally-introducing-routerrouter-a-javascript-routing-library
     * @extends Backbone.Router
     */
    window.Router = Backbone.Router.extend({

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'router')
         */
        _classType: 'router',

        /**
         * _history
         * 
         * Array of paths made during the UX
         * 
         * @var     Array
         * @access  protected
         */
        _history: [],

        /**
         * _previous
         * 
         * Records the last non-modal path
         * 
         * @var     String
         * @access  protected
         */
        _previous: false,

        /**
         * _redirects
         * 
         * @var     Object
         * @access  public
         */
        _redirects: {
            'app/backgrounds/colors':               'app/icons',
            'app/backgrounds/search/(.*)':          'app/photos/search/$1',
            'app/backgrounds/stars':                'app/photos/favorites',
            'app/backgrounds/uploads':              'app/uploads',

            // Safari likes to add a trailing slash...
            'app/icons/':                           'app/icons',
            'app/templates/':                       'app/templates',
            'app/quotes/':                          'app/quotes',
            'app/uploads/':                         'app/uploads',
            'app/logos/':                           'app/logos',
            'app/images/':                          'app/images',

            // 
            'app/backgrounds/(.*)':                 'app/photos/$1',
                'app/icons/stars':                      'app/icons/favorites',      // wildcard redirect not working
                'app/icons/uploads':                    'app/uploads',              // wildcard redirect not working
                'app/templates/stars':                  'app/templates/favorites',  // wildcard redirect not working
                'app/quotes/stars':                     'app/quotes/favorites',     // wildcard redirect not working
                'app/saved/stars':                      'app/saved/favorites',      // wildcard redirect not working
            'app/tutorials/(.*)':                   'app/help/$1'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Router')
         */
        _string: 'Router',

        /**
         * routes
         * 
         * @var     Object
         * @access  public
         */
        routes: {
            'app/admin/images':                             Stencil.getAction('Admin',      ['images', 'results'],          'Admin: Images'),
            'app/admin/users':                              Stencil.getAction('Admin',      ['users', 'results'],           'Admin: Users'),
            'app/admin/settings/services':                  Stencil.getAction('Admin',      ['settings', 'services'],       'Admin: Services Settings'),
            'app/admin/:section':                           Stencil.getAction('Admin',      'section',                      'Admin'),
            'app/admin/users/search':                       Stencil.getAction('Admin',      ['users', 'search'],            'Admin: Users Search'),
            'app/admin/users/search/:query':                Stencil.getAction('Admin',      ['users', 'results'],           'Admin: Users Results'),
            'app/admin/users/:key':                         Stencil.getAction('Admin',      ['users', 'update'],            'Admin: Users Update'),
            'app/admin/categories/add':                     Stencil.getAction('Categories', 'add',                          'Add category modal'),
            'app/admin/coupons/add':                        Stencil.getAction('Coupons',    'add',                          'Add coupon modal'),
            'app/admin/promoSets/add':                      Stencil.getAction('PromoSets',  'add',                          'Add promo set modal'),
            'app/admin/vectorSets/add':                     Stencil.getAction('VectorSets', 'add',                          'Add vector set modal'),
            'app/admin/assets/reimport':                    Stencil.getAction('Admin',      'reimportAssets',               'Reimport assets'),
            'app/admin/cache/refresh':                      Stencil.getAction('Admin',      'cacheRefresh',                 'Refresh cached object'),
            'app':                                          Stencil.getAction('Photos',     'category',                     'Photos: Features'),
            'app/photos/search/:query':                     Stencil.getAction('Photos',     'search',                       'Photos: Search'),
            'app/photos/:category':                         Stencil.getAction('Photos',     'category',                     'Photos: Category'),
            'app/photos/collections/:category':             Stencil.getAction('Photos',     'collection',                   'Photos: Category'),
            'app/fonts/import':                             Stencil.getAction('App',        'googleFonts',                  'Google fonts'),
            'app/icons':                                    Stencil.getAction('Graphics',   'category',                     'Graphics: Features'),
            'app/icons/search/:query':                      Stencil.getAction('Graphics',   'search',                       'Graphics: Search'),
            'app/icons/:category':                          Stencil.getAction('Graphics',   'category',                     'Graphics: Category'),
            'app/icons/collections/:category':              Stencil.getAction('Graphics',   'collection',                   'Graphics: Category'),
            'app/quotes':                                   Stencil.getAction('Quotes',     'category',                     'Quotes: Features'),
            'app/quotes/search/:query':                     Stencil.getAction('Quotes',     'search',                       'Quotes: Search'),
            'app/quotes/:category':                         Stencil.getAction('Quotes',     'category',                     'Quotes: Category'),
            'app/quotes/collections/:category':             Stencil.getAction('Quotes',     'collection',                   'Quotes: Category'),
            'app/templates':                                Stencil.getAction('Templates',  'category',                     'Templates: Features'),
            'app/templates/:category':                      Stencil.getAction('Templates',  'category',                     'Templates: Category'),
            'app/templates/:key/preview':                   Stencil.getAction('Templates',  'preview',                      'Templates: Preview'),
            'app/templates/collections/:category':          Stencil.getAction('Templates',  'collection',                   'Templates: Category'),
            'app/uploads':                                  Stencil.getAction('Uploads',    'category',                     'Uploads: All'),
            'app/uploads/:category':                        Stencil.getAction('Uploads',    'category',                     'Uploads: Category'),
            'app/uploads/collections/:category':            Stencil.getAction('Uploads',    'collection',                   'Uploads: Category'),
            'app/logos':                                    Stencil.getAction('Watermarks', 'category',                     'Watermarks'),
            'app/saved':                                    Stencil.getAction('Images',     'category',                     'Images: All'),
            'app/saved/:category':                          Stencil.getAction('Images',     'category',                     'Images: Category'),
            'app/saved/collections/:category':              Stencil.getAction('Images',     'collection',                   'Images: Category'),
            'app/images/:key/confirm/mobile/:mobile':       Stencil.getAction('Images',     ['mobile', 'confirm'],          'Images: Confirm mobile'),
            'app/images/:key/sent':                         Stencil.getAction('Images',     'sent',                         'Image sent modal'),
            'app/images/:key/normalize':                    Stencil.getAction('Images',     'normalize',                    'Image normalize modal'),
            'app/images/:key/share/:network':               Stencil.getAction('Images',     'share',                        'Image share modal'),
            'app/images/:key/:connection/error':            Stencil.getAction('Images',     'error',                        'Image share error modal'),
            'app/shares/:key/success':                      Stencil.getAction('Shares',     'success',                      'Image shared modal'),
            'app/delinquent':                               Stencil.getAction('Users',      'delinquent',                   'Delinquent modal'),
            'app/login':                                    Stencil.getAction('Users',      'login',                        'Login modal'),
            'app/signup':                                   Stencil.getAction('Users',      'signup',                       'Signup modal'),
            'app/password':                                 Stencil.getAction('Users',      'password',                     'Password modal'),
            'app/promo':                                    Stencil.getAction('Users',      'promo',                        'Promo modal'),
            'app/promo/:partner':                           Stencil.getAction('Users',      'promo',                        'Promo modal (partner)'),
            'app/countdown':                                Stencil.getAction('Accounts',   'countdown',                    'Countdown modal'),
            'app/upgraded/:plan':                           Stencil.getAction('Accounts',   'upgraded',                     'Upgraded modal'),
            'app/plans':                                    Stencil.getAction('Accounts',   'plans',                        'Plans modal'),
            'app/browser':                                  Stencil.getAction('App',        'browser',                      'Browser modal'),
            'app/legacy':                                   Stencil.getAction('App',        'legacy',                       'Legacy modal'),
            'app/orientation':                              Stencil.getAction('App',        'orientation',                  'Orientation modal'),
            'app/alert/:code':                              Stencil.getAction('App',        'alert',                        'Alert modal'),
            // 'app/error/:code/:reference':                   Stencil.getAction('App',        'error',                        'Error modal'),
            'app/error':                                    Stencil.getAction('App',        'error',                        'Error modal'),
            'app/cookies':                                  Stencil.getAction('App',        'cookies',                      'Cookies modal'),
            'app/help/:section':                            Stencil.getAction('App',        'tutorials',                    'Help'),
            'app/upgrade/:plan/:reason':                    Stencil.getAction('Accounts',   'upgrade',                      'Upgrade modal'),
            'app/checkout/:plan/:interval':                 Stencil.getAction('Accounts',   'checkout',                     'Checkout modal'),
            'app/checkout/:plan/:interval/coupon':          Stencil.getAction('Coupons',    'apply',                        'Coupon apply modal'),
            'app/checkout/:plan/:interval/coupon/:code':    Stencil.getAction('Coupons',    'apply',                        'Coupon apply modal'),
            'app/settings/plan':                            Stencil.getAction('Users',      ['settings', 'plan'],           'Settings: Plan'),
            'app/settings/plan/switch/:plan':               Stencil.getAction('Accounts',   ['plan', 'switch'],             'Settings: Plan Switch'),
            'app/settings/plan/switched/:plan':             Stencil.getAction('Accounts',   ['plan', 'switched'],           'Settings: Plan Switched'),
            'app/settings/profile':                         Stencil.getAction('Users',      ['settings', 'profile'],        'Settings: Profile'),
            'app/settings/social':                          Stencil.getAction('Users',      ['settings', 'social'],         'Settings: Social'),
            'app/settings/password':                        Stencil.getAction('Users',      ['settings', 'password'],       'Settings: Password'),
            'app/settings/notifications':                   Stencil.getAction('Users',      ['settings', 'notifications'],  'Settings: Notifications'),
            'app/settings/delete':                          Stencil.getAction('Users',      ['settings', 'obfuscate'],      'Settings: Obfuscate'),
            'app/settings/payment':                         Stencil.getAction('Users',      ['settings', 'payment'],        'Settings: Payment'),
            'app/settings/referral':                        Stencil.getAction('Users',      ['settings', 'referral'],       'Settings: Referral'),
            'app/settings/:network/connected':              Stencil.getAction('Accounts',   'connections',                  'Settings: Connections'),
            'app/extras':                                   Stencil.getAction('App',        'extras',                       'Extras modal'),
            'app/extras/chrome/success':                    Stencil.getAction('App',        'chromeSuccess',                'Chrome installed modal'),
            'app/onboard':                                  Stencil.getAction('Users',      'onboard',                      'Onboarding modal'),
            'app/welcome':                                  Stencil.getAction('Accounts',   'welcomeTour',                  'Welcome tour modal'),
            'app/welcome/:step':                            Stencil.getAction('Accounts',   'welcomeTour',                  'Welcome tour modal'),
            '*wildcard':                                    Stencil.getAction('App',        'wildcard')
        },

        /**
         * initialize
         * 
         * Tracks the fragment the client is currently using, and triggers an
         * event against that fragment.
         * 
         * @see     http://backbonejs.org/#Events-catalog
         * @access  public
         * @return  void
         */
        initialize: function() {
            var _this = this;
            this.on({
                'route': function(route, params) {
                    var fragment = Backbone.history.fragment;
                    this.trigger('route:' + (fragment));
                    _this._history.push(fragment);
                }
            });
        },

        /**
         * execute
         * 
         * @note    Prevents navigation by returning false if the Error modal is
         *          showing.
         * @access  public
         * @param   Function callback
         * @param   Array args
         * @param   String name
         * @return  false|void
         */
        execute: function(callback, args, name) {
            if (ModalUtils.get('Error') !== false) {
                return false;
            }
            if (ModalUtils.get('Alert') !== false) {
                var modal = ModalUtils.get('Alert');
                if (modal.getSettings().closable === false) {
                    return false;
                }
            }
            var params = {},
                query = args.pop();
            if (query !== null) {
                params = this._getParams(query);
            }
            params.event = callback.toString();
            args.push(params);
            callback.apply(this, args);
        },

        /**
         * _getParams
         * 
         * @see     http://stackoverflow.com/questions/8486099/how-do-i-parse-a-url-query-parameters-in-javascript
         * @access  protected
         * @param   String query
         * @return  Object
         */
        _getParams: function(query) {
            var result = {};
            query.split('&').forEach(
                function(part) {
                    if (!part) {
                        return;
                    }
                    var item = part.split('='),
                        key = item[0],
                        val = decodeURIComponent(item[1] || true),
                        from = key.indexOf('[');
                    if (from === -1) {
                        result[key] = val;
                    } else {
                        var to = key.indexOf(']'),
                            index = key.substring(from + 1, to);
                        key = key.substring(0,from);
                        if (!result[key]) {
                            result[key] = [];
                        }
                        if (!index) {
                            result[key].push(val);
                        } else {
                            result[key][index] = val;
                        }
                    }
                }
            );
            return result;
        },

        /**
         * current
         * 
         * @access  protected
         * @return  Object
         */
        current: function() {
            return this.matching(Backbone.history.fragment);
        },

        /**
         * getClassType
         * 
         * @access  public
         * @return  String
         */
        getClassType: function() {
            return this._classType;
        },

        /**
         * getPrevious
         * 
         * Returns the last non-modal path
         * 
         * @access  public
         * @return  String
         */
        getPrevious: function() {
            return this._previous;
        },

        /**
         * getRedirects
         * 
         * @access  public
         * @return  Object
         */
        getRedirects: function() {
            return this._redirects;
        },

        /**
         * log
         * 
         * @access  public
         * @return  void
         */
        log: function() {
            var msg = '/' + (this.current().fragment);
            LogUtils.log.object(this, msg);
        },

        /**
         * matching
         * 
         * @see     http://stackoverflow.com/questions/7563949/backbone-js-get-current-route/16191880#16191880
         * @access  protected
         * @return  Object
         */
        matching: function(fragment) {
            var Router = this,
                routes = _.pairs(Router.routes),
                route = null,
                params = null,
                matched;
            matched = _.find(
                routes,
                function(handler) {
                    route = _.isRegExp(handler[0])
                        ? handler[0]
                        : Router._routeToRegExp(handler[0]);
                    return route.test(fragment);
                }
            );
            if (matched) {
                params = Router._extractParameters(route, fragment);
                route = matched[1];
            }
            return {
                route: route,
                fragment: fragment,
                params: params
            };
        },

        /**
         * recent
         * 
         * @access  public
         * @param   Number recent
         * @return  String
         */
        recent: function(recent) {
            var entry = this._history[this._history.length - 1 - recent];
            if (entry === undefined) {
                entry = 'app';
            }
            return entry;
        },

        /**
         * setPrevious
         * 
         * Sets the previous non-modal path.
         * 
         * @access  public
         * @param   String|false path
         * @return  void
         */
        setPrevious: function(path) {
            this._previous = path;
        },

        /**
         * toString
         * 
         * @access  public
         * @return  String
         */
        toString: function() {
            return this._string;
        }
    });
});

/**
 * Stencil
 * 
 * @note    Global shortform accessors are:
 *          - App
 *          - Frame
 *          - Canvases.Ghost
 *          - Canvases.Preview
 *          - Toolbars
 *          - Footer
 * @events  resource/feature/complete
 *          resource/operation/complete
 *          resource/save/complete
 * @abstract
 */
window.Stencil = (function() {

    /**
     * __app
     * 
     * @access  private
     * @var     AppView
     */
    var __app;

    /**
     * __bootExternally
     * 
     * @access  private
     * @param   Object data
     * @return  void
     */
    var __bootExternally = function(data) {

        // Boot
        NotificationUtils.show(data.notifications.current);

        // Cross-window messaging
        var action = 'message.app.alive';
        RequestUtils.postMessage(action);
        RequestUtils.addMessageListener(function(parsed) {
            if (parsed.action === 'message.app.init') {
                var $body = $('body'),
                    delay = data.delays.slide;
                $body.addClass('down');
                Stencil.init.delay(delay, Stencil, [data]);
            }
        });
    };

    /**
     * __bootInline
     * 
     * @access  private
     * @param   Object data
     * @return  void
     */
    var __bootInline = function(data) {
        Stencil.init(data);
    };

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'stencil')
     */
    var __classType = 'stencil';

    /**
     * __dead
     * 
     * Tracks whether the app has already been killed, to prevent multiple calls
     * to Stencil.kill from having any effect. This would happen if, for
     * example, requests were queued up. When the first one would timeout, any
     * subsequent ones would be aborted, which would then trigger a
     * Stencil.error, which would result in a Stencil.kill call.
     * 
     * @access  private
     * @var     Boolean (default: false)
     */
    var __dead = false;

    /**
     * __frozen
     * 
     * @access  private
     * @var     Boolean (default: false)
     */
    var __frozen = false;

    /**
     * __options
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __options = {};

    /**
     * __router
     * 
     * @access  private
     * @var     Router
     */
    var __router;

    /**
     * __addPostMessageListeners
     * 
     * Adds listeners to window to allow for extension integration.
     * 
     * @todo    Add preloading for image upload, to ensure it shows up right
     *          away when the tab is shown?
     * @access  private
     * @return  void
     */
    var __addPostMessageListeners = function() {
        RequestUtils.addMessageListener(function(parsed) {
            if (parsed.action === 'message.app.hide') {
                App.hide();
            }
        });
        RequestUtils.addMessageListener(function(parsed) {
            if (parsed.action === 'message.app.show') {
                App.show();
            }
        });
        RequestUtils.addMessageListener(function(parsed) {
            if (parsed.action === 'message.app.params.store') {
                Stencil.set('messageParams', parsed.params);
                if (parsed.params.image !== false) {
                    Stencil.importUrl(
                        parsed.params.image,
                        parsed.params.selection,
                        parsed.params.action
                    );
                } else {
                    if (
                        parsed.params.selection !== false
                        && parsed.params.selection !== undefined
                    ) {
                        __launch(function() {
                            var msg = Config.getMessage('image.import.almost');
                            App.getBusy().show(msg);
                            var canvas = Canvases.Preview;
                            canvas.once({
                                'render': function(event) {
                                    canvas.clear(false);
                                    canvas.getBusy().hide();
                                    App.getBusy().hide();
                                    var layer = canvas.addTextLayer({
                                            text: parsed.params.selection.trim(),
                                            width: 80
                                        }),
                                        drawing = layer.getDrawing();
                                    drawing.once({
                                        'draw': function(event) {
                                            drawing.animate();
                                        }
                                    });
                                    drawing.draw();
                                }
                            });
                        });
                    } else {
                        __launch();
                    }
                }
            }
        });
    };

    /**
     * __addUserLoginListeners
     * 
     * @access  private
     * @return  void
     */
    var __addUserLoginListeners = function() {
        User.on({
            'login': function(event, user) {
                AudioUtils.play('login.mp3');
            }
        });
    };

    /**
     * __adjustDefaultCanvases
     * 
     * Currently limited to changing the default font family for the app default
     * canvases, to the value stored in the AccountAccessor's settings.
     * 
     * @access  private
     * @return  void
     */
    var __adjustDefaultCanvases = function() {
        var canvases = Config.default('canvases'),
            account = Stencil.get('account'),
            guest = canvases.guest,
            user = canvases.user,
            defaultFontFamily = account.getDefaultFontFamily();
        guest.layers[2].fontFamily = defaultFontFamily;
        user.layers[2].fontFamily = defaultFontFamily;
    };

    /**
     * __alert
     * 
     * @access  private
     * @param   String msg
     * @return  void
     */
    var __alert = function(msg) {
        alert(msg);
    };

    /**
     * __checkForAdBlockers
     * 
     * @access  private
     * @return  void
     */
    var __checkForAdBlockers = function() {
        if (RequestUtils.cookies.get('adBlocker/notified') === undefined) {
            var url = 'https://www.facebook.com/impression.php',
                imageRequest = new ImageRequest(url);
            imageRequest.once({
                'error': function(event, image) {
                    Stencil.alert('adBlocker.found');
                    RequestUtils.cookies.set('adBlocker/notified', 1);
                }
            });
            imageRequest.request();
        }
    };

    /**
     * __checkForConflictingExtensions
     * 
     * @access  private
     * @return  Boolean
     */
    var __checkForConflictingExtensions = function() {
        if (__app.find('#ezLinkPreviewDIV').length > 0) {
            if (RequestUtils.cookies.get('conflictingExtension/ezLinkPreview') === undefined) {
                Stencil.alert('extension.conflicting.ezLinkPreview');
                RequestUtils.cookies.set('conflictingExtension/ezLinkPreview', 1);
                return true;
            }
        }
        if (__app.find('#ghostery-purple-box').length > 0) {
            if (RequestUtils.cookies.get('conflictingExtension/ghostery') === undefined) {
                Stencil.alert('extension.conflicting.ghostery');
                RequestUtils.cookies.set('conflictingExtension/ghostery', 1);
                return true;
            }
        }
        return false;
    };

    /**
     * __connect
     * 
     * @access  private
     * @param   Function callback
     * @return  void
     */
    var __connect = function(callback) {
        var email = 'support@getstencil.com',
            fallback = 'Something went wrong. Please email ' + (email);
        RequestUtils.ajax({
            signature: {"basename":"Stencil.js","line":274},
            url: '/connect',
            type: 'GET',
            error: function(jqXHR, textStatus, errorThrown) {
                LogUtils.log.object(Stencil, arguments, true);
                __alert('#100 - ' + (fallback));
            },
            success: function(response) {
                if (response.success === true) {
                    callback(response);
                } else {
                    LogUtils.log.object(Stencil, arguments, true);
                    __alert('#101 - ' + (fallback));
                }
            }
        });
    };

    /**
     * __drawTemplates
     * 
     * @access  private
     * @param   Array templates
     * @return  void
     */
    var __drawTemplates = function(templates) {
        for (var index in templates) {
            $('#templates').append(templates[index]);
        }
    };

    /**
     * __launch
     * 
     * @access  private
     * @param   Function callback
     * @return  void
     */
    var __launch = function(callback) {

        // Cookies not supported
        if (UserAgentUtils.supports.cookies() === false) {
            $('div.modal.busy').addClass('hidden');
            $('div.modal.cookies').removeClass('hidden');
            var msg = 'Cookies are required for Stencil';
            throw new Error(msg);
        }

        // Browser not supported
        if (UserAgentUtils.valid() === false) {
            $('div.modal.busy').addClass('hidden');
            $('div.modal.browser').removeClass('hidden');
            var msg = 'Modern browser is required for Stencil';
            throw new Error(msg);
        }

        // Router logging + init
        __router.on({
            'route': __router.log.proxy(__router)
        });
        __connect(function(response) {
            var data = response.data;

            // Config
            Stencil.set('config', data.config);
            // ImagePreloadWorker.preload(Config.get('preload'));

            /**
             * Raven tracking
             * 
             * @note    It's actually important to not update the release value,
             *          even if it can be detected (for example, user hits /connect
             *          upon load with value 'abc', and then after going to their
             *          favorite photos, in that time, a new release is available).
             *          If this value was updated, it might mis-report errors that
             *          have actually been fixed in that version, but since the
             *          user hadn't yet loaded the new codebase, might not actually
             *          be fixed.
             */
            (function() {
                var ravenReleaseString = 'local';
                if (response.version !== false) {
                    ravenReleaseString = response.version;
                }
                Raven.setRelease(ravenReleaseString);
                Raven.setEnvironment(Config.getRole());
            })();

            // Global features
            var globalFeatures = [],
                index,
                category;
            for (index in data.config.categories) {
                category = data.config.categories[index];
                globalFeatures = globalFeatures.concat(category.features);
            }
            globalFeatures = _.uniq(globalFeatures);
            Stencil.set('globalFeatures', globalFeatures);

            // Templates
            __drawTemplates(data.config.markup.templates);

            // Defaults
            Frames.store(data.config.frames);

            // Account
            var model = Stencil.getModel('Account'),
                account = model.setAccessor(data.account);
            Stencil.set('account', account);

            // Adjust default canvases with account's default font
            __adjustDefaultCanvases();

            // Categories
            var collection = new CategoriesCollection();
            collection.map(data.config.categories);
            Stencil.set('globalCategories', collection);

            // Overrides
            var collection = new OverridesCollection();
            collection.map(data.config.overrides);
            Stencil.set('overrides', collection);

            /**
             * Wait for all the normal fonts to be have been loaded before
             * continuing.
             */
            var fontsCollection = Stencil.account().collection('fonts');
            fontsCollection.once({
                'load/all/normal': function(event) {
                    var latoFont = fontsCollection.findByFamilyName('Lato');
                    latoFont.loadFull(function() {

                        // User
                        var user = false;
                        if (data.user !== false) {
                            model = Stencil.getModel('User');
                            user = model.setAccessor(data.user);
                            user.on({
                                'change': Track.user
                            });
                            Stencil.account().on({
                                'change': Track.user
                            });
                        }
                        Stencil.set('user', user);

                        // Scripts
                        Scripts.setupAws();
                        Scripts.setupS3();
                        Scripts.load('headway');
                        Scripts.load('helpScout');
                        Scripts.load('logRocket');
                        Scripts.load('segment');
                        Scripts.load('tapfiliate');

                        // Resource operations
                        __setupResourceOperationListeners();

                        // 
                        RequestUtils.setup.ping();

                        // View
                        var $app = $('body.app');
                        __app = new AppPageView($app);
                        __app.setSelectedFrame();
                        Stencil.set('smartToggleWatermarks', true);
                        __app.getStage().getContent().drawPreviewCanvas();

                        // Initialize change history
                        ChangeHistory.setOperationType('initial');
                        ChangeHistory.track(true, false);

                        // Start navigation
                        Backbone.history.start({
                            pushState: true
                        });

                        // Tablet orientation or legacy welcome
                        if (UserAgentUtils.is.ipad() === true) {
                            if (UserAgentUtils.getOrientation() === 'portrait') {
                                Stencil.navigate('/app/orientation?clean=1');
                            }
                        } else if (__store.user !== false) {
                            __store.user.showLegacyWelcome();
                        }

                        // Done
                        callback && callback();

                        // Check for ad blockers
                        if (__checkForConflictingExtensions() === false) {
                            // __checkForAdBlockers();
                        }

                        // Notification requests
                        NotificationUtils.prompt();

                        // User login events
                        __addUserLoginListeners();

                        /**
                         * @todo    Add blocking check in above that ensures a
                         *          minimum width for non-tablet devices. Can
                         *          compare $('body').width()
                         *          and window.screen.availWidth. The latter
                         *          provides the possible width the window could
                         *          be based on their OS settings. Show a simple
                         *          modal (that can be dismissed) which suggests
                         *          they make the window as big as possible for
                         *          the best experience.
                         */

                        // Login welcome modal
                        // User.on('login', function(event) {

                        // });
                    });
                }
            });

            /**
             * Excluding the Stencil app font Lato, since I'll load that in
             * after all the normal ones have been.
             */
            fontsCollection.loadAllNormal(['Lato']);
        });
    };

    /**
     * __setupResourceOperationListeners
     * 
     * Listens for successful resource features, saves and favorites in order to
     * keep track of how many are running at any point. Currently being used to
     * throttle resource-operations to prevent overloading the server, as well
     * as queueing up too many front-end ajax calls.
     * 
     * @access  private
     * @return  void
     */
    var __setupResourceOperationListeners = function() {
        Stencil.on({
            /**
             * @access  private
             * @param   String event
             * @param   AssetAccessor asset
             * @return  void
             */
            'resource/feature/complete': function(event, asset) {
                var parallelResourceFeatures = Stencil.get('parallelResourceFeatures');
                --parallelResourceFeatures;
                Stencil.set('parallelResourceFeatures', parallelResourceFeatures);
            },
            /**
             * @access  private
             * @param   String event
             * @param   String operation
             * @param   AssetAccessor asset
             * @return  void
             */
            'resource/operation/complete': function(event, operation, asset) {
                var parallelResourceOperations = Stencil.get('parallelResourceOperations');
                --parallelResourceOperations;
                Stencil.set('parallelResourceOperations', parallelResourceOperations);
            },
            /**
             * @access  private
             * @param   String event
             * @param   AssetAccessor asset
             * @return  void
             */
            'resource/save/complete': function(event, asset) {
                var parallelResourceSaves = Stencil.get('parallelResourceSaves');
                --parallelResourceSaves;
                Stencil.set('parallelResourceSaves', parallelResourceSaves);
            }
        });
    };

    /**
     * _showConsoleBranding
     * 
     * @see     https://developers.google.com/web/tools/chrome-devtools/console/console-write
     * @see     http://patorjk.com/software/taag/#p=display&h=3&v=3&f=Graceful&t=Stencil
     * @access  private
     * @param   Object options
     * @return  Boolean
     */
    var _showConsoleBranding = function(options) {
        if (options.role === 'local') {
            return false;
        }
        if (options.source.external === true) {
            return false;
        }
        if (DataUtils.valid(window.console) === false) {
            return false;
        }
        console.log('%c\n' +
            '   _____ __                  _ __\n'     +
            '  / ___// /____  ____  _____(_) /\n'     +
            '  \\__ \\/ __/ _ \\/ __ \\/ ___/ / / \n' +
            ' ___/ / /_/  __/ / / / /__/ / /  \n'     +
            '/____/\\__/\\___/_/ /_/\\___/_/_/   \n'  +
            '\n\n',
            'font-family: \'Courier\'; font-weight: 900; font-size: 11px;'
        );
        return true;
    };

    /**
     * __store
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __store = {};

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Stencil')
     */
    var __string = 'Stencil';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * account
         * 
         * @access  public
         * @return  AccountAccessor
         */
        account: function() {
            return Stencil.get('account');
        },

        /**
         * alert
         * 
         * @access  public
         * @param   String code
         * @return  AlertModalView
         */
        alert: function(code) {
            Stencil.navigate('/app/alert/' + (code) + '?clean=1');
            var modal = ModalUtils.get('Alert');
            return modal;
        },

        /**
         * boot
         * 
         * @access  public
         * @param   Object data
         * @return  Boolean
         */
        boot: function(data) {
            _showConsoleBranding(data);
            if (data.source.external === true) {
                __bootExternally(data);
                return true;
            }
            __bootInline(data);
            return true;
        },

        /**
         * error
         * 
         * Redirects the user to an error view (via AppController). Multiple
         * error-redirects is prevented within Router.js by checking if an
         * ErrorModal is already open, or else if an AlertModal that is not
         * closable is open.
         * 
         * @access  public
         * @param   String code
         * @param   String reference
         * @return  void
         */
        error: function(code, reference) {
            var path = '/app/error' +
                '?code=' + (code) +
                '&reference=' + (reference) +
                '&clean=1';
            Stencil.navigate(path);
            Stencil.kill();
        },

        /**
         * extractError
         * 
         * Attempts to drill down into an ajax response to find a failed rule
         * error. This is used with Stencil.error for debugging purposes.
         * 
         * @access  public
         * @param   Object response
         * @return  Object
         */
        extractError: function(response) {
            if (response.failedRules) {
                if (response.failedRules[0]) {
                    if (response.failedRules[0].error) {
                        var error = response.failedRules[0].error;
                        return {
                            validator: response.failedRules[0].validator,
                            code: error.code || 'uk1',
                            reference: error.reference || 'crash1'
                        };
                    }
                }
            }
            return {
                validator: false,
                code: 'uk0',
                reference: 'crash0'
            };
        },

        /**
         * globalFeatures
         * 
         * @access  public
         * @var     Object
         */
        globalFeatures: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                var globalFeatures = Stencil.get('globalFeatures'),
                    key = accessor.get('key');
                if (accessor.is.asset.apply(accessor) === true) {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                globalFeatures.push(key);
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var globalFeatures = Stencil.get('globalFeatures'),
                    key = accessor.get('key'),
                    index;
                if (accessor.is.asset.apply(accessor) === true) {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = globalFeatures.indexOf(key);
                if (index !== -1) {
                    globalFeatures.splice(index, 1);
                }
            }
        },

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        get: function(key) {
            return __store[key];
        },

        /**
         * getAccessor
         * 
         * @access  public
         * @param   String key
         * @return  false|Accessor
         */
        getAccessor: function(key) {
            if (__store.accessors === undefined) {
                return false;
            }
            if (__store.accessors[key] === undefined) {
                return false;
            }
            return __store.accessors[key];
        },

        /**
         * getAction
         * 
         * Returns a function, which proxies through to a controller and action.
         * The advantage of this approach is that since <getAction> is used
         * within Router upon page-load, I can return this reference without
         * having to wait for the appropriate controllers to be loaded into
         * memory.
         * 
         * @access  public
         * @param   String controller
         * @param   String|Array action
         * @param   String event
         * @return  Function
         */
        getAction: function(controller, action, event) {
            if (jQuery.isArray(action) === false) {
                action = [action];
            }
            var closure = function() {
                var reference = Stencil.getController(controller);
                if (action.length === 1) {
                    reference[action[0]].apply(reference, arguments);
                } else if (action.length === 2) {
                    reference[action[0]][action[1]].apply(reference, arguments);
                } else {
                    var msg = 'Invalid action length';
                    throw new Error(msg);
                }
            };
            closure.toString = function() {
                return event;
            };
            return closure;
        },

        /**
         * getCategories
         * 
         * @access  public
         * @param   String type
         * @return  Array
         */
        getCategories: function(type) {
            var categories = Config.get('categories'),
                matches = [];
            for (var index in categories) {
                if (categories[index].type === type) {
                    matches.push(categories[index]);
                }
            }
            return matches;
        },

        /**
         * getCollection
         * 
         * @access  public
         * @param   String id
         * @return  Collection
         */
        // getCollection: function(id) {
        //     return __store.collections && __store.collections[id] || false;
        // },

        /**
         * getController
         * 
         * @access  public
         * @param   String name
         * @return  Controller
         */
        getController: function(name) {
            if (__store.controllers && __store.controllers[name]) {
                return __store.controllers[name];
            }
            var reference = (name) + 'Controller';
            __store.controllers = __store.controllers || {};
            __store.controllers[name] = new window[reference]();
            return __store.controllers[name];
        },

        /**
         * getModel
         * 
         * @access  public
         * @param   String name
         * @return  Model
         */
        getModel: function(name) {
            if (__store.models && __store.models[name]) {
                return __store.models[name];
            }
            var reference = (name) + 'Model';
            __store.models = __store.models || {};
            __store.models[name] = new window[reference]();
            return __store.models[name];
        },

        /**
         * getOptions
         * 
         * @access  public
         * @return  Object
         */
        getOptions: function() {
            return __options;
        },

        /**
         * getRouter
         * 
         * @access  public
         * @return  Router
         */
        getRouter: function() {
            return __router;
        },

        /**
         * init
         * 
         * @access  public
         * @param   Object options
         * @return  void
         */
        init: function(options) {

            // 
            __options = options;
            if (__options.source.external === true) {

                /**
                 * This click event is intended to capture the user clicking on
                 * body element outside of the app, which we interpret to mean
                 * "close the app". There's a bug with Chrome whereby
                 * right-clicking in the app (which shows the context menu),
                 * pressing escape, switching to a new tab, and then focusing on
                 * the original tab again triggers a <click> event against the
                 * body. I'm not sure why this happens, but to prevent the app
                 * from closing when the user focuses back on the tab, I check
                 * the coordinates of the mouse, and when it seems unlikely it
                 * was the user, I do not close it. The first screen shot below
                 * shows the event object when a user manually clicks on the
                 * body. The second shows the event when the body:click event is
                 * triggered by some unknown process:
                 * https://i.imgur.com/ulb9YzW.png
                 * https://i.imgur.com/1TFn0iV.png
                 * 
                 * @todo    Look into why this is happening; there is likely a
                 *          more elegant way of handling this.
                 */
                $('body').click(function(event) {
                    var $target = $(event.target);
                    if ($target.tag() === 'body') {
                        if (event.clientX !== 0 && event.clientY !== 0) {
                            App.hide();
                        }
                    }
                });
            }

            // Create router
            __router = new Router();
            Stencil.set('alive', true);
            DTUtils.setup.moment();

            // Posting
            if (__options.source.external === true) {
                __addPostMessageListeners();
                RequestUtils.postMessage('message.app.opened');
            } else {
                __launch(function() {
                    if (Account.showWelcomeTour() === true) {
                        Stencil.account().push('settings.hasSeenWelcomeTour', 1);
                        Stencil.navigate('/app/welcome');
                    }
                });
            }
        },

        /**
         * import
         * 
         * Notice that in the error handler, I've created a logProxy function.
         * This is because traditionally, I access the logging method through
         * App.log, but in this case, if import fails, the App view will not
         * have yet been instantiated. So in that case, I go straight to
         * Stencil.
         * 
         * Hmm, maybe I should always be going through Stencil? The problem at
         * the time of writing is that the Stencil.log method has too many
         * parameters. So maybe a Logging js helper file should be created, and
         * all log calls are simply proxies to that?
         * 
         * @todo!   See note above about creating a Logging.js file
         * @access  public
         * @param   String url
         * @param   Function success
         * @param   Function fail
         * @return  void
         */
        import: function(url, success, fail) {
            RequestUtils.ajax({
                signature: {"basename":"Stencil.js","line":974},
                url: '/import',
                type: 'POST',
                data: {
                    url: url
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    LogUtils.log.simple('jQuery AJAX error', true);
                    LogUtils.log.simple(arguments, true);
                    LogUtils.log.simple('s893', true);
                },
                success: function(response) {
                    if (response.success === true) {
                        success(response.data);
                    } else {
                        var error = Stencil.extractError(response);
                        fail(error);
                    }
                }
            });
        },

        /**
         * importUrl
         * 
         * @note    This method works a bit differently because an AppView is not
         *          yet instantiated.
         * @access  public
         * @param   String url
         * @param   false|String selection
         * @param   String action
         * @return  void
         */
        importUrl: function(url, selection, action) {
            var msg = __options.messages['image.import.loading'];
            $('body div.busy div.copy').html(msg);
            Stencil.import(
                url,
                function(data) {
                    var model = Stencil.getModel('Upload'),
                        upload = model.setAccessor(data.object);
                    // upload.preload(function() {
                        __launch(function() {
                            msg = Config.getMessage('image.import.almost');
                            App.getBusy().show(msg);
                            Stencil.navigate('/app/uploads');
                            App.getBusy().show(msg);
                            if (action === 'openCropper') {
                                upload.showCropper();
                            } else {
                                var canvas = Canvases.Preview;
                                canvas.once({
                                    'render': function(event) {
                                        canvas.clear(false);
                                        var layer = canvas.getBackgroundBitmapImageLayer(),
                                            drawing = layer.getDrawing();
                                        canvas.getBusy().show();
                                        drawing.once({
                                            'refresh': function(event) {
                                                canvas.getBusy().hide();
                                                App.getBusy().hide();
                                                if (selection !== false) {
                                                    layer = canvas.addTextLayer({
                                                        text: selection.trim(),
                                                        width: 80
                                                    });
                                                    drawing = layer.getDrawing();
                                                    drawing.once({
                                                        'draw': function(event) {
                                                            drawing.animate();
                                                        }
                                                    });
                                                    drawing.draw();
                                                }
                                            }
                                        });
                                        upload.select(
                                            'load',
                                            false,
                                            {
                                                destination: 'background'
                                            }
                                        );
                                    }
                                });
                            }
                        });
                    // });
                },
                function(error) {
                    var key = 'import.failed';
                    if (error.validator !== false) {
                        if (error.validator[1] === 'validFilesize') {
                            key = 'import.failed.max.filesize';
                        }
                    }
                    __launch(function() {
                        Canvases.Preview.once({
                            'render': function(event) {
                                Stencil.alert(key);
                            }
                        });
                    });
                }
            );
        },

        /**
         * kill
         * 
         * Runs a kind of clean up when the app is no longer alive. Examples of
         * this include an alert that forces a page reload or an error.
         * 
         * @access  public
         * @return  Boolean
         */
        kill: function() {
            if (__dead === true) {
                return false;
            }
            __dead = true;
            $('*').unbind();
            $('.fa-spin').removeClass('fa-spin');
            $(window).unbind('resize');
            TimeoutPool.clearAll();
            IntervalPool.clearAll();
            XHRPool.abortAll();
            return true;
        },

        /**
         * freeze
         * 
         * @access  public
         * @return  void
         */
        freeze: function() {
            App.getElement().addClass('disabled');
            __frozen = true;
        },

        /**
         * frozen
         * 
         * @access  public
         * @return  Boolean
         */
        frozen: function() {
            return __frozen;
        },

        /**
         * navigate
         * 
         * Either proxies the routing method if the param <clean> is found, or
         * else uses Backbone's url-routing system for the app-state.
         * 
         * @note    replace value below is designed to prevent parent window from
         *          having navigational-records added to it when the app is
         *          laoded externally (eg. Chrome Extension).
         * @access  public
         * @param   String path
         * @param   Boolean trigger
         * @param   Boolean refresh whether a navigate should be forced, even if
         *          the agent is already at that url (used in searching)
         * @return  void
         */
        navigate: function(path, trigger, refresh) {
            if (path.indexOf('clean') !== -1) {
                Backbone.history.loadUrl(path);
            } else {
                if (trigger === undefined) {
                    trigger = true;
                }
                // var routed = __router.navigate(path, trigger);
                var routed = Backbone.history.navigate(path, {
                    trigger: trigger,
                    replace: __options.source.external === true
                });
                if (!routed && refresh) {
                    Backbone.history.loadUrl(path);
                }
            }
        },

        /**
         * receiveElectronMessage
         * 
         * @access  public
         * @param   Object msg
         * @return  void
         */
        receiveElectronMessage: function(msg) {
            if (msg.action === 'showBusyModal') {
                (function() {
                    var msg = Config.getMessage('image.import.electron');
                    App.getBusy().show(msg);
                }).waitForMethod('App.getBusy');
            } else if (msg.action === 'importUrls') {
                var urls = msg.urls;
                for (var index in urls) {
                    urls[index] = encodeURIComponent(urls[index]);
                }
                App.getBusy().hide();
                DataUtils.getUrlsAsBlobs(urls, function(blobs) {
                    if (blobs !== false) {
                        (function() {
                            var dropzone = App.getApplicableDropzone(false);
                            if (dropzone.availableForUpload() === true) {
                                if (dropzone.toString() === 'WatermarksDropzoneView') {
                                    Stencil.navigate('/app/logos');
                                } else {
                                    Stencil.navigate('/app/uploads');
                                }
                                dropzone.uploadItems(blobs);
                            }
                        }).waitForMethod('App.getApplicableDropzone');
                    }
                });
            }
        },

        /**
         * set
         * 
         * Helper for application-wide hash map.
         * 
         * @access  public
         * @param   String key
         * @param   mixed value
         * @return  void
         */
        set: function(key, value) {
            if (key === 'user' && value !== false) {
                Raven.setUserContext({
                    email: value.get('email'),
                    id: value.get('id')
                });
            }
            __store[key] = value;
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   String key
         * @param   String name
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(key, name, data) {
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                var reference = (name) + 'Accessor';
                __store.accessors = __store.accessors || {};
                __store.accessors[key] = new window[reference](data);
                accessor = __store.accessors[key];
            } else {
                accessor.merge(data);
            }
            return accessor;
        },

        /**
         * unfreeze
         * 
         * @access  public
         * @return  void
         */
        unfreeze: function() {
            App.getElement().removeClass('disabled');
            __frozen = false;
        }
    });
})();
});
